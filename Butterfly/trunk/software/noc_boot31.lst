Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 1
noc_boot31.a

                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; This boot rom for node $311.
                                        ; ============================================================================
                                        ;
     26 = 0D                            CR	= 13
     27 = 0A                            LF	= 10
     28 = 09                            CTRLH	equ		9
     29 = 20                            txBuf	equ		32
     30 = 30                            rxBuf	equ		48
                                        
     32 = 01                            MT_RST		equ		1
     33 = 02                            MT_RST_ACK	equ		2
     34 = 03                            MT_STOP		equ		3
     35 = 04                            MT_KEYSTROKE			equ	4
     36 = 05                            MT_SET_IOFOCUS			equ	5
     37 = 06                            MT_BUTTON_STATUS		equ	6
     38 = 07                            MT_REQ_INP_FOCUS		equ	7
     39 = 08                            MT_GRNT_INP_FOCUS		equ 8
     40 = 09                            MT_PING					equ	9
     41 = 0A                            MT_START_BASIC_LOAD		equ	10
     42 = 0B                            MT_LOAD_BASIC_CHAR		equ	11
     43 = 0C                            MT_RUN_BASIC_PROG		equ	12
     44 = 0D                            MT_BASIC_EXIT			equ	13
     45 = 0F                            MT_REQ_OUT_FOCUS		equ	15
     46 = 10                            MT_GRNT_OUT_FOCUS		equ	16
     47 = 11                            MT_OUT_CHAR				equ	17
     48 = 12                            MT_PING_ACK				equ	18
     49 = 13                            MT_ETH_PACKET			equ	19
     50 = 14                            MT_GET_DATETIME			equ	20
     51 = 15                            MT_SET_DATETIME			equ	21
     52 = 16                            MT_DATETIME_ACK			equ	22
     53 = 17                            MT_LOAD_CODE			equ	23
     54 = 18                            MT_LOAD_DATA			equ	24
     55 = 19                            MT_EXEC_CODE			equ	25
     56 = 1A                            MT_EXIT					equ	26
     57 = 1B                            MT_RDRAM				equ	27
     58 = 1C                            MT_WRRAM				equ	28
     59 = 1D                            MT_SETPIXEL				equ	29
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 2
noc_boot31.a
     60 = 1E                            MT_GETPIXEL				equ	30
     61 = 1F                            MT_SETADDR				equ	31
     62 = 20                            MT_DATA					equ	32
     63 = 21                            MT_NEXT_IOFOCUS			equ	33
     64 = 22                            MT_GET_ROUTE			equ	34
     65 = 23                            MT_GET_ROUTE_ACK		equ	35
     66 = 24                            MT_ENUM_DEVICES			equ	36
     67 = 25                            MT_ENUM_DEVICES1		equ	37
     68 = 26                            MT_ENUM_DEVICES2		equ	38
                                        
                                        ; Device command opcodes
                                        ;
     72 = 40                            DVC_Nop				EQU		64
     73 = 41                            DVC_Setup			EQU		65
     74 = 42                            DVC_Initialize		EQU		66
     75 = 43                            DVC_Status			EQU		67
     76 = 44                            DVC_MediaCheck		EQU		68
     77 = 45                            DVC_BuildBPB		EQU		69
     78 = 46                            DVC_Open			EQU		70
     79 = 47                            DVC_Close			EQU		71
     80 = 48                            DVC_GetChar			EQU		72
     81 = 49                            DVC_PeekChar		EQU		73
     82 = 4A                            DVC_GetCharDirect	EQU		74
     83 = 4B                            DVC_PeekCharDirect	EQU		75
     84 = 4C                            DVC_InputStatus		EQU		76
     85 = 4D                            DVC_PutChar			EQU		77
     86 = 4E                            DVC_SetPosition		EQU		78
     87 = 4F                            DVC_ReadBlock		EQU		79
     88 = 50                            DVC_WriteBlock		EQU		80
     89 = 51                            DVC_VerifyBlock		EQU		81
     90 = 52                            DVC_OutputStatus	EQU		82
     91 = 53                            DVC_FlushInput		EQU		83
     92 = 54                            DVC_FlushOutput		EQU		84
     93 = 55                            DVC_IRQ				EQU		85
     94 = 56                            DVC_IsRemoveable	EQU		86
     95 = 57                            DVC_IOCTRL_READ		EQU		87
     96 = 58                            DVC_IOCTRL_WRITE	EQU		88
     97 = 59                            DVC_OutputUntilBusy	EQU		89
                                        ; message types	90 to 95 reserved
                                        
                                        
                                        
    102 = 000000000000B000                              ROUTER		equ	$B000
    103 = 10                            RTR_RXSTAT	equ	$10
    104 = 11                            RTR_RXCTL	equ	$11
    105 = 12                            RTR_TXSTAT	equ	$12
                                        
    107 = 000000000000B200                              LEDS		equ	$B200
                                        
    109 = 00                            ROUTER_TRB	equ	0
                                        
    111 = 0E                            MSG_DST		equ	14
    112 = 0C                            MSG_SRC		equ	12
    113 = 09                            MSG_TTL		equ	9
    114 = 08                            MSG_TYPE	equ	8
                                        
    116 = 000000000000A000                              ETHERNET	EQU		0xA000
    117 = 00                            ETH_MODER		EQU		0x00
    118 = 04                            ETH_INT_SOURCE	EQU		0x04
    119 = 08                            ETH_INT_MASK	EQU		0x08
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 3
noc_boot31.a
    120 = 0C                            ETH_IPGT		EQU		0x0C
    121 = 10                            ETH_IPGR1		EQU		0x10
    122 = 14                            ETH_IPGR2		EQU		0x14
    123 = 18                            ETH_PACKETLEN	EQU		0x18
    124 = 1C                            ETH_COLLCONF	EQU		0x1C
    125 = 20                            ETH_TX_DB_NUM	EQU		0x20
    126 = 24                            ETH_CTRLMODER	EQU		0x24
    127 = 28                            ETH_MIIMODER	EQU		0x28
    128 = 2C                            ETH_MIICOMMAND	EQU		0x2C
    129 = 30                            ETH_MIIADDRESS	EQU		0x30
    130 = 34                            ETH_MIITXDATA	EQU		0x34
    131 = 38                            ETH_MIIRXDATA	EQU		0x38
    132 = 3C                            ETH_MIISTATUS	EQU		0x3C
    133 = 40                            ETH_MACADDR0	EQU		0x40
    134 = 44                            ETH_MACADDR1	EQU		0x44
    135 = 48                            ETH_HASH0_ADDR	EQU		0x48
    136 = 4C                            ETH_HASH1_ADDR	EQU		0x4C
    137 = 50                            ETH_TXCTRL		EQU		0x50
                                        
    139 = 4000                          eth_txbuf		EQU		$4000
    140 = 6000                          eth_rxbuf		EQU		$6000
                                        
                                        		bss
                                        		org		$10
    145 00000010                        unique_id	dw	0
                                        
                                        		.code
                                        		cpu		Butterfly16
                                        		org		0xE000
                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; Networking software components
                                        ; ============================================================================
                                        ;
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Zero out the transmit buffer.
                                        ; Used before building transmit buffer.
                                        ; Automatically inserts a time-to-live of 63, and the source id.
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 4
noc_boot31.a
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    189 0000E000                        zeroTxBuf:
    190 0000E000 FE 6E                   		add		sp,sp,#-2
    191 0000E002 E0 D2                   		sw		r2,[sp]
    192 0000E004 00 40 0F 12             		lw		r2,#15
    193 0000E008                        zeroTxBuf1:
    194 0000E008 02 40 20 C0             		sb		r0,txBuf[r2]
    195 0000E00C FF 62                   		sub		r2,r2,#1
    196 0000E00E FC BB                   		bpl		zeroTxBuf1
    197 0000E010 03 40 0F 12             		lw		r2,#63
    198 0000E014 02 40 09 C2             		sb		r2,txBuf+MSG_TTL
    199 0000E018 E4 32                   		tsr		r2,ID
    200 0000E01A 02 40 0C D2             		sw		r2,txBuf+MSG_SRC	; X+Y
    201 0000E01E E0 F2                   		lw		r2,[sp]
    202 0000E020 02 6E                   		add		sp,sp,#2
    203 0000E022 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Set the destination address field in the transmit buffer based on the
                                        ; source address in the receive buffer.
                                        ;----------------------------------------------------------------------------
                                        
    210 0000E024                        SetDestFromRx:
    211 0000E024 03 40 0C F1             		lw		r1,rxBuf+MSG_SRC
    212 0000E028 02 40 0E D1             		sw		r1,txBuf+MSG_DST
    213 0000E02C F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Transmit on the network.
                                        ; Blocks until the transmit buffer is open.
                                        ;
                                        ; Prerequisites:
                                        ;	The transmit buffer txBuf must have already been loaded.
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    229 0000E02E FA 6E                  Xmit:	
    230 0000E030 E0 D1                   		sw		r1,[sp]
    231 0000E032 E2 D2                   		sw		r2,2[sp]
    232 0000E034 E4 D3                   		sw		r3,4[sp]
                                        		; wait for transmit buffer to empty
                                        		; If transmit buffer empty signal times out, transmit anyway
                                        		; @100Mb/s 128 bits should transmit in only about 128 clock cycles.
    236 0000E036 00 13                   		lw		r3,#0
    237 0000E038                        Xmit2:
    238 0000E038 01 63                   		add		r3,r3,#1
    239 0000E03A FC 4F 3E 10             		cmp		r3,#50
    240 0000E03E 20 00                   		nop
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 5
noc_boot31.a
    241 0000E040 06 A7                   		bgtu	Xmit1
    242 0000E042 01 4B 02 E1             		lb		r1,ROUTER+RTR_TXSTAT
    243 0000E046 20 00                   		nop
    244 0000E048 F7 B9                   		bne		Xmit2
    245 0000E04A 00 40 0F 12             		lw		r2,#15
    246 0000E04E                        Xmit1:
    247 0000E04E 02 40 20 E1             		lb		r1,txBuf[r2]
    248 0000E052 00 4B 20 C1             		sb		r1,ROUTER[r2]
    249 0000E056 FF 62                   		add		r2,r2,#-1
    250 0000E058 20 00                   		nop
    251 0000E05A F9 BB                   		bpl		Xmit1
                                        		; trigger a transmit, writing any value will set the transmitter busy bit
    253 0000E05C 01 4B 02 C0             		sb		r0,ROUTER+RTR_TXSTAT
    254 0000E060 E0 F1                   		lw		r1,[sp]
    255 0000E062 E2 F2                   		lw		r2,2[sp]
    256 0000E064 E4 F3                   		lw		r3,4[sp]
    257 0000E066 06 6E                   		add		sp,sp,#6
    258 0000E068 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receive from network.
                                        ; Receive status must have already indicated a message present.
                                        ; Copies recieve buffer from router to rxBuf.
                                        ; The router fifo is configured with first word fall-through. This means
                                        ; the data word appears on the fifo output before the fifo is popped.
                                        ; A fifo pop signal has to be sent after reading the data.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    276 0000E06A                        Recv:
    277 0000E06A FC 6E                   		add		sp,sp,#-4
    278 0000E06C E0 D1                   		sw		r1,[sp]
    279 0000E06E E2 D2                   		sw		r2,2[sp]
                                        		; Pop the rx fifo.
                                        		; This bit $40 should automatically clear so we don't need to
                                        		; set it back to zero.
    283 0000E070 01 4B 01 E1             		lb		r1,ROUTER+RTR_RXCTL
    284 0000E074 04 40 60 31             		or		r1,#$40
    285 0000E078 01 4B 01 C1             		sb		r1,ROUTER+RTR_RXCTL
    286 0000E07C 0B 40 5F 31             		and		r1,#$BF
    287 0000E080 01 4B 01 C1             		sb		r1,ROUTER+RTR_RXCTL
    288 0000E084 00 40 0F 12             		lw		r2,#15
    289 0000E088                        Recv1:
    290 0000E088 00 4B 20 E1             		lb		r1,ROUTER[r2]			; copy message to local buffer
    291 0000E08C 03 40 20 C1             		sb		r1,rxBuf[r2]
    292 0000E090 FF 62                   		add		r2,r2,#-1
    293 0000E092 FA BB                   		bpl		Recv1
    294 0000E094 E0 F1                   		lw		r1,[sp]
    295 0000E096 E2 F2                   		lw		r2,2[sp]
    296 0000E098 04 6E                   		add		sp,sp,#4
    297 0000E09A F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Handler for the ping function. A pink acknowledge message is sent back
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 6
noc_boot31.a
                                        ; to the sender.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    311 0000E09C                        PingHandler:
    312 0000E09C FC 6E                   		add		sp,sp,#-4
    313 0000E09E E0 DF                   		sw		lr,[sp]
    314 0000E0A0 E2 D1                   		sw		r1,2[sp]
    315 0000E0A2 AE BF                   		call	zeroTxBuf
    316 0000E0A4 BF BF                   		call	SetDestFromRx
    317 0000E0A6 01 40 02 11             		lw		r1,#MT_PING_ACK
    318 0000E0AA 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
    319 0000E0AE BF BF                   		call	Xmit
    320 0000E0B0 E0 FF                   		lw		lr,[sp]
    321 0000E0B2 E2 F1                   		lw		r1,2[sp]
    322 0000E0B4 04 6E                   		add		sp,sp,#4
    323 0000E0B6 F0 80                   		ret
                                        ;****************************************************************;
                                        ;                                                                ;
                                        ;		Tiny BASIC Worker for the Finitron Butterfly             ;
                                        ;                                                                ;
                                        ; Supports worker threads.                                       ;
                                        ; There is no user interface to worker threads so the commands   ;
                                        ; LOAD and SAVE are removed.                                     ;
                                        ;                                                                ;
                                        ; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                                        ; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                                        ; Adapted to the 68000 by:                                       ;
                                        ;	Gordon brndly						                         ;
                                        ;	12147 - 51 Street					                         ;
                                        ;	Edmonton AB  T5W 3G8					                     ;
                                        ;	Canada							                             ;
                                        ;	(updated mailing address for 1996)			                 ;
                                        ;                                                                ;
                                        ; Adapted to the Butterfly by:                                    ;
                                        ;    Robert Finch                                                ;
                                        ;    Ontario, Canada                                             ;
                                        ;	 rob<remove>@finitron.ca                                     ;  
                                        ;****************************************************************;
                                        ;   Copyright (C) 2005-2017 by Robert Finch. This program may be ;
                                        ;    freely distributed for personal use only. All commercial	 ;
                                        ;		       rights are reserved.			                     ;
                                        ;****************************************************************;
                                        ;
                                        ; Register Usage
                                        ; r8 = text pointer (global usage)
                                        ; r3,r4 = inputs parameters to subroutines
                                        ; r2 = return value
                                        ;
                                        ;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                                        ;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                                        ;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                                        
                                        ;	OPT	FRS,BRS 	forward ref.'s & brnches default to short
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 7
noc_boot31.a
                                        
                                        ;XMIT_FULL		equ	0x40		; the transmit buffer is full
                                        ;DATA_PRESENT	equ	0x08		; there is data preset at the serial port bc_uart3
    363 = 01                            DATA_PRESENT	equ	0x01		; there is data preset at the serial port bc_uart3
    364 = 20                            XMIT_NOT_FULL	equ	0x20
                                        
    366 = 00000000FFFFDC40                              TS_TIMER	equ		0xFFFFDC40		; system time slice timer
    367 = 00000000FFFFDC50                              KBD			equ		0xFFFFDC50
                                        
    369 = 00000000FFFFDCA0                              RAND		equ		0xFFFFDCA0
    370 = 00000000FFFFD800                              VIC			equ		0xFFFFD800
                                        
    372 = 2000                          VIDEORAM	equ		0x00002000
                                        
                                        ; BOOT ROM routines
                                        
    376 = 0000000FFFFFF804                              getSerial	equ		0xFFFFFF804	; get a serial port character
    377 = 0000000FFFFFF808                              peekSerial	equ		0xFFFFFF808	; get a serial port character
    378 = 0000000FFFFFF80C                              putSerial	equ		0xFFFFFF80C	; put a character to serial port
    379 = 0000000FFFFFF82C                              clearScreen	equ		0xFFFFFF82C	; clear the screen
    380 = 0000000FFFFFF840                              getKbdCharWait	equ	0xFFFFFF840
    381 = 0000000FFFFFF844                              getKbdChar		equ	0xFFFFFF844
                                        
    383 = 20                            warmStart   equ     0x20
    384 = 24                            usrJmp      equ     0x24
                                        
    386 = 0D                            CR		equ	0x0D		; ASCII equates
    387 = 0A                            LF		equ	0x0A
    388 = 09                            TAB		equ	0x09
    389 = 03                            CTRLC	equ	0x03
    390 = 08                            CTRLH	equ	0x08
    391 = 13                            CTRLS	equ	0x13
    392 = 18                            CTRLX	equ	0x18
                                        
    394 = 50                            BUFLEN	equ	80	;	length of keyboard input buffer
                                        
                                        	code
                                        ;	org	0xC000	;
                                        ;
                                        ; Standard jump table. You can change these addresses if you are
                                        ; customizing this interpreter for a different environment.
                                        ;
    403 0000E0B8 FF BE                  START	jmp	CSTART	;	Cold Start entry point
    404 0000E0BA 26 AE                  GOWARM	jmp	WSTART	;	Warm Start entry point
    405 0000E0BC 75 40 00 AE            GOOUT	jmp	OUTC	;	Jump to character-out routine
    406 0000E0C0 74 40 0F AE            GOIN	jmp	INC		;Jump to character-in routine
    407 0000E0C4 78 40 00 AE            GOAUXO	jmp	AUXOUT	;	Jump to auxiliary-out routine
    408 0000E0C8 79 40 0D AE            GOAUXI	jmp	AUXIN	;	Jump to auxiliary-in routine
    409 0000E0CC 7C 40 0F AE            GOBYE	jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                                        ;
                                        ; Modifiable system constants:
                                        ;
    413 0000E0D0 00 02                  TXTBGN	dw	0x0200		;beginning of program memory
    414 0000E0D2 00 1E                  ENDMEM	dw	0x1E00	;	end of available memory
                                        ;
    416 0000E0D4                        INITTBW:
                                        	; First save off the link register and OS sp value
    418 0000E0D4 FE 6E                   	sub		sp,sp,#2
    419 0000E0D6 E0 DF                   	sw		lr,[sp]
    420 0000E0D8 0D 4E 00 F1             	lw		r1,TXTBGN	;	init. end-of-program pointer
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 8
noc_boot31.a
    421 0000E0DC 05 40 06 D1             	sw		r1,TXTUNF
    422 0000E0E0 0D 4E 02 F1             	lw		r1,ENDMEM	;	get address of end of memory
    423 0000E0E4 E0 4F 10 11             	sub		r1,r1,#512	; 	reserve 512 bytes for the stack
    424 0000E0E8 06 40 00 D1             	sw		r1,STKBOT
    425 0000E0EC E0 4F 10 11             	sub     r1,r1,#512 ;   128 vars
    426 0000E0F0 05 40 08 D1             	sw      r1,VARBGN
    427 0000E0F4 EB AF                   	call    clearVars   ; clear the variable area
    428 0000E0F6 04 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    429 0000E0FA 04 40 08 D0             	sw		r0,STKGOS
    430 0000E0FE 04 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    431 0000E102 E0 FF                   	lw		lr,[sp]
    432 0000E104 02 6E                   	add		sp,sp,#2
    433 0000E106 F0 80                   	ret
                                        ;
                                        ; The main interpreter starts here:
                                        ;
                                        ; Usage
                                        ; r1 = temp
                                        ; r8 = text buffer pointer
                                        ; r12 = end of text in text buffer
                                        ;
                                        	; At the end of the running program it'll go back to
                                        	; the warm start location. Use this to return.
    444 0000E108                        WSTART
    445 0000E108 04 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    446 0000E10C 04 40 08 D0             	sw		r0,STKGOS
    447 0000E110 04 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    448 0000E114 04 40 04 FE             	lw		sp,OSSP
    449 0000E118 E0 FF                   	lw		lr,[sp]
    450 0000E11A 02 6E                   	add		sp,sp,#2
    451 0000E11C F0 80                   	ret
                                        
                                        	; Entry point which is called by the reciever dispatcher.
    454 0000E11E                        ST3:
    455 0000E11E FE 6E                   	add		sp,sp,#-2
    456 0000E120 E0 DF                   	sw		lr,[sp]
    457 0000E122 04 40 04 DE             	sw		sp,OSSP
    458 0000E126 0D 4E 02 FE             	lw		sp,ENDMEM	;	init S.P.
    459 0000E12A 6C 40 01 AF             	call	TOUPBUF 	; convert to upper case
    460 0000E12E 80 1C                   	lw		r12,r8		; save pointer to end of line
    461 0000E130 06 40 0E 18             	lea		r8,BUFFER	; point to the beginning of line
    462 0000E134 6F AE                   	br		DIRECT
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** Tables *** DIRECT *** EXEC ***
                                        ;
                                        ; This section of the code tests a string against a table. When
                                        ; a match is found, control is transferred to the section of
                                        ; code according to the table.
                                        ;
                                        ; At 'EXEC', r8 should point to the string, r9 should point to
                                        ; the character table, and r10 should point to the execution
                                        ; table. At 'DIRECT', r8 should point to the string, r9 and
                                        ; r10 will be set up to point to TAB1 and TAB1_1, which are
                                        ; the tables of all direct and statement commands.
                                        ;
                                        ; A '.' in the string will terminate the test and the partial
                                        ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 9
noc_boot31.a
                                        ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                                        ;
                                        ; There are two tables: the character table and the execution
                                        ; table. The character table consists of any number of text items.
                                        ; Each item is a string of characters with the last character's
                                        ; high bit set to one. The execution table holds a 32-bit
                                        ; execution addresses that correspond to each entry in the
                                        ; character table.
                                        ;
                                        ; The end of the character table is a 0 byte which corresponds
                                        ; to the default routine in the execution table, which is
                                        ; executed if none of the other table items are matched.
                                        ;
                                        ; Character-matching tables:
    495 0000E136                        TAB1
    496 0000E136 4C 49 53 D4             	db	"LIS",('T'+0x80)        ; Direct commands
    497 0000E13A 4E 45 D7                	db	"NE",('W'+0x80)
    498 0000E13D 52 55 CE                	db	"RU",('N'+0x80)
    499 0000E140                        TAB2
    500 0000E140 4E 45 58 D4             	db	"NEX",('T'+0x80)         ; Direct / statement
    501 0000E144 4C 45 D4                	db	"LE",('T'+0x80)
    502 0000E147 49 C6                   	db	"I",('F'+0x80)
    503 0000E149 47 4F 54 CF             	db	"GOT",('O'+0x80)
    504 0000E14D 47 4F 53 55 C2          	db	"GOSU",('B'+0x80)
    505 0000E152 52 45 54 55 52 CE       	db	"RETUR",('N'+0x80)
    506 0000E158 52 45 CD                	db	"RE",('M'+0x80)
    507 0000E15B 46 4F D2                	db	"FO",('R'+0x80)
    508 0000E15E 49 4E 50 55 D4          	db	"INPU",('T'+0x80)
    509 0000E163 50 52 49 4E D4          	db	"PRIN",('T'+0x80)
    510 0000E168 50 4F 4B 45 D7          	db	"POKE",('W'+0x80)
    511 0000E16D 50 4F 4B C5             	db	"POK",('E'+0x80)
    512 0000E171 53 54 4F D0             	db	"STO",('P'+0x80)
    513 0000E175 42 59 C5                	db	"BY",('E'+0x80)
    514 0000E178 53 59 D3                	db	"SY",('S'+0x80)
    515 0000E17B 43 4C D2                    db  "CL",('R'+0x80)
    516 0000E17E 45 58 49 D4             	db	"EXI",('T'+0x80)
    517 0000E182 00                      	db	0
    518 0000E183                        TAB4
    519 0000E183 4E 4F 44 45 4E 55 CD    	db	"NODENU",('M'+0x80)
                                      
    520 0000E18A 50 45 45 4B D7          	db	"PEEK",('W'+0x80)        ;Functions
    521 0000E18F 50 45 45 CB             	db	"PEE",('K'+0x80)         ;Functions
    522 0000E193 52 4E C4                	db	"RN",('D'+0x80)
    523 0000E196 41 42 D3                	db	"AB",('S'+0x80)
    524 0000E199 53 49 5A C5             	db	"SIZ",('E'+0x80)
    525 0000E19D 55 53 D2                	db  "US",('R'+0x80)
    526 0000E1A0 00                      	db	0
    527 0000E1A1                        TAB5
    528 0000E1A1 54 CF                   	db	"T",('O'+0x80)           ;"TO" in "FOR"
    529 0000E1A3 00                      	db	0
    530 0000E1A4                        TAB6
    531 0000E1A4 53 54 45 D0             	db	"STE",('P'+0x80)         ;"STEP" in "FOR"
    532 0000E1A8 00                      	db	0
    533 0000E1A9                        TAB8
    534 0000E1A9 3E BD                   	db	'>',('='+0x80)           ;Relational operators
    535 0000E1AB 3C BE                   	db	'<',('>'+0x80)
    536 0000E1AD BE                      	db	('>'+0x80)
    537 0000E1AE BD                      	db	('='+0x80)
    538 0000E1AF 3C BD                   	db	'<',('='+0x80)
    539 0000E1B1 BC                      	db	('<'+0x80)
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 10
noc_boot31.a
    540 0000E1B2 00                      	db	0
    541 0000E1B3                        TAB9
    542 0000E1B3 41 4E C4                    db  "AN",('D'+0x80)
    543 0000E1B6 00                          db  0
    544 0000E1B7                        TAB10
    545 0000E1B7 4F D2                       db  "O",('R'+0x80)
    546 0000E1B9 00                          db  0
                                        
    548 0000E1BA FF FF                   	.align	4
                                        
                                        ;* Execution address tables:
    551 0000E1BC                        TAB1_1
    552 0000E1BC EA E2                   	dw	LISTX			;Direct commands
    553 0000E1BE 68 E2                   	dw	NEW
    554 0000E1C0 7C E2                   	dw	RUN
    555 0000E1C2                        TAB2_1
    556 0000E1C2 3C E4                   	dw	NEXT		;	Direct / statement
    557 0000E1C4 36 E5                   	dw	LET
    558 0000E1C6 96 E4                   	dw	IF
    559 0000E1C8 AE E2                   	dw	GOTO
    560 0000E1CA 82 E3                   	dw	GOSUB
    561 0000E1CC B2 E3                   	dw	RETURN
    562 0000E1CE 9C E4                   	dw	IF2			; REM
    563 0000E1D0 DC E3                   	dw	FOR
    564 0000E1D2 BA E4                   	dw	INPUT
    565 0000E1D4 1E E3                   	dw	PRINT
    566 0000E1D6 20 E6                   	dw	POKEW
    567 0000E1D8 00 E6                   	dw	POKE
    568 0000E1DA 76 E2                   	dw	STOP
    569 0000E1DC CC E0                   	dw	GOBYE
    570 0000E1DE 38 E6                   	dw	SYSX
    571 0000E1E0 C8 E2                   	dw  _clr
    572 0000E1E2 88 F0                   	dw	EXIT
    573 0000E1E4 2E E5                   	dw	DEFLT
    574 0000E1E6                        TAB4_1
    575 0000E1E6 62 EA                   	dw	NODENUM
    576 0000E1E8 B4 E9                   	dw  PEEKW
    577 0000E1EA A8 E9                   	dw	PEEK			;Functions
    578 0000E1EC D2 E9                   	dw	RND
    579 0000E1EE 2C EA                   	dw	ABS
    580 0000E1F0 52 EA                   	dw	SIZEX
    581 0000E1F2 C0 E9                   	dw  USRX
    582 0000E1F4 DE E7                   	dw	XP40
    583 0000E1F6                        TAB5_1
    584 0000E1F6 F2 E3                   	dw	FR1			;"TO" in "FOR"
    585 0000E1F8 E2 EA                   	dw	QWHAT
    586 0000E1FA                        TAB6_1
    587 0000E1FA 04 E4                   	dw	FR2			;"STEP" in "FOR"
    588 0000E1FC 0A E4                   	dw	FR3
    589 0000E1FE                        TAB8_1
    590 0000E1FE 00 E7                   	dw	XP11	;>=		Relational operators
    591 0000E200 0A E7                   	dw	XP12	;<>
    592 0000E202 14 E7                   	dw	XP13	;>
    593 0000E204 28 E7                   	dw	XP15	;=
    594 0000E206 1E E7                   	dw	XP14	;<=
    595 0000E208 32 E7                   	dw	XP16	;<
    596 0000E20A 4C E7                   	dw	XP17
    597 0000E20C                        TAB9_1
    598 0000E20C 8C E6                       dw  XP_AND
    599 0000E20E 94 E6                       dw  XP_ANDX
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 11
noc_boot31.a
    600 0000E210                        TAB10_1
    601 0000E210 68 E6                       dw  XP_OR
    602 0000E212 70 E6                       dw  XP_ORX
                                        
                                        ;*
                                        ; r3 = match flag (trashed)
                                        ; r9 = text table
                                        ; r10 = exec table
                                        ; r11 = trashed
    609 0000E214                        DIRECT
    610 0000E214 13 4E 06 19             	lea		r9,TAB1
    611 0000E218 1B 4E 0C 1A             	lea		r10,TAB1_1
    612 0000E21C                        EXEC
    613 0000E21C F0 1B                   	lw		r11,lr		; save link reg
    614 0000E21E 63 40 09 AF             	call	IGNBLK		; ignore leading blanks
    615 0000E222 B0 1F                   	lw		lr,r11		; restore link reg
    616 0000E224 80 1B                   	lw		r11,r8		; save the pointer
    617 0000E226 00 13                   	lw		r3,#0		; clear match flag
    618 0000E228                        EXLP
    619 0000E228 80 E1                   	lb		r1,[r8]		; get the program character
    620 0000E22A 01 68                   	add		r8,r8,#1
    621 0000E22C 90 E2                   	lb		r2,[r9]		; get the table character
    622 0000E22E 02 A9                   	bne		EXNGO		; If end of table,
    623 0000E230 B0 18                   	lw		r8,r11		;	restore the text pointer and...
    624 0000E232 12 AE                   	br		EXGO		;   execute the default.
    625 0000E234                        EXNGO
    626 0000E234 3D 21                   	cmp		r1,r3		; Else check for period...
    627 0000E236 10 A8                   	beq		EXGO		; if so, execute
    628 0000E238 07 40 5F 32             	and		r2,#0x7f	; ignore the table's high bit
    629 0000E23C 1D 22                   	cmp		r2,r1		;		is there a match?
    630 0000E23E 07 A8                   	beq		EXMAT
    631 0000E240 04 6A                   	add		r10,r10,#4	;if not, try the next entry
    632 0000E242 B0 18                   	lw		r8,r11		; reset the program pointer
    633 0000E244 00 13                   	lw		r3,#0		; sorry, no match
    634 0000E246                        EX1
    635 0000E246 01 69                   	add		r9,r9,#1
    636 0000E248 9F E1                   	lb		r1,-1[r9]	; get to the end of the entry
    637 0000E24A FD BB                   	bpl		EX1
    638 0000E24C ED BE                   	br		EXLP		; back for more matching
    639 0000E24E                        EXMAT
    640 0000E24E 02 40 0E 13             	lw		r3,#'.'		; we've got a match so far
    641 0000E252 01 69                   	add		r9,r9,#1
    642 0000E254 9F E1                   	lb		r1,-1[r9]	; end of table entry?
    643 0000E256 E8 BB                   	bpl		EXLP		; if not, go back for more
    644 0000E258                        EXGO
    645 0000E258 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
    646 0000E25C 03 A8                   	beq		EXGO1
    647 0000E25E 05 BF                   	call	Recv
    648 0000E260 83 40 0E AF             	call	RecvDispatch
    649 0000E264                        EXGO1
    650 0000E264 A0 FB                   	lw		r11,[r10]	; execute the appropriate routine
    651 0000E266 B0 80                   	jmp		[r11]
                                        
                                        
                                        ;    lb      r1,[r8]     ; get token from text space
                                        ;    bpl
                                        ;    and     r1,#0x7f
                                        ;    shl     r1,#2       ; * 4 - word offset
                                        ;    add     r1,r1,#TAB1_1
                                        ;    lw      r1,[r1]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 12
noc_boot31.a
                                        ;    jmp     [r1]
                                        
                                            
                                        ;
                                        ; What follows is the code to execute direct and statement
                                        ; commands. Control is transferred to these points via the command
                                        ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                                        ; After the command is executed, control is transferred to other
                                        ; sections as follows:
                                        ;
                                        ; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                                        ; For 'RUN': go execute the first stored line if any; else go
                                        ; back to the warm start point.
                                        ; For 'GOTO' and 'GOSUB': go execute the target line.
                                        ; For 'RETURN' and 'NEXT'; go back to saved return line.
                                        ; For all others: if 'CURRNT' is 0, go to warm start; else go
                                        ; execute next command. (This is done in 'FINISH'.)
                                        ;
                                        ;******************************************************************
                                        ;
                                        ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                                        ;
                                        ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                                        ;
                                        ; 'STOP<CR>' goes back to WSTART
                                        ;
                                        ; 'RUN<CR>' finds the first stored line, stores its address
                                        ; in CURRNT, and starts executing it. Note that only those
                                        ; commands in TAB2 are legal for a stored program.
                                        ;
                                        ; RUN ON <node number> sends a run command to the specified node
                                        ;
                                        ; There are 3 more entries in 'RUN':
                                        ; 'RUNNXL' finds next line, stores it's address and executes it.
                                        ; 'RUNTSL' stores the address of this line and executes it.
                                        ; 'RUNSML' continues the execution on same line.
                                        ;
                                        ; 'GOTO expr<CR>' evaluates the expression, finds the target
                                        ; line, and jumps to 'RUNTSL' to do it.
                                        ;
    700 0000E268                        NEW
    701 0000E268 42 40 07 AF             	call	ENDCHK
    702 0000E26C 0D 4E 00 F1             	lw		r1,TXTBGN
    703 0000E270 05 40 06 D1             	sw		r1,TXTUNF	;	set the end pointer
    704 0000E274 2B AF                   	call    clearVars
                                        
    706 0000E276                        STOP
    707 0000E276 42 40 00 AF             	call	ENDCHK
    708 0000E27A 46 BE                   	br		WSTART		; WSTART will reset the stack
                                        
    710 0000E27C                        RUN
    711 0000E27C 41 40 0D AF             	call	ENDCHK
    712 0000E280 0D 4E 00 F8             	lw		r8,TXTBGN	;	set pointer to beginning
    713 0000E284 04 40 06 D8             	sw		r8,CURRNT
    714 0000E288 21 AF                   	call    clearVars
                                        
    716 0000E28A                        RUNNXL					; RUN <next line>
    717 0000E28A 04 40 06 F1             	lw		r1,CURRNT	; executing a program?
    718 0000E28E 3C B8                   	beq		WSTART		; if not, we've finished a direct stat.
    719 0000E290 00 11                   	lw		r1,#0	    ; else find the next line number
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 13
noc_boot31.a
    720 0000E292 80 19                   	lw		r9,r8
    721 0000E294 49 40 0D AF             	call	FNDLNP		; search for the next line
    722 0000E298 37 B7                   	bgtu	WSTART		; if we've fallen off the end, stop
                                        
    724 0000E29A                        RUNTSL					; RUN <this line>
    725 0000E29A 04 40 06 D9             	sw		r9,CURRNT	; set CURRNT to point to the line no.
    726 0000E29E 92 18                   	lea		r8,2[r9]	; set the text pointer to
                                        
    728 0000E2A0                        RUNSML                  ; RUN <same line>
    729 0000E2A0 62 40 0E AF             	call	CHKIO		; see if a control-C was pressed
    730 0000E2A4 14 4E 00 19             	lea		r9,TAB2		; find command in TAB2
    731 0000E2A8 1C 4E 02 1A             	lea		r10,TAB2_1
    732 0000E2AC B7 BE                   	br		EXEC		; and execute it
                                        
    734 0000E2AE                        GOTO
    735 0000E2AE 1D 40 01 AF             	call	OREXPR		;evaluate the following expression
    736 0000E2B2 10 15                   	lw      r5,r1
    737 0000E2B4 40 40 01 AF             	call	ENDCHK		;must find end of line
    738 0000E2B8 50 11                   	lw      r1,r5
    739 0000E2BA 48 40 02 AF             	call	FNDLN		; find the target line
    740 0000E2BE ED B8                   	beq		RUNTSL		; go do it
    741 0000E2C0 25 4F 0B 11             	lea		r1,msgBadGotoGosub
    742 0000E2C4 40 40 0F AE             	br		ERROR		; no such line no.
                                        
                                        
    745 0000E2C8                        _clr
    746 0000E2C8 01 AF                       call    clearVars
    747 0000E2CA 57 AE                       br      FINISH
                                        
                                        ; Clear the variable area of memory
    750 0000E2CC                        clearVars
    751 0000E2CC FC 6E                       sub     sp,sp,#4
    752 0000E2CE E0 DF                       sw      lr,[sp]
    753 0000E2D0 E2 D6                       sw      r6,2[sp]
    754 0000E2D2 80 40 00 16                 lw      r6,#2048    ; number of words to clear
    755 0000E2D6 05 40 08 F1                 lw      r1,VARBGN
    756 0000E2DA                        cv1
    757 0000E2DA 10 D0                       sw      r0,[r1]
    758 0000E2DC 04 61                       add     r1,r1,#4
    759 0000E2DE FF 66                       sub		r6,r6,#1
    760 0000E2E0 FC B9                       bne     cv1
    761 0000E2E2 E0 FF                       lw      lr,[sp]
    762 0000E2E4 E2 F6                       lw      r6,2[sp]
    763 0000E2E6 04 6E                       add     sp,sp,#4
    764 0000E2E8 F0 80                       ret    
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; LIST
                                        ;
                                        ; LISTX has two forms:
                                        ; 'LIST<CR>' lists all saved lines
                                        ; 'LIST #<CR>' starts listing at the line #
                                        ; Control-S pauses the listing, control-C stops it.
                                        ;
                                        
    777 0000E2EA                        LISTX
    778 0000E2EA 5B 40 02 AF             	call	TSTNUM		; see if there's a line no.
    779 0000E2EE 10 15                   	lw      r5,r1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 14
noc_boot31.a
    780 0000E2F0 3E 40 03 AF             	call	ENDCHK		; if not, we get a zero
    781 0000E2F4 50 11                   	lw      r1,r5
    782 0000E2F6 46 40 04 AF             	call	FNDLN		; find this or next line
    783 0000E2FA                        LS1
    784 0000E2FA 06 B7                   	bgtu	WSTART		; warm start if we passed the end
                                        
    786 0000E2FC 90 11                   	lw		r1,r9
    787 0000E2FE 57 40 08 AF             	call	PRTLN		; print the line
    788 0000E302 10 19                   	lw		r9,r1		; set pointer for next
    789 0000E304 5F 40 0C AF             	call	CHKIO		; check for listing halt request
    790 0000E308 06 A8                   	beq		LS3
    791 0000E30A FE 4F 1D 10             	cmp		r1,#CTRLS	; pause the listing?
    792 0000E30E 03 A9                   	bne		LS3
    793 0000E310                        LS2
    794 0000E310 5F 40 06 AF             	call	CHKIO		; if so, wait for another keypress
    795 0000E314 FD B8                   	beq		LS2
    796 0000E316                        LS3
    797 0000E316 00 11                   	lw		r1,#0
    798 0000E318 45 40 0B AF             	call	FNDLNP		; find the next line
    799 0000E31C EE BE                   	br		LS1
                                        
                                        
                                        ;******************************************************************
                                        ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                                        ; where '....' is a list of expressions, formats, back-arrows,
                                        ; and strings.	These items a separated by commas.
                                        ;
                                        ; A format is a pound sign followed by a number.  It controls
                                        ; the number of spaces the value of an expression is going to
                                        ; be printed in.  It stays effective for the rest of the print
                                        ; command unless changed by another format.  If no format is
                                        ; specified, 11 positions will be used.
                                        ;
                                        ; A string is quoted in a pair of single- or double-quotes.
                                        ;
                                        ; An underline (back-arrow) means generate a <CR> without a <LF>
                                        ;
                                        ; A <CR LF> is generated after the entire list has been printed
                                        ; or if the list is empty.  If the list ends with a semicolon,
                                        ; however, no <CR LF> is generated.
                                        ;
                                        
    822 0000E31E                        PRINT
    823 0000E31E 0B 15                   	lw		r5,#11		; D4 = number of print spaces
    824 0000E320 58 40 05 AF             	call	TSTC		; if null list and ":"
    825 0000E324 3A 08                   	db	':',PR2-*+1
    826 0000E326 5F 40 0B AF             	call	CRLF		; give CR-LF and continue
    827 0000E32A BA BE                   	br		RUNSML		;		execution on the same line
    828 0000E32C                        PR2
    829 0000E32C 57 40 0F AF             	call	TSTC		;if null list and <CR>
    830 0000E330 0D 08                   	db	CR,PR0-*+1
    831 0000E332 5F 40 05 AF             	call	CRLF		;also give CR-LF and
    832 0000E336 A9 BE                   	br		RUNNXL		;execute the next line
    833 0000E338                        PR0
    834 0000E338 57 40 09 AF             	call	TSTC		;else is it a format?
    835 0000E33C 23 0A                   	db	'#',PR1-*+1
    836 0000E33E 18 40 09 AF             	call	OREXPR		; yes, evaluate expression
    837 0000E342 10 15                   	lw		r5,r1		; and save it as print width
    838 0000E344 0B AE                   	br		PR3		; look for more to print
    839 0000E346                        PR1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 15
noc_boot31.a
    840 0000E346 57 40 02 AF             	call	TSTC	;	is character expression? (MRL)
    841 0000E34A 24 0C                   	db	'$',PR4-*+1
    842 0000E34C 18 40 02 AF             	call	OREXPR	;	yep. Evaluate expression (MRL)
    843 0000E350 EB 4F 04 AF             	call	GOOUT	;	print low byte (MRL)
    844 0000E354 03 AE                   	br		PR3		;look for more. (MRL)
    845 0000E356                        PR4
    846 0000E356 4B 40 00 AF             	call	QTSTG	;	is it a string?
                                        	; the following branch must occupy only two bytes!
    848 0000E35A 09 AE                   	br		PR8		;	if not, must be an expression
    849 0000E35C                        PR3
    850 0000E35C 56 40 07 AF             	call	TSTC	;	if ",", go find next
    851 0000E360 2C 08                   	db	',',PR6-*+1
    852 0000E362 39 40 08 AF             	call	FIN		;in the list.
    853 0000E366 E8 BE                   	br		PR0
    854 0000E368                        PR6
    855 0000E368 5D 40 0A AF             	call	CRLF		;list ends here
    856 0000E36C 06 AE                   	br		FINISH
    857 0000E36E                        PR8
    858 0000E36E 17 40 01 AF             	call	OREXPR		; evaluate the expression
    859 0000E372 50 12                   	lw		r2,r5		; set the width
    860 0000E374 4C 40 0D AF             	call	PRTNUM		; print its value
    861 0000E378 F1 BE                   	br		PR3			; more to print?
                                        
    863 0000E37A                        FINISH
    864 0000E37A 38 40 0C AF             	call	FIN		; Check end of command
    865 0000E37E 3B 40 00 AE             	jmp		QWHAT	; print "What?" if wrong
                                        
                                        
                                        ;*******************************************************************
                                        ;
                                        ; *** GOSUB *** & RETURN ***
                                        ;
                                        ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                                        ; except that the current text pointer, stack pointer, etc. are
                                        ; saved so that execution can be continued after the subroutine
                                        ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                                        ; recursive), the save area must be stacked.  The stack pointer
                                        ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                                        ; If we are in the main routine, 'STKGOS' is zero (this was done
                                        ; in the initialization section of the interpreter), but we still
                                        ; save it as a flag for no further 'RETURN's.
                                        ;
    882 0000E382                        GOSUB
    883 0000E382 46 40 04 AF             	call	PUSHA		; save the current 'FOR' parameters
    884 0000E386 16 40 05 AF             	call	OREXPR		; get line number
    885 0000E38A 41 40 0A AF             	call	FNDLN		; find the target line
    886 0000E38E 04 A8                   	beq		gosub1
    887 0000E390 25 4F 0B 11             	lea		r1,msgBadGotoGosub
    888 0000E394 3A 40 07 AE             	br		ERROR		; if not there, say "How?"
    889 0000E398                        gosub1
    890 0000E398 FA 6E                   	sub		sp,sp,#6
    891 0000E39A E0 D8                   	sw		r8,[sp]		; save text pointer
    892 0000E39C 04 40 06 F1             	lw		r1,CURRNT
    893 0000E3A0 E2 D1                   	sw		r1,2[sp]	; found it, save old 'CURRNT'...
    894 0000E3A2 04 40 08 F1             	lw		r1,STKGOS
    895 0000E3A6 E4 D1                   	sw		r1,4[sp]	; and 'STKGOS'
    896 0000E3A8 04 40 0C D0             	sw		r0,LOPVAR	; load new values
    897 0000E3AC 04 40 08 DE             	sw		sp,STKGOS
    898 0000E3B0 74 BE                   	br		RUNTSL
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 16
noc_boot31.a
                                        
                                        ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                                        ; returns the execution to the command after the most recent
                                        ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                                        ; a 'GOSUB' and is thus an error.
                                        ;
    906 0000E3B2                        RETURN
    907 0000E3B2 38 40 02 AF             	call	ENDCHK		; there should be just a <CR>
    908 0000E3B6 04 40 08 F1             	lw		r1,STKGOS	; get old stack pointer
    909 0000E3BA 04 A9                   	bne		return1
    910 0000E3BC 27 4F 08 11             	lea		r1,msgRetWoGosub
    911 0000E3C0 39 40 01 AE             	br		ERROR		; if zero, it doesn't exist
    912 0000E3C4                        return1
    913 0000E3C4 10 1E                   	lw		sp,r1		; else restore it
    914 0000E3C6 E4 F1                   	lw		r1,4[sp]
    915 0000E3C8 04 40 08 D1             	sw		r1,STKGOS	; and the old 'STKGOS'
    916 0000E3CC E2 F1                   	lw		r1,2[sp]
    917 0000E3CE 04 40 06 D1             	sw		r1,CURRNT	; and the old 'CURRNT'
    918 0000E3D2 E0 F8                   	lw		r8,[sp]		; and the old text pointer
    919 0000E3D4 06 6E                   	add		sp,sp,#6
    920 0000E3D6 42 40 06 AF             	call	POPA		;and the old 'FOR' parameters
    921 0000E3DA CF BE                   	br		FINISH		;and we are back home
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** FOR *** & NEXT ***
                                        ;
                                        ; 'FOR' has two forms:
                                        ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                                        ; The second form means the same thing as the first form with a
                                        ; STEP of positive 1.  The interpreter will find the variable 'var'
                                        ; and set its value to the current value of 'exp1'.  It also
                                        ; evaluates 'exp2' and 'exp1' and saves all these together with
                                        ; the text pointer, etc. in the 'FOR' save area, which consisits of
                                        ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                                        ; already something in the save area (indicated by a non-zero
                                        ; 'LOPVAR'), then the old save area is saved on the stack before
                                        ; the new values are stored.  The interpreter will then dig in the
                                        ; stack and find out if this same variable was used in another
                                        ; currently active 'FOR' loop.  If that is the case, then the old
                                        ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                                        ;
    943 0000E3DC                        FOR
    944 0000E3DC 43 40 07 AF             	call	PUSHA		; save the old 'FOR' save area
    945 0000E3E0 34 40 03 AF             	call	SETVAL		; set the control variable
    946 0000E3E4 04 40 0C D1             	sw		r1,LOPVAR	; save its address
    947 0000E3E8 1A 4E 01 19             	lea		r9,TAB5		; use 'EXEC' to test for 'TO'
    948 0000E3EC 1F 4E 06 1A             	lea		r10,TAB5_1
    949 0000E3F0 15 BE                   	jmp		EXEC
    950 0000E3F2                        FR1
    951 0000E3F2 12 40 0F AF             	call	OREXPR		; evaluate the limit
    952 0000E3F6 05 40 00 D1             	sw		r1,LOPLMT	; save that
    953 0000E3FA 1A 4E 04 19             	lea		r9,TAB6		; use 'EXEC' to look for the
    954 0000E3FE 1F 4E 0A 1A             	lea		r10,TAB6_1	; word 'STEP'
    955 0000E402 0C BE                   	jmp		EXEC
    956 0000E404                        FR2
    957 0000E404 12 40 06 AF             	call	OREXPR		; found it, get the step value
    958 0000E408 01 AE                   	br		FR4
    959 0000E40A                        FR3
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 17
noc_boot31.a
    960 0000E40A 01 11                   	lw		r1,#1		; not found, step defaults to 1
    961 0000E40C                        FR4
    962 0000E40C 04 40 0E D1             	sw		r1,LOPINC	; save that too
                                        
    964 0000E410                        FR5
    965 0000E410 04 40 06 F2             	lw		r2,CURRNT
    966 0000E414 05 40 02 D2             	sw		r2,LOPLN	; save address of current line number
    967 0000E418 05 40 04 D8             	sw		r8,LOPPT	; and text pointer
                                        
                                        
    970 0000E41C E0 13                   	lw		r3,sp		; dig into the stack to find 'LOPVAR'
    971 0000E41E 04 40 0C F6             	lw		r6,LOPVAR
    972 0000E422 01 AE                   	br		FR7
    973 0000E424                        FR6
    974 0000E424 3A 13                   	lea		r3,10[r3]	; look at next stack frame
    975 0000E426                        FR7
    976 0000E426 30 F2                   	lw		r2,[r3]		; is it zero?
    977 0000E428 08 A8                   	beq		FR8			; if so, we're done
    978 0000E42A 6D 22                   	cmp		r2,r6		; same as current LOPVAR?
    979 0000E42C FB B9                   	bne		FR6			; nope, look some more
                                        
    981 0000E42E 30 11                       lw      r1,r3       ; Else remove 5 words from...
    982 0000E430 3A 12                   	lea		r2,10[r3]   ; inside the stack.
    983 0000E432 E0 13                   	lw		r3,sp		
    984 0000E434 3F 40 04 AF             	call	MVDOWN
    985 0000E438 0A 6E                   	add		sp,sp,#10	; set the SP 5 words up
    986 0000E43A                        FR8
    987 0000E43A 9F BE                       br	    FINISH		; and continue execution
                                        
                                        
                                        ; 'NEXT var' serves as the logical (not necessarily physical) end
                                        ; of the 'FOR' loop.  The control variable 'var' is checked with
                                        ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                                        ; the stack to find the right one and purges all those that didn't
                                        ; match.  Either way, it then adds the 'STEP' to that variable and
                                        ; checks the result with against the limit value.  If it is within
                                        ; the limit, control loops back to the command following the
                                        ; 'FOR'.  If it's outside the limit, the save area is purged and
                                        ; execution continues.
                                        ;
   1000 0000E43C                        NEXT
   1001 0000E43C 00 11                   	lw		r1,#0		; don't allocate it
   1002 0000E43E 1E 40 0D AF             	call	TSTV		; get address of variable
   1003 0000E442 04 A9                   	bne		NX4
   1004 0000E444 23 4F 07 11             	lea		r1,msgNextVar
   1005 0000E448 34 40 0D AE             	br		ERROR		; if no variable, say "What?"
   1006 0000E44C                        NX4
   1007 0000E44C 10 19                   	lw		r9,r1		; save variable's address
   1008 0000E44E                        NX0
   1009 0000E44E 04 40 0C F1             	lw		r1,LOPVAR	; If 'LOPVAR' is zero, we never...
   1010 0000E452 04 A9                   	bne		NX5         ; had a FOR loop
   1011 0000E454 22 4F 04 11             	lea		r1,msgNextFor
   1012 0000E458 34 40 05 AE             	br		ERROR		
   1013 0000E45C                        NX5
   1014 0000E45C 9D 21                   	cmp		r1,r9		; else we check them
   1015 0000E45E 03 A8                   	beq		NX2			; OK, they agree
   1016 0000E460 3E 40 01 AF             	call	POPA		; nope, let's see the next frame
   1017 0000E464 F4 BE                   	br		NX0
   1018 0000E466                        NX2
   1019 0000E466 90 F1                   	lw		r1,[r9]		; get control variable's value
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 18
noc_boot31.a
   1020 0000E468 04 40 0E F2             	lw		r2,LOPINC
   1021 0000E46C 20 21                   	add		r1,r2		; add in loop increment
                                        ;	BVS.L	QHOW		say "How?" for 32-bit overflow
   1023 0000E46E 90 D1                   	sw		r1,[r9]		; save control variable's new value
   1024 0000E470 05 40 00 F3             	lw		r3,LOPLMT	; get loop's limit value
   1025 0000E474 26 22                   	or		r2,r2       ; check loop increment
   1026 0000E476 03 AB                   	bpl		NX1			; branch if loop increment is positive
   1027 0000E478 3D 21                   	cmp		r1,r3		; test against limit
   1028 0000E47A 0A A0                   	blt		NXPurge
   1029 0000E47C 02 AE                   	br      NX3
   1030 0000E47E                        NX1
   1031 0000E47E 3D 21                   	cmp		r1,r3
   1032 0000E480 07 A3                   	bgt		NXPurge
   1033 0000E482                        NX3	
   1034 0000E482 05 40 02 F8             	lw		r8,LOPLN	; Within limit, go back to the...
   1035 0000E486 04 40 06 D8             	sw		r8,CURRNT
   1036 0000E48A 05 40 04 F8             	lw		r8,LOPPT	; saved 'CURRNT' and text pointer.
   1037 0000E48E 75 BE                   	br		FINISH
                                        
   1039 0000E490                        NXPurge
   1040 0000E490 3C 40 09 AF                 call    POPA        ; purge this loop
   1041 0000E494 72 BE                       br      FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                                        ;
                                        ; 'REM' can be followed by anything and is ignored by the
                                        ; interpreter.
                                        ;
                                        ;REM
                                        ;    br	    IF2		    ; skip the rest of the line
                                        
                                        ; 'IF' is followed by an expression, as a condition and one or
                                        ; more commands (including other 'IF's) separated by colons.
                                        ; Note that the word 'THEN' is not used.  The interpreter evaluates
                                        ; the expression.  If it is non-zero, execution continues.  If it
                                        ; is zero, the commands that follow are ignored and execution
                                        ; continues on the next line.
                                        ;
   1061 0000E496                        IF
   1062 0000E496 DE AF                       call	OREXPR		; evaluate the expression
   1063 0000E498                        IF1
   1064 0000E498 16 21                       or      r1,r1       ; is it zero?
   1065 0000E49A 02 B9                       bne	    RUNSML		; if not, continue
   1066 0000E49C                        IF2
   1067 0000E49C 80 19                       lw		r9,r8		; set lookup pointer
   1068 0000E49E 00 11                   	lw		r1,#0		; find line #0 (impossible)
   1069 0000E4A0 3A 40 0D AF             	call	FNDSKP		; if so, skip the rest of the line
   1070 0000E4A4 E3 4F 00 A7             	bgtu	WSTART		; if no next line, do a warm start
   1071 0000E4A8                        IF3
   1072 0000E4A8 EF 4F 07 AE             	br		RUNTSL		; run the next line
                                        
                                        
                                        ; INPUT is called first and establishes a stack frame
   1076 0000E4AC                        INPERR
   1077 0000E4AC 04 40 0A FE             	lw		sp,STKINP	; restore the old stack pointer
   1078 0000E4B0 E4 F8                   	lw		r8,4[sp]
   1079 0000E4B2 04 40 06 D8             	sw		r8,CURRNT	; and old 'CURRNT'
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 19
noc_boot31.a
   1080 0000E4B6 E2 F8                   	lw		r8,2[sp]	; and old text pointer
   1081 0000E4B8 0A 6E                   	add		sp,sp,#10	; fall through will subtract 10
                                        
                                        ; 'INPUT' is like the 'PRINT' command, and is followed by a list
                                        ; of items.  If the item is a string in single or double quotes,
                                        ; or is an underline (back arrow), it has the same effect as in
                                        ; 'PRINT'.  If an item is a variable, this variable name is
                                        ; printed out followed by a colon, then the interpreter waits for
                                        ; an expression to be typed in.  The variable is then set to the
                                        ; value of this expression.  If the variable is preceeded by a
                                        ; string (again in single or double quotes), the string will be
                                        ; displayed followed by a colon.  The interpreter the waits for an
                                        ; expression to be entered and sets the variable equal to the
                                        ; expression's value.  If the input expression is invalid, the
                                        ; interpreter will print "What?", "How?", or "Sorry" and reprint
                                        ; the prompt and redo the input.  The execution will not terminate
                                        ; unless you press control-C.  This is handled in 'INPERR'.
                                        ;
   1098 0000E4BA                        INPUT
   1099 0000E4BA F6 6E                   	sub		sp,sp,#10	; allocate stack frame
   1100 0000E4BC E8 D5                   	sw      r5,8[sp]
   1101 0000E4BE                        IP6
   1102 0000E4BE E0 D8                   	sw		r8,[sp]		; save in case of error
   1103 0000E4C0 3F 40 0B AF             	call	QTSTG		; is next item a string?
   1104 0000E4C4 06 AE                   	br		IP2			; nope - this branch must take only two bytes
   1105 0000E4C6 01 11                   	lw		r1,#1		; allocate var
   1106 0000E4C8 1A 40 08 AF             	call	TSTV		; yes, but is it followed by a variable?
   1107 0000E4CC 29 A8                   	beq     IP4		    ; if not, brnch
   1108 0000E4CE 10 1A                   	lw		r10,r1		; put away the variable's address
   1109 0000E4D0 10 AE                   	br		IP3			; if so, input to variable
   1110 0000E4D2                        IP2
   1111 0000E4D2 E2 D8                   	sw		r8,2[sp]	; save for 'PRTSTG'
   1112 0000E4D4 01 11                   	lw		r1,#1
   1113 0000E4D6 1A 40 01 AF             	call	TSTV		; must be a variable now
   1114 0000E4DA 04 A9                   	bne		IP7
   1115 0000E4DC 20 4F 07 11             	lea		r1,msgInputVar
   1116 0000E4E0 30 40 01 AE             	br		ERROR		; "What?" it isn't?
   1117 0000E4E4                        IP7
   1118 0000E4E4 10 1A                   	lw		r10,r1		; put away the variable's address
   1119 0000E4E6 80 E5                   	lb		r5,[r8]		; get ready for 'PRTSTG' by null terminating
   1120 0000E4E8 80 C0                   	sb		r0,[r8]
   1121 0000E4EA E2 F1                   	lw		r1,2[sp]	; get back text pointer
   1122 0000E4EC 3C 40 09 AF             	call	PRTSTG		; print string as prompt
   1123 0000E4F0 80 C5                   	sb		r5,[r8]		; un-null terminate
   1124 0000E4F2                        IP3
   1125 0000E4F2 E2 D8                   	sw		r8,2[sp]	; save in case of error
   1126 0000E4F4 04 40 06 F1             	lw		r1,CURRNT
   1127 0000E4F8 E4 D1                   	sw		r1,4[sp]	; also save 'CURRNT'
   1128 0000E4FA 0F 11                   	lw		r1,#-1
   1129 0000E4FC 04 40 06 D1             	sw		r1,CURRNT	; flag that we are in INPUT
   1130 0000E500 04 40 0A DE             	sw		sp,STKINP	; save the stack pointer too
   1131 0000E504 E6 DA                   	sw		r10,6[sp]	; save the variable address
   1132 0000E506 03 40 0A 11             	lw		r1,#':'		; print a colon first
   1133 0000E50A 30 40 06 AF             	call	GETLN		; then get an input line
   1134 0000E50E 06 40 0E 18             	lea		r8,BUFFER	; point to the buffer
   1135 0000E512 A0 AF                   	call	OREXPR		; evaluate the input
   1136 0000E514 E6 FA                   	lw		r10,6[sp]	; restore the variable address
   1137 0000E516 A0 D1                   	sw		r1,[r10]	; save value in variable
   1138 0000E518 E4 F1                   	lw		r1,4[sp]	; restore old 'CURRNT'
   1139 0000E51A 04 40 06 D1             	sw		r1,CURRNT
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 20
noc_boot31.a
   1140 0000E51E E2 F8                   	lw		r8,2[sp]	; and the old text pointer
   1141 0000E520                        IP4
   1142 0000E520 48 40 05 AF             	call	TSTC		; is the next thing a comma?
   1143 0000E524 2C 04                   	db	',',IP5-*+1
   1144 0000E526 CB BE                   	br		IP6			; yes, more items
   1145 0000E528                        IP5
   1146 0000E528 E8 F5                       lw      r5,8[sp]
   1147 0000E52A 0A 6E                   	add		sp,sp,#10	; clean up the stack
   1148 0000E52C 26 BE                   	jmp		FINISH
                                        
                                        
   1151 0000E52E                        DEFLT
   1152 0000E52E 80 E1                       lb      r1,[r8]
   1153 0000E530 FF 4F 13 10                 cmp     r1,#CR      ; empty line is OK
   1154 0000E534 22 B8                   	beq	    FINISH	    ; else it is 'LET'
                                        
                                        
                                        ; 'LET' is followed by a list of items separated by commas.
                                        ; Each item consists of a variable, an equals sign, and an
                                        ; expression.  The interpreter evaluates the expression and sets
                                        ; the variable to that value.  The interpreter will also handle
                                        ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                                        ;
   1163 0000E536                        LET
   1164 0000E536 29 40 08 AF                 call	SETVAL		; do the assignment
   1165 0000E53A 47 40 08 AF             	call	TSTC		; check for more 'LET' items
   1166 0000E53E 2C 04                   	db	',',LT1-*+1
   1167 0000E540 FA BE                   	br	    LET
   1168 0000E542                        LT1
   1169 0000E542 1B BE                       br	    FINISH		; until we are finished.
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** LOAD *** & SAVE ***
                                        ;
                                        ; These two commands transfer a program to/from an auxiliary
                                        ; device such as a cassette, another computer, etc.  The program
                                        ; is converted to an easily-stored format: each line starts with
                                        ; a colon, the line no. as 4 hex digits, and the rest of the line.
                                        ; At the end, a line starting with an '@' sign is sent.  This
                                        ; format can be read back with a minimum of processing time by
                                        ; the Butterfly.
                                        ;
   1184 0000E544                        LOAD
   1185 0000E544 0D 4E 00 F8             	lw		r8,TXTBGN	; set pointer to start of prog. area
   1186 0000E548 00 40 0D 11             	lw		r1,#CR		; For a CP/M host, tell it we're ready...
   1187 0000E54C DB 4F 0A AF             	call	GOAUXO		; by sending a CR to finish PIP command.
   1188 0000E550                        LOD1
   1189 0000E550 DB 4F 0A AF             	call	GOAUXI		; look for start of line
   1190 0000E554 FD BA                   	bmi		LOD1
   1191 0000E556 FC 4F 10 10             	cmp		r1,#'@'		; end of program?
   1192 0000E55A 1B A8                   	beq		LODEND
   1193 0000E55C FE 4F 16 10             	cmp     r1,#0x1A    ; or EOF marker
   1194 0000E560 18 A8                   	beq     LODEND
   1195 0000E562 FC 4F 16 10             	cmp		r1,#':'		; if not, is it start of line?
   1196 0000E566 F4 B9                   	bne		LOD1		; if not, wait for it
   1197 0000E568 18 AF                   	call	GCHAR		; get line number
   1198 0000E56A 80 C1                   	sb		r1,[r8]		; store it
   1199 0000E56C A1 31                   	shr		r1,#1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 21
noc_boot31.a
   1200 0000E56E A1 31                   	shr		r1,#1
   1201 0000E570 A1 31                   	shr		r1,#1
   1202 0000E572 A1 31                   	shr		r1,#1
   1203 0000E574 A1 31                   	shr		r1,#1
   1204 0000E576 A1 31                   	shr		r1,#1
   1205 0000E578 A1 31                   	shr		r1,#1
   1206 0000E57A A1 31                   	shr		r1,#1
   1207 0000E57C 81 C1                   	sb		r1,1[r8]
   1208 0000E57E 02 68                   	add		r8,r8,#2
   1209 0000E580                        LOD2
   1210 0000E580 DA 4F 02 AF             	call	GOAUXI		; get another text char.
   1211 0000E584 FD BA                   	bmi		LOD2
   1212 0000E586 80 C1                   	sb		r1,[r8]
   1213 0000E588 01 68                   	add		r8,r8,#1	; store it
   1214 0000E58A FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
   1215 0000E58E F8 B9                   	bne		LOD2		; if not, go back for more
   1216 0000E590 DF BE                   	br		LOD1		; if so, start a new line
   1217 0000E592                        LODEND
   1218 0000E592 05 40 06 D8             	sw		r8,TXTUNF	; set end-of program pointer
   1219 0000E596 DB 4F 07 AE             	br		WSTART		; back to direct mode
                                        
                                        ; get character from input (16 bit value)
   1222 0000E59A                        GCHAR
   1223 0000E59A FA 6E                   	sub		sp,sp,#6
   1224 0000E59C E0 DF                   	sw		lr,[sp]
   1225 0000E59E E2 D5                   	sw		r5,2[sp]
   1226 0000E5A0 E4 D6                   	sw		r6,4[sp]
   1227 0000E5A2 04 16                   	lw      r6,#4       ; repeat four times
   1228 0000E5A4 00 15                   	lw		r5,#0
   1229 0000E5A6                        GCHAR1
   1230 0000E5A6 D8 4F 0F AF             	call	GOAUXI		; get a char
   1231 0000E5AA FD BA                   	bmi		GCHAR1
   1232 0000E5AC 0D AF                   	call	asciiToHex
   1233 0000E5AE 81 35                   	shl		r5,#1
   1234 0000E5B0 81 35                   	shl		r5,#1
   1235 0000E5B2 81 35                   	shl		r5,#1
   1236 0000E5B4 81 35                   	shl		r5,#1
   1237 0000E5B6 16 25                   	or		r5,r1
   1238 0000E5B8 FF 66                   	sub		r6,r6,#1
   1239 0000E5BA F5 B9                   	bne     GCHAR1
   1240 0000E5BC 50 11                   	lw		r1,r5
   1241 0000E5BE E0 FF                   	lw		lr,[sp]
   1242 0000E5C0 E2 F5                   	lw		r5,2[sp]
   1243 0000E5C2 E4 F6                   	lw		r6,4[sp]
   1244 0000E5C4 06 6E                   	add     sp,sp,#6
   1245 0000E5C6 F0 80                   	ret
                                        
                                        ; convert an ascii char to hex code
                                        ; input
                                        ;	r2 = char to convert
                                        
   1251 0000E5C8                        asciiToHex
   1252 0000E5C8 FC 4F 17 10             	cmp		r1,#'9'
   1253 0000E5CC 01 A2                   	ble		a2h1		; less than '9'
   1254 0000E5CE F9 61                   	sub		r1,r1,#7	; shift 'A' to '9'+1
   1255 0000E5D0                        a2h1
   1256 0000E5D0 D0 61                   	sub		r1,r1,#'0'	;
   1257 0000E5D2 00 40 5F 31             	and		r1,#15		; make sure a nybble
   1258 0000E5D6 F0 80                   	ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 22
noc_boot31.a
                                        ; output a CR LF sequence to auxillary output
                                        ; Registers Affected
                                        ;   r3 = LF
   1263 0000E5D8                        AUXOCRLF
   1264 0000E5D8 FE 6E                       sub     sp,sp,#2
   1265 0000E5DA E0 DF                       sw      lr,[sp]
   1266 0000E5DC 00 40 0D 11                 lw      r1,#CR
   1267 0000E5E0 D7 4F 00 AF                 call    GOAUXO
   1268 0000E5E4 0A 11                       lw      r1,#LF
   1269 0000E5E6 D6 4F 0D AF                 call    GOAUXO
   1270 0000E5EA E0 FF                       lw      lr,[sp]
   1271 0000E5EC 02 6E                   	add		sp,sp,#2
   1272 0000E5EE F0 80                       ret
                                        
                                        
                                        ; convert nybble in r2 to ascii hex char2
                                        ; r2 = character to convert
                                        
   1278 0000E5F0                        toAsciiHex
   1279 0000E5F0 00 40 5F 31             	and		r1,#15		; make sure it's a nybble
   1280 0000E5F4 FF 4F 16 10             	cmp		r1,#10		; > 10 ?
   1281 0000E5F8 01 A0                   	blt		tah1
   1282 0000E5FA 07 61                   	add		r1,r1,#7	; bump it up to the letter 'A'
   1283 0000E5FC                        tah1
   1284 0000E5FC 30 61                   	add		r1,r1,#'0'	; bump up to ascii '0'
   1285 0000E5FE F0 80                   	ret
                                        
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** POKE *** & SYSX ***
                                        ;
                                        ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                                        ; address specified by 'expr1'.
                                        ;
                                        ; 'SYSX expr' jumps to the machine language subroutine whose
                                        ; starting address is specified by 'expr'.  The subroutine can use
                                        ; all registers but must leave the stack the way it found it.
                                        ; The subroutine returns to the interpreter by executing an RET.
                                        ;
   1301 0000E600                        POKE
   1302 0000E600 FE 6E                   	sub		sp,sp,#2
   1303 0000E602 28 AF                   	call	OREXPR		; get the memory address
   1304 0000E604 41 40 03 AF             	call	TSTC		; it must be followed by a comma
   1305 0000E608 2C 10                   	db	',',PKER-*+1
   1306 0000E60A E0 D1                   	sw		r1,[sp]	    ; save the address
   1307 0000E60C 23 AF                   	call	OREXPR		; get the byte to be POKE'd
   1308 0000E60E E0 F2                   	lw		r2,[sp]	    ; get the address back
   1309 0000E610 20 C1                   	sb		r1,[r2]		; store the byte in memory
   1310 0000E612 02 6E                   	add		sp,sp,#2
   1311 0000E614 EB 4F 01 AE             	br		FINISH
   1312 0000E618                        PKER
   1313 0000E618 1A 4F 00 11             	lea		r1,msgComma
   1314 0000E61C 26 40 03 AE             	br		ERROR		; if no comma, say "What?"
                                        
                                        
   1317 0000E620                        POKEW
   1318 0000E620 FE 6E                   	sub		sp,sp,#2
   1319 0000E622 18 AF                   	call	OREXPR		; get the memory address
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 23
noc_boot31.a
   1320 0000E624 40 40 03 AF             	call	TSTC		; it must be followed by a comma
   1321 0000E628 2C F0                   	db	',',PKER-*+1
   1322 0000E62A E0 D1                   	sw		r1,[sp]	    ; save the address
   1323 0000E62C 13 AF                   	call	OREXPR		; get the byte to be POKE'd
   1324 0000E62E E0 F2                   	lw		r2,[sp]	    ; get the address back
   1325 0000E630 20 D1                   	sw		r1,[r2]		; store the word in memory
   1326 0000E632 02 6E                   	add		sp,sp,#2
   1327 0000E634 EA 4F 01 AE             	jmp		FINISH
                                        
                                        
   1330 0000E638                        SYSX
   1331 0000E638 FE 6E                   	sub		sp,sp,#2
   1332 0000E63A 0C AF                   	call	OREXPR		; get the subroutine's address
   1333 0000E63C 16 20                   	or		r0,r1		; make sure we got a valid address
   1334 0000E63E 04 A9                   	bne		sysx1
   1335 0000E640 1F 4F 05 11             	lea		r1,msgSYSBad
   1336 0000E644 24 40 0F AE             	br		ERROR
   1337 0000E648                        sysx1
   1338 0000E648 E0 D8                   	sw		r8,[sp]	    ; save the text pointer
   1339 0000E64A 10 8F                   	call	[r1]		; jump to the subroutine
   1340 0000E64C E0 F8                   	lw		r8,[sp]	    ; restore the text pointer
   1341 0000E64E 02 6E                   	add		sp,sp,#2
   1342 0000E650 E9 4F 03 AE             	br		FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** EXPR ***
                                        ;
                                        ; 'EXPR' evaluates arithmetical or logical expressions.
                                        ; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ; <EXPR>::=<EXPR2>
                                        ;	   <EXPR2><rel.op.><EXPR2>
                                        ; where <rel.op.> is one of the operators in TAB8 and the result
                                        ; of these operations is 1 if true and 0 if false.
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        ; where () are optional and (... are optional repeats.
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                                        ; as an index, functions can have an <EXPR> as arguments, and
                                        ; <EXPR4> can be an <EXPR> in parenthesis.
                                        ;
                                        
                                        
                                        ; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                                        ;
   1370 0000E654                        OREXPR
   1371 0000E654 FC 6E                   	sub		sp,sp,#4
   1372 0000E656 E0 DF                   	sw		lr,[sp]
   1373 0000E658 0F AF                   	call	ANDEXPR		; get first <ANDEXPR>
   1374 0000E65A                        XP_OR1
   1375 0000E65A E2 D1                   	sw		r1,2[sp]	; save <ANDEXPR> value
   1376 0000E65C 1B 4E 07 19             	lea		r9,TAB10		; look up a logical operator
   1377 0000E660 21 4E 00 1A             	lea		r10,TAB10_1
   1378 0000E664 DD 4F 0A AE             	jmp		EXEC		; go do it
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 24
noc_boot31.a
   1380 0000E668                        XP_OR
   1381 0000E668 07 AF                       call    ANDEXPR
   1382 0000E66A E2 F2                       lw      r2,2[sp]
   1383 0000E66C 26 21                       or      r1,r2
   1384 0000E66E F5 BE                       br      XP_OR1
                                        
   1386 0000E670                        XP_ORX
   1387 0000E670 E2 F1                   	lw		r1,2[sp]
   1388 0000E672 E0 FF                       lw      lr,[sp]
   1389 0000E674 04 6E                       add     sp,sp,#4
   1390 0000E676 F0 80                       ret
                                        
                                        
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ;
   1395 0000E678                        ANDEXPR
   1396 0000E678 FC 6E                   	sub		sp,sp,#4
   1397 0000E67A E0 DF                   	sw		lr,[sp]
   1398 0000E67C 37 AF                   	call	EXPR		; get first <EXPR>
   1399 0000E67E                        XP_AND1
   1400 0000E67E E2 D1                   	sw		r1,2[sp]	; save <EXPR> value
   1401 0000E680 1B 4E 03 19             	lea		r9,TAB9		; look up a logical operator
   1402 0000E684 20 4E 0C 1A             	lea		r10,TAB9_1
   1403 0000E688 DC 4F 08 AE             	jmp		EXEC		; go do it
                                        
   1405 0000E68C                        XP_AND
   1406 0000E68C 2F AF                       call    EXPR
   1407 0000E68E E2 F2                       lw      r2,2[sp]
   1408 0000E690 25 21                       and     r1,r2
   1409 0000E692 F5 BE                       br      XP_AND1
                                        
   1411 0000E694                        XP_ANDX
   1412 0000E694 E2 F1                   	lw		r1,2[sp]
   1413 0000E696 E0 FF                       lw      lr,[sp]
   1414 0000E698 04 6E                       add     sp,sp,#4
   1415 0000E69A F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a digit
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if digit, otherwise 0
                                        ;
   1424 0000E69C                        isDigit
   1425 0000E69C FD 4F 10 10                 cmp     r1,#'0'
   1426 0000E6A0 05 A0                       blt     isDigitFalse
   1427 0000E6A2 FC 4F 17 10                 cmp     r1,#'9'
   1428 0000E6A6 02 A3                       bgt     isDigitFalse
   1429 0000E6A8 01 11                       lw      r1,#1
   1430 0000E6AA F0 80                       ret
   1431 0000E6AC                        isDigitFalse
   1432 0000E6AC 00 11                       lw      r1,#0
   1433 0000E6AE F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphabetic
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 25
noc_boot31.a
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1442 0000E6B0                        isAlpha
   1443 0000E6B0 FB 4F 1F 10                 cmp     r1,#'A'
   1444 0000E6B4 0B A0                       blt     isAlphaFalse
   1445 0000E6B6 FA 4F 16 10                 cmp     r1,#'Z'
   1446 0000E6BA 06 A2                       ble     isAlphaTrue
   1447 0000E6BC F9 4F 1F 10                 cmp     r1,#'a'
   1448 0000E6C0 05 A0                       blt     isAlphaFalse
   1449 0000E6C2 F8 4F 16 10                 cmp     r1,#'z'
   1450 0000E6C6 02 A3                       bgt     isAlphaFalse
   1451 0000E6C8                        isAlphaTrue
   1452 0000E6C8 01 11                       lw      r1,#1
   1453 0000E6CA F0 80                       ret
   1454 0000E6CC                        isAlphaFalse
   1455 0000E6CC 00 11                       lw      r1,#0
   1456 0000E6CE F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphanumeric
                                        ;   Parameters
                                        ;       r1 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1465 0000E6D0                        isAlnum
   1466 0000E6D0 FE 6E                       sub     sp,sp,#2
   1467 0000E6D2 E0 DF                       sw      lr,[sp]
   1468 0000E6D4 10 12                       lw      r2,r1		; save test char
   1469 0000E6D6 E2 BF                       call    isDigit
   1470 0000E6D8 06 A9                       bne		isDigitx	; if it is a digit
   1471 0000E6DA 20 11                       lw      r1,r2		; get back test char
   1472 0000E6DC E9 BF                       call    isAlpha
   1473 0000E6DE E0 FF                       lw      lr,[sp]
   1474 0000E6E0 02 6E                       add		sp,sp,#2
   1475 0000E6E2 16 21                       or      r1,r1
   1476 0000E6E4 F0 80                       ret
   1477 0000E6E6                        isDigitx
   1478 0000E6E6 E0 FF                       lw      lr,[sp]
   1479 0000E6E8 02 6E                       add     sp,sp,#2	; return Z=0
   1480 0000E6EA F0 80                       ret
                                        
                                        
   1483 0000E6EC                        EXPR
   1484 0000E6EC FC 6E                   	sub		sp,sp,#4
   1485 0000E6EE E0 DF                   	sw		lr,[sp]
   1486 0000E6F0 39 AF                   	call	EXPR2
   1487 0000E6F2 E2 D1                   	sw		r1,2[sp]	; save <EXPR2> value
   1488 0000E6F4 1A 4E 09 19             	lea		r9,TAB8		; look up a relational operator
   1489 0000E6F8 1F 4E 0E 1A             	lea		r10,TAB8_1
   1490 0000E6FC D8 4F 0E AE             	jmp		EXEC		; go do it
                                        
   1492 0000E700                        XP11
   1493 0000E700 E2 F1                   	lw		r1,2[sp]
   1494 0000E702 28 AF                   	call	XP18	; is it ">="?
   1495 0000E704 1D 22                   	cmp		r2,r1
   1496 0000E706 1E A1                   	bge		XPRT1	; no, return r2=1
   1497 0000E708 19 AE                   	br		XPRT0	; else return r2=0
                                        
   1499 0000E70A                        XP12
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 26
noc_boot31.a
   1500 0000E70A E2 F1                   	lw		r1,2[sp]
   1501 0000E70C 23 AF                   	call	XP18	; is it "<>"?
   1502 0000E70E 1D 22                   	cmp		r2,r1
   1503 0000E710 19 A9                   	bne		XPRT1	; no, return r2=1
   1504 0000E712 14 AE                   	br		XPRT0	; else return r2=0
                                        
   1506 0000E714                        XP13
   1507 0000E714 E2 F1                   	lw		r1,2[sp]
   1508 0000E716 1E AF                   	call	XP18	; is it ">"?
   1509 0000E718 1D 22                   	cmp		r2,r1
   1510 0000E71A 14 A3                   	bgt		XPRT1	; no, return r2=1
   1511 0000E71C 0F AE                   	br		XPRT0	; else return r2=0
                                        
   1513 0000E71E                        XP14
   1514 0000E71E E2 F1                   	lw		r1,2[sp]
   1515 0000E720 19 AF                   	call	XP18	; is it "<="?
   1516 0000E722 1D 22                   	cmp		r2,r1
   1517 0000E724 0F A2                   	ble		XPRT1	; no, return r2=1
   1518 0000E726 0A AE                   	br		XPRT0	; else return r2=0
                                        
   1520 0000E728                        XP15
   1521 0000E728 E2 F1                   	lw		r1,2[sp]
   1522 0000E72A 14 AF                   	call	XP18	; is it "="?
   1523 0000E72C 1D 22                   	cmp		r2,r1
   1524 0000E72E 0A A8                   	beq		XPRT1	; if not, return r2=1
   1525 0000E730 05 AE                   	br		XPRT0	; else return r2=0
                                        
                                        
   1528 0000E732                        XP16
   1529 0000E732 E2 F1                   	lw		r1,2[sp]
   1530 0000E734 0F AF                   	call	XP18	; is it "<"?
   1531 0000E736 1D 22                   	cmp		r2,r1
   1532 0000E738 05 A0                   	blt		XPRT1	; if not, return r2=1
   1533 0000E73A 00 AE                   	br		XPRT0	; else return r2=0
                                        
   1535 0000E73C                        XPRT0
   1536 0000E73C E0 FF                   	lw		lr,[sp]
   1537 0000E73E 04 6E                   	add		sp,sp,#4
   1538 0000E740 00 11                   	lw		r1,#0   ; return r1=0 (false)
   1539 0000E742 F0 80                   	ret
                                        
   1541 0000E744                        XPRT1
   1542 0000E744 E0 FF                   	lw		lr,[sp]
   1543 0000E746 04 6E                   	add		sp,sp,#4
   1544 0000E748 01 11                   	lw		r1,#1	; return r1=1 (true)
   1545 0000E74A F0 80                   	ret
                                        
   1547 0000E74C                        XP17				; it's not a rel. operator
   1548 0000E74C E2 F1                   	lw		r1,2[sp]	; return r2=<EXPR2>
   1549 0000E74E E0 FF                   	lw		lr,[sp]
   1550 0000E750 04 6E                   	add		sp,sp,#4
   1551 0000E752 F0 80                   	ret
                                        
   1553 0000E754                        XP18
   1554 0000E754 FC 6E                   	sub		sp,sp,#4
   1555 0000E756 E0 DF                   	sw		lr,[sp]
   1556 0000E758 E2 D1                   	sw		r1,2[sp]
   1557 0000E75A 04 AF                   	call	EXPR2		; do a second <EXPR2>
   1558 0000E75C E2 F2                   	lw		r2,2[sp]
   1559 0000E75E E0 FF                   	lw		lr,[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 27
noc_boot31.a
   1560 0000E760 04 6E                   	add		sp,sp,#4
   1561 0000E762 F0 80                   	ret
                                        
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        
   1565 0000E764                        EXPR2
   1566 0000E764 FC 6E                   	sub		sp,sp,#4
   1567 0000E766 E0 DF                   	sw		lr,[sp]
   1568 0000E768 36 40 01 AF             	call	TSTC		; negative sign?
   1569 0000E76C 2D 08                   	db	'-',XP21-*+1
   1570 0000E76E 00 11                   	lw		r1,#0		; yes, fake '0-'
   1571 0000E770 E2 D1                   	sw		r1,2[sp]
   1572 0000E772 0F AE                   	br		XP26
   1573 0000E774                        XP21
   1574 0000E774 35 40 0B AF             	call	TSTC		; positive sign? ignore it
   1575 0000E778 2B 02                   	db	'+',XP22-*+1
   1576 0000E77A                        XP22
   1577 0000E77A 12 AF                   	call	EXPR3		; first <EXPR3>
   1578 0000E77C                        XP23
   1579 0000E77C E2 D1                   	sw		r1,2[sp]	; yes, save the value
   1580 0000E77E 35 40 06 AF             	call	TSTC		; add?
   1581 0000E782 2B 0A                   	db	'+',XP25-*+1
   1582 0000E784 0D AF                   	call	EXPR3		; get the second <EXPR3>
   1583 0000E786                        XP24
   1584 0000E786 E2 F2                   	lw		r2,2[sp]
   1585 0000E788 20 21                   	add		r1,r2		; add it to the first <EXPR3>
                                        ;	BVS.L	QHOW		brnch if there's an overflow
   1587 0000E78A F8 BE                   	br		XP23		; else go back for more operations
   1588 0000E78C                        XP25
   1589 0000E78C 34 40 0F AF             	call	TSTC		; subtract?
   1590 0000E790 2D 08                   	db	'-',XP45-*+1
   1591 0000E792                        XP26
   1592 0000E792 06 AF                   	call	EXPR3		; get second <EXPR3>
   1593 0000E794 20 31                   	neg		r1			; change its sign
   1594 0000E796 F7 BE                   	br		XP24		; and do an addition
                                        
   1596 0000E798                        XP45
   1597 0000E798 E2 F1                   	lw		r1,2[sp]
   1598 0000E79A E0 FF                   	lw		lr,[sp]
   1599 0000E79C 04 6E                   	add		sp,sp,#4
   1600 0000E79E F0 80                   	ret
                                        
                                        
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        
   1605 0000E7A0                        EXPR3
   1606 0000E7A0 FC 6E                   	sub		sp,sp,#4
   1607 0000E7A2 E0 DF                   	sw		lr,[sp]
   1608 0000E7A4 14 AF                   	call	EXPR4		; get first <EXPR4>
   1609 0000E7A6                        XP31
   1610 0000E7A6 E2 D1                   	sw		r1,2[sp]	; yes, save that first result
   1611 0000E7A8 34 40 01 AF             	call	TSTC		; multiply?
   1612 0000E7AC 2A 0A                   	db	'*',XP34-*+1
   1613 0000E7AE 0F AF                   	call	EXPR4		; get second <EXPR4>
   1614 0000E7B0 E2 F2                   	lw		r2,2[sp]
   1615 0000E7B2 B8 AF                   	call	MULT32		; multiply the two
   1616 0000E7B4 F8 BE                   	br		XP31		 ; then look for more terms
   1617 0000E7B6                        XP34
   1618 0000E7B6 33 40 0A AF             	call	TSTC		; divide?
   1619 0000E7BA 2F 0C                   	db	'/',XP47-*+1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 28
noc_boot31.a
   1620 0000E7BC 08 AF                   	call	EXPR4		; get second <EXPR4>
   1621 0000E7BE 10 12                   	lw      r2,r1
   1622 0000E7C0 E2 F1                   	lw		r1,2[sp]
   1623 0000E7C2 CD AF                   	call	DIV32		; do the division
   1624 0000E7C4 F0 BE                   	br		XP31		; go back for any more terms
                                        
   1626 0000E7C6                        XP47
   1627 0000E7C6 E2 F1                   	lw		r1,2[sp]
   1628 0000E7C8 E0 FF                   	lw		lr,[sp]
   1629 0000E7CA 04 6E                   	add		sp,sp,#4
   1630 0000E7CC F0 80                   	ret
                                        
                                        
                                        ; Functions are called through EXPR4
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        
   1638 0000E7CE                        EXPR4
   1639 0000E7CE FA 6E                       sub     sp,sp,#6
   1640 0000E7D0 E0 DF                       sw      lr,[sp]
   1641 0000E7D2 18 4E 03 19             	lea		r9,TAB4		; find possible function
   1642 0000E7D6 1E 4E 06 1A             	lea		r10,TAB4_1
   1643 0000E7DA D1 4F 0F AE             	jmp		EXEC        ; branch to function which does subsequent
                                        	                    ; ret for EXPR4
                                        
   1646 0000E7DE                        XP40                    ; we get here if it wasn't a function
   1647 0000E7DE 00 11                   	lw		r1,#0
   1648 0000E7E0 1D AF                   	call	TSTV		
   1649 0000E7E2 04 A8                   	beq     XP41        ; nor a variable
   1650 0000E7E4 10 F1                   	lw		r1,[r1]		; if a variable, return its value in r1
   1651 0000E7E6 E0 FF                   	lw      lr,[sp]
   1652 0000E7E8 06 6E                   	add     sp,sp,#6
   1653 0000E7EA F0 80                   	ret
   1654 0000E7EC                        XP41
   1655 0000E7EC 33 40 01 AF             	call	TSTNUM		; or is it a number?
   1656 0000E7F0 26 22                   	or		r2,r2		; (if not, # of digits will be zero)
   1657 0000E7F2 01 A9                   	bne		XP46		; if so, return it in r1
   1658 0000E7F4 03 AF                   	call    PARN        ; check for (EXPR)
   1659 0000E7F6                        XP46
   1660 0000E7F6 E0 FF                   	lw      lr,[sp]
   1661 0000E7F8 06 6E                   	add     sp,sp,#6
   1662 0000E7FA F0 80                   	ret
                                        
                                        
                                        ; Check for a parenthesized expression
   1666 0000E7FC                        PARN
   1667 0000E7FC FE 6E                   	sub		sp,sp,#2
   1668 0000E7FE E0 DF                   	sw		lr,[sp]
   1669 0000E800 31 40 05 AF             	call	TSTC		; else look for ( OREXPR )
   1670 0000E804 28 10                   	db	'(',XP43-*+1
   1671 0000E806 26 BF                   	call	OREXPR
   1672 0000E808 31 40 01 AF             	call	TSTC
   1673 0000E80C 29 08                   	db	')',XP43-*+1
   1674 0000E80E                        XP42
   1675 0000E80E E0 FF                   	lw		lr,[sp]
   1676 0000E810 02 6E                   	add		sp,sp,#2
   1677 0000E812 F0 80                   	ret
   1678 0000E814                        XP43
   1679 0000E814 11 4F 0D 11             	lea		r1,msgWhat
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 29
noc_boot31.a
   1680 0000E818 16 40 05 AE             	br		ERROR
                                        
                                        
                                        ; ===== Test for a valid variable name.  Returns Z=1 if not
                                        ;	found, else returns Z=0 and the address of the
                                        ;	variable in r1.
                                        ; Parameters
                                        ;	r1 = 1 = allocate if not found
                                        ; Returns
                                        ;	r1 = address of variable, zero if not found
                                        
   1691 0000E81C                        TSTV
   1692 0000E81C FA 6E                   	sub		sp,sp,#6
   1693 0000E81E E0 DF                   	sw		lr,[sp]
   1694 0000E820 E2 D5                   	sw		r5,2[sp]
   1695 0000E822 10 15                   	lw		r5,r1		; allocate flag
   1696 0000E824 33 40 06 AF             	call	IGNBLK
   1697 0000E828 80 E1                   	lb		r1,[r8]		; look at the program text
   1698 0000E82A FC 4F 10 10             	cmp     r1,#'@'
   1699 0000E82E 1C A0                   	blt     tstv_notfound   ; C=1: not a variable
   1700 0000E830 12 A9                   	bne		TV1			; brnch if not "@" array
   1701 0000E832 01 68                   	add		r8,r8,#1	; If it is, it should be
   1702 0000E834 E3 BF                   	call	PARN		; followed by (EXPR) as its index.
   1703 0000E836 81 31                   	shl     r1,#1
   1704 0000E838 81 31                   	shl     r1,#1
                                        ;	BCS.L	QHOW		say "How?" if index is too big
   1706 0000E83A E4 D1                       sw      r1,4[sp]    ; save the index
   1707 0000E83C F4 6E                       sub		sp,sp,#12
   1708 0000E83E E0 DF                       sw		lr,[sp]
   1709 0000E840 10 40 07 AF             	call	SIZEX		; get amount of free memory
   1710 0000E844 E4 F2                   	lw      r2,4[sp]    ; get back the index
   1711 0000E846 1D 22                   	cmp     r2,r1       ; see if there's enough memory
   1712 0000E848 02 A4                   	bltu	TV2
   1713 0000E84A 14 40 07 AE             	jmp    	QSORRY		; if not, say "Sorry"
   1714 0000E84E                        TV2
   1715 0000E84E 05 40 08 F1             	lw      r1,VARBGN   ; put address of array element...
   1716 0000E852 22 21                   	sub     r1,r2       ; into r1 (neg. offset is used)
   1717 0000E854 05 AE                   	br      TSTVRT
   1718 0000E856                        TV1	
   1719 0000E856 0D AF                       call    getVarName      ; get variable name
   1720 0000E858 07 A8                       beq     tstv_notfound   ; if not, set Z=1 and return
   1721 0000E85A 50 12                       lw		r2,r5
   1722 0000E85C 45 AF                       call    findVar     ; find or allocate
   1723 0000E85E 04 A8                       beq		tstv_notfound
   1724 0000E860                        TSTVRT
   1725 0000E860 E2 F5                   	lw		r5,2[sp]
   1726 0000E862 E0 FF                   	lw		lr,[sp]
   1727 0000E864 06 6E                   	add		sp,sp,#6    ; Z=0 (found)
   1728 0000E866 F0 80                   	ret
   1729 0000E868                        tstv_notfound
   1730 0000E868 E2 F5                   	lw		r5,2[sp]
   1731 0000E86A E0 FF                       lw      lr,[sp]
   1732 0000E86C 06 6E                       add     sp,sp,#6
   1733 0000E86E 00 11                       lw      r1,#0       ; Z=1 if not found
   1734 0000E870 F0 80                       ret
                                        
                                        
                                        ; Returns
                                        ;   r1 = 3 character variable name + type
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 30
noc_boot31.a
   1740 0000E872                        getVarName
   1741 0000E872 FA 6E                       sub     sp,sp,#6
   1742 0000E874 E0 DF                       sw      lr,[sp]
   1743 0000E876 E4 D5                       sw		r5,4[sp]
                                        
   1745 0000E878 80 E1                       lb      r1,[r8]     ; get first character
   1746 0000E87A E2 D1                       sw		r1,2[sp]	; save off current name
   1747 0000E87C 19 BF                       call    isAlpha
   1748 0000E87E 2F A8                       beq     gvn1
   1749 0000E880 02 15                       lw      r5,#2       ; loop twice more
                                        
                                        	; check for second/third character
   1752 0000E882                        gvn4
   1753 0000E882 01 68                   	add     r8,r8,#1
   1754 0000E884 80 E1                   	lb      r1,[r8]     ; do we have another char ?
   1755 0000E886 24 BF                   	call    isAlnum
   1756 0000E888 12 A8                   	beq     gvn2        ; nope
   1757 0000E88A E2 F1                   	lw      r1,2[sp]    ; get varname
   1758 0000E88C 81 31                   	shl     r1,#1       ; shift left by eight
   1759 0000E88E 81 31                   	shl     r1,#1       ; shift left by eight
   1760 0000E890 81 31                   	shl     r1,#1       ; shift left by eight
   1761 0000E892 81 31                   	shl     r1,#1       ; shift left by eight
   1762 0000E894 81 31                   	shl     r1,#1       ; shift left by eight
   1763 0000E896 81 31                   	shl     r1,#1       ; shift left by eight
   1764 0000E898 81 31                   	shl     r1,#1       ; shift left by eight
   1765 0000E89A 81 31                   	shl     r1,#1       ; shift left by eight
   1766 0000E89C 80 E2                   	lb      r2,[r8]
   1767 0000E89E 26 21                   	or      r1,r2       ; add in new char
   1768 0000E8A0 E2 D1                       sw      r1,2[sp]   ; save off name again
   1769 0000E8A2 FF 65                       sub		r5,r5,#1
   1770 0000E8A4 EE B9                       bne     gvn4
                                        
                                            ; now ignore extra variable name characters
   1773 0000E8A6                        gvn6
   1774 0000E8A6 01 68                       add     r8,r8,#1
   1775 0000E8A8 80 E1                       lb      r1,[r8]
   1776 0000E8AA 12 BF                       call    isAlnum
   1777 0000E8AC FC B9                       bne     gvn6        ; keep looping as long as we have identifier chars
                                            
   1779 0000E8AE                        gvn2
   1780 0000E8AE 80 E1                   	lb		r1,[r8]
   1781 0000E8B0 FD 4F 1B 10                 cmp     r1,#'%'
   1782 0000E8B4 05 A8                       beq     gvn3
   1783 0000E8B6 FD 4F 1C 10                 cmp     r1,#'$'
   1784 0000E8BA 02 A8                       beq     gvn3
   1785 0000E8BC 00 11                       lw      r1,#0
   1786 0000E8BE FF 68                       sub     r8,r8,#1
                                        
                                            ; insert variable type indicator and return
   1789 0000E8C0                        gvn3
   1790 0000E8C0 01 68                       add     r8,r8,#1
   1791 0000E8C2 E2 F2                       lw      r2,2[sp]
   1792 0000E8C4 81 32                       shl     r2,#1
   1793 0000E8C6 81 32                       shl     r2,#1
   1794 0000E8C8 81 32                       shl     r2,#1
   1795 0000E8CA 81 32                       shl     r2,#1
   1796 0000E8CC 81 32                       shl     r2,#1
   1797 0000E8CE 81 32                       shl     r2,#1
   1798 0000E8D0 81 32                       shl     r2,#1
   1799 0000E8D2 81 32                       shl     r2,#1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 31
noc_boot31.a
   1800 0000E8D4 26 21                       or      r1,r2       ; add in variable type
   1801 0000E8D6 E0 FF                       lw      lr,[sp]
   1802 0000E8D8 E4 F5                       lw		r5,4[sp]
   1803 0000E8DA 06 6E                       add     sp,sp,#6   ; return Z = 0, r1 = varname
   1804 0000E8DC F0 80                       ret
                                        
                                            ; not a variable name
   1807 0000E8DE                        gvn1
   1808 0000E8DE E0 FF                       lw      lr,[sp]
   1809 0000E8E0 E4 F5                       lw		r5,4[sp]
   1810 0000E8E2 06 6E                       add     sp,sp,#6
   1811 0000E8E4 00 11                       lw      r1,#0       ; return Z = 1 if not a varname
   1812 0000E8E6 F0 80                       ret
                                        
                                        
                                        ; Find variable
                                        ;   r1 = varname
                                        ;	r2 = allocate flag
                                        ; Returns
                                        ;   r1 = variable address, Z =0 if found / allocated, Z=1 if not found
                                        
   1821 0000E8E8                        findVar
   1822 0000E8E8 FC 6E                       sub     sp,sp,#4
   1823 0000E8EA E0 DF                       sw      lr,[sp]
   1824 0000E8EC E2 D7                       sw      r7,2[sp]
   1825 0000E8EE 05 40 08 F3                 lw      r3,VARBGN
   1826 0000E8F2                        fv4
   1827 0000E8F2 30 F7                       lw      r7,[r3]     ; get varname / type
   1828 0000E8F4 0A A8                       beq     fv3         ; no more vars ?
   1829 0000E8F6 7D 21                       cmp     r1,r7       ; match ?
   1830 0000E8F8 0B A8                       beq     fv1
   1831 0000E8FA 08 63                       add     r3,r3,#8    ; move to next var
   1832 0000E8FC 06 40 00 F7                 lw      r7,STKBOT
   1833 0000E900 7D 23                       cmp     r3,r7
   1834 0000E902 F7 B0                       blt     fv4         ; loop back to look at next var
                                        
                                            ; variable not found
                                            ; no more memory
   1838 0000E904 17 4F 00 11                 lea     r1,msgVarSpace
   1839 0000E908 EE AE                       br      ERROR
                                        ;    lw      lr,[sp]
                                        ;    lw      r7,2[sp]
                                        ;    add     sp,sp,#4
                                        ;    lw      r1,#0
                                        ;    ret
                                        
                                            ; variable not found
                                            ; allocate new ?
   1848 0000E90A                        fv3
   1849 0000E90A 26 22                   	or		r2,r2
   1850 0000E90C 06 A8                   	beq		fv2
   1851 0000E90E 30 D1                       sw      r1,[r3]     ; save varname / type
                                            ; found variable
                                            ; return address
   1854 0000E910                        fv1
   1855 0000E910 34 11                       add     r1,r3,#4
   1856 0000E912 E0 FF                       lw      lr,[sp]
   1857 0000E914 E2 F7                       lw      r7,2[sp]
   1858 0000E916 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1859 0000E918 F0 80                       ret
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 32
noc_boot31.a
                                        
                                            ; didn't find var and not allocating
   1862 0000E91A                        fv2
   1863 0000E91A E0 FF                       lw      lr,[sp]
   1864 0000E91C E2 F7                       lw      r7,2[sp]
   1865 0000E91E 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1866 0000E920 00 11                   	lw		r1,#0		; Z = 1, r1 = 0
   1867 0000E922 F0 80                       ret
                                        
                                        
                                        ; ===== Multiplies the 32 bit values in r1 and r2, returning
                                        ;	the 32 bit result in r1.
                                        ;
                                        
   1874 0000E924                        MULT32
   1875 0000E924 FA 6E                   	sub		sp,sp,#6
   1876 0000E926 E0 D5                   	sw		r5,[sp]		; w
   1877 0000E928 E2 D6                   	sw		r6,2[sp]	; s
   1878 0000E92A E4 D7                   	sw		r7,4[sp]
                                        
   1880 0000E92C 00 15                   	lw		r5,#0		; w = 0;
   1881 0000E92E 10 16                   	lw		r6,r1
   1882 0000E930 24 26                   	xor		r6,r2		; s = a ^ b
   1883 0000E932 16 21                   	or		r1,r1
   1884 0000E934 01 AB                   	bpl		mult1
   1885 0000E936 20 31                   	neg		r1
   1886 0000E938                        mult1
   1887 0000E938 26 22                   	or		r2,r2
   1888 0000E93A 01 AB                   	bpl		mult2
   1889 0000E93C 20 32                   	neg		r2
   1890 0000E93E                        mult2
   1891 0000E93E 10 17                   	lw		r7,r1
   1892 0000E940 51 37                   	and		r7,#1
   1893 0000E942 01 A8                   	beq		mult3
   1894 0000E944 20 25                   	add		r5,r2		; w += b
   1895 0000E946                        mult3
   1896 0000E946 81 32                   	shl		r2,#1		; b <<= 1
   1897 0000E948 A1 31                   	shr		r1,#1		; a >>= 1
   1898 0000E94A F9 B9                   	bne		mult2       ; a = 0 ?
   1899 0000E94C                        mult4
   1900 0000E94C 66 26                       or      r6,r6
   1901 0000E94E 01 AB                   	bpl		mult5
   1902 0000E950 20 35                   	neg		r5
   1903 0000E952                        mult5
   1904 0000E952 50 11                   	lw		r1,r5
   1905 0000E954 E4 F7                   	lw		r7,4[sp]
   1906 0000E956 E2 F6                   	lw		r6,2[sp]
   1907 0000E958 E0 F5                   	lw		r5,[sp]
   1908 0000E95A 06 6E                   	add		sp,sp,#6
   1909 0000E95C F0 80                   	ret
                                        
                                        
                                        ; ===== Divide the 32 bit value in r2 by the 32 bit value in r3.
                                        ;	Returns the 32 bit quotient in r1, remainder in r2
                                        ;
                                        ; r2 = a
                                        ; r3 = b
                                        ; r6 = remainder
                                        ; r7 = iteration count
                                        ; r8 = sign
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 33
noc_boot31.a
                                        ;
                                        
                                        ; q = a / b
                                        ; a = r1
                                        ; b = r2
                                        ; q = r2
                                        
   1927 0000E95E                        DIV32
   1928 0000E95E 26 22                       or      r2,r2       ; check for divide-by-zero
   1929 0000E960 03 A9                       bne		div6
   1930 0000E962 15 4F 0D 11                 lea		r1,msgDivZero
   1931 0000E966 BF AE                       br		ERROR		; divide by zero error
   1932 0000E968                        div6
   1933 0000E968 FA 6E                   	sub		sp,sp,#6
   1934 0000E96A E0 D6                   	sw		r6,[sp]
   1935 0000E96C E2 D7                   	sw		r7,2[sp]
   1936 0000E96E E4 D8                   	sw		r8,4[sp]
                                        
   1938 0000E970 02 40 00 18                 lw      r8,#32      ; iteration count for 32 bits
   1939 0000E974 00 16                   	lw		r6,#0		; r = 0
   1940 0000E976 20 17                       lw      r7,r2       ; r7 = sign of result
   1941 0000E978 14 27                       xor     r7,r1
   1942 0000E97A 16 21                   	or	    r1,r1	    ; take absolute value of r1 (a)
   1943 0000E97C 01 AB                   	bpl     div1
   1944 0000E97E 20 31                   	neg     r1
   1945 0000E980                        div1
   1946 0000E980 26 22                       or      r2,r2	    ; take absolute value of r2 (b)
   1947 0000E982 01 AB                   	bpl	    div2
   1948 0000E984 20 32                   	neg     r2
   1949 0000E986                        div2
   1950 0000E986 81 31                   	shl		r1,#1		; a <<= 1
   1951 0000E988 61 26                   	adc		r6,r6		; r <<= 1
   1952 0000E98A 6D 22                   	cmp		r2,r6		; b < r ?
   1953 0000E98C 02 A7                   	bgtu	div4
   1954 0000E98E 22 26                   	sub		r6,r2		; r -= b
   1955 0000E990 61 31                   	or      r1,#1       ; a |= 1
   1956 0000E992                        div4
   1957 0000E992 FF 68                   	sub		r8,r8,#1
   1958 0000E994 F8 B9                       bne     div2        ; n--
   1959 0000E996 76 27                   	or      r7,r7
   1960 0000E998 01 AB                   	bpl     div5
   1961 0000E99A 20 31                   	neg     r1
   1962 0000E99C                        div5
   1963 0000E99C 60 12                   	lw		r2,r6		; r2 = r
   1964 0000E99E E2 F7                   	lw		r7,2[sp]
   1965 0000E9A0 E4 F8                   	lw		r8,4[sp]
   1966 0000E9A2 E0 F6                   	lw		r6,[sp]
   1967 0000E9A4 06 6E                   	add		sp,sp,#6
   1968 0000E9A6 F0 80                   	ret
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1973 0000E9A8                        PEEK
   1974 0000E9A8 29 BF                   	call	PARN		; get the memory address
   1975 0000E9AA 10 E1                   	lb		r1,[r1]		; get the addressed byte
   1976 0000E9AC 0E 21                   	zxb		r1			; upper 3 bytes will be zero
   1977 0000E9AE E0 FF                   	lw		lr,[sp]	; and return it
   1978 0000E9B0 06 6E                   	add		sp,sp,#6
   1979 0000E9B2 F0 80                   	ret
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 34
noc_boot31.a
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1985 0000E9B4                        PEEKW
   1986 0000E9B4 23 BF                   	call	PARN		; get the memory address
   1987 0000E9B6 5E 31                   	and		r1,#-2		; align to word address
   1988 0000E9B8 10 F1                   	lw		r1,[r1]		; get the addressed word
   1989 0000E9BA E0 FF                   	lw		lr,[sp]	; and return it
   1990 0000E9BC 06 6E                   	add		sp,sp,#6
   1991 0000E9BE F0 80                   	ret
                                        
                                        
                                        ; user function call
                                        ; call the user function with argument in r1
   1996 0000E9C0                        USRX
   1997 0000E9C0 1D BF                   	call	PARN		; get expression value
   1998 0000E9C2 E2 D8                   	sw		r8,2[sp]	; save the text pointer
   1999 0000E9C4 02 40 04 F2             	lw      r2,usrJmp   ; get usr vector
   2000 0000E9C8 20 8F                   	call	[r2]		; jump to the subroutine
   2001 0000E9CA E2 F8                   	lw		r8,2[sp]	; restore the text pointer
   2002 0000E9CC E0 FF                   	lw		lr,[sp]
   2003 0000E9CE 06 6E                   	add		sp,sp,#6
   2004 0000E9D0 F0 80                   	ret
                                        
                                        
                                        ; ===== The RND function returns a random number from 1 to
                                        ;	the value of the following expression in D0.
                                        ;
   2010 0000E9D2                        RND
   2011 0000E9D2 14 BF                   	call	PARN		; get the upper limit
   2012 0000E9D4 16 21                   	or		r1,r1		; it must be positive and non-zero
   2013 0000E9D6 0E A8                   	beq		rnd2
   2014 0000E9D8 0A AA                   	bmi		rnd1
   2015 0000E9DA 10 12                   	lw		r2,r1
   2016 0000E9DC CA 4D 04 D0             	sh		r0,RAND+4	; read command
   2017 0000E9E0 CA 4D 00 F1             	lw		r1,RAND		; get a number
   2018 0000E9E4 0E AF                   	call	modu4		; RND(n)=MOD(number,n)+1
   2019 0000E9E6 01 61                   	add		r1,r1,#1
   2020 0000E9E8 E0 FF                   	lw		lr,[sp]
   2021 0000E9EA 06 6E                   	add		sp,sp,#6
   2022 0000E9EC F0 80                   	ret
   2023 0000E9EE                        rnd1
   2024 0000E9EE 1E 4F 01 11             	lea		r1,msgRNDBad
   2025 0000E9F2 79 AE                   	br		ERROR
   2026 0000E9F4                        rnd2
   2027 0000E9F4 CA 4D 04 D0             	sh		r0,RAND+4
   2028 0000E9F8 CA 4D 00 F1             	lw		r1,RAND
   2029 0000E9FC E0 FF                   	lw		lr,[sp]
   2030 0000E9FE 06 6E                   	add		sp,sp,#6
   2031 0000EA00 F0 80                   	ret
                                        
                                        
                                        ; r = a mod b
                                        ; a = r2
                                        ; b = r3
                                        ; r = r1
   2038 0000EA02                        modu4
   2039 0000EA02 FA 6E                   	sub		sp,sp,#6
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 35
noc_boot31.a
   2040 0000EA04 E0 D5                   	sw		r5,[sp]
   2041 0000EA06 E2 D6                   	sw		r6,2[sp]
   2042 0000EA08 E4 D7                   	sw		r7,4[sp]
   2043 0000EA0A 02 40 00 17             	lw      r7,#32		; n = 32
   2044 0000EA0E 00 15                   	lw		r5,#0		; w = 0
   2045 0000EA10 00 16                   	lw		r6,#0		; r = 0
   2046 0000EA12                        mod2
   2047 0000EA12 81 31                   	shl		r1,#1		; a <<= 1
   2048 0000EA14 61 26                   	adc		r6,r6		; r <<= 1
   2049 0000EA16 6D 22                   	cmp		r2,r6		; b < r ?
   2050 0000EA18 01 A7                   	bgtu	mod1
   2051 0000EA1A 22 26                   	sub		r6,r2		; r -= b
   2052 0000EA1C                        mod1
   2053 0000EA1C FF 67                   	sub		r7,r7,#1
   2054 0000EA1E F9 B9                       bne     mod2        ; n--
   2055 0000EA20 60 11                   	lw		r1,r6
   2056 0000EA22 E0 F5                   	lw		r5,[sp]
   2057 0000EA24 E2 F6                   	lw		r6,2[sp]
   2058 0000EA26 E4 F7                   	lw		r7,4[sp]
   2059 0000EA28 06 6E                   	add		sp,sp,#6
   2060 0000EA2A F0 80                   	ret
                                        
                                        
                                        
                                        ; ===== The ABS function returns an absolute value in r2.
                                        ;
   2066 0000EA2C                        ABS
   2067 0000EA2C EE 4F 06 AF             	call	PARN		; get the following expr.'s value
   2068 0000EA30 16 21                   	or		r1,r1
   2069 0000EA32 01 AB                   	bpl		abs1
   2070 0000EA34 20 31                   	neg		r1			; if negative, complement it
                                        ;	bmi		QHOW		; if still negative, it was too big
   2072 0000EA36                        abs1
   2073 0000EA36 E0 FF                   	lw		lr,[sp]
   2074 0000EA38 06 6E                   	add		sp,sp,#6
   2075 0000EA3A F0 80                   	ret
                                        
                                        
                                        ; ===== The SGN function returns the sign in r1. +1,0, or -1
                                        ;
   2080 0000EA3C                        SGN
   2081 0000EA3C ED 4F 0E AF             	call	PARN		; get the following expr.'s value
   2082 0000EA40 16 21                   	or		r1,r1
   2083 0000EA42 04 A8                   	beq		sgn1
   2084 0000EA44 02 AB                   	bpl		sgn2
   2085 0000EA46 0F 11                   	lw		r1,#-1
   2086 0000EA48 01 AE                   	br		sgn1
   2087 0000EA4A                        sgn2
   2088 0000EA4A 01 11                   	lw		r1,#1
   2089 0000EA4C                        sgn1
   2090 0000EA4C E0 FF                   	lw		lr,[sp]
   2091 0000EA4E 06 6E                   	add		sp,sp,#6
   2092 0000EA50 F0 80                   	ret
                                        
                                        
                                        ; ===== The SIZE function returns the size of free memory in r1.
                                        ;
   2097 0000EA52                        SIZEX
   2098 0000EA52 05 40 08 F1             	lw		r1,VARBGN	; get the number of free bytes...
   2099 0000EA56 05 40 06 F2             	lw		r2,TXTUNF	; between 'TXTUNF' and 'VARBGN'
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 36
noc_boot31.a
   2100 0000EA5A 22 21                   	sub		r1,r2
   2101 0000EA5C E0 FF                   	lw		lr,[sp]
   2102 0000EA5E 06 6E                   	add		sp,sp,#6
   2103 0000EA60 F0 80                   	ret					; return the number in r2
                                        
                                        ; ==== Return the node number that the code is running on
                                        ;
   2107 0000EA62                        NODENUM
   2108 0000EA62 E4 31                   	tsr		r1,ID
   2109 0000EA64 E0 FF                   	lw		lr,[sp]
   2110 0000EA66 06 6E                   	add		sp,sp,#6
   2111 0000EA68 F0 80                   	ret
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                                        ;
                                        ; 'SETVAL' expects a variable, followed by an equal sign and then
                                        ; an expression.  It evaluates the expression and sets the variable
                                        ; to that value.
                                        ;
                                        ; 'FIN' checks the end of a command.  If it ended with ":",
                                        ; execution continues.	If it ended with a CR, it finds the
                                        ; the next line and continues from there.
                                        ;
                                        ; 'ENDCHK' checks if a command is ended with a CR. This is
                                        ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                                        ;
                                        ; 'ERROR' prints the string pointed to by A0. It then prints the
                                        ; line pointed to by CURRNT with a "?" inserted at where the
                                        ; old text pointer (should be on top of the stack) points to.
                                        ; Execution of Tiny BASIC is stopped and a warm start is done.
                                        ; If CURRNT is zero (indicating a direct command), the direct
                                        ; command is not printed. If CURRNT is -1 (indicating
                                        ; 'INPUT' command in progress), the input line is not printed
                                        ; and execution is not terminated but continues at 'INPERR'.
                                        ;
                                        ; Related to 'ERROR' are the following:
                                        ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                                        ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                                        ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                                        ; 'QHOW' and 'AHOW' also do this for "How?".
                                        ;
                                        
                                        ; returns
                                        ; r2 = variable's address
                                        ;
   2147 0000EA6A                        SETVAL
   2148 0000EA6A FC 6E                       sub     sp,sp,#4
   2149 0000EA6C E0 DF                       sw      lr,[sp]
   2150 0000EA6E 01 11                       lw		r1,#1		; allocate var
   2151 0000EA70 ED 4F 04 AF                 call	TSTV		; variable name?
   2152 0000EA74 03 A9                       bne		sv2
   2153 0000EA76 1C 4F 0A 11                	lea		r1,msgVar
   2154 0000EA7A 35 AE                      	br		ERROR 
   2155 0000EA7C                        sv2
   2156 0000EA7C E2 D1                   	sw      r1,2[sp]    ; save the variable's address
   2157 0000EA7E 1D 40 06 AF             	call	TSTC		; get past the "=" sign
   2158 0000EA82 3D 12                   	db	'=',SV1-*+1
   2159 0000EA84 DE 4F 06 AF             	call	OREXPR		; evaluate the expression
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 37
noc_boot31.a
   2160 0000EA88 E2 F2                   	lw      r2,2[sp]    ; get back the variable's address
   2161 0000EA8A 20 D1                   	sw      r1,[r2]     ; and save value in the variable
   2162 0000EA8C 20 11                   	lw		r1,r2		; return r1 = variable address
   2163 0000EA8E E0 FF                   	lw      lr,[sp]
   2164 0000EA90 04 6E                   	add     sp,sp,#4
   2165 0000EA92 F0 80                   	ret
   2166 0000EA94                        SV1
   2167 0000EA94 26 AE                       br	    QWHAT		; if no "=" sign
                                        
                                        
   2170 0000EA96                        FIN
   2171 0000EA96 FE 6E                   	sub		sp,sp,#2
   2172 0000EA98 E0 DF                   	sw		lr,[sp]
   2173 0000EA9A 1C 40 08 AF             	call	TSTC		; *** FIN ***
   2174 0000EA9E 3A 08                   	db	':',FI1-*+1
   2175 0000EAA0 02 6E                   	add		sp,sp,#2	; if ":", discard return address
   2176 0000EAA2 BF 4F 0D AE             	br		RUNSML		; continue on the same line
   2177 0000EAA6                        FI1
   2178 0000EAA6 1C 40 02 AF             	call	TSTC		; not ":", is it a CR?
   2179 0000EAAA 0D 0A                   	db	CR,FI2-*+1
   2180 0000EAAC E0 FF                   	lw		lr,[sp]	; else return to the caller
   2181 0000EAAE 02 6E                   	add		sp,sp,#2	; yes, purge return address
   2182 0000EAB0 BE 4F 0B AE             	br		RUNNXL		; execute the next line
   2183 0000EAB4                        FI2
   2184 0000EAB4 E0 FF                   	lw		lr,[sp]	; else return to the caller
   2185 0000EAB6 02 6E                   	add		sp,sp,#2
   2186 0000EAB8 F0 80                   	ret
                                        
                                        
                                        ; Check that there is nothing else on the line
                                        ; Registers Affected
                                        ;   r1
                                        ;
   2193 0000EABA                        ENDCHK
   2194 0000EABA FE 6E                   	sub		sp,sp,#2
   2195 0000EABC E0 DF                   	sw		lr,[sp]
   2196 0000EABE 1E 40 09 AF             	call	IGNBLK
   2197 0000EAC2 80 E1                   	lb		r1,[r8]
   2198 0000EAC4 FF 4F 13 10             	cmp		r1,#CR		; does it end with a CR?
   2199 0000EAC8 03 A8                   	beq		ec1
   2200 0000EACA 2A 4F 04 11             	lea		r1,msgExtraChars
   2201 0000EACE 0B AE                   	jmp		ERROR
   2202 0000EAD0                        ec1
   2203 0000EAD0 E0 FF                   	lw		lr,[sp]
   2204 0000EAD2 02 6E                   	add		sp,sp,#2
   2205 0000EAD4 F0 80                   	ret
                                        
                                        
   2208 0000EAD6                        TOOBIG
   2209 0000EAD6 28 4F 0F 11             	lea		r1,msgTooBig
   2210 0000EADA 05 AE                   	br		ERROR
   2211 0000EADC                        QSORRY
   2212 0000EADC 12 4F 05 11                 lea     r1,SRYMSG
   2213 0000EAE0 02 AE                   	br	    ERROR
   2214 0000EAE2                        QWHAT
   2215 0000EAE2 11 4F 0D 11             	lea		r1,msgWhat
   2216 0000EAE6                        ERROR
   2217 0000EAE6 21 40 0D AF             	call	PRMESG		; display the error message
   2218 0000EAEA 04 40 06 F1             	lw		r1,CURRNT	; get the current line number
   2219 0000EAEE B0 4F 0B A8             	beq		WSTART		; if zero, do a warm start
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 38
noc_boot31.a
   2220 0000EAF2 11 10                   	cmp		r1,#-1		; is the line no. pointer = -1?
   2221 0000EAF4 CD 4F 0A A8             	beq		INPERR		; if so, redo input
   2222 0000EAF8 80 E5                   	lb		r5,[r8]		; save the char. pointed to
   2223 0000EAFA 80 C0                   	sb		r0,[r8]		; put a zero where the error is
   2224 0000EAFC 04 40 06 F1             	lw		r1,CURRNT	; point to start of current line
   2225 0000EB00 17 40 07 AF             	call	PRTLN		; display the line in error up to the 0
   2226 0000EB04 10 16                   	lw      r6,r1       ; save off end pointer
   2227 0000EB06 80 C5                   	sb		r5,[r8]		; restore the character
   2228 0000EB08 03 40 0F 11             	lw		r1,#'?'		; display a "?"
   2229 0000EB0C AD 4F 06 AF             	call	GOOUT
   2230 0000EB10 00 12                   	lw      r2,#0       ; stop char = 0
   2231 0000EB12 6F 11                   	sub		r1,r6,#1	; point back to the error char.
   2232 0000EB14 B6 AF                   	call	PRTSTG		; display the rest of the line
   2233 0000EB16 AF 4F 07 AE             	jmp	    WSTART		; and do a warm start
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** GETLN *** FNDLN (& friends) ***
                                        ;
                                        ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                                        ; the character in r3 (given by the caller), then it fills the
                                        ; buffer and echos. It ignores LF's but still echos
                                        ; them back. Control-H is used to delete the last character
                                        ; entered (if there is one), and control-X is used to delete the
                                        ; whole line and start over again. CR signals the end of a line,
                                        ; and causes 'GETLN' to return.
                                        ;
                                        ;
   2249 0000EB1A                        GETLN
   2250 0000EB1A FC 6E                   	sub		sp,sp,#4
   2251 0000EB1C E0 DF                   	sw		lr,[sp]
   2252 0000EB1E E2 D5                   	sw		r5,2[sp]
   2253 0000EB20 AC 4F 0C AF             	call	GOOUT		; display the prompt
   2254 0000EB24 01 11                   	lw		r1,#1		; turn on cursor flash
   2255 0000EB26 02 40 00 C1             	sb		r1,cursFlash
   2256 0000EB2A 02 40 00 11             	lw		r1,#' '		; and a space
   2257 0000EB2E AC 4F 05 AF             	call	GOOUT
   2258 0000EB32 06 40 0E 18             	lea		r8,BUFFER	; r8 is the buffer pointer
   2259 0000EB36                        GL1
   2260 0000EB36 1E 40 03 AF             	call	CHKIO		; check keyboard
   2261 0000EB3A FD B8                   	beq		GL1			; wait for a char. to come in
   2262 0000EB3C FF 4F 18 10             	cmp		r1,#CTRLH	; delete last character?
   2263 0000EB40 14 A8                   	beq		GL3			; if so
   2264 0000EB42 FE 4F 18 10             	cmp		r1,#CTRLX	; delete the whole line?
   2265 0000EB46 20 A8                   	beq		GL4			; if so
   2266 0000EB48 FF 4F 13 10             	cmp		r1,#CR		; accept a CR
   2267 0000EB4C 03 A8                   	beq		GL2
   2268 0000EB4E FE 4F 10 10             	cmp		r1,#' '		; if other control char., discard it
   2269 0000EB52 F1 B4                   	bltu	GL1
   2270 0000EB54                        GL2
   2271 0000EB54 80 C1                   	sb		r1,[r8]		; save the char.
   2272 0000EB56 01 68                   	add		r8,r8,#1
   2273 0000EB58 AB 4F 00 AF             	call	GOOUT		; echo the char back out
   2274 0000EB5C 8F E1                   	lb      r1,-1[r8]   ; get char back (GOOUT destroys r1)
   2275 0000EB5E FF 4F 13 10             	cmp		r1,#CR		; if it's a CR, end the line
   2276 0000EB62 25 A8                   	beq		GL7
   2277 0000EB64 F4 4F 83 10             	cmp		r8,#(BUFFER+BUFLEN-1)	; any more room?
   2278 0000EB68 E6 B4                   	bltu	GL1			; yes: get some more, else delete last char.
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 39
noc_boot31.a
   2280 0000EB6A                        GL3
   2281 0000EB6A 08 11                   	lw		r1,#CTRLH	; delete a char. if possible
   2282 0000EB6C AA 4F 06 AF             	call	GOOUT
   2283 0000EB70 02 40 00 11             	lw		r1,#' '
   2284 0000EB74 AA 4F 02 AF             	call	GOOUT
   2285 0000EB78 F9 4F 82 10             	cmp		r8,#BUFFER	; any char.'s left?
   2286 0000EB7C DC B6                   	bleu	GL1			; if not
   2287 0000EB7E 08 11                   	lw		r1,#CTRLH	; if so, finish the BS-space-BS sequence
   2288 0000EB80 A9 4F 0C AF             	call	GOOUT
   2289 0000EB84 FF 68                   	sub		r8,r8,#1	; decrement the text pointer
   2290 0000EB86 D7 BE                   	br		GL1			; back for more
                                        
   2292 0000EB88                        GL4
   2293 0000EB88 80 11                   	lw		r1,r8		; delete the whole line
   2294 0000EB8A F9 4F 12 15             	sub		r5,r1,#BUFFER   ; figure out how many backspaces we need
   2295 0000EB8E 0C A8                   	beq		GL6			; if none needed, brnch
   2296 0000EB90                        GL5	
   2297 0000EB90 08 11                   	lw		r1,#CTRLH	; and display BS-space-BS sequences
   2298 0000EB92 A9 4F 03 AF             	call	GOOUT
   2299 0000EB96 02 40 00 11             	lw		r1,#' '
   2300 0000EB9A A8 4F 0F AF             	call	GOOUT
   2301 0000EB9E 08 11                   	lw		r1,#CTRLH
   2302 0000EBA0 A8 4F 0C AF             	call	GOOUT
   2303 0000EBA4 FF 65                   	sub		r5,r5,#1
   2304 0000EBA6 F4 B9                   	bne     GL5
   2305 0000EBA8                        GL6
   2306 0000EBA8 06 40 0E 18             	lea		r8,BUFFER	; reinitialize the text pointer
   2307 0000EBAC C4 BE                   	br		GL1			; and go back for more
   2308 0000EBAE                        GL7
   2309 0000EBAE 00 11                   	lw		r1,#0		; turn off cursor flash
   2310 0000EBB0 02 40 00 C1             	sb		r1,cursFlash
   2311 0000EBB4 0A 11                   	lw		r1,#LF		; echo a LF for the CR
   2312 0000EBB6 A8 4F 01 AF             	call	GOOUT
   2313 0000EBBA E0 FF                   	lw		lr,[sp]
   2314 0000EBBC E2 F5                   	lw		r5,2[sp]
   2315 0000EBBE 04 6E                   	add		sp,sp,#4
   2316 0000EBC0 F0 80                   	ret
                                        
                                        
                                        ; 'FNDLN' finds a line with a given line no. (in r1) in the
                                        ; text save area.  r9 is used as the text pointer. If the line
                                        ; is found, r9 will point to the beginning of that line
                                        ; (i.e. the high byte of the line no.), and flags are Z.
                                        ; If that line is not there and a line with a higher line no.
                                        ; is found, r9 points there and flags are NC & NZ. If we reached
                                        ; the end of the text save area and cannot find the line, flags
                                        ; are C & NZ.
                                        ; Z=1 if line found
                                        ; N=1 if end of text save area
                                        ; Z=0 & N=0 if higher line found
                                        ;
                                        ; 'FNDLN' will initialize r9 to the beginning of the text save
                                        ; area to start the search. Some other entries of this routine
                                        ; will not initialize r9 and do the search.
                                        ; 'FNDLNP' will start with r9 and search for the line no.
                                        ; 'FNDNXT' will bump r9 by 2, find a CR and then start search.
                                        ; 'FNDSKP' uses r9 to find a CR, and then starts the search.
                                        ; return Z=1 if line is found, r9 = pointer to line
                                        ;
                                        ; Parameters
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 40
noc_boot31.a
                                        ;	r1 = line number to find
                                        ;
   2342 0000EBC2                        FNDLN
   2343 0000EBC2 00 40 11 10             	cmp		r1,#0xFFFF	; line no. must be < 65535
   2344 0000EBC6 03 A6                   	bleu	fl1
   2345 0000EBC8 1B 4F 04 11             	lea		r1,msgLineRange
   2346 0000EBCC 8C BE                   	br		ERROR
   2347 0000EBCE                        fl1
   2348 0000EBCE 0D 4E 00 F9             	lw		r9,TXTBGN	; init. the text save pointer
                                        
   2350 0000EBD2                        FNDLNP
   2351 0000EBD2 05 40 06 FA             	lw		r10,TXTUNF	; check if we passed the end
   2352 0000EBD6 FF 6A                   	sub		r10,r10,#1
   2353 0000EBD8 AD 29                   	cmp		r9,r10
   2354 0000EBDA 0F A7                   	bgtu	FNDRET		; if so, return with Z=0 & C=1
   2355 0000EBDC 90 E3                   	lb		r3,[r9]		; get low order byte of line number
   2356 0000EBDE 0E 23                   	zxb		r3
   2357 0000EBE0 91 E2                   	lb		r2,1[r9]	; get high order byte
   2358 0000EBE2 0E 22                   	zxb		r2
   2359 0000EBE4 81 32                   	shl		r2,#1
   2360 0000EBE6 81 32                   	shl		r2,#1
   2361 0000EBE8 81 32                   	shl		r2,#1
   2362 0000EBEA 81 32                   	shl		r2,#1
   2363 0000EBEC 81 32                   	shl		r2,#1
   2364 0000EBEE 81 32                   	shl		r2,#1
   2365 0000EBF0 81 32                   	shl		r2,#1
   2366 0000EBF2 81 32                   	shl		r2,#1
   2367 0000EBF4 36 22                   	or		r2,r3		; build whole line number
   2368 0000EBF6 2D 21                   	cmp		r1,r2		; is this the line we want?
   2369 0000EBF8 01 A7                   	bgtu	FNDNXT		; no, not there yet
   2370 0000EBFA                        FNDRET
   2371 0000EBFA F0 80                   	ret			; return the cond. codes
                                        
   2373 0000EBFC                        FNDNXT
   2374 0000EBFC 02 69                   	add		r9,r9,#2	; find the next line
                                        
   2376 0000EBFE                        FNDSKP
   2377 0000EBFE 90 E2                   	lb		r2,[r9]
   2378 0000EC00 01 69                   	add		r9,r9,#1
   2379 0000EC02 FF 4F 23 10             	cmp		r2,#CR		; try to find a CR
   2380 0000EC06 FB B9                   	bne		FNDSKP		; keep looking
   2381 0000EC08 E4 BE                   	br		FNDLNP		; check if end of text
                                        
                                        
                                        ;******************************************************************
                                        ; 'MVUP' moves a block up from where r1 points to where r2 points
                                        ; until r1=r3
                                        ;
   2388 0000EC0A                        MVUP1
   2389 0000EC0A 10 E4                   	lb		r4,[r1]
   2390 0000EC0C 20 C4                   	sb		r4,[r2]
   2391 0000EC0E 01 61                   	add		r1,r1,#1
   2392 0000EC10 01 62                   	add		r2,r2,#1
   2393 0000EC12                        MVUP
   2394 0000EC12 3D 21                   	cmp		r1,r3
   2395 0000EC14 FA B9                   	bne		MVUP1
   2396 0000EC16                        MVRET
   2397 0000EC16 F0 80                   	ret
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 41
noc_boot31.a
                                        ; 'MVDOWN' moves a block down from where r1 points to where r2
                                        ; points until r1=r3
                                        ;
   2403 0000EC18                        MVDOWN1
   2404 0000EC18 FF 61                   	sub		r1,r1,#1
   2405 0000EC1A FF 62                   	sub		r2,r2,#1
   2406 0000EC1C 10 E4                   	lb		r4,[r1]
   2407 0000EC1E 20 C4                   	sb		r4,[r2]
   2408 0000EC20                        MVDOWN
   2409 0000EC20 3D 21                   	cmp		r1,r3
   2410 0000EC22 FA B9                   	bne		MVDOWN1
   2411 0000EC24 F0 80                   	ret
                                        
                                        
                                        ; 'POPA' restores the 'FOR' loop variable save area from the stack
                                        ;
                                        ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                                        ;
                                        ; Note: a single zero word is stored on the stack in the
                                        ; case that no FOR loops need to be saved. This needs to be
                                        ; done because PUSHA / POPA is called all the time.
                                        
   2422 0000EC26                        POPA
   2423 0000EC26 E0 F1                   	lw		r1,[sp]		; restore LOPVAR, but zero means no more
   2424 0000EC28 04 40 0C D1             	sw		r1,LOPVAR
   2425 0000EC2C 0E A8                   	beq		PP1
   2426 0000EC2E E8 F1                   	lw		r1,8[sp]	; if not zero, restore the rest
   2427 0000EC30 05 40 04 D1             	sw		r1,LOPPT
   2428 0000EC34 E6 F1                   	lw		r1,6[sp]
   2429 0000EC36 05 40 02 D1             	sw		r1,LOPLN
   2430 0000EC3A E4 F1                   	lw		r1,4[sp]
   2431 0000EC3C 05 40 00 D1             	sw		r1,LOPLMT
   2432 0000EC40 E2 F1                   	lw		r1,2[sp]
   2433 0000EC42 04 40 0E D1             	sw		r1,LOPINC
   2434 0000EC46 0A 6E                   	add		sp,sp,#10
   2435 0000EC48 F0 80                   	ret
   2436 0000EC4A                        PP1
   2437 0000EC4A 02 6E                   	add		sp,sp,#2
   2438 0000EC4C F0 80                   	ret
                                        
                                        
   2441 0000EC4E                        PUSHA
   2442 0000EC4E 06 40 00 F1             	lw		r1,STKBOT	; Are we running out of stack room?
   2443 0000EC52 0A 61                   	add		r1,r1,#10	; we might need this many bytes
   2444 0000EC54 1D 2E                   	cmp		sp,r1
   2445 0000EC56 42 B4                   	bltu	QSORRY		; out of stack space
   2446 0000EC58 04 40 0C F1             	lw		r1,LOPVAR	; save loop variables
   2447 0000EC5C 0F A8                   	beq		PU1			; if LOPVAR is zero, that's all
   2448 0000EC5E F6 6E                   	sub		sp,sp,#10
   2449 0000EC60 E0 D1                   	sw		r1,[sp]
   2450 0000EC62 05 40 04 F1             	lw		r1,LOPPT
   2451 0000EC66 E8 D1                   	sw		r1,8[sp]	; else save all the others
   2452 0000EC68 05 40 02 F1             	lw		r1,LOPLN
   2453 0000EC6C E6 D1                   	sw		r1,6[sp]
   2454 0000EC6E 05 40 00 F1             	lw		r1,LOPLMT
   2455 0000EC72 E4 D1                   	sw		r1,4[sp]
   2456 0000EC74 04 40 0E F1             	lw		r1,LOPINC
   2457 0000EC78 E2 D1                   	sw		r1,2[sp]
   2458 0000EC7A F0 80                   	ret
   2459 0000EC7C                        PU1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 42
noc_boot31.a
   2460 0000EC7C FE 6E                   	sub		sp,sp,#2
   2461 0000EC7E E0 D1                   	sw		r1,[sp]
   2462 0000EC80 F0 80                   	ret
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                                        ;
                                        ; 'PRTSTG' prints a string pointed to by r3. It stops printing
                                        ; and returns to the caller when either a CR is printed or when
                                        ; the next byte is the same as what was passed in r4 by the
                                        ; caller.
                                        ;
                                        ; 'QTSTG' looks for an underline (back-arrow on some systems),
                                        ; single-quote, or double-quote.  If none of these are found, returns
                                        ; to the caller.  If underline, outputs a CR without a LF.  If single
                                        ; or double quote, prints the quoted string and demands a matching
                                        ; end quote.  After the printing, the next 2 bytes of the caller are
                                        ; skipped over (usually a short brnch instruction).
                                        ;
                                        ; 'PRTNUM' prints the 32 bit number in r3, leading blanks are added if
                                        ; needed to pad the number of spaces to the number in r4.
                                        ; However, if the number of digits is larger than the no. in
                                        ; r4, all digits are printed anyway. Negative sign is also
                                        ; printed and counted in, positive sign is not.
                                        ;
                                        ; 'PRTLN' prints the saved text line pointed to by r3
                                        ; with line no. and all.
                                        ;
                                        
                                        ; r1 = pointer to string
                                        ; r2 = stop character
                                        ; return r1 = pointer to end of line + 1
                                        
   2495 0000EC82                        PRTSTG
   2496 0000EC82 F8 6E                       sub     sp,sp,#8
   2497 0000EC84 E0 DF                       sw      lr,[sp]
   2498 0000EC86 E2 D5                       sw      r5,2[sp]
   2499 0000EC88 E4 D6                       sw      r6,4[sp]
   2500 0000EC8A E6 D7                       sw      r7,6[sp]
   2501 0000EC8C 10 15                       lw      r5,r1       ; r5 = pointer
   2502 0000EC8E 20 16                       lw      r6,r2       ; r6 = stop char
   2503 0000EC90                        PS1
   2504 0000EC90 50 E7                       lb      r7,[r5]     ; get a text character
   2505 0000EC92 01 65                       add     r5,r5,#1
   2506 0000EC94 6D 27                   	cmp     r7,r6		; same as stop character?
   2507 0000EC96 09 A8                   	beq	    PRTRET		; if so, return
   2508 0000EC98 70 11                   	lw      r1,r7
   2509 0000EC9A A0 4F 0F AF             	call	GOOUT		; display the char.
   2510 0000EC9E FF 4F 73 10             	cmp     r7,#CR      ; is it a C.R.?
   2511 0000ECA2 F6 B9                   	bne	    PS1		    ; no, go back for more
   2512 0000ECA4 0A 11                   	lw      r1,#LF      ; yes, add a L.F.
   2513 0000ECA6 A0 4F 09 AF             	call	GOOUT
   2514 0000ECAA                        PRTRET
   2515 0000ECAA 70 12                       lw      r2,r7       ; return r2 = stop char
   2516 0000ECAC 50 11                   	lw		r1,r5		; return r1 = line pointer
   2517 0000ECAE E2 F5                       lw      r5,2[sp]
   2518 0000ECB0 E4 F6                       lw      r6,4[sp]
   2519 0000ECB2 E6 F7                       lw      r7,6[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 43
noc_boot31.a
   2520 0000ECB4 E0 FF                       lw      lr,[sp]
   2521 0000ECB6 08 6E                       add     sp,sp,#8
   2522 0000ECB8 F0 80                       ret			        ; then return
                                        
                                        
   2525 0000ECBA                        QTSTG
   2526 0000ECBA FE 6E                   	sub		sp,sp,#2
   2527 0000ECBC E0 DF                   	sw		lr,[sp]
   2528 0000ECBE B7 AF                   	call	TSTC		; *** QTSTG ***
   2529 0000ECC0 22 18                   	db	'"',QT3-*+1
   2530 0000ECC2 02 40 02 12             	lw		r2,#'"'		; it is a "
   2531 0000ECC6                        QT1
   2532 0000ECC6 80 11                   	lw		r1,r8
   2533 0000ECC8 DC BF                   	call	PRTSTG		; print until another
   2534 0000ECCA 10 18                   	lw		r8,r1
   2535 0000ECCC FF 4F 26 10             	cmp		r2,#LF		; was last one a CR?
   2536 0000ECD0 0E A9                   	bne		QT2
   2537 0000ECD2 02 6E                   	add		sp,sp,#2
   2538 0000ECD4 AD 4F 09 AE             	br		RUNNXL		; if so, run next line
   2539 0000ECD8                        QT3
   2540 0000ECD8 AA AF                   	call	TSTC		; is it a single quote?
   2541 0000ECDA 27 08                   	db	"'",QT4-*+1
   2542 0000ECDC 02 40 07 12             	lw		r2,#''''	; if so, do same as above
   2543 0000ECE0 F2 BE                   	br		QT1
   2544 0000ECE2                        QT4
   2545 0000ECE2 A5 AF                   	call	TSTC		; is it an underline?
   2546 0000ECE4 5F 10                   	db	'_',QT5-*+1
   2547 0000ECE6 00 40 0D 11             	lw		r1,#CR		; if so, output a CR without LF
   2548 0000ECEA 9E 4F 07 AF             	call	GOOUT
   2549 0000ECEE                        QT2
   2550 0000ECEE E0 FF                   	lw		lr,[sp]
   2551 0000ECF0 02 6E                   	add		sp,sp,#2
   2552 0000ECF2 F2 80                   	jmp		2[lr]		; skip over 2 bytes when returning
   2553 0000ECF4                        QT5						; not " ' or _
   2554 0000ECF4 E0 FF                   	lw		lr,[sp]
   2555 0000ECF6 02 6E                   	add		sp,sp,#2
   2556 0000ECF8 F0 80                   	ret
                                        
                                        
                                        ; Output a CR LF sequence
                                        ;
   2561 0000ECFA                        prCRLF
   2562 0000ECFA FE 6E                   	sub		sp,sp,#2
   2563 0000ECFC E0 DF                   	sw		lr,[sp]
   2564 0000ECFE 00 40 0D 11             	lw		r1,#CR
   2565 0000ED02 9D 4F 0B AF             	call	GOOUT
   2566 0000ED06 0A 11                   	lw		r1,#LF
   2567 0000ED08 9D 4F 08 AF             	call	GOOUT
   2568 0000ED0C E0 FF                   	lw		lr,[sp]
   2569 0000ED0E 02 6E                   	add		sp,sp,#2
   2570 0000ED10 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
                                        ; Register Usage
                                        ;	r5 = number of padding spaces
   2577 0000ED12                        PRTNUM
   2578 0000ED12 F8 6E                   	sub		sp,sp,#8
   2579 0000ED14 E0 DF                   	sw		lr,[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 44
noc_boot31.a
   2580 0000ED16 E2 D5                   	sw		r5,2[sp]
   2581 0000ED18 E4 D6                   	sw		r6,4[sp]
   2582 0000ED1A E6 D7                   	sw		r7,6[sp]
                                        
   2584 0000ED1C 06 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2585 0000ED20 10 16                   	lw		r6,r1		; save number for later
   2586 0000ED22 20 15                   	lw		r5,r2		; r5 = min number of chars
   2587 0000ED24 16 21                   	
   2588 0000ED26 02 AB                   	bpl		PN1			; if not
   2589 0000ED28 20 31                   	neg		r1			; else make it positive
   2590 0000ED2A FF 65                   	sub		r5,r5,#1	; one less for width count
   2591 0000ED2C                        PN1
   2592 0000ED2C 0A 12                   	lw		r2,#10		; divide by 10
   2593 0000ED2E E1 4F 06 AF             	call	DIV32
   2594 0000ED32 30 62                   	add		r2,r2,#'0'	; convert remainder to ascii
   2595 0000ED34 70 C2                   	sb		r2,[r7]		; and store in buffer
   2596 0000ED36 01 67                   	add		r7,r7,#1
   2597 0000ED38 FF 65                   	sub		r5,r5,#1	; decrement width
   2598 0000ED3A 10 10                   	cmp		r1,#0
   2599 0000ED3C F7 B9                   	bne		PN1
   2600 0000ED3E                        PN6
   2601 0000ED3E 56 25                   	or		r5,r5		; test pad count
   2602 0000ED40 06 A2                   	ble		PN4			; skip padding if not needed
   2603 0000ED42                        PN3
   2604 0000ED42 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2605 0000ED46 9B 4F 09 AF             	call	GOOUT
   2606 0000ED4A FF 65                   	sub		r5,r5,#1
   2607 0000ED4C FA B9                   	bne		PN3
   2608 0000ED4E                        PN4
   2609 0000ED4E 66 26                   	or		r6,r6		; is number negative?
   2610 0000ED50 04 AB                   	bpl		PN5
   2611 0000ED52 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2612 0000ED56 9B 4F 01 AF             	call	GOOUT
   2613 0000ED5A                        PN5
   2614 0000ED5A FF 67                   	sub		r7,r7,#1
   2615 0000ED5C 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2616 0000ED5E 9A 4F 0D AF             	call	GOOUT
   2617 0000ED62 F9 4F 7E 10             	cmp		r7,#NUMWKA
   2618 0000ED66 F9 B7                   	bgtu	PN5
   2619 0000ED68                        PNRET
   2620 0000ED68 E0 FF                   	lw		lr,[sp]
   2621 0000ED6A E2 F5                   	lw		r5,2[sp]
   2622 0000ED6C E4 F6                   	lw		r6,4[sp]
   2623 0000ED6E E6 F7                   	lw		r7,6[sp]
   2624 0000ED70 08 6E                   	add		sp,sp,#8
   2625 0000ED72 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
   2630 0000ED74                        PRTHEXNUM
   2631 0000ED74 F6 6E                   	sub		sp,sp,#10
   2632 0000ED76 E0 DF                   	sw		lr,[sp]
   2633 0000ED78 E2 D5                   	sw		r5,2[sp]
   2634 0000ED7A E4 D6                   	sw		r6,4[sp]
   2635 0000ED7C E6 D7                   	sw		r7,6[sp]
   2636 0000ED7E E8 D8                   	sw		r8,8[sp]
                                        
   2638 0000ED80 06 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2639 0000ED84 10 16                   	lw		r6,r1		; save number for later
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 45
noc_boot31.a
   2640 0000ED86 0A 15                   	lw		r5,#10		; r5 = min number of chars
   2641 0000ED88 10 14                   	lw		r4,r1
   2642 0000ED8A 46 24                   	
   2643 0000ED8C 03 AB                   	bpl		PHN1		; if not
   2644 0000ED8E 20 34                   	neg		r4			; else make it positive
   2645 0000ED90 FF 65                   	sub		r5,r5,#1	; one less for width count
   2646 0000ED92 0A 18                   	lw		r8,#10		; maximum of 10 digits
   2647 0000ED94                        PHN1
   2648 0000ED94 40 11                   	lw		r1,r4
   2649 0000ED96 00 40 5F 31             	and		r1,#15
   2650 0000ED9A FF 4F 16 10             	cmp		r1,#10
   2651 0000ED9E 02 A0                   	blt		PHN7
   2652 0000EDA0 37 61                   	add		r1,r1,#'A'-10
   2653 0000EDA2 01 AE                   	br		PHN8
   2654 0000EDA4                        PHN7
   2655 0000EDA4 30 61                   	add		r1,r1,#'0'		; convert remainder to ascii
   2656 0000EDA6                        PHN8
   2657 0000EDA6 70 C1                   	sb		r1,[r7]		; and store in buffer
   2658 0000EDA8 01 67                   	add		r7,r7,#1
   2659 0000EDAA FF 65                   	sub		r5,r5,#1	; decrement width
   2660 0000EDAC A1 34                   	shr		r4,#1
   2661 0000EDAE A1 34                   	shr		r4,#1
   2662 0000EDB0 A1 34                   	shr		r4,#1
   2663 0000EDB2 A1 34                   	shr		r4,#1
   2664 0000EDB4 02 A8                   	beq		PHN6			; is it zero yet ?
   2665 0000EDB6 FF 68                   	sub		r8,r8,#1	; safety
   2666 0000EDB8 ED B9                   	bne		PHN1
   2667 0000EDBA                        PHN6
   2668 0000EDBA 56 25                   	or		r5,r5		; test pad count
   2669 0000EDBC 06 A2                   	ble		PHN4			; skip padding if not needed
   2670 0000EDBE                        PHN3
   2671 0000EDBE 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2672 0000EDC2 97 4F 0B AF             	call	GOOUT
   2673 0000EDC6 FF 65                   	sub		r5,r5,#1
   2674 0000EDC8 FA B9                   	bne		PHN3
   2675 0000EDCA                        PHN4
   2676 0000EDCA 66 26                   	or		r6,r6		; is number negative?
   2677 0000EDCC 04 AB                   	bpl		PHN5
   2678 0000EDCE 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2679 0000EDD2 97 4F 03 AF             	call	GOOUT
   2680 0000EDD6                        PHN5
   2681 0000EDD6 FF 67                   	sub		r7,r7,#1
   2682 0000EDD8 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2683 0000EDDA 96 4F 0F AF             	call	GOOUT
   2684 0000EDDE F9 4F 7E 10             	cmp		r7,#NUMWKA
   2685 0000EDE2 F9 B7                   	bgtu	PHN5
   2686 0000EDE4                        PHNRET
   2687 0000EDE4 E0 FF                   	lw		lr,[sp]
   2688 0000EDE6 E2 F5                   	lw		r5,2[sp]
   2689 0000EDE8 E4 F6                   	lw		r6,4[sp]
   2690 0000EDEA E6 F7                   	lw		r7,6[sp]
   2691 0000EDEC E8 F8                   	lw		r8,8[sp]
   2692 0000EDEE 0A 6E                   	add		sp,sp,#10
   2693 0000EDF0 F0 80                   	ret
                                        
                                        
                                        ; r1 = pointer to line
                                        ; returns r1 = pointer to end of line + 1
   2698 0000EDF2                        PRTLN
   2699 0000EDF2 FC 6E                       sub     sp,sp,#4
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 46
noc_boot31.a
   2700 0000EDF4 E0 DF                       sw      lr,[sp]
   2701 0000EDF6 E2 D5                       sw      r5,2[sp]
   2702 0000EDF8 12 15                       add     r5,r1,#2
   2703 0000EDFA 5E E1                       lb		r1,-2[r5]	; get the binary line number
   2704 0000EDFC 0E 21                       zxb		r1
   2705 0000EDFE 5F E2                       lb		r2,-1[r5]
   2706 0000EE00 0E 22                       zxb		r2
   2707 0000EE02 81 32                       shl		r2,#1
   2708 0000EE04 81 32                       shl		r2,#1
   2709 0000EE06 81 32                       shl		r2,#1
   2710 0000EE08 81 32                       shl		r2,#1
   2711 0000EE0A 81 32                       shl		r2,#1
   2712 0000EE0C 81 32                       shl		r2,#1
   2713 0000EE0E 81 32                       shl		r2,#1
   2714 0000EE10 81 32                       shl		r2,#1
   2715 0000EE12 26 21                       or		r1,r2
   2716 0000EE14 00 12                       lw      r2,#0       ; display a 0 or more digit line no.
   2717 0000EE16 7D BF                   	call	PRTNUM
   2718 0000EE18 02 40 00 11             	lw      r1,#' '     ; followed by a blank
   2719 0000EE1C 94 4F 0E AF             	call	GOOUT
   2720 0000EE20 00 12                   	lw      r2,#0       ; stop char. is a zero
   2721 0000EE22 50 11                   	lw      r1,r5
   2722 0000EE24 2E BF                   	call    PRTSTG		; display the rest of the line
   2723 0000EE26 E2 F5                   	lw      r5,2[sp]
   2724 0000EE28 E0 FF                   	lw      lr,[sp]
   2725 0000EE2A 04 6E                   	add     sp,sp,#4
   2726 0000EE2C F0 80                   	ret
                                        
                                        
                                        ; ===== Test text byte following the call to this subroutine. If it
                                        ;	equals the byte pointed to by r8, return to the code following
                                        ;	the call. If they are not equal, brnch to the point
                                        ;	indicated by the offset byte following the text byte.
                                        ;
                                        ; Registers Affected
                                        ;   r3,r8
                                        ; Returns
                                        ;	r8 = updated text pointer
                                        ;
   2739 0000EE2E                        TSTC
   2740 0000EE2E FC 6E                   	sub		sp,sp,#4
   2741 0000EE30 E0 DF                   	sw		lr,[sp]
   2742 0000EE32 E2 D1                   	sw		r1,2[sp]
   2743 0000EE34 2F AF                   	call	IGNBLK		; ignore leading blanks
   2744 0000EE36 E0 FF                   	lw		lr,[sp]	; get the return address
   2745 0000EE38 F0 E3                   	lb		r3,[lr]	; get the byte to compare
   2746 0000EE3A 80 E1                   	lb		r1,[r8]
   2747 0000EE3C 1D 23                   	cmp		r3,r1		; is it = to what r8 points to?
   2748 0000EE3E 05 A8                   	beq		TC1			; if so
                                        						; If not, add the second
   2750 0000EE40 F1 E3                   	lb		r3,1[lr]	; byte following the call to
   2751 0000EE42 30 2F                   	add		lr,r3		; the return address.
   2752 0000EE44 E2 F1                   	lw		r1,2[sp]
   2753 0000EE46 04 6E                   	add		sp,sp,#4
   2754 0000EE48 F0 80                   	ret					; jump to the routine
   2755 0000EE4A                        TC1
   2756 0000EE4A 01 68                   	add		r8,r8,#1	; if equal, bump text pointer
   2757 0000EE4C E2 F1                   	lw		r1,2[sp]
   2758 0000EE4E 04 6E                   	add     sp,sp,#4
   2759 0000EE50 F2 80                   	jmp		2[lr]		; Skip the 2 bytes following
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 47
noc_boot31.a
                                        						; the call and continue.
                                        
                                        
                                        ; ===== See if the text pointed to by r8 is a number. If so,
                                        ;	return the number in r2 and the number of digits in r3,
                                        ;	else return zero in r2 and r3.
                                        ; Registers Affected
                                        ;   r1,r2,r3,r4
                                        ; Returns
                                        ; 	r1 = number
                                        ;	r2 = number of digits in number
                                        ;	r8 = updated text pointer
                                        ;
   2773 0000EE52                        TSTNUM
   2774 0000EE52 FE 6E                   	sub		sp,sp,#2
   2775 0000EE54 E0 DF                   	sw		lr,[sp]
   2776 0000EE56 1E AF                   	call	IGNBLK		; skip over blanks
   2777 0000EE58 00 11                   	lw		r1,#0		; initialize return parameters
   2778 0000EE5A 00 12                   	lw		r2,#0
   2779 0000EE5C                        TN1
   2780 0000EE5C 80 E3                   	lb		r3,[r8]
   2781 0000EE5E FD 4F 30 10             	cmp		r3,#'0'		; is it less than zero?
   2782 0000EE62 15 A4                   	bltu	TSNMRET 	; if so, that's all
   2783 0000EE64 FC 4F 37 10             	cmp		r3,#'9'		; is it greater than nine?
   2784 0000EE68 12 A7                   	bgtu	TSNMRET 	; if so, return
   2785 0000EE6A 33 43 14 10             	cmp		r1,#214748364	; see if there's room for new digit
   2786 0000EE6E 04 A6                   	bleu	TN2
   2787 0000EE70 14 4F 09 11             	lea		r1,msgNumTooBig
   2788 0000EE74 E3 4F 07 AE             	br		ERROR		; if not, we've overflowd
   2789 0000EE78                        TN2
   2790 0000EE78 10 14                   	lw		r4,r1		; quickly multiply result by 10
   2791 0000EE7A 81 31                   	shl		r1,#1		; * 2
   2792 0000EE7C 81 31                   	shl		r1,#1		; * 4
   2793 0000EE7E 40 21                   	add		r1,r4		; * 5
   2794 0000EE80 81 31                   	shl		r1,#1		; * 10
   2795 0000EE82 01 68                   	add		r8,r8,#1	; adjust text pointer
   2796 0000EE84 00 40 5F 33             	and		r3,#0xF		; add in the new digit
   2797 0000EE88 30 21                   	add		r1,r3
   2798 0000EE8A 01 62                   	add		r2,r2,#1	; increment the no. of digits
   2799 0000EE8C E7 BE                   	br		TN1
   2800 0000EE8E                        TSNMRET
   2801 0000EE8E E0 FF                   	lw		lr,[sp]
   2802 0000EE90 02 6E                   	add		sp,sp,#2
   2803 0000EE92 F0 80                   	ret
                                        
                                        
                                        ;===== Skip over blanks in the text pointed to by r8.
                                        ;
                                        ; Registers Affected:
                                        ;	r8
                                        ; Returns
                                        ;	r8 = pointer updateded past any spaces or tabs
                                        ;
   2813 0000EE94                        IGNBLK
   2814 0000EE94 FE 6E                   	sub		sp,sp,#2
   2815 0000EE96 E0 D1                   	sw		r1,[sp]
   2816 0000EE98                        IGB2
   2817 0000EE98 80 E1                   	lb		r1,[r8]			; get char
   2818 0000EE9A FE 4F 10 10             	cmp		r1,#' '			; see if it's a space
   2819 0000EE9E 03 A8                   	beq		IGB1			; if so, swallow it
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 48
noc_boot31.a
   2820 0000EEA0 FF 4F 17 10             	cmp		r1,#'\t'		; or a tab
   2821 0000EEA4 02 A9                   	bne		IGBRET
   2822 0000EEA6                        IGB1
   2823 0000EEA6 01 68                   	add		r8,r8,#1		; increment the text pointer
   2824 0000EEA8 F7 BE                   	br		IGB2
   2825 0000EEAA                        IGBRET
   2826 0000EEAA E0 F1                   	lw		r1,[sp]
   2827 0000EEAC 02 6E                   	add		sp,sp,#2
   2828 0000EEAE F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the line of text in the input buffer to upper
                                        ;	case (except for stuff between quotes).
                                        ;
                                        ; Registers Affected
                                        ;   r1,r3
                                        ; Returns
                                        ;	r8 = pointing to end of text in buffer
                                        ;
   2839 0000EEB0                        TOUPBUF
   2840 0000EEB0 FE 6E                   	sub		sp,sp,#2
   2841 0000EEB2 E0 DF                   	sw		lr,[sp]
   2842 0000EEB4 06 40 0E 18             	lea		r8,BUFFER	; set up text pointer
   2843 0000EEB8 00 13                   	lw		r3,#0		; clear quote flag
   2844 0000EEBA                        TOUPB1
   2845 0000EEBA 80 E1                   	lb		r1,[r8]		; get the next text char.
   2846 0000EEBC 01 68                   	add		r8,r8,#1
   2847 0000EEBE FF 4F 13 10             	cmp		r1,#CR		; is it end of line?
   2848 0000EEC2 13 A8                   	beq		TOUPBRT 	; if so, return
   2849 0000EEC4 FD 4F 1E 10             	cmp		r1,#'"'		; a double quote?
   2850 0000EEC8 08 A8                   	beq		DOQUO
   2851 0000EECA FD 4F 19 10             	cmp		r1,#''''	; or a single quote?
   2852 0000EECE 05 A8                   	beq		DOQUO
   2853 0000EED0 30 10                   	cmp		r3,#0		; inside quotes?
   2854 0000EED2 F3 B9                   	bne		TOUPB1		; if so, do the next one
   2855 0000EED4 0D AF                   	call	toUpper 	; convert to upper case
   2856 0000EED6 8F C1                   	sb		r1,-1[r8]	; store it
   2857 0000EED8 F0 BE                   	br		TOUPB1		; and go back for more
   2858 0000EEDA                        DOQUO
   2859 0000EEDA 30 10                   	cmp		r3,#0		; are we inside quotes?
   2860 0000EEDC 02 A9                   	bne		DOQUO1
   2861 0000EEDE 10 13                   	lw		r3,r1		; if not, toggle inside-quotes flag
   2862 0000EEE0 EC BE                   	br		TOUPB1
   2863 0000EEE2                        DOQUO1
   2864 0000EEE2 1D 23                   	cmp		r3,r1		; make sure we're ending proper quote
   2865 0000EEE4 EA B9                   	bne		TOUPB1		; if not, ignore it
   2866 0000EEE6 00 13                   	lw		r3,#0		; else clear quote flag
   2867 0000EEE8 E8 BE                   	br		TOUPB1
   2868 0000EEEA                        TOUPBRT
   2869 0000EEEA E0 FF                   	lw		lr,[sp]
   2870 0000EEEC 02 6E                   	add		sp,sp,#2
   2871 0000EEEE F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the character in r1 to upper case
                                        ;
   2876 0000EEF0                        toUpper
   2877 0000EEF0 F9 4F 1F 10             	cmp		r1,#'a'		; is it < 'a'?
   2878 0000EEF4 04 A0                   	blt	    TOUPRET
   2879 0000EEF6 F8 4F 16 10             	cmp		r1,#'z'		; or > 'z'?
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 49
noc_boot31.a
   2880 0000EEFA 01 A3                   	bgt	    TOUPRET
   2881 0000EEFC E0 61                   	sub		r1,r1,#32	; if not, make it upper case
   2882 0000EEFE                        TOUPRET
   2883 0000EEFE F0 80                   	ret
                                        
                                        
                                        ; 'CHKIO' checks the input. If there's no input, it will return
                                        ; to the caller with the Z flag set. If there is input, the Z
                                        ; flag is cleared and the input byte is in r2. However, if a
                                        ; control-C is read, 'CHKIO' will warm-start BASIC and will not
                                        ; return to the caller.
                                        ;
   2892 0000EF00                        CHKIO
   2893 0000EF00 FE 6E                   	sub		sp,sp,#2	; save link reg
   2894 0000EF02 E0 DF                   	sw		lr,[sp]
   2895 0000EF04 8D 4F 0C AF             	call	GOIN		; get input if possible
   2896 0000EF08 07 A8                   	beq		CHKRET2		; if Zero, no input
   2897 0000EF0A 1D 10                   	cmp		r1,#CTRLC	; is it control-C?
   2898 0000EF0C 02 A9                   	bne		CHKRET		; if not
   2899 0000EF0E 8F 4F 0B AE             	jmp		WSTART		; if so, do a warm start
   2900 0000EF12                        CHKRET
   2901 0000EF12 E0 FF                   	lw		lr,[sp]
   2902 0000EF14 02 6E                   	add		sp,sp,#2	; Z=0
   2903 0000EF16 F0 80                   	ret
   2904 0000EF18                        CHKRET2
   2905 0000EF18 E0 FF                   	lw		lr,[sp]
   2906 0000EF1A 02 6E                   	add		sp,sp,#2
   2907 0000EF1C 00 11                   	lw		r1,#0		; Z=1
   2908 0000EF1E F0 80                   	ret
                                        
                                        
                                        ; ===== Display a CR-LF sequence
                                        ;
   2913 0000EF20                        CRLF
   2914 0000EF20 12 4F 0B 11             	lea		r1,CLMSG
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r4
                                        ;
   2921 0000EF24                        PRMESG
   2922 0000EF24 FC 6E                   	sub		sp,sp,#4
   2923 0000EF26 E0 DF                   	sw		lr,[sp]
   2924 0000EF28 E2 D5                   	sw		r5,2[sp]
   2925 0000EF2A 10 15                   	lw      r5,r1       ; r5 = pointer to message
   2926 0000EF2C                        PRMESG1
   2927 0000EF2C 01 65                   	add		r5,r5,#1
   2928 0000EF2E 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2929 0000EF30 03 A8                   	beq		PRMRET
   2930 0000EF32 8C 4F 03 AF             	call	GOOUT		;else display it trashes r4
   2931 0000EF36 FA BE                   	br		PRMESG1
   2932 0000EF38                        PRMRET
   2933 0000EF38 50 11                   	lw		r1,r5
   2934 0000EF3A E2 F5                   	lw		r5,2[sp]
   2935 0000EF3C E0 FF                   	lw		lr,[sp]
   2936 0000EF3E 04 6E                   	add		sp,sp,#4
   2937 0000EF40 F0 80                   	ret
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 50
noc_boot31.a
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r3
                                        ;
   2944 0000EF42                        PRMESGAUX
   2945 0000EF42 FC 6E                   	sub		sp,sp,#4
   2946 0000EF44 E0 DF                   	sw		lr,[sp]
   2947 0000EF46 E2 D5                   	sw		r5,2[sp]
   2948 0000EF48 10 15                   	lw      r5,r1       ; r3 = pointer
   2949 0000EF4A                        PRMESGA1
   2950 0000EF4A 01 65                   	add		r5,r5,#1
   2951 0000EF4C 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2952 0000EF4E 03 A8                   	beq		PRMRETA
   2953 0000EF50 8B 4F 08 AF             	call	GOAUXO		;else display it
   2954 0000EF54 FA BE                   	br		PRMESGA1
   2955 0000EF56                        PRMRETA
   2956 0000EF56 50 11                   	lw		r1,r5
   2957 0000EF58 E2 F5                   	lw		r5,2[sp]
   2958 0000EF5A E0 FF                   	lw		lr,[sp]
   2959 0000EF5C 04 6E                   	add		sp,sp,#4
   2960 0000EF5E F0 80                   	ret
                                        
                                        ;*****************************************************
                                        ; The following routines are the only ones that need *
                                        ; to be changed for a different I/O environment.     *
                                        ;*****************************************************
                                        
                                        
                                        ; ===== Output character to the console (Port 1) from register D0
                                        ;	(Preserves all registers.)
                                        ;
   2971 0000EF60                        OUTC
   2972 0000EF60 FF BE                   	jmp		_putChar
                                        
                                        
                                        ; ===== Input a character from the console into register D0 (or
                                        ;	return Zero status if there's no character available).
                                        ;
   2978 0000EF62                        INC
   2979 0000EF62 FE 6E                   	add		sp,sp,#-2
   2980 0000EF64 E0 DF                   	sw		lr,[sp]
   2981 0000EF66 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   2982 0000EF6A 04 A8                   	beq		INC1
   2983 0000EF6C 87 4F 0D AF             	call	Recv
   2984 0000EF70 1B 40 06 AF             	call	RecvDispatch
   2985 0000EF74                        INC1
                                        ; get char from keyboard
                                        ; returns char in r1
   2988 0000EF74                        _getChar
   2989 0000EF74 C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   2990 0000EF78 08 AB                   	bpl		gc1
   2991 0000EF7A C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   2992 0000EF7E 05 AA                   	bmi		gc1			; was it a keyup event ? (ignore)
   2993 0000EF80 07 40 5F 31             	and		r1,#0x7f
   2994 0000EF84 E0 FF                   	lw		lr,[sp]
   2995 0000EF86 02 6E                   	add		sp,sp,#2
   2996 0000EF88 F0 80                   	ret
   2997 0000EF8A                        gc1
   2998 0000EF8A E0 FF                   	lw		lr,[sp]
   2999 0000EF8C 02 6E                   	add		sp,sp,#2
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 51
noc_boot31.a
   3000 0000EF8E 00 11                   	lw		r1,#0		; return Z=1 (no character)
   3001 0000EF90 F0 80                   	ret
                                        
                                        
                                        ; get char from keyboard
                                        ; returns char in r1
   3006 0000EF92                        _getCharWait
   3007 0000EF92                        gc2
   3008 0000EF92 C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   3009 0000EF96 FD BB                   	bpl		gc2
   3010 0000EF98 C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   3011 0000EF9C FA BA                   	bmi		gc2			; was it a keyup event ? (ignore)
   3012 0000EF9E 07 40 5F 31             	and		r1,#0x7f
   3013 0000EFA2 F0 80                   	ret
                                        
                                        
                                        ; Trigger a load operation on the target node.
                                        
   3018 0000EFA4                        TriggerTgtLoad:
   3019 0000EFA4 82 4F 0C AF             	call	zeroTxBuf
   3020 0000EFA8 01 40 0A E2             	lb		r2,tgtNode
   3021 0000EFAC 02 40 0E C2             	sb		r2,txBuf+MSG_DST
   3022 0000EFB0 01 40 01 12             	lw		r2,#$11
   3023 0000EFB4 02 40 0C C2             	sb		r2,txBuf+MSG_SRC
   3024 0000EFB8 0A 12                   	lw		r2,#10				; trigger load on target node
   3025 0000EFBA 02 40 08 C2             	sb		r2,txBuf+MSG_TYPE
   3026 0000EFBE 83 4F 06 AF             	call	Xmit
   3027 0000EFC2 E2 F2                   	lw		r2,2[sp]
   3028 0000EFC4 E0 FF                   	lw		lr,[sp]
   3029 0000EFC6 F0 80                   	ret
                                        
                                        ; ===== Output character to the host (Port 2) from register r1
                                        ;	(Preserves all registers.)
                                        ;
   3034 0000EFC8                        AUXOUT
   3035 0000EFC8 FC 6E                   	add		sp,sp,#-4
   3036 0000EFCA E0 DF                   	sw		lr,[sp]
   3037 0000EFCC E2 D2                   	sw		r2,2[sp]
   3038 0000EFCE 01 40 0A E2             	lb		r2,tgtNode
                                        	cmp		#$11
   3040 0000EFD2 05 A9                   	bne		auxout1
   3041 0000EFD4 41 48 09 AF             	call	putSerial	; call boot rom routine
   3042 0000EFD8 E2 F2                   	lw		r2,2[sp]
   3043 0000EFDA E0 FF                   	lw		lr,[sp]
   3044 0000EFDC F0 80                   	ret
   3045 0000EFDE                        auxout1:
   3046 0000EFDE 80 4F 0F AF             	call	zeroTxBuf
   3047 0000EFE2 02 40 00 C1             	sb		r1,txBuf
   3048 0000EFE6 01 40 0A E2             	lb		r2,tgtNode
   3049 0000EFEA 02 40 0E C2             	sb		r2,txBuf+MSG_DST
   3050 0000EFEE 01 40 01 12             	lw		r2,#$11
   3051 0000EFF2 02 40 0C C2             	sb		r2,txBuf+MSG_SRC
   3052 0000EFF6 0B 12                   	lw		r2,#11				; recieve BASIC program char
   3053 0000EFF8 02 40 08 C2             	sb		r2,txBuf+MSG_TYPE
   3054 0000EFFC 81 4F 07 AF             	call	Xmit
   3055 0000F000 E2 F2                   	lw		r2,2[sp]
   3056 0000F002 E0 FF                   	lw		lr,[sp]
   3057 0000F004 F0 80                   	ret
                                        ;
                                        ; ===== Input a character from the host into register D0 (or
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 52
noc_boot31.a
                                        ;	return negative status if there's no character available).
                                        ;
   3062 0000F006                        AUXIN
                                        ; get character from serial port
                                        ; return  N=1 if no character available
   3065 0000F006 3F 48 0E AE             	jmp		peekSerial
                                        
                                        
   3068 0000F00A                        _scrollScreen
   3069 0000F00A FC 6E                   	sub		sp,sp,#4
   3070 0000F00C E0 D5                   	sw		r5,[sp]
   3071 0000F00E 60 40 00 13             	lw		r3,#1536	; number of chars to move - 1
   3072 0000F012 00 42 00 12             	lw		r2,#VIDEORAM
   3073 0000F016 01 40 04 E1             	lb		r1,txtWidth
   3074 0000F01A 81 31                   	shl		r1,#1
   3075 0000F01C 81 31                   	shl		r1,#1
   3076 0000F01E                        ss1:
   3077 0000F01E 20 15                   	lw		r5,r2
   3078 0000F020 10 25                   	add		r5,r1
   3079 0000F022 50 F4                   	lw		r4,[r5]		; char at next line
   3080 0000F024 20 D4                   	sw		r4,[r2]		; goes to this line
   3081 0000F026 04 62                   	add		r2,r2,#4
   3082 0000F028 FF 63                   	sub		r3,r3,#1
   3083 0000F02A F9 B9                   	bne     ss1
                                        	; blank out last line
   3085 0000F02C 02 40 00 13             	lw		r3,#' '
   3086 0000F030 01 40 0C D3             	sh		r3,charToPrint
   3087 0000F034 01 40 04 E3             	lb		r3,txtWidth
   3088 0000F038 01 40 0C F4             	lw		r4,charToPrint	; and colors
   3089 0000F03C                        ss2
   3090 0000F03C 20 D4                   	sw		r4,[r2]
   3091 0000F03E 04 62                   	add		r2,r2,#4
   3092 0000F040 FF 63                   	sub		r3,r3,#1
   3093 0000F042 FC B9                   	bne     ss2
   3094 0000F044 E0 F5                   	lw		r5,[sp]
   3095 0000F046 04 6E                   	add		sp,sp,#4
   3096 0000F048 F0 80                   	ret
                                        
                                        
                                        ; flash the character at the screen position
                                        ;   r1: 1 = flash, 0 = no flash
   3101 0000F04A                        _flashCursor
   3102 0000F04A 00 42 00 12             	lw		r2,#VIDEORAM
   3103 0000F04E 01 40 08 F3             	lh		r3,pos
   3104 0000F052 81 33                   	shl		r3,#1
   3105 0000F054 81 33                   	shl		r3,#1
   3106 0000F056 20 23                   	add		r3,r2		; r3 = scr[pos]
                                        
   3108 0000F058 16 21                   	or		r1,r1
   3109 0000F05A 04 A8                   	beq		fc1
   3110 0000F05C 33 E2                   	lb		r2,3[r3]	; get background color
   3111 0000F05E 08 40 60 32             	or		r2,#0x80	; set flash indicator
   3112 0000F062 03 AE                   	br		fcx
   3113 0000F064                        fc1
   3114 0000F064 33 E2                   	lb		r2,3[r3]	; get background color
   3115 0000F066 07 40 5F 32             	and		r2,#0x7f	; clear flash indicator
   3116 0000F06A                        fcx:
   3117 0000F06A 33 C2                   	sb		r2,3[r3]
   3118 0000F06C F0 80                   	ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 53
noc_boot31.a
                                        
                                        ; ===== Return to the resident monitor, operating system, etc.
                                        ;
   3123 0000F06E                        BYEBYE
   3124 0000F06E 04 40 04 FE             	lw		sp,OSSP
   3125 0000F072 E0 FF                       lw      lr,[sp]
   3126 0000F074 02 6E                       add		sp,sp,#2
   3127 0000F076 F0 80                   	ret
                                        
                                        ; Set the message address fields
                                        
   3131 0000F078                        SetMsgAddr:
   3132 0000F078 E4 31                   	tsr		r1,ID
   3133 0000F07A 02 40 0C C1             	sb		r1,txBuf+MSG_SRC
   3134 0000F07E 01 40 01 11             	lw		r1,#$11
   3135 0000F082 02 40 0E C1             	sb		r1,txBuf+MSG_DST
   3136 0000F086 F0 80                   	ret
                                        
   3138 0000F088                        EXIT
   3139 0000F088 AE 4F 04 AF             	call	OREXPR
   3140 0000F08C 7B 4F 08 AF             	call	zeroTxBuf
   3141 0000F090 02 40 00 D1             	sw		r1,txBuf
   3142 0000F094 F1 BF                   	call	SetMsgAddr
   3143 0000F096 00 40 0D 11             	lw		r1,#MT_BASIC_EXIT
   3144 0000F09A 02 40 08 C1             	sb		r1,txBuf+MSG_TYPE
   3145 0000F09E 7C 4F 06 AF             	call	Xmit
   3146 0000F0A2 83 4F 01 AE             	jmp		WSTART
                                        
   3148 0000F0A6                        RequestOutputFocus:
   3149 0000F0A6 FE 6E                   	add		sp,sp,#-2
   3150 0000F0A8 E0 DF                   	sw		lr,[sp]
   3151 0000F0AA 7A 4F 09 AF             	call	zeroTxBuf
   3152 0000F0AE E4 BF                   	call	SetMsgAddr
   3153 0000F0B0 00 40 0F 11             	lw		r1,#MT_REQ_OUT_FOCUS
   3154 0000F0B4 02 40 08 C1             	sb		r1,txBuf+MSG_TYPE
   3155 0000F0B8 7B 4F 09 AF             	call	Xmit
   3156 0000F0BC                        ROF1:
   3157 0000F0BC 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   3158 0000F0C0 FD B8                   	beq		ROF1
   3159 0000F0C2 7D 4F 02 AF             	call	Recv
   3160 0000F0C6 10 40 0B AF             	call	RecvDispatch
   3161 0000F0CA 03 40 08 E1             	lb		r1,rxBuf+MSG_TYPE
   3162 0000F0CE FF 4F 10 10             	cmp		r1,#MT_GRNT_OUT_FOCUS
   3163 0000F0D2 F4 B9                   	bne		ROF1
   3164 0000F0D4 E0 FF                   	lw		lr,[sp]
   3165 0000F0D6 02 6E                   	add		sp,sp,#2
   3166 0000F0D8 F0 80                   	ret
                                        
                                        ;	MOVE.B	#228,D7 	return to Tutor
                                        ;	TRAP	#14
                                        
   3171 0000F0DA 0D 0A 42 75 74 74      msgInit db	CR,LF,"Butterfly Tiny BASIC v1.1",CR,LF,"(C) 2005-2017  Robert Finch",CR,LF,LF,0
   3171 0000F0E0 65 72 66 6C 79 20 54  
   3171 0000F0E7 69 6E 79 20 42 41 53  
   3171 0000F0EE 49 43 20 76 31 2E 31  
   3171 0000F0F5 0D 0A 28 43 29 20 32  
   3171 0000F0FC 30 30 35 2D 32 30 31  
   3171 0000F103 37 20 20 52 6F 62 65  
   3171 0000F10A 72 74 20 46 69 6E 63  
   3171 0000F111 68 0D 0A 0A 00        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 54
noc_boot31.a
   3172 0000F116 0D 0A 4F 4B 0D 0A      OKMSG	db	CR,LF,"OK",CR,LF,0
   3172 0000F11C 00                    
   3173 0000F11D 57 68 61 74 3F 0D      msgWhat	db	"What?",CR,LF,0
   3173 0000F123 0A 00                 
   3174 0000F125 53 6F 72 72 79 2E      SRYMSG	db	"Sorry."
                                      
   3175 0000F12B 0D 0A 00               CLMSG	db	CR,LF,0
   3176 0000F12E 43 6F 6D 70 61 63      msgReadError	db	"Compact FLASH read error",CR,LF,0
   3176 0000F134 74 20 46 4C 41 53 48  
   3176 0000F13B 20 72 65 61 64 20 65  
   3176 0000F142 72 72 6F 72 0D 0A 00  
                                      
   3177 0000F149 4E 75 6D 62 65 72      msgNumTooBig	db	"Number is too big",CR,LF,0
   3177 0000F14F 20 69 73 20 74 6F 6F  
   3177 0000F156 20 62 69 67 0D 0A 00  
                                      
   3178 0000F15D 44 69 76 69 73 69      msgDivZero		db	"Division by zero",CR,LF,0
   3178 0000F163 6F 6E 20 62 79 20 7A  
   3178 0000F16A 65 72 6F 0D 0A 00     
   3179 0000F170 4F 75 74 20 6F 66      msgVarSpace     db  "Out of variable space",CR,LF,0
   3179 0000F176 20 76 61 72 69 61 62  
   3179 0000F17D 6C 65 20 73 70 61 63  
   3179 0000F184 65 0D 0A 00           
   3180 0000F188 20 62 79 74 65 73      msgBytesFree	db	" bytes free",CR,LF,0
   3180 0000F18E 20 66 72 65 65 0D 0A  
   3180 0000F195 00                    
   3181 0000F196 0D 0A 52 65 61 64      msgReady		db	CR,LF,"Ready",CR,LF,0
   3181 0000F19C 79 0D 0A 00           
   3182 0000F1A0 45 78 70 65 63 74      msgComma		db	"Expecting a comma",CR,LF,0
   3182 0000F1A6 69 6E 67 20 61 20 63  
   3182 0000F1AD 6F 6D 6D 61 0D 0A 00  
                                      
   3183 0000F1B4 4C 69 6E 65 20 6E      msgLineRange	db	"Line number too big",CR,LF,0
   3183 0000F1BA 75 6D 62 65 72 20 74  
   3183 0000F1C1 6F 6F 20 62 69 67 0D  
   3183 0000F1C8 0A 00                 
   3184 0000F1CA 45 78 70 65 63 74      msgVar			db	"Expecting a variable",CR,LF,0
   3184 0000F1D0 69 6E 67 20 61 20 76  
   3184 0000F1D7 61 72 69 61 62 6C 65  
   3184 0000F1DE 0D 0A 00              
   3185 0000F1E1 52 4E 44 20 62 61      msgRNDBad		db	"RND bad parameter",CR,LF,0
   3185 0000F1E7 64 20 70 61 72 61 6D  
   3185 0000F1EE 65 74 65 72 0D 0A 00  
                                      
   3186 0000F1F5 53 59 53 20 62 61      msgSYSBad		db	"SYS bad address",CR,LF,0
   3186 0000F1FB 64 20 61 64 64 72 65  
   3186 0000F202 73 73 0D 0A 00        
   3187 0000F207 49 4E 50 55 54 20      msgInputVar		db	"INPUT expecting a variable",CR,LF,0
   3187 0000F20D 65 78 70 65 63 74 69  
   3187 0000F214 6E 67 20 61 20 76 61  
   3187 0000F21B 72 69 61 62 6C 65 0D  
   3187 0000F222 0A 00                 
   3188 0000F224 4E 45 58 54 20 77      msgNextFor		db	"NEXT without FOR",CR,LF,0
   3188 0000F22A 69 74 68 6F 75 74 20  
   3188 0000F231 46 4F 52 0D 0A 00     
   3189 0000F237 4E 45 58 54 20 65      msgNextVar		db	"NEXT expecting a defined variable",CR,LF,0
   3189 0000F23D 78 70 65 63 74 69 6E  
   3189 0000F244 67 20 61 20 64 65 66  
   3189 0000F24B 69 6E 65 64 20 76 61  
   3189 0000F252 72 69 61 62 6C 65 0D  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 55
noc_boot31.a
   3189 0000F259 0A 00                 
   3190 0000F25B 47 4F 54 4F 2F 47      msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LF,0
   3190 0000F261 4F 53 55 42 20 62 61  
   3190 0000F268 64 20 6C 69 6E 65 20  
   3190 0000F26F 6E 75 6D 62 65 72 0D  
   3190 0000F276 0A 00                 
   3191 0000F278 52 45 54 55 52 4E      msgRetWoGosub   db	"RETURN without GOSUB",CR,LF,0
   3191 0000F27E 20 77 69 74 68 6F 75  
   3191 0000F285 74 20 47 4F 53 55 42  
   3191 0000F28C 0D 0A 00              
   3192 0000F28F 50 72 6F 67 72 61      msgTooBig		db	"Program is too big",CR,LF,0
   3192 0000F295 6D 20 69 73 20 74 6F  
   3192 0000F29C 6F 20 62 69 67 0D 0A  
   3192 0000F2A3 00                    
   3193 0000F2A4 45 78 74 72 61 20      msgExtraChars	db	"Extra characters on line ignored",CR,LF,0
   3193 0000F2AA 63 68 61 72 61 63 74  
   3193 0000F2B1 65 72 73 20 6F 6E 20  
   3193 0000F2B8 6C 69 6E 65 20 69 67  
   3193 0000F2BF 6E 6F 72 65 64 0D 0A  
   3193 0000F2C6 00                    
                                        
   3195 0000F2C7 FF                      	.align	4
   3262 = 0000F2C8                      LSTROM	equ	*		; end of possible ROM area
                                        ;
                                        ; Internal variables follow:
                                        ;
                                        		bss
                                        ;		org		0x0030
   3202 00000014                        txtWidth	db	0		; BIOS var =60
   3203 00000015                        txtHeight	db	0		; BIOS var =27
   3204 00000016                        cursx	db		0		; cursor x position
   3205 00000017                        cursy	db		0		; cursor y position
   3206 00000018                        pos		dw		0		; text screen position
   3207 0000001A                        tgtNode	db		0
   3208 0000001B                        srcNode	db		0
                                        ;		org		0x0038
   3210 0000001C                        charToPrint		dw		0
   3211 0000001E                        fgColor			db		0
   3212 0000001F                        bkColor			db		0
   3213 00000020                        cursFlash		db		0	; flash the cursor ?
   3214 00000021                         				db		0
   3215 00000022                        NormAttr		dw		0
                                        
   3217 00000024                        lineLinkTbl		fill.b	25,0	; screen line link table
   3218 0000003D                         	align 4
                                        
                                        ;		org		0x0080
   3221 00000040                        typef   db      0   ; variable / expression type
   3222 00000041                                 align   4
   3223 00000044                        OSSP	dw	1	; OS value of sp
   3224 00000046                        CURRNT	dw	1	;	Current line pointer
   3225 00000048                        STKGOS	dw	1	;	Saves stack pointer in 'GOSUB'
   3226 0000004A                        STKINP	dw	1	;	Saves stack pointer during 'INPUT'
   3227 0000004C                        LOPVAR	dw	1	;	'FOR' loop save area
   3228 0000004E                        LOPINC	dw	1	;	increment
   3229 00000050                        LOPLMT	dw	1	;	limit
   3230 00000052                        LOPLN	dw	1	;	line number
   3231 00000054                        LOPPT	dw	1	;	text pointer
   3232 00000056                        TXTUNF	dw	1	;	points to unfilled text area
   3233 00000058                        VARBGN	dw	1	;	points to variable area
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 56
noc_boot31.a
   3234 0000005A                        IVARBGN dw  1   ;   points to integer variable area
   3235 0000005C                        SVARBGN dw  1   ;   points to string variable area
   3236 0000005E                        FVARBGN dw  1   ;   points to float variable area
   3237 00000060                        STKBOT	dw	1	;	holds lower limit for stack growth
   3238 00000062                        NUMWKA	fill.b	12,0			; numeric work area
   3239 0000006E                        BUFFER	fill.b	BUFLEN,0x00		;		Keyboard input buffer
                                        
                                                bss
                                                org     0x2000
   3243 00002000                        textScr1
                                                org     0x2000
                                        ;	END
                                        
                                        ; Operation of an ordinary (worker) node is pretty simple. It just waits in
                                        ; loop polling for recieved messages which are then dispatched.
                                        
                                        		.code
   3251 0000F2C8                        start:
   3252 0000F2C8 FF 41 0E 1E             		lw		sp,#$1FFE
   3253 0000F2CC 85 AF                   		call	ethInit
   3254 0000F2CE                        start2:
   3255 0000F2CE FF 41 0E 1E             		lw		sp,#$1FFE
   3256 0000F2D2                        noMsg1:
                                        		;call	ethPoll
   3258 0000F2D2 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
   3259 0000F2D6 FD B8                   		beq		noMsg1
   3260 0000F2D8 6C 4F 07 AF             		call	Recv
   3261 0000F2DC 01 AF                   		call	RecvDispatch
   3262 0000F2DE F7 BE                   		bra		start2
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receiver dispatch
                                        ;
                                        ; Executes different message handlers based on the message type.
                                        ;----------------------------------------------------------------------------
                                        
   3270 0000F2E0                        RecvDispatch:
   3271 0000F2E0 FC 6E                   		add		sp,sp,#-4
   3272 0000F2E2 E0 DF                   		sw		lr,[sp]
   3273 0000F2E4 E2 D1                   		sw		r1,2[sp]
   3274 0000F2E6 03 40 08 E1             		lb		r1,rxBuf+MSG_TYPE
   3275 0000F2EA 1F 10                   		cmp		r1,#MT_RST			; reset message ?
   3276 0000F2EC 0C A9                   		bne		RecvDispatch2
                                        		; Send back a reset ACK message to indicate node is good to go.
   3278 0000F2EE 68 4F 07 AF             		call	zeroTxBuf
   3279 0000F2F2 11 40 01 11             		lw		r1,#$111
   3280 0000F2F6 02 40 0E D1             		sw		r1,txBuf+MSG_DST
   3281 0000F2FA 02 11                   		lw		r1,#MT_RST_ACK
   3282 0000F2FC 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
   3283 0000F300 69 4F 05 AF             		call	Xmit
   3284 0000F304 65 AE                   		br		RecvDispatchXit
                                        
                                        		; Process PING request
   3287 0000F306                        RecvDispatch2:
   3288 0000F306 FF 4F 17 10             		cmp		r1,#MT_PING
   3289 0000F30A 03 A9                   		bne		RecvDispatch9
   3290 0000F30C 6C 4F 06 AF             		call	PingHandler
   3291 0000F310 5F AE                   		br		RecvDispatchXit
                                        
   3293 0000F312                        RecvDispatch9:
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 57
noc_boot31.a
   3294 0000F312 FF 4F 16 10             		cmp		r1,#MT_START_BASIC_LOAD	; start BASIC load
   3295 0000F316 07 A9                   		bne		RecvDispatch3
   3296 0000F318 03 40 0C E1             		lb		r1,rxBuf+MSG_SRC
   3297 0000F31C 6D 4F 0A AF             		call	INITTBW
   3298 0000F320 0D 4E 00 F8             		lw		r8,TXTBGN			; r8 = text begin
   3299 0000F324 55 AE                   		br		RecvDispatchXit
   3300 0000F326                        RecvDispatch3:
   3301 0000F326 FF 4F 15 10             		cmp		r1,#MT_LOAD_BASIC_CHAR	; load BASIC program char
   3302 0000F32A 0D A9                   		bne		RecvDispatch4
   3303 0000F32C 03 40 00 F1             		lw		r1,rxBuf
   3304 0000F330 80 D1                   		sw		r1,[r8]
   3305 0000F332 03 40 02 F1             		lw		r1,rxBuf+2
   3306 0000F336 82 D1                   		sw		r1,2[r8]
   3307 0000F338 03 40 04 F1             		lw		r1,rxBuf+4
   3308 0000F33C 84 D1                   		sw		r1,4[r8]
   3309 0000F33E 06 68                   		add		r8,r8,#6
   3310 0000F340 05 40 06 D8             		sw		r8,TXTUNF
   3311 0000F344 45 AE                   		br		RecvDispatchXit
   3312 0000F346                        RecvDispatch4:
                                        		; Run a BASIC program by stuffing a 'RUN' command into the BASIC
                                        		; buffer.
   3315 0000F346 FF 4F 14 10             		cmp		r1,#MT_RUN_BASIC_PROG
   3316 0000F34A 17 A9                   		bne		RecvDispatch5
   3317 0000F34C 05 40 02 11             		lw		r1,#'R'
   3318 0000F350 06 40 0E C1             		sb		r1,BUFFER
   3319 0000F354 05 40 05 11             		lw		r1,#'U'
   3320 0000F358 06 40 0F C1             		sb		r1,BUFFER+1
   3321 0000F35C 04 40 0E 11             		lw		r1,#'N'
   3322 0000F360 07 40 00 C1             		sb		r1,BUFFER+2
   3323 0000F364 00 40 0D 11             		lw		r1,#13
   3324 0000F368 07 40 01 C1             		sb		r1,BUFFER+3
   3325 0000F36C 07 40 02 C0             		sb		r0,BUFFER+4
   3326 0000F370 07 40 02 18             		lw		r8,#BUFFER+4
   3327 0000F374 6D 4F 03 AF             		call	ST3
   3328 0000F378 2B AE                   		br		RecvDispatchXit
                                        
                                        		; Load program code
   3331 0000F37A                        RecvDispatch5:
   3332 0000F37A FE 4F 19 10             		cmp		r1,#MT_LOAD_CODE
   3333 0000F37E 06 A9                   		bne		RecvDispatch6
   3334 0000F380 03 40 02 F1             		lw		r1,rxBuf+2
   3335 0000F384 03 40 04 F2             		lw		r2,rxBuf+4
   3336 0000F388 20 D1                   		sw		r1,[r2]
   3337 0000F38A 22 AE                   		br		RecvDispatchXit
                                        
                                        		; Load program data
   3340 0000F38C                        RecvDispatch6:
   3341 0000F38C FE 4F 18 10             		cmp		r1,#MT_LOAD_DATA
   3342 0000F390 06 A9                   		bne		RecvDispatch7
   3343 0000F392 03 40 02 F1             		lw		r1,rxBuf+2
   3344 0000F396 03 40 04 F2             		lw		r2,rxBuf+4
   3345 0000F39A 20 D1                   		sw		r1,[r2]
   3346 0000F39C 19 AE                   		br		RecvDispatchXit
                                        		; Load program code
                                        
                                        		; Execute program
   3350 0000F39E                        RecvDispatch7:
   3351 0000F39E FE 4F 17 10             		cmp		r1,#MT_EXEC_CODE
   3352 0000F3A2 FF B9                   		bne		RecvDispatch8
   3353 0000F3A4 03 40 0C F1             		lw		r1,rxBuf+MSG_SRC
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 58
noc_boot31.a
   3354 0000F3A8 FE 6E                   		add		sp,sp,#-2
   3355 0000F3AA E0 D1                   		sw		r1,[sp]
   3356 0000F3AC 03 40 04 F2             		lw		r2,rxBuf+4
   3357 0000F3B0 20 8F                   		call	[r2]
   3358 0000F3B2 E0 F2                   		lw		r2,[sp]
   3359 0000F3B4 02 6E                   		add		sp,sp,#2
   3360 0000F3B6 62 4F 03 AF             		call	zeroTxBuf
   3361 0000F3BA 02 40 02 D1             		sw		r1,txBuf+2
   3362 0000F3BE 02 40 0E D2             		sw		r2,txBuf+MSG_DST
   3363 0000F3C2 01 40 0A 11             		lw		r1,#MT_EXIT
   3364 0000F3C6 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
   3365 0000F3CA 63 4F 00 AF             		call	Xmit
   3366 0000F3CE 00 AE                   		br		RecvDispatchXit
                                        
   3368 0000F3D0                        RecvDispatchXit:
   3369 0000F3D0 E0 FF                   		lw		lr,[sp]
   3370 0000F3D2 E2 F1                   		lw		r1,2[sp]
   3371 0000F3D4 04 6E                   		add		sp,sp,#4
   3372 0000F3D6 F0 80                   		ret
                                        
                                        ;============================================================================
                                        ;============================================================================
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Initialize Ethernet controller.
                                        ;----------------------------------------------------------------------------
                                        
   3381 0000F3D8                        ethInit:
   3382 0000F3D8 00 4A 00 15             		lw		r5,#ETHERNET
   3383 0000F3DC 01 40 04 11             		lw		r1,#20				; MII clock divider (2.5MHz from 50MHz)
   3384 0000F3E0 02 40 58 D1             		sw		r1,ETH_MIIMODER[r5]	; 32 bit preamble
                                        
   3386 0000F3E4 01 40 00 D0             		sw		r0,unique_id
                                        
                                        		; Set the MAC address
   3389 0000F3E8 0F 40 0F 11             		lw		r1,#$00FF
   3390 0000F3EC 3E 4F 5C D1             		sw		r1,ETH_MAC_ADDR1[r5]
   3391 0000F3F0 EF 4E 00 11             		lw		r1,#$EEF0
   3392 0000F3F4 3F 4F 56 D1             		sw		r1,ETH_MAC_ADDR0+2[r5]
   3393 0000F3F8 A4 4D 02 11             		lw		r1,#$DA42
   3394 0000F3FC 3F 4F 5C D1             		sw		r1,ETH_MAC_ADDR0[r5]
                                        
                                        		; Set the PHY address
   3397 0000F400 01 11                   		lw		r1,#1				; this spec'd according to board
   3398 0000F402 03 40 50 C1             		sb		r1,ETH_MIIADDRESS[r5]
   3399 0000F406 01 11                   		lw		r1,#1				; select BMSR (status register)
   3400 0000F408 03 40 51 C1             		sb		r1,ETH_MIIADDRESS+1[r5]
                                        		; MII should not be busy here, we haven't issued a command yet.
   3402 0000F40C 00 12                   		lw		r2,#0
   3403 0000F40E                        ethInit1:
   3404 0000F40E 01 62                   		add		r2,r2,#1
   3405 0000F410 F9 4F 2C 10             		cmp		r2,#100
   3406 0000F414 3A A7                   		bgtu	ethInitErr
   3407 0000F416 03 40 5C F1             		lw		r1,ETH_MIISTATUS[r5]
   3408 0000F41A 52 31                   		and		r1,#2				; busy bit
   3409 0000F41C F8 B9                   		bne		ethInit1
                                        
   3411 0000F41E 02 11                   		lw		r1,#2				; read status
   3412 0000F420 02 40 5C C1             		sb		r1,ETH_MIICOMMAND[r5]
   3413 0000F424                        ethInit4:
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 59
noc_boot31.a
   3414 0000F424 04 11                   		lw		r1,#4
   3415 0000F426 10 40 01 12             		lw		r2,#$101				; auto-neg. advertise 100MBs full duplex
   3416 0000F42A 30 AF                   		call	ethWriteMII
                                        
   3418 0000F42C 00 11                   		lw		r1,#0					; perform software reset
   3419 0000F42E 00 48 00 12             		lw		r2,#$8000
   3420 0000F432 2C AF                   		call	ethWriteMII
                                        
   3422 0000F434 04 11                   		lw		r1,#4
   3423 0000F436 10 40 01 12             		lw		r2,#$101				; auto-neg. advertise 100MBs full duplex
   3424 0000F43A 28 AF                   		call	ethWriteMII
                                        
   3426 0000F43C 00 11                   		lw		r1,#0					; select register #0 (BMCR)
   3427 0000F43E 10 42 00 12             		lw		r2,#$2100				; select 100MBPs, full duplex
   3428 0000F442 24 AF                   		call	ethWriteMII
                                        
                                        		; For green ethernet
                                        		;
                                        		;	reg		data
                                        		;	31		$0003
                                        		;	25		$3247
                                        		;	16		$AC7C
                                        		;	31		$0000
   3437 0000F444 01 40 0F 11             		lw		r1,#31
   3438 0000F448 03 12                   		lw		r2,#3
   3439 0000F44A 20 AF                   		call	ethWriteMII
   3440 0000F44C 01 40 09 11             		lw		r1,#25
   3441 0000F450 24 43 06 F2             		lw		r2,$3247
   3442 0000F454 1B AF                   		call	ethWriteMII
   3443 0000F456 01 40 00 11             		lw		r1,#16
   3444 0000F45A C7 4A 0C 12             		lw		r2,#$AC7C
   3445 0000F45E 16 AF                   		call	ethWriteMII
   3446 0000F460 01 40 0F 11             		lw		r1,#31
   3447 0000F464 00 12                   		lw		r2,#0
   3448 0000F466 12 AF                   		call	ethWriteMII
                                        
                                        		; setup receive buffer descriptor
   3451 0000F468 00 46 00 11             		lw		r1,#eth_rxbuf		; set buffer address
   3452 0000F46C A0 40 54 D1             		sw		r1,$A04[r5]
   3453 0000F470 A0 40 56 D0             		sw		r0,$A06[r5]
   3454 0000F474 00 4A 00 11             		lw		r1,#$A000			; empty, wrap buffer
   3455 0000F478 A0 40 50 D1             		sw		r1,$A00[r5]
   3456 0000F47C 80 40 00 11             		lw		r1,#$0800
   3457 0000F480 A0 40 52 D1             		sw		r1,$A02[r5]
                                        
   3459 0000F484 02 4A 01 11             		lw		r1,#$A021			; enable recieve all frames
   3460 0000F488 50 D1                   		sw		r1,ETH_MODER[r5]
   3461 0000F48A                        ethInitErr:
   3462 0000F48A F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Write to an MII register.
                                        ;
                                        ; Parameters:
                                        ;	r1 = register address
                                        ;	r2 = data for register
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 60
noc_boot31.a
                                        ;----------------------------------------------------------------------------
                                        
   3476 0000F48C                        ethWriteMII:
   3477 0000F48C FA 6E                   		add		sp,sp,#-6
   3478 0000F48E E0 D3                   		sw		r3,[sp]
   3479 0000F490 E2 D5                   		sw		r5,2[sp]
   3480 0000F492 E4 D2                   		sw		r2,4[sp]
   3481 0000F494 00 4A 00 15             		lw		r5,#ETHERNET
   3482 0000F498 00 12                   		lw		r2,#0
   3483 0000F49A                        ethWriteMII1:
   3484 0000F49A 01 62                   		add		r2,r2,#1
   3485 0000F49C C1 4F 28 10             		cmp		r2,#1000
   3486 0000F4A0 0B A7                   		bgtu	ethWriteMIIErr
   3487 0000F4A2 03 40 5C E3             		lb		r3,ETH_MIISTATUS[r5]
   3488 0000F4A6 52 33                   		and		r3,#2				; busy bit
   3489 0000F4A8 F8 B9                   		bne		ethWriteMII1
   3490 0000F4AA 03 40 51 C1             		sb		r1,ETH_MIIADDRESS+1[r5]	; MII register number
   3491 0000F4AE 4A 4F 5E D2             		sw		r2,ETH_MIITX_DATA[r5]
   3492 0000F4B2 04 13                   		lw		r3,#4					; write control data
   3493 0000F4B4 02 40 5C C3             		sb		r3,ETH_MIICOMMAND[r5]
   3494 0000F4B8                        ethWriteMIIErr:
   3495 0000F4B8 E0 F3                   		lw		r3,[sp]
   3496 0000F4BA E2 F5                   		lw		r5,2[sp]
   3497 0000F4BC E4 F2                   		lw		r2,4[sp]
   3498 0000F4BE 06 6E                   		add		sp,sp,#6
   3499 0000F4C0 F0 80                   		ret
                                        
                                        
                                        ;----------------------------------------------------------------------------
                                        ;----------------------------------------------------------------------------
                                        ; Poll for ethernet packets and send them to node $11
                                        ;
   3506 0000F4C2                        ethPoll:
   3507 0000F4C2 FC 6E                   		add		sp,sp,#-4
   3508 0000F4C4 E0 DF                   		sw		lr,[sp]
   3509 0000F4C6 A0 40 50 F1             		lw		r1,$A00[r5]				; get BD status
   3510 0000F4CA 00 48 50 31             		and		r1,#$8000
                                        		bne		r1,r0,ethPoll3
   3512 0000F4CE 00 12                   		lw		r2,#0
   3513 0000F4D0 00 14                   		lw		r4,#0
   3514 0000F4D2 00 46 00 13             		lw		r3,#eth_rxbuf
   3515 0000F4D6                        ethPoll2:
   3516 0000F4D6 59 4F 03 AF             		call	zeroTxBuf
   3517 0000F4DA 30 15                   		mov		r5,r3
   3518 0000F4DC 40 25                   		add		r5,r4
   3519 0000F4DE 50 F1                   		lw		r1,[r5]
   3520 0000F4E0 02 40 02 D1             		sw		r1,txBuf+2
   3521 0000F4E4 02 40 04 D4             		sw		r4,txBuf+4
   3522 0000F4E8 11 40 01 11             		lw		r1,#$111
   3523 0000F4EC 02 40 0E D1             		sw		r1,txBuf+MSG_DST
   3524 0000F4F0 01 40 03 11             		lw		r1,#MT_ETH_PACKET
   3525 0000F4F4 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
   3526 0000F4F8 59 4F 09 AF             		call	Xmit
   3527 0000F4FC 02 64                   		add		r4,r4,#2
   3528 0000F4FE 01 62                   		add		r2,r2,#1
   3529 0000F500 80 4F 20 10             		cmp		r2,#2048
   3530 0000F504 E8 B4                   		bltu	ethPoll2
   3531 0000F506 3E AE                   		br		ethPoll4				; for now
   3532 0000F508 00 46 00 11             		lw		r1,#eth_rxbuf
   3533 0000F50C 47 AF                   		call	ethInterpretPacket
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 61
noc_boot31.a
   3534 0000F50E 1F 10                   		cmp		r1,#1
   3535 0000F510 39 A9                   		bne		ethPoll4
   3536 0000F512 00 46 00 11             		lw		r1,#eth_rxbuf
   3537 0000F516 EE AF                   		call	ethVerifyIP
   3538 0000F518 FF B8                   		beq		ethPoll5
   3539 0000F51A 00 46 00 11             		lw		r1,#eth_rxbuf
   3540 0000F51E 01 12                   		lw		r2,#1
   3541 0000F520 7F AF                   		call	ethBuildPacket
   3542 0000F522 10 1A                   		mov		r10,r1					; r10 = icmpstart
   3543 0000F524 00 46 00 14             		lw		r4,#eth_rxbuf
   3544 0000F528 A0 24                   		add		r4,r10
   3545 0000F52A 40 C0                   		sb		r0,[r4]
   3546 0000F52C 00 46 00 14             		lw		r4,#eth_rxbuf
   3547 0000F530 01 40 41 E5             		lb		r5,17[r4]				; r5 = len
   3548 0000F534 0E 65                   		add		r5,r5,#14
   3549 0000F536 00 46 00 14             		lw		r4,#eth_rxbuf
   3550 0000F53A A0 24                   		add		r4,r10
   3551 0000F53C 42 EB                   		lb		r11,2[r4]
   3552 0000F53E 43 EC                   		lb		r12,3[r4]
   3553 0000F540 C0 16                   		mov		r6,r12
   3554 0000F542 81 3B                   		shl		r11,#1
   3555 0000F544 81 3B                   		shl		r11,#1
   3556 0000F546 81 3B                   		shl		r11,#1
   3557 0000F548 81 3B                   		shl		r11,#1
   3558 0000F54A 81 3B                   		shl		r11,#1
   3559 0000F54C 81 3B                   		shl		r11,#1
   3560 0000F54E 81 3B                   		shl		r11,#1
   3561 0000F550 81 3B                   		shl		r11,#1
   3562 0000F552 B6 26                   		or		r6,r11
   3563 0000F554 4F 36                   		xor		r6,#-1
   3564 0000F556 80 4F 60 16             		sub		r6,r6,#$800
   3565 0000F55A 4F 36                   		xor		r6,#-1
   3566 0000F55C 43 C6                   		sb		r6,3[r4]
   3567 0000F55E A1 36                   		shr		r6,#1
   3568 0000F560 A1 36                   		shr		r6,#1
   3569 0000F562 A1 36                   		shr		r6,#1
   3570 0000F564 A1 36                   		shr		r6,#1
   3571 0000F566 A1 36                   		shr		r6,#1
   3572 0000F568 A1 36                   		shr		r6,#1
   3573 0000F56A A1 36                   		shr		r6,#1
   3574 0000F56C A1 36                   		shr		r6,#1
   3575 0000F56E 42 C6                   		sb		r6,2[r4]
   3576 0000F570 00 46 00 11             		lw		r1,#eth_rxbuf
   3577 0000F574 A0 12                   		mov		r2,r10					; r2= icmpstart
   3578 0000F576 92 AF                   		call	ethChecksum
   3579 0000F578 00 46 00 F1             		lw		r1,eth_rxbuf
   3580 0000F57C 00 44 00 F2             		lw		r2,eth_txbuf
   3581 0000F580 50 13                   		mov		r3,r5					; r3 = len
   3582 0000F582 29 AF                   		call	ethSendPacket
                                        		;br
   3584 0000F584                        ethPoll4:
   3585 0000F584 1E 10                   		cmp		r1,#2
                                        
   3587 0000F586 00 4A 00 11             		lw		r1,#$A000				; empty, wrap buffer
   3588 0000F58A A0 40 50 D1             		sw		r1,$A00[r5]
   3589 0000F58E 80 40 00 11             		lw		r1,#$0800
   3590 0000F592 A0 40 52 D1             		sw		r1,$A02[r5]
   3591 0000F596                        ethPoll3:
   3592 0000F596 E0 FF                   		lw		lr,[sp]
   3593 0000F598 04 6E                   		add		sp,sp,#4
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 62
noc_boot31.a
   3594 0000F59A F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Detect what type of packet is received.
                                        ;----------------------------------------------------------------------------
                                        
   3600 0000F59C                        ethInterpretPacket:
   3601 0000F59C 10 12                   		mov		r2,r1
   3602 0000F59E 00 40 2C F1             		lw		r1,12[r2]
   3603 0000F5A2 9F 4F 18 10             		cmp		r1,#$0608				; 806 = ARP (big endian words)
   3604 0000F5A6 02 A9                   		bne		ethInterpretPacket1
   3605 0000F5A8 02 11                   		lw		r1,#2
   3606 0000F5AA F0 80                   		ret
   3607 0000F5AC                        ethInterpretPacket1:
   3608 0000F5AC FF 4F 18 10             		cmp		r1,#$0008				; 800 = IP protocol
   3609 0000F5B0 0A A9                   		bne		ethInterpretPacket2
   3610 0000F5B2 01 40 27 E1             		lb		r1,23[r2]
   3611 0000F5B6 1F 10                   		cmp		r1,#1
   3612 0000F5B8 08 A8                   		beq		ethInterpretPacketICMP
   3613 0000F5BA FE 4F 1F 10             		cmp		r1,#$11
   3614 0000F5BE 07 A8                   		beq		ethInterpretPacketUDP
   3615 0000F5C0 FF 4F 1A 10             		cmp		r1,#$06
   3616 0000F5C4 06 A8                   		beq		ethInterpretPacketTCP
   3617 0000F5C6                        ethInterpretPacket2:
   3618 0000F5C6 00 11                   		lw		r1,#0
   3619 0000F5C8 F0 80                   		ret
   3620 0000F5CA                        ethInterpretPacketICMP:
   3621 0000F5CA 01 11                   		lw		r1,#1;
   3622 0000F5CC F0 80                   		ret
   3623 0000F5CE                        ethInterpretPacketUDP:
   3624 0000F5CE 03 11                   		lw		r1,#3
   3625 0000F5D0 F0 80                   		ret
   3626 0000F5D2                        ethInterpretPacketTCP:
   3627 0000F5D2 04 11                   		lw		r1,#4
   3628 0000F5D4 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ;
                                        ;----------------------------------------------------------------------------
                                        
   3634 0000F5D6                        ethSendPacket:
   3635 0000F5D6                        ethSendPacket1:
   3636 0000F5D6 80 4A 00 F1             		lw		r1,ETHERNET+$800
   3637 0000F5DA 00 48 50 31             		and		r1,#$8000			; wait for ready bit = 0
   3638 0000F5DE FB B9                   		bne		ethSendPacket1
   3639 0000F5E0 00 46 00 12             		lw		r2,#eth_rxbuf
   3640 0000F5E4 00 44 00 13             		lw		r3,#eth_txbuf
   3641 0000F5E8 80 40 00 14             		lw		r4,#$800
                                        		; Copy receive buffer to transmit buffer
   3643 0000F5EC                        ethSendPacket2:
   3644 0000F5EC 20 F1                   		lw		r1,[r2]
   3645 0000F5EE 30 D1                   		sw		r1,[r3]
   3646 0000F5F0 FE 64                   		sub		r4,r4,#2
   3647 0000F5F2 FC BB                   		bpl		ethSendPacket2
   3648 0000F5F4 01 11                   		lw		r1,#1				; clear transmit interrupt
   3649 0000F5F6 00 4A 04 C1             		sb		r1,ETHERNET+ETH_INT_SOURCE
   3650 0000F5FA 00 44 00 11             		lw		r1,#eth_txbuf
   3651 0000F5FE 80 4A 04 D1             		sw		r1,ETHERNET+$804	; set buffer address in TxBD
   3652 0000F602 80 4A 06 D0             		sw		r0,ETHERNET+$806
   3653 0000F606 80 40 00 11             		lw		r1,#$0800
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 63
noc_boot31.a
   3654 0000F60A 80 4A 02 D1             		sw		r1,ETHERNET+$802	; set packet length
   3655 0000F60E 00 4F 00 11             		lw		r1,#$F000
   3656 0000F612 80 4A 00 D1             		sw		r1,ETHERNET+$800	; 
   3657 0000F616                        ethSendPacket3:
   3658 0000F616 00 4A 04 F1             		lw		r1,ETHERNET+ETH_INT_SOURCE
   3659 0000F61A 51 31                   		and		r1,#1
   3660 0000F61C FC B8                   		beq		ethSendPacket3
   3661 0000F61E F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ;----------------------------------------------------------------------------
                                        
   3666 0000F620                        ethBuildPacket:
   3667 0000F620 10 14                   		mov		r4,r1
   3668 0000F622 20 15                   		mov		r5,r2
                                        		; Read MAC address of source and copy to destination field
   3670 0000F624 46 F1                   		lw		r1,6[r4]
   3671 0000F626 48 F2                   		lw		r2,8[r4]
   3672 0000F628 4A F3                   		lw		r3,10[r4]
   3673 0000F62A 40 D1                   		sw		r1,[r4]
   3674 0000F62C 42 D2                   		sw		r2,2[r4]
   3675 0000F62E 44 D3                   		sw		r3,4[r4]
                                        		; Write MAC address to source field
   3677 0000F630 F0 4F 00 11             		lw		r1,#$FF00
   3678 0000F634 0E 4F 0E 12             		lw		r2,#$F0EE
   3679 0000F638 2D 44 0A 13             		lw		r3,#$42DA
   3680 0000F63C 46 D1                   		sw		r1,6[r4]
   3681 0000F63E 48 D2                   		sw		r2,8[r4]
   3682 0000F640 4A D3                   		sw		r3,10[r4]
                                        		; If swap IP address
   3684 0000F642 56 25                   		or		r5,r5
   3685 0000F644 10 A8                   		beq		ethBuildPacket1
   3686 0000F646 01 40 4A F1             		lw		r1,26[r4]
   3687 0000F64A 01 40 4C F2             		lw		r2,28[r4]
   3688 0000F64E 01 40 4E F6             		lw		r6,30[r4]
   3689 0000F652 02 40 40 F7             		lw		r7,32[r4]
   3690 0000F656 01 40 4A D6             		sw		r6,26[r4]
   3691 0000F65A 01 40 4C D7             		sw		r7,28[r4]
   3692 0000F65E 01 40 4E D1             		sw		r1,30[r4]
   3693 0000F662 02 40 40 D2             		sw		r2,32[r4]
   3694 0000F666                        ethBuildPacket1:
   3695 0000F666 01 40 00 F1             		lw		r1,unique_id
   3696 0000F66A 01 61                   		add		r1,r1,#1
   3697 0000F66C 01 40 00 D1             		sw		r1,unique_id
   3698 0000F670 01 40 43 C1             		sb		r1,19[r4]
   3699 0000F674 A1 31                   		shr		r1,#1
   3700 0000F676 A1 31                   		shr		r1,#1
   3701 0000F678 A1 31                   		shr		r1,#1
   3702 0000F67A A1 31                   		shr		r1,#1
   3703 0000F67C A1 31                   		shr		r1,#1
   3704 0000F67E A1 31                   		shr		r1,#1
   3705 0000F680 A1 31                   		shr		r1,#1
   3706 0000F682 A1 31                   		shr		r1,#1
   3707 0000F684 01 40 42 C1             		sb		r1,18[r4]
                                        
                                        		; Get number of bytes in IP header
   3710 0000F688 00 40 4E E1             		lb		r1,14[r4]	; 
   3711 0000F68C 00 40 5F 31             		and		r1,#$F
   3712 0000F690 81 31                   		shl		r1,#1		; *4
   3713 0000F692 81 31                   		shl		r1,#1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 64
noc_boot31.a
   3714 0000F694 0E 61                   		add		r1,#14
   3715 0000F696 69 4F 06 D1             		sw		r1,data_start
   3716 0000F69A F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Compute checksum and insert into buffer
                                        ;
                                        ; Parameters:
                                        ;	r1 = buffer address
                                        ;	r2 = start of data
                                        ;----------------------------------------------------------------------------
                                        
   3726 0000F69C                        ethChecksum:
   3727 0000F69C 10 14                   		mov		r4,r1
   3728 0000F69E 20 15                   		mov		r5,r2
   3729 0000F6A0 01 40 48 D0             		sw		r0,24[r4]
   3730 0000F6A4 00 16                   		lw		r6,#0		; r6 = sum
   3731 0000F6A6 00 1B                   		lw		r11,#0		; r11 = sum[31:16]
   3732 0000F6A8 00 40 0E 17             		lw		r7,#14
   3733 0000F6AC FF 65                   		sub		r5,r5,#1	; r5 = data_start - 1
   3734 0000F6AE                        ethChecksum2:
   3735 0000F6AE 5D 27                   		cmp		r7,r5
   3736 0000F6B0 12 A1                   		bge		ethChecksum1
   3737 0000F6B2 40 18                   		mov		r8,r4
   3738 0000F6B4 70 28                   		add		r8,r7
   3739 0000F6B6 80 E9                   		lb		r9,[r8]		; r9 = shi
   3740 0000F6B8 81 EA                   		lb		r10,1[r8]	; r10 = slo
   3741 0000F6BA 0E 2A                   		zxb		r10
   3742 0000F6BC 81 39                   		shl		r9,#1
   3743 0000F6BE 81 39                   		shl		r9,#1
   3744 0000F6C0 81 39                   		shl		r9,#1
   3745 0000F6C2 81 39                   		shl		r9,#1
   3746 0000F6C4 81 39                   		shl		r9,#1
   3747 0000F6C6 81 39                   		shl		r9,#1
   3748 0000F6C8 81 39                   		shl		r9,#1
   3749 0000F6CA 81 39                   		shl		r9,#1
   3750 0000F6CC 96 2A                   		or		r10,r9
   3751 0000F6CE A0 26                   		add		r6,r10		; sum = sum + ((shi<<8)|slo)
   3752 0000F6D0 10 3B                   		adc		r11,#0
   3753 0000F6D2 02 67                   		add		r7,r7,#2
   3754 0000F6D4 EC BE                   		br		ethChecksum2
   3755 0000F6D6                        ethChecksum1:
                                        		; add overflow bits (upper 16) to lower 16
   3757 0000F6D6 B0 26                   		add		r6,r11
   3758 0000F6D8 4F 36                   		xor		r6,#-1		; sum = ~sum
   3759 0000F6DA 01 40 49 C6             		sb		r6,25[r4]
   3760 0000F6DE A1 36                   		shr		r6,#1
   3761 0000F6E0 A1 36                   		shr		r6,#1
   3762 0000F6E2 A1 36                   		shr		r6,#1
   3763 0000F6E4 A1 36                   		shr		r6,#1
   3764 0000F6E6 A1 36                   		shr		r6,#1
   3765 0000F6E8 A1 36                   		shr		r6,#1
   3766 0000F6EA A1 36                   		shr		r6,#1
   3767 0000F6EC A1 36                   		shr		r6,#1
   3768 0000F6EE 01 40 48 C6             		sb		r6,24[r4]
   3769 0000F6F2 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Verify that the IP address is either a general broadcast address, or it
                                        ; matches our IP address.
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 65
noc_boot31.a
                                        ;
                                        ; Parameters:
                                        ;	r1 = pointer to receive buffer
                                        ; Returns:
                                        ;	r1 = 1 if IP matches, 0 if no match
                                        ;----------------------------------------------------------------------------
                                        
   3781 0000F6F4                        ethVerifyIP:
   3782 0000F6F4 10 15                   		mov		r5,r1
   3783 0000F6F6 01 40 5E E1             		lb		r1,30[r5]
   3784 0000F6FA 01 40 5F E2             		lb		r2,31[r5]
   3785 0000F6FE 02 40 50 E3             		lb		r3,32[r5]
   3786 0000F702 02 40 51 E4             		lb		r4,33[r5]
   3787 0000F706 81 33                   		shl		r3,#1
   3788 0000F708 81 33                   		shl		r3,#1
   3789 0000F70A 81 33                   		shl		r3,#1
   3790 0000F70C 81 33                   		shl		r3,#1
   3791 0000F70E 81 33                   		shl		r3,#1
   3792 0000F710 81 33                   		shl		r3,#1
   3793 0000F712 81 33                   		shl		r3,#1
   3794 0000F714 81 33                   		shl		r3,#1
   3795 0000F716 46 23                   		or		r3,r4
   3796 0000F718 81 31                   		shl		r1,#1
   3797 0000F71A 81 31                   		shl		r1,#1
   3798 0000F71C 81 31                   		shl		r1,#1
   3799 0000F71E 81 31                   		shl		r1,#1
   3800 0000F720 81 31                   		shl		r1,#1
   3801 0000F722 81 31                   		shl		r1,#1
   3802 0000F724 81 31                   		shl		r1,#1
   3803 0000F726 81 31                   		shl		r1,#1
   3804 0000F728 26 21                   		or		r1,r2
   3805 0000F72A 00 40 11 10             		cmp		r1,#$FFFF
   3806 0000F72E 03 A9                   		bne		ethVerifyIP2
   3807 0000F730 00 40 31 10             		cmp		r3,#$FFFF
   3808 0000F734 06 A8                   		beq		ethVerifyIP3
   3809 0000F736                        ethVerifyIP2:
   3810 0000F736 F5 43 18 10             		cmp		r1,#$C0A8		; 192.168.
   3811 0000F73A 05 A9                   		bne		ethVerifyIP1
   3812 0000F73C ED 4F 36 10             		cmp		r3,#$012A		; 1.42
   3813 0000F740 02 A9                   		bne		ethVerifyIP1
   3814 0000F742                        ethVerifyIP3:
   3815 0000F742 01 11                   		lw		r1,#1
   3816 0000F744 F0 80                   		ret
   3817 0000F746                        ethVerifyIP1:
   3818 0000F746 00 11                   		lw		r1,#0
   3819 0000F748 F0 80                   		ret
                                        
   3821 0000F74A FF FF FF FF FF FF FF    		org		0xFFFE
   3821 0000F751 FF FF FF FF FF FF FF  
   3821 0000F758 FF FF FF FF FF FF FF  
   3821 0000F75F FF FF FF FF FF FF FF  
   3821 0000F766 FF FF FF FF FF FF FF  
   3821 0000F76D FF FF FF FF FF FF FF  
   3821 0000F774 FF FF FF FF FF FF FF  
   3821 0000F77B FF FF FF FF FF FF FF  
   3821 0000F782 FF FF FF FF FF FF FF  
   3821 0000F789 FF FF FF FF FF FF FF  
   3821 0000F790 FF FF FF FF FF FF FF  
   3821 0000F797 FF FF FF FF FF FF FF  
   3821 0000F79E FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 66
noc_boot31.a
   3821 0000F7A5 FF FF FF FF FF FF FF  
   3821 0000F7AC FF FF FF FF FF FF FF  
   3821 0000F7B3 FF FF FF FF FF FF FF  
   3821 0000F7BA FF FF FF FF FF FF FF  
   3821 0000F7C1 FF FF FF FF FF FF FF  
   3821 0000F7C8 FF FF FF FF FF FF FF  
   3821 0000F7CF FF FF FF FF FF FF FF  
   3821 0000F7D6 FF FF FF FF FF FF FF  
   3821 0000F7DD FF FF FF FF FF FF FF  
   3821 0000F7E4 FF FF FF FF FF FF FF  
   3821 0000F7EB FF FF FF FF FF FF FF  
   3821 0000F7F2 FF FF FF FF FF FF FF  
   3821 0000F7F9 FF FF FF FF FF FF FF  
   3821 0000F800 FF FF FF FF FF FF FF  
   3821 0000F807 FF FF FF FF FF FF FF  
   3821 0000F80E FF FF FF FF FF FF FF  
   3821 0000F815 FF FF FF FF FF FF FF  
   3821 0000F81C FF FF FF FF FF FF FF  
   3821 0000F823 FF FF FF FF FF FF FF  
   3821 0000F82A FF FF FF FF FF FF FF  
   3821 0000F831 FF FF FF FF FF FF FF  
   3821 0000F838 FF FF FF FF FF FF FF  
   3821 0000F83F FF FF FF FF FF FF FF  
   3821 0000F846 FF FF FF FF FF FF FF  
   3821 0000F84D FF FF FF FF FF FF FF  
   3821 0000F854 FF FF FF FF FF FF FF  
   3821 0000F85B FF FF FF FF FF FF FF  
   3821 0000F862 FF FF FF FF FF FF FF  
   3821 0000F869 FF FF FF FF FF FF FF  
   3821 0000F870 FF FF FF FF FF FF FF  
   3821 0000F877 FF FF FF FF FF FF FF  
   3821 0000F87E FF FF FF FF FF FF FF  
   3821 0000F885 FF FF FF FF FF FF FF  
   3821 0000F88C FF FF FF FF FF FF FF  
   3821 0000F893 FF FF FF FF FF FF FF  
   3821 0000F89A FF FF FF FF FF FF FF  
   3821 0000F8A1 FF FF FF FF FF FF FF  
   3821 0000F8A8 FF FF FF FF FF FF FF  
   3821 0000F8AF FF FF FF FF FF FF FF  
   3821 0000F8B6 FF FF FF FF FF FF FF  
   3821 0000F8BD FF FF FF FF FF FF FF  
   3821 0000F8C4 FF FF FF FF FF FF FF  
   3821 0000F8CB FF FF FF FF FF FF FF  
   3821 0000F8D2 FF FF FF FF FF FF FF  
   3821 0000F8D9 FF FF FF FF FF FF FF  
   3821 0000F8E0 FF FF FF FF FF FF FF  
   3821 0000F8E7 FF FF FF FF FF FF FF  
   3821 0000F8EE FF FF FF FF FF FF FF  
   3821 0000F8F5 FF FF FF FF FF FF FF  
   3821 0000F8FC FF FF FF FF FF FF FF  
   3821 0000F903 FF FF FF FF FF FF FF  
   3821 0000F90A FF FF FF FF FF FF FF  
   3821 0000F911 FF FF FF FF FF FF FF  
   3821 0000F918 FF FF FF FF FF FF FF  
   3821 0000F91F FF FF FF FF FF FF FF  
   3821 0000F926 FF FF FF FF FF FF FF  
   3821 0000F92D FF FF FF FF FF FF FF  
   3821 0000F934 FF FF FF FF FF FF FF  
   3821 0000F93B FF FF FF FF FF FF FF  
   3821 0000F942 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 67
noc_boot31.a
   3821 0000F949 FF FF FF FF FF FF FF  
   3821 0000F950 FF FF FF FF FF FF FF  
   3821 0000F957 FF FF FF FF FF FF FF  
   3821 0000F95E FF FF FF FF FF FF FF  
   3821 0000F965 FF FF FF FF FF FF FF  
   3821 0000F96C FF FF FF FF FF FF FF  
   3821 0000F973 FF FF FF FF FF FF FF  
   3821 0000F97A FF FF FF FF FF FF FF  
   3821 0000F981 FF FF FF FF FF FF FF  
   3821 0000F988 FF FF FF FF FF FF FF  
   3821 0000F98F FF FF FF FF FF FF FF  
   3821 0000F996 FF FF FF FF FF FF FF  
   3821 0000F99D FF FF FF FF FF FF FF  
   3821 0000F9A4 FF FF FF FF FF FF FF  
   3821 0000F9AB FF FF FF FF FF FF FF  
   3821 0000F9B2 FF FF FF FF FF FF FF  
   3821 0000F9B9 FF FF FF FF FF FF FF  
   3821 0000F9C0 FF FF FF FF FF FF FF  
   3821 0000F9C7 FF FF FF FF FF FF FF  
   3821 0000F9CE FF FF FF FF FF FF FF  
   3821 0000F9D5 FF FF FF FF FF FF FF  
   3821 0000F9DC FF FF FF FF FF FF FF  
   3821 0000F9E3 FF FF FF FF FF FF FF  
   3821 0000F9EA FF FF FF FF FF FF FF  
   3821 0000F9F1 FF FF FF FF FF FF FF  
   3821 0000F9F8 FF FF FF FF FF FF FF  
   3821 0000F9FF FF FF FF FF FF FF FF  
   3821 0000FA06 FF FF FF FF FF FF FF  
   3821 0000FA0D FF FF FF FF FF FF FF  
   3821 0000FA14 FF FF FF FF FF FF FF  
   3821 0000FA1B FF FF FF FF FF FF FF  
   3821 0000FA22 FF FF FF FF FF FF FF  
   3821 0000FA29 FF FF FF FF FF FF FF  
   3821 0000FA30 FF FF FF FF FF FF FF  
   3821 0000FA37 FF FF FF FF FF FF FF  
   3821 0000FA3E FF FF FF FF FF FF FF  
   3821 0000FA45 FF FF FF FF FF FF FF  
   3821 0000FA4C FF FF FF FF FF FF FF  
   3821 0000FA53 FF FF FF FF FF FF FF  
   3821 0000FA5A FF FF FF FF FF FF FF  
   3821 0000FA61 FF FF FF FF FF FF FF  
   3821 0000FA68 FF FF FF FF FF FF FF  
   3821 0000FA6F FF FF FF FF FF FF FF  
   3821 0000FA76 FF FF FF FF FF FF FF  
   3821 0000FA7D FF FF FF FF FF FF FF  
   3821 0000FA84 FF FF FF FF FF FF FF  
   3821 0000FA8B FF FF FF FF FF FF FF  
   3821 0000FA92 FF FF FF FF FF FF FF  
   3821 0000FA99 FF FF FF FF FF FF FF  
   3821 0000FAA0 FF FF FF FF FF FF FF  
   3821 0000FAA7 FF FF FF FF FF FF FF  
   3821 0000FAAE FF FF FF FF FF FF FF  
   3821 0000FAB5 FF FF FF FF FF FF FF  
   3821 0000FABC FF FF FF FF FF FF FF  
   3821 0000FAC3 FF FF FF FF FF FF FF  
   3821 0000FACA FF FF FF FF FF FF FF  
   3821 0000FAD1 FF FF FF FF FF FF FF  
   3821 0000FAD8 FF FF FF FF FF FF FF  
   3821 0000FADF FF FF FF FF FF FF FF  
   3821 0000FAE6 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 68
noc_boot31.a
   3821 0000FAED FF FF FF FF FF FF FF  
   3821 0000FAF4 FF FF FF FF FF FF FF  
   3821 0000FAFB FF FF FF FF FF FF FF  
   3821 0000FB02 FF FF FF FF FF FF FF  
   3821 0000FB09 FF FF FF FF FF FF FF  
   3821 0000FB10 FF FF FF FF FF FF FF  
   3821 0000FB17 FF FF FF FF FF FF FF  
   3821 0000FB1E FF FF FF FF FF FF FF  
   3821 0000FB25 FF FF FF FF FF FF FF  
   3821 0000FB2C FF FF FF FF FF FF FF  
   3821 0000FB33 FF FF FF FF FF FF FF  
   3821 0000FB3A FF FF FF FF FF FF FF  
   3821 0000FB41 FF FF FF FF FF FF FF  
   3821 0000FB48 FF FF FF FF FF FF FF  
   3821 0000FB4F FF FF FF FF FF FF FF  
   3821 0000FB56 FF FF FF FF FF FF FF  
   3821 0000FB5D FF FF FF FF FF FF FF  
   3821 0000FB64 FF FF FF FF FF FF FF  
   3821 0000FB6B FF FF FF FF FF FF FF  
   3821 0000FB72 FF FF FF FF FF FF FF  
   3821 0000FB79 FF FF FF FF FF FF FF  
   3821 0000FB80 FF FF FF FF FF FF FF  
   3821 0000FB87 FF FF FF FF FF FF FF  
   3821 0000FB8E FF FF FF FF FF FF FF  
   3821 0000FB95 FF FF FF FF FF FF FF  
   3821 0000FB9C FF FF FF FF FF FF FF  
   3821 0000FBA3 FF FF FF FF FF FF FF  
   3821 0000FBAA FF FF FF FF FF FF FF  
   3821 0000FBB1 FF FF FF FF FF FF FF  
   3821 0000FBB8 FF FF FF FF FF FF FF  
   3821 0000FBBF FF FF FF FF FF FF FF  
   3821 0000FBC6 FF FF FF FF FF FF FF  
   3821 0000FBCD FF FF FF FF FF FF FF  
   3821 0000FBD4 FF FF FF FF FF FF FF  
   3821 0000FBDB FF FF FF FF FF FF FF  
   3821 0000FBE2 FF FF FF FF FF FF FF  
   3821 0000FBE9 FF FF FF FF FF FF FF  
   3821 0000FBF0 FF FF FF FF FF FF FF  
   3821 0000FBF7 FF FF FF FF FF FF FF  
   3821 0000FBFE FF FF FF FF FF FF FF  
   3821 0000FC05 FF FF FF FF FF FF FF  
   3821 0000FC0C FF FF FF FF FF FF FF  
   3821 0000FC13 FF FF FF FF FF FF FF  
   3821 0000FC1A FF FF FF FF FF FF FF  
   3821 0000FC21 FF FF FF FF FF FF FF  
   3821 0000FC28 FF FF FF FF FF FF FF  
   3821 0000FC2F FF FF FF FF FF FF FF  
   3821 0000FC36 FF FF FF FF FF FF FF  
   3821 0000FC3D FF FF FF FF FF FF FF  
   3821 0000FC44 FF FF FF FF FF FF FF  
   3821 0000FC4B FF FF FF FF FF FF FF  
   3821 0000FC52 FF FF FF FF FF FF FF  
   3821 0000FC59 FF FF FF FF FF FF FF  
   3821 0000FC60 FF FF FF FF FF FF FF  
   3821 0000FC67 FF FF FF FF FF FF FF  
   3821 0000FC6E FF FF FF FF FF FF FF  
   3821 0000FC75 FF FF FF FF FF FF FF  
   3821 0000FC7C FF FF FF FF FF FF FF  
   3821 0000FC83 FF FF FF FF FF FF FF  
   3821 0000FC8A FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 69
noc_boot31.a
   3821 0000FC91 FF FF FF FF FF FF FF  
   3821 0000FC98 FF FF FF FF FF FF FF  
   3821 0000FC9F FF FF FF FF FF FF FF  
   3821 0000FCA6 FF FF FF FF FF FF FF  
   3821 0000FCAD FF FF FF FF FF FF FF  
   3821 0000FCB4 FF FF FF FF FF FF FF  
   3821 0000FCBB FF FF FF FF FF FF FF  
   3821 0000FCC2 FF FF FF FF FF FF FF  
   3821 0000FCC9 FF FF FF FF FF FF FF  
   3821 0000FCD0 FF FF FF FF FF FF FF  
   3821 0000FCD7 FF FF FF FF FF FF FF  
   3821 0000FCDE FF FF FF FF FF FF FF  
   3821 0000FCE5 FF FF FF FF FF FF FF  
   3821 0000FCEC FF FF FF FF FF FF FF  
   3821 0000FCF3 FF FF FF FF FF FF FF  
   3821 0000FCFA FF FF FF FF FF FF FF  
   3821 0000FD01 FF FF FF FF FF FF FF  
   3821 0000FD08 FF FF FF FF FF FF FF  
   3821 0000FD0F FF FF FF FF FF FF FF  
   3821 0000FD16 FF FF FF FF FF FF FF  
   3821 0000FD1D FF FF FF FF FF FF FF  
   3821 0000FD24 FF FF FF FF FF FF FF  
   3821 0000FD2B FF FF FF FF FF FF FF  
   3821 0000FD32 FF FF FF FF FF FF FF  
   3821 0000FD39 FF FF FF FF FF FF FF  
   3821 0000FD40 FF FF FF FF FF FF FF  
   3821 0000FD47 FF FF FF FF FF FF FF  
   3821 0000FD4E FF FF FF FF FF FF FF  
   3821 0000FD55 FF FF FF FF FF FF FF  
   3821 0000FD5C FF FF FF FF FF FF FF  
   3821 0000FD63 FF FF FF FF FF FF FF  
   3821 0000FD6A FF FF FF FF FF FF FF  
   3821 0000FD71 FF FF FF FF FF FF FF  
   3821 0000FD78 FF FF FF FF FF FF FF  
   3821 0000FD7F FF FF FF FF FF FF FF  
   3821 0000FD86 FF FF FF FF FF FF FF  
   3821 0000FD8D FF FF FF FF FF FF FF  
   3821 0000FD94 FF FF FF FF FF FF FF  
   3821 0000FD9B FF FF FF FF FF FF FF  
   3821 0000FDA2 FF FF FF FF FF FF FF  
   3821 0000FDA9 FF FF FF FF FF FF FF  
   3821 0000FDB0 FF FF FF FF FF FF FF  
   3821 0000FDB7 FF FF FF FF FF FF FF  
   3821 0000FDBE FF FF FF FF FF FF FF  
   3821 0000FDC5 FF FF FF FF FF FF FF  
   3821 0000FDCC FF FF FF FF FF FF FF  
   3821 0000FDD3 FF FF FF FF FF FF FF  
   3821 0000FDDA FF FF FF FF FF FF FF  
   3821 0000FDE1 FF FF FF FF FF FF FF  
   3821 0000FDE8 FF FF FF FF FF FF FF  
   3821 0000FDEF FF FF FF FF FF FF FF  
   3821 0000FDF6 FF FF FF FF FF FF FF  
   3821 0000FDFD FF FF FF FF FF FF FF  
   3821 0000FE04 FF FF FF FF FF FF FF  
   3821 0000FE0B FF FF FF FF FF FF FF  
   3821 0000FE12 FF FF FF FF FF FF FF  
   3821 0000FE19 FF FF FF FF FF FF FF  
   3821 0000FE20 FF FF FF FF FF FF FF  
   3821 0000FE27 FF FF FF FF FF FF FF  
   3821 0000FE2E FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 70
noc_boot31.a
   3821 0000FE35 FF FF FF FF FF FF FF  
   3821 0000FE3C FF FF FF FF FF FF FF  
   3821 0000FE43 FF FF FF FF FF FF FF  
   3821 0000FE4A FF FF FF FF FF FF FF  
   3821 0000FE51 FF FF FF FF FF FF FF  
   3821 0000FE58 FF FF FF FF FF FF FF  
   3821 0000FE5F FF FF FF FF FF FF FF  
   3821 0000FE66 FF FF FF FF FF FF FF  
   3821 0000FE6D FF FF FF FF FF FF FF  
   3821 0000FE74 FF FF FF FF FF FF FF  
   3821 0000FE7B FF FF FF FF FF FF FF  
   3821 0000FE82 FF FF FF FF FF FF FF  
   3821 0000FE89 FF FF FF FF FF FF FF  
   3821 0000FE90 FF FF FF FF FF FF FF  
   3821 0000FE97 FF FF FF FF FF FF FF  
   3821 0000FE9E FF FF FF FF FF FF FF  
   3821 0000FEA5 FF FF FF FF FF FF FF  
   3821 0000FEAC FF FF FF FF FF FF FF  
   3821 0000FEB3 FF FF FF FF FF FF FF  
   3821 0000FEBA FF FF FF FF FF FF FF  
   3821 0000FEC1 FF FF FF FF FF FF FF  
   3821 0000FEC8 FF FF FF FF FF FF FF  
   3821 0000FECF FF FF FF FF FF FF FF  
   3821 0000FED6 FF FF FF FF FF FF FF  
   3821 0000FEDD FF FF FF FF FF FF FF  
   3821 0000FEE4 FF FF FF FF FF FF FF  
   3821 0000FEEB FF FF FF FF FF FF FF  
   3821 0000FEF2 FF FF FF FF FF FF FF  
   3821 0000FEF9 FF FF FF FF FF FF FF  
   3821 0000FF00 FF FF FF FF FF FF FF  
   3821 0000FF07 FF FF FF FF FF FF FF  
   3821 0000FF0E FF FF FF FF FF FF FF  
   3821 0000FF15 FF FF FF FF FF FF FF  
   3821 0000FF1C FF FF FF FF FF FF FF  
   3821 0000FF23 FF FF FF FF FF FF FF  
   3821 0000FF2A FF FF FF FF FF FF FF  
   3821 0000FF31 FF FF FF FF FF FF FF  
   3821 0000FF38 FF FF FF FF FF FF FF  
   3821 0000FF3F FF FF FF FF FF FF FF  
   3821 0000FF46 FF FF FF FF FF FF FF  
   3821 0000FF4D FF FF FF FF FF FF FF  
   3821 0000FF54 FF FF FF FF FF FF FF  
   3821 0000FF5B FF FF FF FF FF FF FF  
   3821 0000FF62 FF FF FF FF FF FF FF  
   3821 0000FF69 FF FF FF FF FF FF FF  
   3821 0000FF70 FF FF FF FF FF FF FF  
   3821 0000FF77 FF FF FF FF FF FF FF  
   3821 0000FF7E FF FF FF FF FF FF FF  
   3821 0000FF85 FF FF FF FF FF FF FF  
   3821 0000FF8C FF FF FF FF FF FF FF  
   3821 0000FF93 FF FF FF FF FF FF FF  
   3821 0000FF9A FF FF FF FF FF FF FF  
   3821 0000FFA1 FF FF FF FF FF FF FF  
   3821 0000FFA8 FF FF FF FF FF FF FF  
   3821 0000FFAF FF FF FF FF FF FF FF  
   3821 0000FFB6 FF FF FF FF FF FF FF  
   3821 0000FFBD FF FF FF FF FF FF FF  
   3821 0000FFC4 FF FF FF FF FF FF FF  
   3821 0000FFCB FF FF FF FF FF FF FF  
   3821 0000FFD2 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 71
noc_boot31.a
   3821 0000FFD9 FF FF FF FF FF FF FF  
   3821 0000FFE0 FF FF FF FF FF FF FF  
   3821 0000FFE7 FF FF FF FF FF FF FF  
   3821 0000FFEE FF FF FF FF FF FF FF  
   3821 0000FFF5 FF FF FF FF FF FF FF  
   3821 0000FFFC FF FF                 
   3822 0000FFFE C8 F2                   		dw		start
