Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 1
noc_boot41.a

                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; This boot rom for node $411.
                                        ; $411 is dedicated to date/time services
                                        ; ============================================================================
                                        ;
     27 = 02                            nDCB	equ		2
     28 = 0D                            CR	= 13
     29 = 0A                            LF	= 10
     30 = 02                            nDCB    equ		2
     31 = 09                            CTRLH	equ		9
     32 = 20                            txBuf	equ		32
     33 = 30                            rxBuf	equ		48
                                        
     35 = 01                            MT_RST		equ		1
     36 = 02                            MT_RST_ACK	equ		2
     37 = 03                            MT_STOP		equ		3
     38 = 04                            MT_KEYSTROKE			equ	4
     39 = 05                            MT_SET_IOFOCUS			equ	5
     40 = 06                            MT_BUTTON_STATUS		equ	6
     41 = 07                            MT_REQ_INP_FOCUS		equ	7
     42 = 08                            MT_GRNT_INP_FOCUS		equ 8
     43 = 09                            MT_PING					equ	9
     44 = 0A                            MT_START_BASIC_LOAD		equ	10
     45 = 0B                            MT_LOAD_BASIC_CHAR		equ	11
     46 = 0C                            MT_RUN_BASIC_PROG		equ	12
     47 = 0D                            MT_BASIC_EXIT			equ	13
     48 = 0F                            MT_REQ_OUT_FOCUS		equ	15
     49 = 10                            MT_GRNT_OUT_FOCUS		equ	16
     50 = 11                            MT_OUT_CHAR				equ	17
     51 = 12                            MT_PING_ACK				equ	18
     52 = 13                            MT_ETH_PACKET			equ	19
     53 = 14                            MT_GET_DATETIME			equ	20
     54 = 15                            MT_SET_DATETIME			equ	21
     55 = 16                            MT_DATETIME_ACK			equ	22
     56 = 17                            MT_LOAD_CODE			equ	23
     57 = 18                            MT_LOAD_DATA			equ	24
     58 = 19                            MT_EXEC_CODE			equ	25
     59 = 1A                            MT_EXIT					equ	26
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 2
noc_boot41.a
     60 = 1B                            MT_RDRAM				equ	27
     61 = 1C                            MT_WRRAM				equ	28
     62 = 1D                            MT_SETPIXEL				equ	29
     63 = 1E                            MT_GETPIXEL				equ	30
     64 = 1F                            MT_SETADDR				equ	31
     65 = 20                            MT_DATA					equ	32
     66 = 21                            MT_NEXT_IOFOCUS			equ	33
     67 = 22                            MT_GET_ROUTE			equ	34
     68 = 23                            MT_GET_ROUTE_ACK		equ	35
     69 = 24                            MT_ENUM_DEVICES			equ	36
     70 = 25                            MT_ENUM_DEVICES1		equ	37
     71 = 26                            MT_ENUM_DEVICES2		equ	38
                                        
                                        ; Device command opcodes
                                        ;
     75 = 40                            DVC_Nop				EQU		64
     76 = 41                            DVC_Setup			EQU		65
     77 = 42                            DVC_Initialize		EQU		66
     78 = 43                            DVC_Status			EQU		67
     79 = 44                            DVC_MediaCheck		EQU		68
     80 = 45                            DVC_BuildBPB		EQU		69
     81 = 46                            DVC_Open			EQU		70
     82 = 47                            DVC_Close			EQU		71
     83 = 48                            DVC_GetChar			EQU		72
     84 = 49                            DVC_PeekChar		EQU		73
     85 = 4A                            DVC_GetCharDirect	EQU		74
     86 = 4B                            DVC_PeekCharDirect	EQU		75
     87 = 4C                            DVC_InputStatus		EQU		76
     88 = 4D                            DVC_PutChar			EQU		77
     89 = 4E                            DVC_SetPosition		EQU		78
     90 = 4F                            DVC_ReadBlock		EQU		79
     91 = 50                            DVC_WriteBlock		EQU		80
     92 = 51                            DVC_VerifyBlock		EQU		81
     93 = 52                            DVC_OutputStatus	EQU		82
     94 = 53                            DVC_FlushInput		EQU		83
     95 = 54                            DVC_FlushOutput		EQU		84
     96 = 55                            DVC_IRQ				EQU		85
     97 = 56                            DVC_IsRemoveable	EQU		86
     98 = 57                            DVC_IOCTRL_READ		EQU		87
     99 = 58                            DVC_IOCTRL_WRITE	EQU		88
    100 = 59                            DVC_OutputUntilBusy	EQU		89
                                        ; message types	90 to 95 reserved
                                        
                                        
                                        ; Device Control Block
                                        ;
    106 = 00                            DCB_Name			EQU		0		; string: first byte is length, 11 chars max
    107 = 0C                            DCB_Type			EQU		0x0C
    108 = 0E                            DCB_nBPB			EQU		0x0E
    109 = 10                            DCB_LastErc			EQU		0x10		; last error code
    110 = 14                            DCB_StartBlock		EQU		0x14		; starting block number (partitioned devices)
    111 = 18                            DCB_nBlocks			EQU		0x18		; number of blocks on device
    112 = 1C                            DCB_pCmdProc		EQU		0x1C		; pointer to command processor routine
    113 = 20                            DCB_ReentCount		EQU		0x20		; re-entrancy count (1 to 255)
    114 = 21                            DCB_fSingleUser		EQU		0x21
    115 = 22                            DCB_hJob			EQU		0x22		; handle to associated job
    116 = 24                            DCB_Mbx				EQU		0x24
    117 = 26                            DCB_pSema			EQU		0x26		; pointer to device semaphore
    118 = 28                            DCB_Resv1			EQU		0x28		; reserved
    119 = 30                            DCB_Size			EQU		0x30
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 3
noc_boot41.a
                                        
    121 = 1F                            MAX_DEV_OP			EQU		31
                                        
                                        
    124 = 000000000000B000                              ROUTER		equ	$B000
    125 = 10                            RTR_RXSTAT	equ	$10
    126 = 11                            RTR_RXCTL	equ	$11
    127 = 12                            RTR_TXSTAT	equ	$12
                                        
    129 = 00                            ROUTER_TRB	equ	0
                                        
    131 = 000000000000B300                              I2C_MASTER		EQU		$B300
    132 = 0000B300                      I2C_PRESCALE_LO	EQU		I2C_MASTER+$00
    133 = 0000B301                      I2C_PRESCALE_HI	EQU		I2C_MASTER+$01
    134 = 0000B302                      I2C_CONTROL		EQU		I2C_MASTER+$02
    135 = 0000B303                      I2C_TX			EQU		I2C_MASTER+$03
    136 = 0000B303                      I2C_RX			EQU		I2C_MASTER+$03
    137 = 0000B304                      I2C_CMD			EQU		I2C_MASTER+$04
    138 = 0000B304                      I2C_STAT		EQU		I2C_MASTER+$04
                                        
                                        
    141 = 0E                            MSG_DST		equ	14
    142 = 0C                            MSG_SRC		equ	12
    143 = 09                            MSG_TTL		equ	9
    144 = 08                            MSG_TYPE	equ	8
                                        
                                        		bss
                                        		org		$40
    149 00000040                        RTCBuf	fill.b	64,0
                                        		align	2
    151 00000080                        NodeDCB				fill.b	DCB_Size,0
    152 000000B0                        RTCControlBlock		fill.b	DCB_Size,0
    153 000000E0                        RTCPos	dw		0
                                        
                                        		.code
                                        		cpu		Butterfly16
                                        		org		0xE000
                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; Networking software components
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 4
noc_boot41.a
                                        ; ============================================================================
                                        ;
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Zero out the transmit buffer.
                                        ; Used before building transmit buffer.
                                        ; Automatically inserts a time-to-live of 63, and the source id.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    197 0000E000                        zeroTxBuf:
    198 0000E000 FE 6E                   		add		sp,sp,#-2
    199 0000E002 E0 D2                   		sw		r2,[sp]
    200 0000E004 00 40 0F 12             		lw		r2,#15
    201 0000E008                        zeroTxBuf1:
    202 0000E008 02 40 20 C0             		sb		r0,txBuf[r2]
    203 0000E00C FF 62                   		sub		r2,r2,#1
    204 0000E00E FC BB                   		bpl		zeroTxBuf1
    205 0000E010 03 40 0F 12             		lw		r2,#63
    206 0000E014 02 40 09 C2             		sb		r2,txBuf+MSG_TTL
    207 0000E018 E4 32                   		tsr		r2,ID
    208 0000E01A 02 40 0C D2             		sw		r2,txBuf+MSG_SRC	; X+Y
    209 0000E01E E0 F2                   		lw		r2,[sp]
    210 0000E020 02 6E                   		add		sp,sp,#2
    211 0000E022 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Set the destination address field in the transmit buffer based on the
                                        ; source address in the receive buffer.
                                        ;----------------------------------------------------------------------------
                                        
    218 0000E024                        SetDestFromRx:
    219 0000E024 03 40 0C F1             		lw		r1,rxBuf+MSG_SRC
    220 0000E028 02 40 0E D1             		sw		r1,txBuf+MSG_DST
    221 0000E02C F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Transmit on the network.
                                        ; Blocks until the transmit buffer is open.
                                        ;
                                        ; Prerequisites:
                                        ;	The transmit buffer txBuf must have already been loaded.
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    237 0000E02E FA 6E                  Xmit:	
    238 0000E030 E0 D1                   		sw		r1,[sp]
    239 0000E032 E2 D2                   		sw		r2,2[sp]
    240 0000E034 E4 D3                   		sw		r3,4[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 5
noc_boot41.a
                                        		; wait for transmit buffer to empty
                                        		; If transmit buffer empty signal times out, transmit anyway
                                        		; @100Mb/s 128 bits should transmit in only about 128 clock cycles.
    244 0000E036 00 13                   		lw		r3,#0
    245 0000E038                        Xmit2:
    246 0000E038 01 63                   		add		r3,r3,#1
    247 0000E03A FC 4F 3E 10             		cmp		r3,#50
    248 0000E03E 20 00                   		nop
    249 0000E040 06 A7                   		bgtu	Xmit1
    250 0000E042 01 4B 02 E1             		lb		r1,ROUTER+RTR_TXSTAT
    251 0000E046 20 00                   		nop
    252 0000E048 F7 B9                   		bne		Xmit2
    253 0000E04A 00 40 0F 12             		lw		r2,#15
    254 0000E04E                        Xmit1:
    255 0000E04E 02 40 20 E1             		lb		r1,txBuf[r2]
    256 0000E052 00 4B 20 C1             		sb		r1,ROUTER[r2]
    257 0000E056 FF 62                   		add		r2,r2,#-1
    258 0000E058 20 00                   		nop
    259 0000E05A F9 BB                   		bpl		Xmit1
                                        		; trigger a transmit, writing any value will set the transmitter busy bit
    261 0000E05C 01 4B 02 C0             		sb		r0,ROUTER+RTR_TXSTAT
    262 0000E060 E0 F1                   		lw		r1,[sp]
    263 0000E062 E2 F2                   		lw		r2,2[sp]
    264 0000E064 E4 F3                   		lw		r3,4[sp]
    265 0000E066 06 6E                   		add		sp,sp,#6
    266 0000E068 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receive from network.
                                        ; Receive status must have already indicated a message present.
                                        ; Copies recieve buffer from router to rxBuf.
                                        ; The router fifo is configured with first word fall-through. This means
                                        ; the data word appears on the fifo output before the fifo is popped.
                                        ; A fifo pop signal has to be sent after reading the data.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    284 0000E06A                        Recv:
    285 0000E06A FC 6E                   		add		sp,sp,#-4
    286 0000E06C E0 D1                   		sw		r1,[sp]
    287 0000E06E E2 D2                   		sw		r2,2[sp]
                                        		; Pop the rx fifo.
                                        		; This bit $40 should automatically clear so we don't need to
                                        		; set it back to zero.
    291 0000E070 01 4B 01 E1             		lb		r1,ROUTER+RTR_RXCTL
    292 0000E074 04 40 60 31             		or		r1,#$40
    293 0000E078 01 4B 01 C1             		sb		r1,ROUTER+RTR_RXCTL
    294 0000E07C 0B 40 5F 31             		and		r1,#$BF
    295 0000E080 01 4B 01 C1             		sb		r1,ROUTER+RTR_RXCTL
    296 0000E084 00 40 0F 12             		lw		r2,#15
    297 0000E088                        Recv1:
    298 0000E088 00 4B 20 E1             		lb		r1,ROUTER[r2]			; copy message to local buffer
    299 0000E08C 03 40 20 C1             		sb		r1,rxBuf[r2]
    300 0000E090 FF 62                   		add		r2,r2,#-1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 6
noc_boot41.a
    301 0000E092 FA BB                   		bpl		Recv1
    302 0000E094 E0 F1                   		lw		r1,[sp]
    303 0000E096 E2 F2                   		lw		r2,2[sp]
    304 0000E098 04 6E                   		add		sp,sp,#4
    305 0000E09A F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Handler for the ping function. A pink acknowledge message is sent back
                                        ; to the sender.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    319 0000E09C                        PingHandler:
    320 0000E09C FC 6E                   		add		sp,sp,#-4
    321 0000E09E E0 DF                   		sw		lr,[sp]
    322 0000E0A0 E2 D1                   		sw		r1,2[sp]
    323 0000E0A2 AE BF                   		call	zeroTxBuf
    324 0000E0A4 BF BF                   		call	SetDestFromRx
    325 0000E0A6 01 40 02 11             		lw		r1,#MT_PING_ACK
    326 0000E0AA 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
    327 0000E0AE BF BF                   		call	Xmit
    328 0000E0B0 E0 FF                   		lw		lr,[sp]
    329 0000E0B2 E2 F1                   		lw		r1,2[sp]
    330 0000E0B4 04 6E                   		add		sp,sp,#4
    331 0000E0B6 F0 80                   		ret
                                        ;----------------------------------------------------------------------------
                                        ; Dispatch routine for received messages.
                                        ; A reset message is processed here, not counting on the DCB to be setup
                                        ; correctly. Otherwise all other messages are passed to the command processor
                                        ; for the intended device.
                                        ;----------------------------------------------------------------------------
                                        
    339 0000E0B8                        RecvDispatch:
    340 0000E0B8 F8 6E                   		add		sp,sp,#-8
    341 0000E0BA E0 DF                   		sw		lr,[sp]
    342 0000E0BC E2 D1                   		sw		r1,2[sp]
    343 0000E0BE E4 D2                   		sw		r2,4[sp]
    344 0000E0C0 E6 D3                   		sw		r3,6[sp]
    345 0000E0C2 E4 31                   		tsr		r1,ID
    346 0000E0C4 EE 4F 1F 10             		cmp		r1,#$111
    347 0000E0C8 10 A8                   		beq		RecvDispatch2
    348 0000E0CA 03 40 08 E1             		lb		r1,rxBuf+MSG_TYPE
    349 0000E0CE 1F 10                   		cmp		r1,#MT_RST			; reset message ?
    350 0000E0D0 0C A9                   		bne		RecvDispatch2
    351 0000E0D2 A0 40 06 AF             		call	ResetNode
                                        		; Send back a reset ACK message to indicate node is good to go.
    353 0000E0D6 94 BF                   		call	zeroTxBuf
    354 0000E0D8 11 40 01 11             		lw		r1,#$111
    355 0000E0DC 02 40 0E D1             		sw		r1,txBuf+MSG_DST
    356 0000E0E0 02 11                   		lw		r1,#MT_RST_ACK
    357 0000E0E2 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
    358 0000E0E6 A3 BF                   		call	Xmit
    359 0000E0E8 1D AE                   		br		RecvDispatchXit
    360 0000E0EA                        RecvDispatch2:
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 7
noc_boot41.a
    361 0000E0EA 03 40 0E F1             		lw		r1,rxBuf+MSG_DST
    362 0000E0EE FF 40 5F 31             		and		r1,#$FFF
    363 0000E0F2 E4 32                   		tsr		r2,ID
    364 0000E0F4 1D 22                   		cmp		r2,r1
    365 0000E0F6 16 A9                   		bne		RecvDispatchXit
    366 0000E0F8 03 40 0E F2             		lw		r2,rxBuf+MSG_DST
    367 0000E0FC 91 32                   		rol		r2,#1		; Get the 'D' nybble into r2
    368 0000E0FE 91 32                   		rol		r2,#1
    369 0000E100 91 32                   		rol		r2,#1
    370 0000E102 91 32                   		rol		r2,#1
    371 0000E104 00 40 5F 32             		and		r2,#$0F		; max 15 devices
    372 0000E108 81 32                   		shl		r2,#1		; multiply by 48 (size of DCB)
    373 0000E10A 81 32                   		shl		r2,#1
    374 0000E10C 81 32                   		shl		r2,#1
    375 0000E10E 81 32                   		shl		r2,#1
    376 0000E110 20 13                   		mov		r3,r2
    377 0000E112 81 32                   		shl		r2,#1
    378 0000E114 30 22                   		add		r2,r3
    379 0000E116 08 40 20 12             		add		r2,r2,#NodeDCB
    380 0000E11A 01 40 2C F2             		lw		r2,DCB_pCmdProc[r2]
    381 0000E11E 03 40 08 E1             		lb		r1,rxBuf+MSG_TYPE
    382 0000E122 20 8F                   		call	[r2]
    383 0000E124                        RecvDispatchXit:
    384 0000E124 E0 FF                   		lw		lr,[sp]
    385 0000E126 E2 F1                   		lw		r1,2[sp]
    386 0000E128 E4 F2                   		lw		r2,4[sp]
    387 0000E12A E6 F3                   		lw		r3,6[sp]
    388 0000E12C 08 6E                   		add		sp,sp,#8
    389 0000E12E F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Message command processor for node.
                                        ;
                                        ; Executes different message handlers based on the message type.
                                        ;----------------------------------------------------------------------------
                                        
    397 0000E130                        StdMsgHandlers:
    398 0000E130 F8 6E                   		add		sp,sp,#-8
    399 0000E132 E0 DF                   		sw		lr,[sp]
    400 0000E134 E4 D2                   		sw		r2,4[sp]
    401 0000E136 E6 D3                   		sw		r3,6[sp]
                                        
    403 0000E138 03 40 08 E1             		lb		r1,rxBuf+MSG_TYPE
                                        
                                        		; Process PING request
    406 0000E13C FF 4F 17 10             		cmp		r1,#MT_PING
    407 0000E140 03 A9                   		bne		StdMsgHandlers1
    408 0000E142 AC BF                   		call	PingHandler
    409 0000E144 01 11                   		lw		r1,#1
    410 0000E146 68 AE                   		br		StdMsgHandlersXit
                                        
    412 0000E148                        StdMsgHandlers1:
    413 0000E148 FF 4F 16 10             		cmp		r1,#MT_START_BASIC_LOAD	; start BASIC load
    414 0000E14C 07 A9                   		bne		StdMsgHandlers2
    415 0000E14E 03 40 0C F1             		lw		r1,rxBuf+MSG_SRC
    416 0000E152 BE AF                   		call	INITTBW
    417 0000E154 2C 4E 0C F8             		lw		r8,TXTBGN			; r8 = text begin
    418 0000E158 01 11                   		lw		r1,#1
    419 0000E15A 5E AE                   		br		StdMsgHandlersXit
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 8
noc_boot41.a
    421 0000E15C                        StdMsgHandlers2:
    422 0000E15C FF 4F 15 10             		cmp		r1,#MT_LOAD_BASIC_CHAR	; load BASIC program char
    423 0000E160 0E A9                   		bne		StdMsgHandlers4
    424 0000E162 03 40 00 F1             		lw		r1,rxBuf
    425 0000E166 80 D1                   		sw		r1,[r8]
    426 0000E168 03 40 02 F1             		lw		r1,rxBuf+2
    427 0000E16C 82 D1                   		sw		r1,2[r8]
    428 0000E16E 03 40 04 F1             		lw		r1,rxBuf+4
    429 0000E172 84 D1                   		sw		r1,4[r8]
    430 0000E174 06 68                   		add		r8,r8,#6
    431 0000E176 12 40 06 D8             		sw		r8,TXTUNF
    432 0000E17A 01 11                   		lw		r1,#1
    433 0000E17C 4D AE                   		br		StdMsgHandlersXit
                                        
                                        		; Run a BASIC program by stuffing a 'RUN' command into the BASIC
                                        		; buffer.
    437 0000E17E                        StdMsgHandlers4:
    438 0000E17E FF 4F 14 10             		cmp		r1,#MT_RUN_BASIC_PROG
    439 0000E182 17 A9                   		bne		StdMsgHandlers5
    440 0000E184 05 40 02 11             		lw		r1,#'R'
    441 0000E188 13 40 0E C1             		sb		r1,BUFFER
    442 0000E18C 05 40 05 11             		lw		r1,#'U'
    443 0000E190 13 40 0F C1             		sb		r1,BUFFER+1
    444 0000E194 04 40 0E 11             		lw		r1,#'N'
    445 0000E198 14 40 00 C1             		sb		r1,BUFFER+2
    446 0000E19C 00 40 0D 11             		lw		r1,#13
    447 0000E1A0 14 40 01 C1             		sb		r1,BUFFER+3
    448 0000E1A4 14 40 02 C0             		sb		r0,BUFFER+4
    449 0000E1A8 14 40 02 18             		lw		r8,#BUFFER+4
    450 0000E1AC B6 AF                   		call	ST3
    451 0000E1AE 01 11                   		lw		r1,#1
    452 0000E1B0 33 AE                   		br		StdMsgHandlersXit
                                        
                                        		; Load program code
    455 0000E1B2                        StdMsgHandlers5:
    456 0000E1B2 FE 4F 19 10             		cmp		r1,#MT_LOAD_CODE
    457 0000E1B6 07 A9                   		bne		StdMsgHandlers6
    458 0000E1B8 03 40 02 F1             		lw		r1,rxBuf+2
    459 0000E1BC 03 40 04 F2             		lw		r2,rxBuf+4
    460 0000E1C0 20 D1                   		sw		r1,[r2]
    461 0000E1C2 01 11                   		lw		r1,#1
    462 0000E1C4 29 AE                   		br		StdMsgHandlersXit
                                        
                                        		; Load program data
    465 0000E1C6                        StdMsgHandlers6:
    466 0000E1C6 FE 4F 18 10             		cmp		r1,#MT_LOAD_DATA
    467 0000E1CA 07 A9                   		bne		StdMsgHandlers7
    468 0000E1CC 03 40 02 F1             		lw		r1,rxBuf+2
    469 0000E1D0 03 40 04 F2             		lw		r2,rxBuf+4
    470 0000E1D4 20 D1                   		sw		r1,[r2]
    471 0000E1D6 01 11                   		lw		r1,#1
    472 0000E1D8 1F AE                   		br		StdMsgHandlersXit
                                        		; Load program code
                                        
                                        		; Execute program
    476 0000E1DA                        StdMsgHandlers7:
    477 0000E1DA FE 4F 17 10             		cmp		r1,#MT_EXEC_CODE
    478 0000E1DE 15 A9                   		bne		StdMsgHandlers8
    479 0000E1E0 03 40 0C F1             		lw		r1,rxBuf+MSG_SRC
    480 0000E1E4 FE 6E                   		add		sp,sp,#-2
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 9
noc_boot41.a
    481 0000E1E6 E0 D1                   		sw		r1,[sp]
    482 0000E1E8 03 40 04 F2             		lw		r2,rxBuf+4
    483 0000E1EC 20 8F                   		call	[r2]
    484 0000E1EE E0 F2                   		lw		r2,[sp]
    485 0000E1F0 02 6E                   		add		sp,sp,#2
    486 0000E1F2 06 BF                   		call	zeroTxBuf
    487 0000E1F4 02 40 02 D1             		sw		r1,txBuf+2
    488 0000E1F8 02 40 0E D2             		sw		r2,txBuf+MSG_DST
    489 0000E1FC 01 40 0A 11             		lw		r1,#MT_EXIT
    490 0000E200 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
    491 0000E204 14 BF                   		call	Xmit
    492 0000E206 01 11                   		lw		r1,#1
    493 0000E208 07 AE                   		br		StdMsgHandlersXit
                                        
                                        		; Enumerate the devices in the node. Provide a list back
                                        		; to node $111.
    497 0000E20A                        StdMsgHandlers8:
    498 0000E20A FD 4F 1C 10             		cmp		r1,#MT_ENUM_DEVICES
    499 0000E20E 03 A9                   		bne		StdMsgHandlers12
    500 0000E210 09 AF                   		call	EnumDevices
    501 0000E212 01 11                   		lw		r1,#1
    502 0000E214 01 AE                   		br		StdMsgHandlersXit
                                        
    504 0000E216                        StdMsgHandlers12:
    505 0000E216 00 11                   		lw		r1,#0
    506 0000E218                        StdMsgHandlersXit:
    507 0000E218 E0 FF                   		lw		lr,[sp]
    508 0000E21A E4 F2                   		lw		r2,4[sp]
    509 0000E21C E6 F3                   		lw		r3,6[sp]
    510 0000E21E 08 6E                   		add		sp,sp,#8
    511 0000E220 16 21                   		or		r1,r1
    512 0000E222 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Standard message handler for enunmerating devices.
                                        ;
                                        ; Enumerate the devices present in the node.
                                        ;----------------------------------------------------------------------------
                                        
    520 0000E224                        EnumDevices:
    521 0000E224 F6 6E                   		add		sp,sp,#-10
    522 0000E226 E0 DF                   		sw		lr,[sp]
    523 0000E228 E2 D1                   		sw		r1,2[sp]
    524 0000E22A E4 D2                   		sw		r2,4[sp]
    525 0000E22C E6 D3                   		sw		r3,6[sp]
    526 0000E22E E8 D4                   		sw		r4,8[sp]
    527 0000E230 00 13                   		lw		r3,#0
    528 0000E232 00 12                   		lw		r2,#0
    529 0000E234                        EnumDevices1:
    530 0000E234 EE 4F 04 AF             		call	zeroTxBuf
    531 0000E238 EF 4F 04 AF             		call	SetDestFromRx
    532 0000E23C 30 14                   		mov		r4,r3
    533 0000E23E C1 34                   		ror		r4,#1			; put count in r4 bits 12 to 15
    534 0000E240 C1 34                   		ror		r4,#1
    535 0000E242 C1 34                   		ror		r4,#1
    536 0000E244 C1 34                   		ror		r4,#1
    537 0000E246 E4 31                   		tsr		r1,ID
    538 0000E248 46 21                   		or		r1,r4
    539 0000E24A 02 40 00 D1             		sw		r1,txBuf
    540 0000E24E 08 40 20 F1             		lw		r1,NodeDCB[r2]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 10
noc_boot41.a
    541 0000E252 02 40 02 D1             		sw		r1,txBuf+2
    542 0000E256 08 40 22 F1             		lw		r1,NodeDCB+2[r2]
    543 0000E25A 02 40 04 D1             		sw		r1,txBuf+4
    544 0000E25E 08 40 24 F1             		lw		r1,NodeDCB+4[r2]
    545 0000E262 02 40 06 D1             		sw		r1,txBuf+6
    546 0000E266 02 40 05 11             		lw		r1,#MT_ENUM_DEVICES1
    547 0000E26A EE 4F 00 AF             		call	Xmit
    548 0000E26E EC 4F 07 AF             		call	zeroTxBuf
    549 0000E272 ED 4F 07 AF             		call	SetDestFromRx
    550 0000E276 08 40 26 F1             		lw		r1,NodeDCB+6[r2]
    551 0000E27A 02 40 00 D1             		sw		r1,txBuf
    552 0000E27E 08 40 28 F1             		lw		r1,NodeDCB+8[r2]
    553 0000E282 02 40 02 D1             		sw		r1,txBuf+2
    554 0000E286 08 40 2A F1             		lw		r1,NodeDCB+10[r2]
    555 0000E28A 02 40 04 D1             		sw		r1,txBuf+4
    556 0000E28E 08 40 2C F1             		lw		r1,NodeDCB+12[r2]
    557 0000E292 02 40 06 D1             		sw		r1,txBuf+6
    558 0000E296 02 40 06 11             		lw		r1,#MT_ENUM_DEVICES2
    559 0000E29A EC 4F 08 AF             		call	Xmit
    560 0000E29E 30 62                   		add		r2,r2,#DCB_Size
    561 0000E2A0 01 63                   		add		r3,r3,#1
    562 0000E2A2 3E 10                   		cmp		r3,#nDCB
    563 0000E2A4 C7 B4                   		bltu	EnumDevices1
    564 0000E2A6 E0 FF                   		lw		lr,[sp]
    565 0000E2A8 E2 F1                   		lw		r1,2[sp]
    566 0000E2AA E4 F2                   		lw		r2,4[sp]
    567 0000E2AC E6 F3                   		lw		r3,6[sp]
    568 0000E2AE E8 F4                   		lw		r4,8[sp]
    569 0000E2B0 0A 6E                   		add		sp,sp,#10
    570 0000E2B2 F0 80                   		ret
                                        
                                        ;****************************************************************;
                                        ;                                                                ;
                                        ;		Tiny BASIC Worker for the Finitron Butterfly             ;
                                        ;                                                                ;
                                        ; Supports worker threads.                                       ;
                                        ; There is no user interface to worker threads so the commands   ;
                                        ; LOAD and SAVE are removed.                                     ;
                                        ;                                                                ;
                                        ; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                                        ; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                                        ; Adapted to the 68000 by:                                       ;
                                        ;	Gordon brndly						                         ;
                                        ;	12147 - 51 Street					                         ;
                                        ;	Edmonton AB  T5W 3G8					                     ;
                                        ;	Canada							                             ;
                                        ;	(updated mailing address for 1996)			                 ;
                                        ;                                                                ;
                                        ; Adapted to the Butterfly by:                                    ;
                                        ;    Robert Finch                                                ;
                                        ;    Ontario, Canada                                             ;
                                        ;	 rob<remove>@finitron.ca                                     ;  
                                        ;****************************************************************;
                                        ;   Copyright (C) 2005-2017 by Robert Finch. This program may be ;
                                        ;    freely distributed for personal use only. All commercial	 ;
                                        ;		       rights are reserved.			                     ;
                                        ;****************************************************************;
                                        ;
                                        ; Register Usage
                                        ; r8 = text pointer (global usage)
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 11
noc_boot41.a
                                        ; r3,r4 = inputs parameters to subroutines
                                        ; r2 = return value
                                        ;
                                        ;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                                        ;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                                        ;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                                        
                                        ;	OPT	FRS,BRS 	forward ref.'s & brnches default to short
                                        
                                        ;XMIT_FULL		equ	0x40		; the transmit buffer is full
                                        ;DATA_PRESENT	equ	0x08		; there is data preset at the serial port bc_uart3
    611 = 01                            DATA_PRESENT	equ	0x01		; there is data preset at the serial port bc_uart3
    612 = 20                            XMIT_NOT_FULL	equ	0x20
                                        
    614 = 00000000FFFFDC40                              TS_TIMER	equ		0xFFFFDC40		; system time slice timer
    615 = 00000000FFFFDC50                              KBD			equ		0xFFFFDC50
                                        
    617 = 00000000FFFFDCA0                              RAND		equ		0xFFFFDCA0
    618 = 00000000FFFFD800                              VIC			equ		0xFFFFD800
                                        
    620 = 2000                          VIDEORAM	equ		0x00002000
                                        
                                        ; BOOT ROM routines
                                        
    624 = 0000000FFFFFF804                              getSerial	equ		0xFFFFFF804	; get a serial port character
    625 = 0000000FFFFFF808                              peekSerial	equ		0xFFFFFF808	; get a serial port character
    626 = 0000000FFFFFF80C                              putSerial	equ		0xFFFFFF80C	; put a character to serial port
    627 = 0000000FFFFFF82C                              clearScreen	equ		0xFFFFFF82C	; clear the screen
    628 = 0000000FFFFFF840                              getKbdCharWait	equ	0xFFFFFF840
    629 = 0000000FFFFFF844                              getKbdChar		equ	0xFFFFFF844
                                        
    631 = 20                            warmStart   equ     0x20
    632 = 24                            usrJmp      equ     0x24
                                        
    634 = 0D                            CR		equ	0x0D		; ASCII equates
    635 = 0A                            LF		equ	0x0A
    636 = 09                            TAB		equ	0x09
    637 = 03                            CTRLC	equ	0x03
    638 = 08                            CTRLH	equ	0x08
    639 = 13                            CTRLS	equ	0x13
    640 = 18                            CTRLX	equ	0x18
                                        
    642 = 50                            BUFLEN	equ	80	;	length of keyboard input buffer
                                        
                                        	code
                                        ;	org	0xC000	;
                                        ;
                                        ; Standard jump table. You can change these addresses if you are
                                        ; customizing this interpreter for a different environment.
                                        ;
    651 0000E2B4 FF BE                  START	jmp	CSTART	;	Cold Start entry point
    652 0000E2B6 26 AE                  GOWARM	jmp	WSTART	;	Warm Start entry point
    653 0000E2B8 75 40 01 AE            GOOUT	jmp	OUTC	;	Jump to character-out routine
    654 0000E2BC 75 40 00 AE            GOIN	jmp	INC		;Jump to character-in routine
    655 0000E2C0 78 40 01 AE            GOAUXO	jmp	AUXOUT	;	Jump to auxiliary-out routine
    656 0000E2C4 79 40 0E AE            GOAUXI	jmp	AUXIN	;	Jump to auxiliary-in routine
    657 0000E2C8 7D 40 00 AE            GOBYE	jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                                        ;
                                        ; Modifiable system constants:
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 12
noc_boot41.a
    661 0000E2CC 00 02                  TXTBGN	dw	0x0200		;beginning of program memory
    662 0000E2CE 00 1E                  ENDMEM	dw	0x1E00	;	end of available memory
                                        ;
    664 0000E2D0                        INITTBW:
                                        	; First save off the link register and OS sp value
    666 0000E2D0 FE 6E                   	sub		sp,sp,#2
    667 0000E2D2 E0 DF                   	sw		lr,[sp]
    668 0000E2D4 2C 4E 0C F1             	lw		r1,TXTBGN	;	init. end-of-program pointer
    669 0000E2D8 12 40 06 D1             	sw		r1,TXTUNF
    670 0000E2DC 2C 4E 0E F1             	lw		r1,ENDMEM	;	get address of end of memory
    671 0000E2E0 E0 4F 10 11             	sub		r1,r1,#512	; 	reserve 512 bytes for the stack
    672 0000E2E4 13 40 00 D1             	sw		r1,STKBOT
    673 0000E2E8 E0 4F 10 11             	sub     r1,r1,#512 ;   128 vars
    674 0000E2EC 12 40 08 D1             	sw      r1,VARBGN
    675 0000E2F0 EC AF                   	call    clearVars   ; clear the variable area
    676 0000E2F2 11 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    677 0000E2F6 11 40 08 D0             	sw		r0,STKGOS
    678 0000E2FA 11 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    679 0000E2FE E0 FF                   	lw		lr,[sp]
    680 0000E300 02 6E                   	add		sp,sp,#2
    681 0000E302 F0 80                   	ret
                                        ;
                                        ; The main interpreter starts here:
                                        ;
                                        ; Usage
                                        ; r1 = temp
                                        ; r8 = text buffer pointer
                                        ; r12 = end of text in text buffer
                                        ;
                                        	; At the end of the running program it'll go back to
                                        	; the warm start location. Use this to return.
    692 0000E304                        WSTART
    693 0000E304 11 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    694 0000E308 11 40 08 D0             	sw		r0,STKGOS
    695 0000E30C 11 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    696 0000E310 11 40 04 FE             	lw		sp,OSSP
    697 0000E314 E0 FF                   	lw		lr,[sp]
    698 0000E316 02 6E                   	add		sp,sp,#2
    699 0000E318 F0 80                   	ret
                                        
                                        	; Entry point which is called by the reciever dispatcher.
    702 0000E31A                        ST3:
    703 0000E31A FE 6E                   	add		sp,sp,#-2
    704 0000E31C E0 DF                   	sw		lr,[sp]
    705 0000E31E 11 40 04 DE             	sw		sp,OSSP
    706 0000E322 2C 4E 0E FE             	lw		sp,ENDMEM	;	init S.P.
    707 0000E326 6C 40 02 AF             	call	TOUPBUF 	; convert to upper case
    708 0000E32A 80 1C                   	lw		r12,r8		; save pointer to end of line
    709 0000E32C 13 40 0E 18             	lea		r8,BUFFER	; point to the beginning of line
    710 0000E330 6F AE                   	br		DIRECT
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** Tables *** DIRECT *** EXEC ***
                                        ;
                                        ; This section of the code tests a string against a table. When
                                        ; a match is found, control is transferred to the section of
                                        ; code according to the table.
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 13
noc_boot41.a
                                        ; At 'EXEC', r8 should point to the string, r9 should point to
                                        ; the character table, and r10 should point to the execution
                                        ; table. At 'DIRECT', r8 should point to the string, r9 and
                                        ; r10 will be set up to point to TAB1 and TAB1_1, which are
                                        ; the tables of all direct and statement commands.
                                        ;
                                        ; A '.' in the string will terminate the test and the partial
                                        ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                                        ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                                        ;
                                        ; There are two tables: the character table and the execution
                                        ; table. The character table consists of any number of text items.
                                        ; Each item is a string of characters with the last character's
                                        ; high bit set to one. The execution table holds a 32-bit
                                        ; execution addresses that correspond to each entry in the
                                        ; character table.
                                        ;
                                        ; The end of the character table is a 0 byte which corresponds
                                        ; to the default routine in the execution table, which is
                                        ; executed if none of the other table items are matched.
                                        ;
                                        ; Character-matching tables:
    743 0000E332                        TAB1
    744 0000E332 4C 49 53 D4             	db	"LIS",('T'+0x80)        ; Direct commands
    745 0000E336 4E 45 D7                	db	"NE",('W'+0x80)
    746 0000E339 52 55 CE                	db	"RU",('N'+0x80)
    747 0000E33C                        TAB2
    748 0000E33C 4E 45 58 D4             	db	"NEX",('T'+0x80)         ; Direct / statement
    749 0000E340 4C 45 D4                	db	"LE",('T'+0x80)
    750 0000E343 49 C6                   	db	"I",('F'+0x80)
    751 0000E345 47 4F 54 CF             	db	"GOT",('O'+0x80)
    752 0000E349 47 4F 53 55 C2          	db	"GOSU",('B'+0x80)
    753 0000E34E 52 45 54 55 52 CE       	db	"RETUR",('N'+0x80)
    754 0000E354 52 45 CD                	db	"RE",('M'+0x80)
    755 0000E357 46 4F D2                	db	"FO",('R'+0x80)
    756 0000E35A 49 4E 50 55 D4          	db	"INPU",('T'+0x80)
    757 0000E35F 50 52 49 4E D4          	db	"PRIN",('T'+0x80)
    758 0000E364 50 4F 4B 45 D7          	db	"POKE",('W'+0x80)
    759 0000E369 50 4F 4B C5             	db	"POK",('E'+0x80)
    760 0000E36D 53 54 4F D0             	db	"STO",('P'+0x80)
    761 0000E371 42 59 C5                	db	"BY",('E'+0x80)
    762 0000E374 53 59 D3                	db	"SY",('S'+0x80)
    763 0000E377 43 4C D2                    db  "CL",('R'+0x80)
    764 0000E37A 45 58 49 D4             	db	"EXI",('T'+0x80)
    765 0000E37E 00                      	db	0
    766 0000E37F                        TAB4
    767 0000E37F 4E 4F 44 45 4E 55 CD    	db	"NODENU",('M'+0x80)
                                      
    768 0000E386 50 45 45 4B D7          	db	"PEEK",('W'+0x80)        ;Functions
    769 0000E38B 50 45 45 CB             	db	"PEE",('K'+0x80)         ;Functions
    770 0000E38F 52 4E C4                	db	"RN",('D'+0x80)
    771 0000E392 41 42 D3                	db	"AB",('S'+0x80)
    772 0000E395 53 49 5A C5             	db	"SIZ",('E'+0x80)
    773 0000E399 55 53 D2                	db  "US",('R'+0x80)
    774 0000E39C 00                      	db	0
    775 0000E39D                        TAB5
    776 0000E39D 54 CF                   	db	"T",('O'+0x80)           ;"TO" in "FOR"
    777 0000E39F 00                      	db	0
    778 0000E3A0                        TAB6
    779 0000E3A0 53 54 45 D0             	db	"STE",('P'+0x80)         ;"STEP" in "FOR"
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 14
noc_boot41.a
    780 0000E3A4 00                      	db	0
    781 0000E3A5                        TAB8
    782 0000E3A5 3E BD                   	db	'>',('='+0x80)           ;Relational operators
    783 0000E3A7 3C BE                   	db	'<',('>'+0x80)
    784 0000E3A9 BE                      	db	('>'+0x80)
    785 0000E3AA BD                      	db	('='+0x80)
    786 0000E3AB 3C BD                   	db	'<',('='+0x80)
    787 0000E3AD BC                      	db	('<'+0x80)
    788 0000E3AE 00                      	db	0
    789 0000E3AF                        TAB9
    790 0000E3AF 41 4E C4                    db  "AN",('D'+0x80)
    791 0000E3B2 00                          db  0
    792 0000E3B3                        TAB10
    793 0000E3B3 4F D2                       db  "O",('R'+0x80)
    794 0000E3B5 00                          db  0
                                        
    796 0000E3B6 FF FF                   	.align	4
                                        
                                        ;* Execution address tables:
    799 0000E3B8                        TAB1_1
    800 0000E3B8 E8 E4                   	dw	LISTX			;Direct commands
    801 0000E3BA 66 E4                   	dw	NEW
    802 0000E3BC 7A E4                   	dw	RUN
    803 0000E3BE                        TAB2_1
    804 0000E3BE 3A E6                   	dw	NEXT		;	Direct / statement
    805 0000E3C0 34 E7                   	dw	LET
    806 0000E3C2 94 E6                   	dw	IF
    807 0000E3C4 AC E4                   	dw	GOTO
    808 0000E3C6 80 E5                   	dw	GOSUB
    809 0000E3C8 B0 E5                   	dw	RETURN
    810 0000E3CA 9A E6                   	dw	IF2			; REM
    811 0000E3CC DA E5                   	dw	FOR
    812 0000E3CE B8 E6                   	dw	INPUT
    813 0000E3D0 1C E5                   	dw	PRINT
    814 0000E3D2 1E E8                   	dw	POKEW
    815 0000E3D4 FE E7                   	dw	POKE
    816 0000E3D6 74 E4                   	dw	STOP
    817 0000E3D8 C8 E2                   	dw	GOBYE
    818 0000E3DA 36 E8                   	dw	SYSX
    819 0000E3DC C6 E4                   	dw  _clr
    820 0000E3DE 86 F2                   	dw	EXIT
    821 0000E3E0 2C E7                   	dw	DEFLT
    822 0000E3E2                        TAB4_1
    823 0000E3E2 60 EC                   	dw	NODENUM
    824 0000E3E4 B2 EB                   	dw  PEEKW
    825 0000E3E6 A6 EB                   	dw	PEEK			;Functions
    826 0000E3E8 D0 EB                   	dw	RND
    827 0000E3EA 2A EC                   	dw	ABS
    828 0000E3EC 50 EC                   	dw	SIZEX
    829 0000E3EE BE EB                   	dw  USRX
    830 0000E3F0 DC E9                   	dw	XP40
    831 0000E3F2                        TAB5_1
    832 0000E3F2 F0 E5                   	dw	FR1			;"TO" in "FOR"
    833 0000E3F4 E0 EC                   	dw	QWHAT
    834 0000E3F6                        TAB6_1
    835 0000E3F6 02 E6                   	dw	FR2			;"STEP" in "FOR"
    836 0000E3F8 08 E6                   	dw	FR3
    837 0000E3FA                        TAB8_1
    838 0000E3FA FE E8                   	dw	XP11	;>=		Relational operators
    839 0000E3FC 08 E9                   	dw	XP12	;<>
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 15
noc_boot41.a
    840 0000E3FE 12 E9                   	dw	XP13	;>
    841 0000E400 26 E9                   	dw	XP15	;=
    842 0000E402 1C E9                   	dw	XP14	;<=
    843 0000E404 30 E9                   	dw	XP16	;<
    844 0000E406 4A E9                   	dw	XP17
    845 0000E408                        TAB9_1
    846 0000E408 8A E8                       dw  XP_AND
    847 0000E40A 92 E8                       dw  XP_ANDX
    848 0000E40C                        TAB10_1
    849 0000E40C 66 E8                       dw  XP_OR
    850 0000E40E 6E E8                       dw  XP_ORX
                                        
                                        ;*
                                        ; r3 = match flag (trashed)
                                        ; r9 = text table
                                        ; r10 = exec table
                                        ; r11 = trashed
    857 0000E410                        DIRECT
    858 0000E410 33 4E 02 19             	lea		r9,TAB1
    859 0000E414 3B 4E 08 1A             	lea		r10,TAB1_1
    860 0000E418                        EXEC
    861 0000E418 F0 1B                   	lw		r11,lr		; save link reg
    862 0000E41A 63 40 0A AF             	call	IGNBLK		; ignore leading blanks
    863 0000E41E B0 1F                   	lw		lr,r11		; restore link reg
    864 0000E420 80 1B                   	lw		r11,r8		; save the pointer
    865 0000E422 00 13                   	lw		r3,#0		; clear match flag
    866 0000E424                        EXLP
    867 0000E424 80 E1                   	lb		r1,[r8]		; get the program character
    868 0000E426 01 68                   	add		r8,r8,#1
    869 0000E428 90 E2                   	lb		r2,[r9]		; get the table character
    870 0000E42A 02 A9                   	bne		EXNGO		; If end of table,
    871 0000E42C B0 18                   	lw		r8,r11		;	restore the text pointer and...
    872 0000E42E 12 AE                   	br		EXGO		;   execute the default.
    873 0000E430                        EXNGO
    874 0000E430 3D 21                   	cmp		r1,r3		; Else check for period...
    875 0000E432 10 A8                   	beq		EXGO		; if so, execute
    876 0000E434 07 40 5F 32             	and		r2,#0x7f	; ignore the table's high bit
    877 0000E438 1D 22                   	cmp		r2,r1		;		is there a match?
    878 0000E43A 07 A8                   	beq		EXMAT
    879 0000E43C 04 6A                   	add		r10,r10,#4	;if not, try the next entry
    880 0000E43E B0 18                   	lw		r8,r11		; reset the program pointer
    881 0000E440 00 13                   	lw		r3,#0		; sorry, no match
    882 0000E442                        EX1
    883 0000E442 01 69                   	add		r9,r9,#1
    884 0000E444 9F E1                   	lb		r1,-1[r9]	; get to the end of the entry
    885 0000E446 FD BB                   	bpl		EX1
    886 0000E448 ED BE                   	br		EXLP		; back for more matching
    887 0000E44A                        EXMAT
    888 0000E44A 02 40 0E 13             	lw		r3,#'.'		; we've got a match so far
    889 0000E44E 01 69                   	add		r9,r9,#1
    890 0000E450 9F E1                   	lb		r1,-1[r9]	; end of table entry?
    891 0000E452 E8 BB                   	bpl		EXLP		; if not, go back for more
    892 0000E454                        EXGO
    893 0000E454 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
    894 0000E458 04 A8                   	beq		EXGO1
    895 0000E45A E0 4F 06 AF             	call	Recv
    896 0000E45E E2 4F 0B AF             	call	RecvDispatch
    897 0000E462                        EXGO1
    898 0000E462 A0 FB                   	lw		r11,[r10]	; execute the appropriate routine
    899 0000E464 B0 80                   	jmp		[r11]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 16
noc_boot41.a
                                        
                                        
                                        ;    lb      r1,[r8]     ; get token from text space
                                        ;    bpl
                                        ;    and     r1,#0x7f
                                        ;    shl     r1,#2       ; * 4 - word offset
                                        ;    add     r1,r1,#TAB1_1
                                        ;    lw      r1,[r1]
                                        ;    jmp     [r1]
                                        
                                            
                                        ;
                                        ; What follows is the code to execute direct and statement
                                        ; commands. Control is transferred to these points via the command
                                        ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                                        ; After the command is executed, control is transferred to other
                                        ; sections as follows:
                                        ;
                                        ; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                                        ; For 'RUN': go execute the first stored line if any; else go
                                        ; back to the warm start point.
                                        ; For 'GOTO' and 'GOSUB': go execute the target line.
                                        ; For 'RETURN' and 'NEXT'; go back to saved return line.
                                        ; For all others: if 'CURRNT' is 0, go to warm start; else go
                                        ; execute next command. (This is done in 'FINISH'.)
                                        ;
                                        ;******************************************************************
                                        ;
                                        ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                                        ;
                                        ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                                        ;
                                        ; 'STOP<CR>' goes back to WSTART
                                        ;
                                        ; 'RUN<CR>' finds the first stored line, stores its address
                                        ; in CURRNT, and starts executing it. Note that only those
                                        ; commands in TAB2 are legal for a stored program.
                                        ;
                                        ; RUN ON <node number> sends a run command to the specified node
                                        ;
                                        ; There are 3 more entries in 'RUN':
                                        ; 'RUNNXL' finds next line, stores it's address and executes it.
                                        ; 'RUNTSL' stores the address of this line and executes it.
                                        ; 'RUNSML' continues the execution on same line.
                                        ;
                                        ; 'GOTO expr<CR>' evaluates the expression, finds the target
                                        ; line, and jumps to 'RUNTSL' to do it.
                                        ;
    948 0000E466                        NEW
    949 0000E466 42 40 07 AF             	call	ENDCHK
    950 0000E46A 2C 4E 0C F1             	lw		r1,TXTBGN
    951 0000E46E 12 40 06 D1             	sw		r1,TXTUNF	;	set the end pointer
    952 0000E472 2B AF                   	call    clearVars
                                        
    954 0000E474                        STOP
    955 0000E474 42 40 00 AF             	call	ENDCHK
    956 0000E478 45 BE                   	br		WSTART		; WSTART will reset the stack
                                        
    958 0000E47A                        RUN
    959 0000E47A 41 40 0D AF             	call	ENDCHK
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 17
noc_boot41.a
    960 0000E47E 2C 4E 0C F8             	lw		r8,TXTBGN	;	set pointer to beginning
    961 0000E482 11 40 06 D8             	sw		r8,CURRNT
    962 0000E486 21 AF                   	call    clearVars
                                        
    964 0000E488                        RUNNXL					; RUN <next line>
    965 0000E488 11 40 06 F1             	lw		r1,CURRNT	; executing a program?
    966 0000E48C 3B B8                   	beq		WSTART		; if not, we've finished a direct stat.
    967 0000E48E 00 11                   	lw		r1,#0	    ; else find the next line number
    968 0000E490 80 19                   	lw		r9,r8
    969 0000E492 49 40 0D AF             	call	FNDLNP		; search for the next line
    970 0000E496 36 B7                   	bgtu	WSTART		; if we've fallen off the end, stop
                                        
    972 0000E498                        RUNTSL					; RUN <this line>
    973 0000E498 11 40 06 D9             	sw		r9,CURRNT	; set CURRNT to point to the line no.
    974 0000E49C 92 18                   	lea		r8,2[r9]	; set the text pointer to
                                        
    976 0000E49E                        RUNSML                  ; RUN <same line>
    977 0000E49E 62 40 0E AF             	call	CHKIO		; see if a control-C was pressed
    978 0000E4A2 33 4E 0C 19             	lea		r9,TAB2		; find command in TAB2
    979 0000E4A6 3B 4E 0E 1A             	lea		r10,TAB2_1
    980 0000E4AA B6 BE                   	br		EXEC		; and execute it
                                        
    982 0000E4AC                        GOTO
    983 0000E4AC 1D 40 01 AF             	call	OREXPR		;evaluate the following expression
    984 0000E4B0 10 15                   	lw      r5,r1
    985 0000E4B2 40 40 01 AF             	call	ENDCHK		;must find end of line
    986 0000E4B6 50 11                   	lw      r1,r5
    987 0000E4B8 48 40 02 AF             	call	FNDLN		; find the target line
    988 0000E4BC ED B8                   	beq		RUNTSL		; go do it
    989 0000E4BE 45 4F 09 11             	lea		r1,msgBadGotoGosub
    990 0000E4C2 40 40 0F AE             	br		ERROR		; no such line no.
                                        
                                        
    993 0000E4C6                        _clr
    994 0000E4C6 01 AF                       call    clearVars
    995 0000E4C8 57 AE                       br      FINISH
                                        
                                        ; Clear the variable area of memory
    998 0000E4CA                        clearVars
    999 0000E4CA FC 6E                       sub     sp,sp,#4
   1000 0000E4CC E0 DF                       sw      lr,[sp]
   1001 0000E4CE E2 D6                       sw      r6,2[sp]
   1002 0000E4D0 80 40 00 16                 lw      r6,#2048    ; number of words to clear
   1003 0000E4D4 12 40 08 F1                 lw      r1,VARBGN
   1004 0000E4D8                        cv1
   1005 0000E4D8 10 D0                       sw      r0,[r1]
   1006 0000E4DA 04 61                       add     r1,r1,#4
   1007 0000E4DC FF 66                       sub		r6,r6,#1
   1008 0000E4DE FC B9                       bne     cv1
   1009 0000E4E0 E0 FF                       lw      lr,[sp]
   1010 0000E4E2 E2 F6                       lw      r6,2[sp]
   1011 0000E4E4 04 6E                       add     sp,sp,#4
   1012 0000E4E6 F0 80                       ret    
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; LIST
                                        ;
                                        ; LISTX has two forms:
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 18
noc_boot41.a
                                        ; 'LIST<CR>' lists all saved lines
                                        ; 'LIST #<CR>' starts listing at the line #
                                        ; Control-S pauses the listing, control-C stops it.
                                        ;
                                        
   1025 0000E4E8                        LISTX
   1026 0000E4E8 5B 40 02 AF             	call	TSTNUM		; see if there's a line no.
   1027 0000E4EC 10 15                   	lw      r5,r1
   1028 0000E4EE 3E 40 03 AF             	call	ENDCHK		; if not, we get a zero
   1029 0000E4F2 50 11                   	lw      r1,r5
   1030 0000E4F4 46 40 04 AF             	call	FNDLN		; find this or next line
   1031 0000E4F8                        LS1
   1032 0000E4F8 05 B7                   	bgtu	WSTART		; warm start if we passed the end
                                        
   1034 0000E4FA 90 11                   	lw		r1,r9
   1035 0000E4FC 57 40 08 AF             	call	PRTLN		; print the line
   1036 0000E500 10 19                   	lw		r9,r1		; set pointer for next
   1037 0000E502 5F 40 0C AF             	call	CHKIO		; check for listing halt request
   1038 0000E506 06 A8                   	beq		LS3
   1039 0000E508 FE 4F 1D 10             	cmp		r1,#CTRLS	; pause the listing?
   1040 0000E50C 03 A9                   	bne		LS3
   1041 0000E50E                        LS2
   1042 0000E50E 5F 40 06 AF             	call	CHKIO		; if so, wait for another keypress
   1043 0000E512 FD B8                   	beq		LS2
   1044 0000E514                        LS3
   1045 0000E514 00 11                   	lw		r1,#0
   1046 0000E516 45 40 0B AF             	call	FNDLNP		; find the next line
   1047 0000E51A EE BE                   	br		LS1
                                        
                                        
                                        ;******************************************************************
                                        ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                                        ; where '....' is a list of expressions, formats, back-arrows,
                                        ; and strings.	These items a separated by commas.
                                        ;
                                        ; A format is a pound sign followed by a number.  It controls
                                        ; the number of spaces the value of an expression is going to
                                        ; be printed in.  It stays effective for the rest of the print
                                        ; command unless changed by another format.  If no format is
                                        ; specified, 11 positions will be used.
                                        ;
                                        ; A string is quoted in a pair of single- or double-quotes.
                                        ;
                                        ; An underline (back-arrow) means generate a <CR> without a <LF>
                                        ;
                                        ; A <CR LF> is generated after the entire list has been printed
                                        ; or if the list is empty.  If the list ends with a semicolon,
                                        ; however, no <CR LF> is generated.
                                        ;
                                        
   1070 0000E51C                        PRINT
   1071 0000E51C 0B 15                   	lw		r5,#11		; D4 = number of print spaces
   1072 0000E51E 58 40 05 AF             	call	TSTC		; if null list and ":"
   1073 0000E522 3A 08                   	db	':',PR2-*+1
   1074 0000E524 5F 40 0B AF             	call	CRLF		; give CR-LF and continue
   1075 0000E528 BA BE                   	br		RUNSML		;		execution on the same line
   1076 0000E52A                        PR2
   1077 0000E52A 57 40 0F AF             	call	TSTC		;if null list and <CR>
   1078 0000E52E 0D 08                   	db	CR,PR0-*+1
   1079 0000E530 5F 40 05 AF             	call	CRLF		;also give CR-LF and
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 19
noc_boot41.a
   1080 0000E534 A9 BE                   	br		RUNNXL		;execute the next line
   1081 0000E536                        PR0
   1082 0000E536 57 40 09 AF             	call	TSTC		;else is it a format?
   1083 0000E53A 23 0A                   	db	'#',PR1-*+1
   1084 0000E53C 18 40 09 AF             	call	OREXPR		; yes, evaluate expression
   1085 0000E540 10 15                   	lw		r5,r1		; and save it as print width
   1086 0000E542 0B AE                   	br		PR3		; look for more to print
   1087 0000E544                        PR1
   1088 0000E544 57 40 02 AF             	call	TSTC	;	is character expression? (MRL)
   1089 0000E548 24 0C                   	db	'$',PR4-*+1
   1090 0000E54A 18 40 02 AF             	call	OREXPR	;	yep. Evaluate expression (MRL)
   1091 0000E54E EB 4F 03 AF             	call	GOOUT	;	print low byte (MRL)
   1092 0000E552 03 AE                   	br		PR3		;look for more. (MRL)
   1093 0000E554                        PR4
   1094 0000E554 4B 40 00 AF             	call	QTSTG	;	is it a string?
                                        	; the following branch must occupy only two bytes!
   1096 0000E558 09 AE                   	br		PR8		;	if not, must be an expression
   1097 0000E55A                        PR3
   1098 0000E55A 56 40 07 AF             	call	TSTC	;	if ",", go find next
   1099 0000E55E 2C 08                   	db	',',PR6-*+1
   1100 0000E560 39 40 08 AF             	call	FIN		;in the list.
   1101 0000E564 E8 BE                   	br		PR0
   1102 0000E566                        PR6
   1103 0000E566 5D 40 0A AF             	call	CRLF		;list ends here
   1104 0000E56A 06 AE                   	br		FINISH
   1105 0000E56C                        PR8
   1106 0000E56C 17 40 01 AF             	call	OREXPR		; evaluate the expression
   1107 0000E570 50 12                   	lw		r2,r5		; set the width
   1108 0000E572 4C 40 0D AF             	call	PRTNUM		; print its value
   1109 0000E576 F1 BE                   	br		PR3			; more to print?
                                        
   1111 0000E578                        FINISH
   1112 0000E578 38 40 0C AF             	call	FIN		; Check end of command
   1113 0000E57C 3B 40 00 AE             	jmp		QWHAT	; print "What?" if wrong
                                        
                                        
                                        ;*******************************************************************
                                        ;
                                        ; *** GOSUB *** & RETURN ***
                                        ;
                                        ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                                        ; except that the current text pointer, stack pointer, etc. are
                                        ; saved so that execution can be continued after the subroutine
                                        ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                                        ; recursive), the save area must be stacked.  The stack pointer
                                        ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                                        ; If we are in the main routine, 'STKGOS' is zero (this was done
                                        ; in the initialization section of the interpreter), but we still
                                        ; save it as a flag for no further 'RETURN's.
                                        ;
   1130 0000E580                        GOSUB
   1131 0000E580 46 40 04 AF             	call	PUSHA		; save the current 'FOR' parameters
   1132 0000E584 16 40 05 AF             	call	OREXPR		; get line number
   1133 0000E588 41 40 0A AF             	call	FNDLN		; find the target line
   1134 0000E58C 04 A8                   	beq		gosub1
   1135 0000E58E 45 4F 09 11             	lea		r1,msgBadGotoGosub
   1136 0000E592 3A 40 07 AE             	br		ERROR		; if not there, say "How?"
   1137 0000E596                        gosub1
   1138 0000E596 FA 6E                   	sub		sp,sp,#6
   1139 0000E598 E0 D8                   	sw		r8,[sp]		; save text pointer
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 20
noc_boot41.a
   1140 0000E59A 11 40 06 F1             	lw		r1,CURRNT
   1141 0000E59E E2 D1                   	sw		r1,2[sp]	; found it, save old 'CURRNT'...
   1142 0000E5A0 11 40 08 F1             	lw		r1,STKGOS
   1143 0000E5A4 E4 D1                   	sw		r1,4[sp]	; and 'STKGOS'
   1144 0000E5A6 11 40 0C D0             	sw		r0,LOPVAR	; load new values
   1145 0000E5AA 11 40 08 DE             	sw		sp,STKGOS
   1146 0000E5AE 74 BE                   	br		RUNTSL
                                        
                                        
                                        ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                                        ; returns the execution to the command after the most recent
                                        ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                                        ; a 'GOSUB' and is thus an error.
                                        ;
   1154 0000E5B0                        RETURN
   1155 0000E5B0 38 40 02 AF             	call	ENDCHK		; there should be just a <CR>
   1156 0000E5B4 11 40 08 F1             	lw		r1,STKGOS	; get old stack pointer
   1157 0000E5B8 04 A9                   	bne		return1
   1158 0000E5BA 47 4F 06 11             	lea		r1,msgRetWoGosub
   1159 0000E5BE 39 40 01 AE             	br		ERROR		; if zero, it doesn't exist
   1160 0000E5C2                        return1
   1161 0000E5C2 10 1E                   	lw		sp,r1		; else restore it
   1162 0000E5C4 E4 F1                   	lw		r1,4[sp]
   1163 0000E5C6 11 40 08 D1             	sw		r1,STKGOS	; and the old 'STKGOS'
   1164 0000E5CA E2 F1                   	lw		r1,2[sp]
   1165 0000E5CC 11 40 06 D1             	sw		r1,CURRNT	; and the old 'CURRNT'
   1166 0000E5D0 E0 F8                   	lw		r8,[sp]		; and the old text pointer
   1167 0000E5D2 06 6E                   	add		sp,sp,#6
   1168 0000E5D4 42 40 06 AF             	call	POPA		;and the old 'FOR' parameters
   1169 0000E5D8 CF BE                   	br		FINISH		;and we are back home
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** FOR *** & NEXT ***
                                        ;
                                        ; 'FOR' has two forms:
                                        ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                                        ; The second form means the same thing as the first form with a
                                        ; STEP of positive 1.  The interpreter will find the variable 'var'
                                        ; and set its value to the current value of 'exp1'.  It also
                                        ; evaluates 'exp2' and 'exp1' and saves all these together with
                                        ; the text pointer, etc. in the 'FOR' save area, which consisits of
                                        ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                                        ; already something in the save area (indicated by a non-zero
                                        ; 'LOPVAR'), then the old save area is saved on the stack before
                                        ; the new values are stored.  The interpreter will then dig in the
                                        ; stack and find out if this same variable was used in another
                                        ; currently active 'FOR' loop.  If that is the case, then the old
                                        ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                                        ;
   1191 0000E5DA                        FOR
   1192 0000E5DA 43 40 07 AF             	call	PUSHA		; save the old 'FOR' save area
   1193 0000E5DE 34 40 03 AF             	call	SETVAL		; set the control variable
   1194 0000E5E2 11 40 0C D1             	sw		r1,LOPVAR	; save its address
   1195 0000E5E6 39 4E 0D 19             	lea		r9,TAB5		; use 'EXEC' to test for 'TO'
   1196 0000E5EA 3F 4E 02 1A             	lea		r10,TAB5_1
   1197 0000E5EE 14 BE                   	jmp		EXEC
   1198 0000E5F0                        FR1
   1199 0000E5F0 12 40 0F AF             	call	OREXPR		; evaluate the limit
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 21
noc_boot41.a
   1200 0000E5F4 12 40 00 D1             	sw		r1,LOPLMT	; save that
   1201 0000E5F8 3A 4E 00 19             	lea		r9,TAB6		; use 'EXEC' to look for the
   1202 0000E5FC 3F 4E 06 1A             	lea		r10,TAB6_1	; word 'STEP'
   1203 0000E600 0B BE                   	jmp		EXEC
   1204 0000E602                        FR2
   1205 0000E602 12 40 06 AF             	call	OREXPR		; found it, get the step value
   1206 0000E606 01 AE                   	br		FR4
   1207 0000E608                        FR3
   1208 0000E608 01 11                   	lw		r1,#1		; not found, step defaults to 1
   1209 0000E60A                        FR4
   1210 0000E60A 11 40 0E D1             	sw		r1,LOPINC	; save that too
                                        
   1212 0000E60E                        FR5
   1213 0000E60E 11 40 06 F2             	lw		r2,CURRNT
   1214 0000E612 12 40 02 D2             	sw		r2,LOPLN	; save address of current line number
   1215 0000E616 12 40 04 D8             	sw		r8,LOPPT	; and text pointer
                                        
                                        
   1218 0000E61A E0 13                   	lw		r3,sp		; dig into the stack to find 'LOPVAR'
   1219 0000E61C 11 40 0C F6             	lw		r6,LOPVAR
   1220 0000E620 01 AE                   	br		FR7
   1221 0000E622                        FR6
   1222 0000E622 3A 13                   	lea		r3,10[r3]	; look at next stack frame
   1223 0000E624                        FR7
   1224 0000E624 30 F2                   	lw		r2,[r3]		; is it zero?
   1225 0000E626 08 A8                   	beq		FR8			; if so, we're done
   1226 0000E628 6D 22                   	cmp		r2,r6		; same as current LOPVAR?
   1227 0000E62A FB B9                   	bne		FR6			; nope, look some more
                                        
   1229 0000E62C 30 11                       lw      r1,r3       ; Else remove 5 words from...
   1230 0000E62E 3A 12                   	lea		r2,10[r3]   ; inside the stack.
   1231 0000E630 E0 13                   	lw		r3,sp		
   1232 0000E632 3F 40 04 AF             	call	MVDOWN
   1233 0000E636 0A 6E                   	add		sp,sp,#10	; set the SP 5 words up
   1234 0000E638                        FR8
   1235 0000E638 9F BE                       br	    FINISH		; and continue execution
                                        
                                        
                                        ; 'NEXT var' serves as the logical (not necessarily physical) end
                                        ; of the 'FOR' loop.  The control variable 'var' is checked with
                                        ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                                        ; the stack to find the right one and purges all those that didn't
                                        ; match.  Either way, it then adds the 'STEP' to that variable and
                                        ; checks the result with against the limit value.  If it is within
                                        ; the limit, control loops back to the command following the
                                        ; 'FOR'.  If it's outside the limit, the save area is purged and
                                        ; execution continues.
                                        ;
   1248 0000E63A                        NEXT
   1249 0000E63A 00 11                   	lw		r1,#0		; don't allocate it
   1250 0000E63C 1E 40 0D AF             	call	TSTV		; get address of variable
   1251 0000E640 04 A9                   	bne		NX4
   1252 0000E642 43 4F 05 11             	lea		r1,msgNextVar
   1253 0000E646 34 40 0D AE             	br		ERROR		; if no variable, say "What?"
   1254 0000E64A                        NX4
   1255 0000E64A 10 19                   	lw		r9,r1		; save variable's address
   1256 0000E64C                        NX0
   1257 0000E64C 11 40 0C F1             	lw		r1,LOPVAR	; If 'LOPVAR' is zero, we never...
   1258 0000E650 04 A9                   	bne		NX5         ; had a FOR loop
   1259 0000E652 42 4F 02 11             	lea		r1,msgNextFor
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 22
noc_boot41.a
   1260 0000E656 34 40 05 AE             	br		ERROR		
   1261 0000E65A                        NX5
   1262 0000E65A 9D 21                   	cmp		r1,r9		; else we check them
   1263 0000E65C 03 A8                   	beq		NX2			; OK, they agree
   1264 0000E65E 3E 40 01 AF             	call	POPA		; nope, let's see the next frame
   1265 0000E662 F4 BE                   	br		NX0
   1266 0000E664                        NX2
   1267 0000E664 90 F1                   	lw		r1,[r9]		; get control variable's value
   1268 0000E666 11 40 0E F2             	lw		r2,LOPINC
   1269 0000E66A 20 21                   	add		r1,r2		; add in loop increment
                                        ;	BVS.L	QHOW		say "How?" for 32-bit overflow
   1271 0000E66C 90 D1                   	sw		r1,[r9]		; save control variable's new value
   1272 0000E66E 12 40 00 F3             	lw		r3,LOPLMT	; get loop's limit value
   1273 0000E672 26 22                   	or		r2,r2       ; check loop increment
   1274 0000E674 03 AB                   	bpl		NX1			; branch if loop increment is positive
   1275 0000E676 3D 21                   	cmp		r1,r3		; test against limit
   1276 0000E678 0A A0                   	blt		NXPurge
   1277 0000E67A 02 AE                   	br      NX3
   1278 0000E67C                        NX1
   1279 0000E67C 3D 21                   	cmp		r1,r3
   1280 0000E67E 07 A3                   	bgt		NXPurge
   1281 0000E680                        NX3	
   1282 0000E680 12 40 02 F8             	lw		r8,LOPLN	; Within limit, go back to the...
   1283 0000E684 11 40 06 D8             	sw		r8,CURRNT
   1284 0000E688 12 40 04 F8             	lw		r8,LOPPT	; saved 'CURRNT' and text pointer.
   1285 0000E68C 75 BE                   	br		FINISH
                                        
   1287 0000E68E                        NXPurge
   1288 0000E68E 3C 40 09 AF                 call    POPA        ; purge this loop
   1289 0000E692 72 BE                       br      FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                                        ;
                                        ; 'REM' can be followed by anything and is ignored by the
                                        ; interpreter.
                                        ;
                                        ;REM
                                        ;    br	    IF2		    ; skip the rest of the line
                                        
                                        ; 'IF' is followed by an expression, as a condition and one or
                                        ; more commands (including other 'IF's) separated by colons.
                                        ; Note that the word 'THEN' is not used.  The interpreter evaluates
                                        ; the expression.  If it is non-zero, execution continues.  If it
                                        ; is zero, the commands that follow are ignored and execution
                                        ; continues on the next line.
                                        ;
   1309 0000E694                        IF
   1310 0000E694 DE AF                       call	OREXPR		; evaluate the expression
   1311 0000E696                        IF1
   1312 0000E696 16 21                       or      r1,r1       ; is it zero?
   1313 0000E698 02 B9                       bne	    RUNSML		; if not, continue
   1314 0000E69A                        IF2
   1315 0000E69A 80 19                       lw		r9,r8		; set lookup pointer
   1316 0000E69C 00 11                   	lw		r1,#0		; find line #0 (impossible)
   1317 0000E69E 3A 40 0D AF             	call	FNDSKP		; if so, skip the rest of the line
   1318 0000E6A2 E2 4F 0F A7             	bgtu	WSTART		; if no next line, do a warm start
   1319 0000E6A6                        IF3
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 23
noc_boot41.a
   1320 0000E6A6 EF 4F 07 AE             	br		RUNTSL		; run the next line
                                        
                                        
                                        ; INPUT is called first and establishes a stack frame
   1324 0000E6AA                        INPERR
   1325 0000E6AA 11 40 0A FE             	lw		sp,STKINP	; restore the old stack pointer
   1326 0000E6AE E4 F8                   	lw		r8,4[sp]
   1327 0000E6B0 11 40 06 D8             	sw		r8,CURRNT	; and old 'CURRNT'
   1328 0000E6B4 E2 F8                   	lw		r8,2[sp]	; and old text pointer
   1329 0000E6B6 0A 6E                   	add		sp,sp,#10	; fall through will subtract 10
                                        
                                        ; 'INPUT' is like the 'PRINT' command, and is followed by a list
                                        ; of items.  If the item is a string in single or double quotes,
                                        ; or is an underline (back arrow), it has the same effect as in
                                        ; 'PRINT'.  If an item is a variable, this variable name is
                                        ; printed out followed by a colon, then the interpreter waits for
                                        ; an expression to be typed in.  The variable is then set to the
                                        ; value of this expression.  If the variable is preceeded by a
                                        ; string (again in single or double quotes), the string will be
                                        ; displayed followed by a colon.  The interpreter the waits for an
                                        ; expression to be entered and sets the variable equal to the
                                        ; expression's value.  If the input expression is invalid, the
                                        ; interpreter will print "What?", "How?", or "Sorry" and reprint
                                        ; the prompt and redo the input.  The execution will not terminate
                                        ; unless you press control-C.  This is handled in 'INPERR'.
                                        ;
   1346 0000E6B8                        INPUT
   1347 0000E6B8 F6 6E                   	sub		sp,sp,#10	; allocate stack frame
   1348 0000E6BA E8 D5                   	sw      r5,8[sp]
   1349 0000E6BC                        IP6
   1350 0000E6BC E0 D8                   	sw		r8,[sp]		; save in case of error
   1351 0000E6BE 3F 40 0B AF             	call	QTSTG		; is next item a string?
   1352 0000E6C2 06 AE                   	br		IP2			; nope - this branch must take only two bytes
   1353 0000E6C4 01 11                   	lw		r1,#1		; allocate var
   1354 0000E6C6 1A 40 08 AF             	call	TSTV		; yes, but is it followed by a variable?
   1355 0000E6CA 29 A8                   	beq     IP4		    ; if not, brnch
   1356 0000E6CC 10 1A                   	lw		r10,r1		; put away the variable's address
   1357 0000E6CE 10 AE                   	br		IP3			; if so, input to variable
   1358 0000E6D0                        IP2
   1359 0000E6D0 E2 D8                   	sw		r8,2[sp]	; save for 'PRTSTG'
   1360 0000E6D2 01 11                   	lw		r1,#1
   1361 0000E6D4 1A 40 01 AF             	call	TSTV		; must be a variable now
   1362 0000E6D8 04 A9                   	bne		IP7
   1363 0000E6DA 40 4F 05 11             	lea		r1,msgInputVar
   1364 0000E6DE 30 40 01 AE             	br		ERROR		; "What?" it isn't?
   1365 0000E6E2                        IP7
   1366 0000E6E2 10 1A                   	lw		r10,r1		; put away the variable's address
   1367 0000E6E4 80 E5                   	lb		r5,[r8]		; get ready for 'PRTSTG' by null terminating
   1368 0000E6E6 80 C0                   	sb		r0,[r8]
   1369 0000E6E8 E2 F1                   	lw		r1,2[sp]	; get back text pointer
   1370 0000E6EA 3C 40 09 AF             	call	PRTSTG		; print string as prompt
   1371 0000E6EE 80 C5                   	sb		r5,[r8]		; un-null terminate
   1372 0000E6F0                        IP3
   1373 0000E6F0 E2 D8                   	sw		r8,2[sp]	; save in case of error
   1374 0000E6F2 11 40 06 F1             	lw		r1,CURRNT
   1375 0000E6F6 E4 D1                   	sw		r1,4[sp]	; also save 'CURRNT'
   1376 0000E6F8 0F 11                   	lw		r1,#-1
   1377 0000E6FA 11 40 06 D1             	sw		r1,CURRNT	; flag that we are in INPUT
   1378 0000E6FE 11 40 0A DE             	sw		sp,STKINP	; save the stack pointer too
   1379 0000E702 E6 DA                   	sw		r10,6[sp]	; save the variable address
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 24
noc_boot41.a
   1380 0000E704 03 40 0A 11             	lw		r1,#':'		; print a colon first
   1381 0000E708 30 40 06 AF             	call	GETLN		; then get an input line
   1382 0000E70C 13 40 0E 18             	lea		r8,BUFFER	; point to the buffer
   1383 0000E710 A0 AF                   	call	OREXPR		; evaluate the input
   1384 0000E712 E6 FA                   	lw		r10,6[sp]	; restore the variable address
   1385 0000E714 A0 D1                   	sw		r1,[r10]	; save value in variable
   1386 0000E716 E4 F1                   	lw		r1,4[sp]	; restore old 'CURRNT'
   1387 0000E718 11 40 06 D1             	sw		r1,CURRNT
   1388 0000E71C E2 F8                   	lw		r8,2[sp]	; and the old text pointer
   1389 0000E71E                        IP4
   1390 0000E71E 48 40 05 AF             	call	TSTC		; is the next thing a comma?
   1391 0000E722 2C 04                   	db	',',IP5-*+1
   1392 0000E724 CB BE                   	br		IP6			; yes, more items
   1393 0000E726                        IP5
   1394 0000E726 E8 F5                       lw      r5,8[sp]
   1395 0000E728 0A 6E                   	add		sp,sp,#10	; clean up the stack
   1396 0000E72A 26 BE                   	jmp		FINISH
                                        
                                        
   1399 0000E72C                        DEFLT
   1400 0000E72C 80 E1                       lb      r1,[r8]
   1401 0000E72E FF 4F 13 10                 cmp     r1,#CR      ; empty line is OK
   1402 0000E732 22 B8                   	beq	    FINISH	    ; else it is 'LET'
                                        
                                        
                                        ; 'LET' is followed by a list of items separated by commas.
                                        ; Each item consists of a variable, an equals sign, and an
                                        ; expression.  The interpreter evaluates the expression and sets
                                        ; the variable to that value.  The interpreter will also handle
                                        ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                                        ;
   1411 0000E734                        LET
   1412 0000E734 29 40 08 AF                 call	SETVAL		; do the assignment
   1413 0000E738 47 40 08 AF             	call	TSTC		; check for more 'LET' items
   1414 0000E73C 2C 04                   	db	',',LT1-*+1
   1415 0000E73E FA BE                   	br	    LET
   1416 0000E740                        LT1
   1417 0000E740 1B BE                       br	    FINISH		; until we are finished.
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** LOAD *** & SAVE ***
                                        ;
                                        ; These two commands transfer a program to/from an auxiliary
                                        ; device such as a cassette, another computer, etc.  The program
                                        ; is converted to an easily-stored format: each line starts with
                                        ; a colon, the line no. as 4 hex digits, and the rest of the line.
                                        ; At the end, a line starting with an '@' sign is sent.  This
                                        ; format can be read back with a minimum of processing time by
                                        ; the Butterfly.
                                        ;
   1432 0000E742                        LOAD
   1433 0000E742 2C 4E 0C F8             	lw		r8,TXTBGN	; set pointer to start of prog. area
   1434 0000E746 00 40 0D 11             	lw		r1,#CR		; For a CP/M host, tell it we're ready...
   1435 0000E74A DB 4F 09 AF             	call	GOAUXO		; by sending a CR to finish PIP command.
   1436 0000E74E                        LOD1
   1437 0000E74E DB 4F 09 AF             	call	GOAUXI		; look for start of line
   1438 0000E752 FD BA                   	bmi		LOD1
   1439 0000E754 FC 4F 10 10             	cmp		r1,#'@'		; end of program?
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 25
noc_boot41.a
   1440 0000E758 1B A8                   	beq		LODEND
   1441 0000E75A FE 4F 16 10             	cmp     r1,#0x1A    ; or EOF marker
   1442 0000E75E 18 A8                   	beq     LODEND
   1443 0000E760 FC 4F 16 10             	cmp		r1,#':'		; if not, is it start of line?
   1444 0000E764 F4 B9                   	bne		LOD1		; if not, wait for it
   1445 0000E766 18 AF                   	call	GCHAR		; get line number
   1446 0000E768 80 C1                   	sb		r1,[r8]		; store it
   1447 0000E76A A1 31                   	shr		r1,#1
   1448 0000E76C A1 31                   	shr		r1,#1
   1449 0000E76E A1 31                   	shr		r1,#1
   1450 0000E770 A1 31                   	shr		r1,#1
   1451 0000E772 A1 31                   	shr		r1,#1
   1452 0000E774 A1 31                   	shr		r1,#1
   1453 0000E776 A1 31                   	shr		r1,#1
   1454 0000E778 A1 31                   	shr		r1,#1
   1455 0000E77A 81 C1                   	sb		r1,1[r8]
   1456 0000E77C 02 68                   	add		r8,r8,#2
   1457 0000E77E                        LOD2
   1458 0000E77E DA 4F 01 AF             	call	GOAUXI		; get another text char.
   1459 0000E782 FD BA                   	bmi		LOD2
   1460 0000E784 80 C1                   	sb		r1,[r8]
   1461 0000E786 01 68                   	add		r8,r8,#1	; store it
   1462 0000E788 FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
   1463 0000E78C F8 B9                   	bne		LOD2		; if not, go back for more
   1464 0000E78E DF BE                   	br		LOD1		; if so, start a new line
   1465 0000E790                        LODEND
   1466 0000E790 12 40 06 D8             	sw		r8,TXTUNF	; set end-of program pointer
   1467 0000E794 DB 4F 06 AE             	br		WSTART		; back to direct mode
                                        
                                        ; get character from input (16 bit value)
   1470 0000E798                        GCHAR
   1471 0000E798 FA 6E                   	sub		sp,sp,#6
   1472 0000E79A E0 DF                   	sw		lr,[sp]
   1473 0000E79C E2 D5                   	sw		r5,2[sp]
   1474 0000E79E E4 D6                   	sw		r6,4[sp]
   1475 0000E7A0 04 16                   	lw      r6,#4       ; repeat four times
   1476 0000E7A2 00 15                   	lw		r5,#0
   1477 0000E7A4                        GCHAR1
   1478 0000E7A4 D8 4F 0E AF             	call	GOAUXI		; get a char
   1479 0000E7A8 FD BA                   	bmi		GCHAR1
   1480 0000E7AA 0D AF                   	call	asciiToHex
   1481 0000E7AC 81 35                   	shl		r5,#1
   1482 0000E7AE 81 35                   	shl		r5,#1
   1483 0000E7B0 81 35                   	shl		r5,#1
   1484 0000E7B2 81 35                   	shl		r5,#1
   1485 0000E7B4 16 25                   	or		r5,r1
   1486 0000E7B6 FF 66                   	sub		r6,r6,#1
   1487 0000E7B8 F5 B9                   	bne     GCHAR1
   1488 0000E7BA 50 11                   	lw		r1,r5
   1489 0000E7BC E0 FF                   	lw		lr,[sp]
   1490 0000E7BE E2 F5                   	lw		r5,2[sp]
   1491 0000E7C0 E4 F6                   	lw		r6,4[sp]
   1492 0000E7C2 06 6E                   	add     sp,sp,#6
   1493 0000E7C4 F0 80                   	ret
                                        
                                        ; convert an ascii char to hex code
                                        ; input
                                        ;	r2 = char to convert
                                        
   1499 0000E7C6                        asciiToHex
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 26
noc_boot41.a
   1500 0000E7C6 FC 4F 17 10             	cmp		r1,#'9'
   1501 0000E7CA 01 A2                   	ble		a2h1		; less than '9'
   1502 0000E7CC F9 61                   	sub		r1,r1,#7	; shift 'A' to '9'+1
   1503 0000E7CE                        a2h1
   1504 0000E7CE D0 61                   	sub		r1,r1,#'0'	;
   1505 0000E7D0 00 40 5F 31             	and		r1,#15		; make sure a nybble
   1506 0000E7D4 F0 80                   	ret
                                        
                                        ; output a CR LF sequence to auxillary output
                                        ; Registers Affected
                                        ;   r3 = LF
   1511 0000E7D6                        AUXOCRLF
   1512 0000E7D6 FE 6E                       sub     sp,sp,#2
   1513 0000E7D8 E0 DF                       sw      lr,[sp]
   1514 0000E7DA 00 40 0D 11                 lw      r1,#CR
   1515 0000E7DE D6 4F 0F AF                 call    GOAUXO
   1516 0000E7E2 0A 11                       lw      r1,#LF
   1517 0000E7E4 D6 4F 0C AF                 call    GOAUXO
   1518 0000E7E8 E0 FF                       lw      lr,[sp]
   1519 0000E7EA 02 6E                   	add		sp,sp,#2
   1520 0000E7EC F0 80                       ret
                                        
                                        
                                        ; convert nybble in r2 to ascii hex char2
                                        ; r2 = character to convert
                                        
   1526 0000E7EE                        toAsciiHex
   1527 0000E7EE 00 40 5F 31             	and		r1,#15		; make sure it's a nybble
   1528 0000E7F2 FF 4F 16 10             	cmp		r1,#10		; > 10 ?
   1529 0000E7F6 01 A0                   	blt		tah1
   1530 0000E7F8 07 61                   	add		r1,r1,#7	; bump it up to the letter 'A'
   1531 0000E7FA                        tah1
   1532 0000E7FA 30 61                   	add		r1,r1,#'0'	; bump up to ascii '0'
   1533 0000E7FC F0 80                   	ret
                                        
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** POKE *** & SYSX ***
                                        ;
                                        ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                                        ; address specified by 'expr1'.
                                        ;
                                        ; 'SYSX expr' jumps to the machine language subroutine whose
                                        ; starting address is specified by 'expr'.  The subroutine can use
                                        ; all registers but must leave the stack the way it found it.
                                        ; The subroutine returns to the interpreter by executing an RET.
                                        ;
   1549 0000E7FE                        POKE
   1550 0000E7FE FE 6E                   	sub		sp,sp,#2
   1551 0000E800 28 AF                   	call	OREXPR		; get the memory address
   1552 0000E802 41 40 03 AF             	call	TSTC		; it must be followed by a comma
   1553 0000E806 2C 10                   	db	',',PKER-*+1
   1554 0000E808 E0 D1                   	sw		r1,[sp]	    ; save the address
   1555 0000E80A 23 AF                   	call	OREXPR		; get the byte to be POKE'd
   1556 0000E80C E0 F2                   	lw		r2,[sp]	    ; get the address back
   1557 0000E80E 20 C1                   	sb		r1,[r2]		; store the byte in memory
   1558 0000E810 02 6E                   	add		sp,sp,#2
   1559 0000E812 EB 4F 01 AE             	br		FINISH
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 27
noc_boot41.a
   1560 0000E816                        PKER
   1561 0000E816 39 4F 0E 11             	lea		r1,msgComma
   1562 0000E81A 26 40 03 AE             	br		ERROR		; if no comma, say "What?"
                                        
                                        
   1565 0000E81E                        POKEW
   1566 0000E81E FE 6E                   	sub		sp,sp,#2
   1567 0000E820 18 AF                   	call	OREXPR		; get the memory address
   1568 0000E822 40 40 03 AF             	call	TSTC		; it must be followed by a comma
   1569 0000E826 2C F0                   	db	',',PKER-*+1
   1570 0000E828 E0 D1                   	sw		r1,[sp]	    ; save the address
   1571 0000E82A 13 AF                   	call	OREXPR		; get the byte to be POKE'd
   1572 0000E82C E0 F2                   	lw		r2,[sp]	    ; get the address back
   1573 0000E82E 20 D1                   	sw		r1,[r2]		; store the word in memory
   1574 0000E830 02 6E                   	add		sp,sp,#2
   1575 0000E832 EA 4F 01 AE             	jmp		FINISH
                                        
                                        
   1578 0000E836                        SYSX
   1579 0000E836 FE 6E                   	sub		sp,sp,#2
   1580 0000E838 0C AF                   	call	OREXPR		; get the subroutine's address
   1581 0000E83A 16 20                   	or		r0,r1		; make sure we got a valid address
   1582 0000E83C 04 A9                   	bne		sysx1
   1583 0000E83E 3F 4F 03 11             	lea		r1,msgSYSBad
   1584 0000E842 24 40 0F AE             	br		ERROR
   1585 0000E846                        sysx1
   1586 0000E846 E0 D8                   	sw		r8,[sp]	    ; save the text pointer
   1587 0000E848 10 8F                   	call	[r1]		; jump to the subroutine
   1588 0000E84A E0 F8                   	lw		r8,[sp]	    ; restore the text pointer
   1589 0000E84C 02 6E                   	add		sp,sp,#2
   1590 0000E84E E9 4F 03 AE             	br		FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** EXPR ***
                                        ;
                                        ; 'EXPR' evaluates arithmetical or logical expressions.
                                        ; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ; <EXPR>::=<EXPR2>
                                        ;	   <EXPR2><rel.op.><EXPR2>
                                        ; where <rel.op.> is one of the operators in TAB8 and the result
                                        ; of these operations is 1 if true and 0 if false.
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        ; where () are optional and (... are optional repeats.
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                                        ; as an index, functions can have an <EXPR> as arguments, and
                                        ; <EXPR4> can be an <EXPR> in parenthesis.
                                        ;
                                        
                                        
                                        ; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                                        ;
   1618 0000E852                        OREXPR
   1619 0000E852 FC 6E                   	sub		sp,sp,#4
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 28
noc_boot41.a
   1620 0000E854 E0 DF                   	sw		lr,[sp]
   1621 0000E856 0F AF                   	call	ANDEXPR		; get first <ANDEXPR>
   1622 0000E858                        XP_OR1
   1623 0000E858 E2 D1                   	sw		r1,2[sp]	; save <ANDEXPR> value
   1624 0000E85A 3B 4E 03 19             	lea		r9,TAB10		; look up a logical operator
   1625 0000E85E 40 4E 0C 1A             	lea		r10,TAB10_1
   1626 0000E862 DD 4F 09 AE             	jmp		EXEC		; go do it
                                        
   1628 0000E866                        XP_OR
   1629 0000E866 07 AF                       call    ANDEXPR
   1630 0000E868 E2 F2                       lw      r2,2[sp]
   1631 0000E86A 26 21                       or      r1,r2
   1632 0000E86C F5 BE                       br      XP_OR1
                                        
   1634 0000E86E                        XP_ORX
   1635 0000E86E E2 F1                   	lw		r1,2[sp]
   1636 0000E870 E0 FF                       lw      lr,[sp]
   1637 0000E872 04 6E                       add     sp,sp,#4
   1638 0000E874 F0 80                       ret
                                        
                                        
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ;
   1643 0000E876                        ANDEXPR
   1644 0000E876 FC 6E                   	sub		sp,sp,#4
   1645 0000E878 E0 DF                   	sw		lr,[sp]
   1646 0000E87A 37 AF                   	call	EXPR		; get first <EXPR>
   1647 0000E87C                        XP_AND1
   1648 0000E87C E2 D1                   	sw		r1,2[sp]	; save <EXPR> value
   1649 0000E87E 3A 4E 0F 19             	lea		r9,TAB9		; look up a logical operator
   1650 0000E882 40 4E 08 1A             	lea		r10,TAB9_1
   1651 0000E886 DC 4F 07 AE             	jmp		EXEC		; go do it
                                        
   1653 0000E88A                        XP_AND
   1654 0000E88A 2F AF                       call    EXPR
   1655 0000E88C E2 F2                       lw      r2,2[sp]
   1656 0000E88E 25 21                       and     r1,r2
   1657 0000E890 F5 BE                       br      XP_AND1
                                        
   1659 0000E892                        XP_ANDX
   1660 0000E892 E2 F1                   	lw		r1,2[sp]
   1661 0000E894 E0 FF                       lw      lr,[sp]
   1662 0000E896 04 6E                       add     sp,sp,#4
   1663 0000E898 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a digit
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if digit, otherwise 0
                                        ;
   1672 0000E89A                        isDigit
   1673 0000E89A FD 4F 10 10                 cmp     r1,#'0'
   1674 0000E89E 05 A0                       blt     isDigitFalse
   1675 0000E8A0 FC 4F 17 10                 cmp     r1,#'9'
   1676 0000E8A4 02 A3                       bgt     isDigitFalse
   1677 0000E8A6 01 11                       lw      r1,#1
   1678 0000E8A8 F0 80                       ret
   1679 0000E8AA                        isDigitFalse
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 29
noc_boot41.a
   1680 0000E8AA 00 11                       lw      r1,#0
   1681 0000E8AC F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphabetic
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1690 0000E8AE                        isAlpha
   1691 0000E8AE FB 4F 1F 10                 cmp     r1,#'A'
   1692 0000E8B2 0B A0                       blt     isAlphaFalse
   1693 0000E8B4 FA 4F 16 10                 cmp     r1,#'Z'
   1694 0000E8B8 06 A2                       ble     isAlphaTrue
   1695 0000E8BA F9 4F 1F 10                 cmp     r1,#'a'
   1696 0000E8BE 05 A0                       blt     isAlphaFalse
   1697 0000E8C0 F8 4F 16 10                 cmp     r1,#'z'
   1698 0000E8C4 02 A3                       bgt     isAlphaFalse
   1699 0000E8C6                        isAlphaTrue
   1700 0000E8C6 01 11                       lw      r1,#1
   1701 0000E8C8 F0 80                       ret
   1702 0000E8CA                        isAlphaFalse
   1703 0000E8CA 00 11                       lw      r1,#0
   1704 0000E8CC F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphanumeric
                                        ;   Parameters
                                        ;       r1 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1713 0000E8CE                        isAlnum
   1714 0000E8CE FE 6E                       sub     sp,sp,#2
   1715 0000E8D0 E0 DF                       sw      lr,[sp]
   1716 0000E8D2 10 12                       lw      r2,r1		; save test char
   1717 0000E8D4 E2 BF                       call    isDigit
   1718 0000E8D6 06 A9                       bne		isDigitx	; if it is a digit
   1719 0000E8D8 20 11                       lw      r1,r2		; get back test char
   1720 0000E8DA E9 BF                       call    isAlpha
   1721 0000E8DC E0 FF                       lw      lr,[sp]
   1722 0000E8DE 02 6E                       add		sp,sp,#2
   1723 0000E8E0 16 21                       or      r1,r1
   1724 0000E8E2 F0 80                       ret
   1725 0000E8E4                        isDigitx
   1726 0000E8E4 E0 FF                       lw      lr,[sp]
   1727 0000E8E6 02 6E                       add     sp,sp,#2	; return Z=0
   1728 0000E8E8 F0 80                       ret
                                        
                                        
   1731 0000E8EA                        EXPR
   1732 0000E8EA FC 6E                   	sub		sp,sp,#4
   1733 0000E8EC E0 DF                   	sw		lr,[sp]
   1734 0000E8EE 39 AF                   	call	EXPR2
   1735 0000E8F0 E2 D1                   	sw		r1,2[sp]	; save <EXPR2> value
   1736 0000E8F2 3A 4E 05 19             	lea		r9,TAB8		; look up a relational operator
   1737 0000E8F6 3F 4E 0A 1A             	lea		r10,TAB8_1
   1738 0000E8FA D8 4F 0D AE             	jmp		EXEC		; go do it
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 30
noc_boot41.a
   1740 0000E8FE                        XP11
   1741 0000E8FE E2 F1                   	lw		r1,2[sp]
   1742 0000E900 28 AF                   	call	XP18	; is it ">="?
   1743 0000E902 1D 22                   	cmp		r2,r1
   1744 0000E904 1E A1                   	bge		XPRT1	; no, return r2=1
   1745 0000E906 19 AE                   	br		XPRT0	; else return r2=0
                                        
   1747 0000E908                        XP12
   1748 0000E908 E2 F1                   	lw		r1,2[sp]
   1749 0000E90A 23 AF                   	call	XP18	; is it "<>"?
   1750 0000E90C 1D 22                   	cmp		r2,r1
   1751 0000E90E 19 A9                   	bne		XPRT1	; no, return r2=1
   1752 0000E910 14 AE                   	br		XPRT0	; else return r2=0
                                        
   1754 0000E912                        XP13
   1755 0000E912 E2 F1                   	lw		r1,2[sp]
   1756 0000E914 1E AF                   	call	XP18	; is it ">"?
   1757 0000E916 1D 22                   	cmp		r2,r1
   1758 0000E918 14 A3                   	bgt		XPRT1	; no, return r2=1
   1759 0000E91A 0F AE                   	br		XPRT0	; else return r2=0
                                        
   1761 0000E91C                        XP14
   1762 0000E91C E2 F1                   	lw		r1,2[sp]
   1763 0000E91E 19 AF                   	call	XP18	; is it "<="?
   1764 0000E920 1D 22                   	cmp		r2,r1
   1765 0000E922 0F A2                   	ble		XPRT1	; no, return r2=1
   1766 0000E924 0A AE                   	br		XPRT0	; else return r2=0
                                        
   1768 0000E926                        XP15
   1769 0000E926 E2 F1                   	lw		r1,2[sp]
   1770 0000E928 14 AF                   	call	XP18	; is it "="?
   1771 0000E92A 1D 22                   	cmp		r2,r1
   1772 0000E92C 0A A8                   	beq		XPRT1	; if not, return r2=1
   1773 0000E92E 05 AE                   	br		XPRT0	; else return r2=0
                                        
                                        
   1776 0000E930                        XP16
   1777 0000E930 E2 F1                   	lw		r1,2[sp]
   1778 0000E932 0F AF                   	call	XP18	; is it "<"?
   1779 0000E934 1D 22                   	cmp		r2,r1
   1780 0000E936 05 A0                   	blt		XPRT1	; if not, return r2=1
   1781 0000E938 00 AE                   	br		XPRT0	; else return r2=0
                                        
   1783 0000E93A                        XPRT0
   1784 0000E93A E0 FF                   	lw		lr,[sp]
   1785 0000E93C 04 6E                   	add		sp,sp,#4
   1786 0000E93E 00 11                   	lw		r1,#0   ; return r1=0 (false)
   1787 0000E940 F0 80                   	ret
                                        
   1789 0000E942                        XPRT1
   1790 0000E942 E0 FF                   	lw		lr,[sp]
   1791 0000E944 04 6E                   	add		sp,sp,#4
   1792 0000E946 01 11                   	lw		r1,#1	; return r1=1 (true)
   1793 0000E948 F0 80                   	ret
                                        
   1795 0000E94A                        XP17				; it's not a rel. operator
   1796 0000E94A E2 F1                   	lw		r1,2[sp]	; return r2=<EXPR2>
   1797 0000E94C E0 FF                   	lw		lr,[sp]
   1798 0000E94E 04 6E                   	add		sp,sp,#4
   1799 0000E950 F0 80                   	ret
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 31
noc_boot41.a
                                        
   1801 0000E952                        XP18
   1802 0000E952 FC 6E                   	sub		sp,sp,#4
   1803 0000E954 E0 DF                   	sw		lr,[sp]
   1804 0000E956 E2 D1                   	sw		r1,2[sp]
   1805 0000E958 04 AF                   	call	EXPR2		; do a second <EXPR2>
   1806 0000E95A E2 F2                   	lw		r2,2[sp]
   1807 0000E95C E0 FF                   	lw		lr,[sp]
   1808 0000E95E 04 6E                   	add		sp,sp,#4
   1809 0000E960 F0 80                   	ret
                                        
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        
   1813 0000E962                        EXPR2
   1814 0000E962 FC 6E                   	sub		sp,sp,#4
   1815 0000E964 E0 DF                   	sw		lr,[sp]
   1816 0000E966 36 40 01 AF             	call	TSTC		; negative sign?
   1817 0000E96A 2D 08                   	db	'-',XP21-*+1
   1818 0000E96C 00 11                   	lw		r1,#0		; yes, fake '0-'
   1819 0000E96E E2 D1                   	sw		r1,2[sp]
   1820 0000E970 0F AE                   	br		XP26
   1821 0000E972                        XP21
   1822 0000E972 35 40 0B AF             	call	TSTC		; positive sign? ignore it
   1823 0000E976 2B 02                   	db	'+',XP22-*+1
   1824 0000E978                        XP22
   1825 0000E978 12 AF                   	call	EXPR3		; first <EXPR3>
   1826 0000E97A                        XP23
   1827 0000E97A E2 D1                   	sw		r1,2[sp]	; yes, save the value
   1828 0000E97C 35 40 06 AF             	call	TSTC		; add?
   1829 0000E980 2B 0A                   	db	'+',XP25-*+1
   1830 0000E982 0D AF                   	call	EXPR3		; get the second <EXPR3>
   1831 0000E984                        XP24
   1832 0000E984 E2 F2                   	lw		r2,2[sp]
   1833 0000E986 20 21                   	add		r1,r2		; add it to the first <EXPR3>
                                        ;	BVS.L	QHOW		brnch if there's an overflow
   1835 0000E988 F8 BE                   	br		XP23		; else go back for more operations
   1836 0000E98A                        XP25
   1837 0000E98A 34 40 0F AF             	call	TSTC		; subtract?
   1838 0000E98E 2D 08                   	db	'-',XP45-*+1
   1839 0000E990                        XP26
   1840 0000E990 06 AF                   	call	EXPR3		; get second <EXPR3>
   1841 0000E992 20 31                   	neg		r1			; change its sign
   1842 0000E994 F7 BE                   	br		XP24		; and do an addition
                                        
   1844 0000E996                        XP45
   1845 0000E996 E2 F1                   	lw		r1,2[sp]
   1846 0000E998 E0 FF                   	lw		lr,[sp]
   1847 0000E99A 04 6E                   	add		sp,sp,#4
   1848 0000E99C F0 80                   	ret
                                        
                                        
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        
   1853 0000E99E                        EXPR3
   1854 0000E99E FC 6E                   	sub		sp,sp,#4
   1855 0000E9A0 E0 DF                   	sw		lr,[sp]
   1856 0000E9A2 14 AF                   	call	EXPR4		; get first <EXPR4>
   1857 0000E9A4                        XP31
   1858 0000E9A4 E2 D1                   	sw		r1,2[sp]	; yes, save that first result
   1859 0000E9A6 34 40 01 AF             	call	TSTC		; multiply?
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 32
noc_boot41.a
   1860 0000E9AA 2A 0A                   	db	'*',XP34-*+1
   1861 0000E9AC 0F AF                   	call	EXPR4		; get second <EXPR4>
   1862 0000E9AE E2 F2                   	lw		r2,2[sp]
   1863 0000E9B0 B8 AF                   	call	MULT32		; multiply the two
   1864 0000E9B2 F8 BE                   	br		XP31		 ; then look for more terms
   1865 0000E9B4                        XP34
   1866 0000E9B4 33 40 0A AF             	call	TSTC		; divide?
   1867 0000E9B8 2F 0C                   	db	'/',XP47-*+1
   1868 0000E9BA 08 AF                   	call	EXPR4		; get second <EXPR4>
   1869 0000E9BC 10 12                   	lw      r2,r1
   1870 0000E9BE E2 F1                   	lw		r1,2[sp]
   1871 0000E9C0 CD AF                   	call	DIV32		; do the division
   1872 0000E9C2 F0 BE                   	br		XP31		; go back for any more terms
                                        
   1874 0000E9C4                        XP47
   1875 0000E9C4 E2 F1                   	lw		r1,2[sp]
   1876 0000E9C6 E0 FF                   	lw		lr,[sp]
   1877 0000E9C8 04 6E                   	add		sp,sp,#4
   1878 0000E9CA F0 80                   	ret
                                        
                                        
                                        ; Functions are called through EXPR4
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        
   1886 0000E9CC                        EXPR4
   1887 0000E9CC FA 6E                       sub     sp,sp,#6
   1888 0000E9CE E0 DF                       sw      lr,[sp]
   1889 0000E9D0 37 4E 0F 19             	lea		r9,TAB4		; find possible function
   1890 0000E9D4 3E 4E 02 1A             	lea		r10,TAB4_1
   1891 0000E9D8 D1 4F 0E AE             	jmp		EXEC        ; branch to function which does subsequent
                                        	                    ; ret for EXPR4
                                        
   1894 0000E9DC                        XP40                    ; we get here if it wasn't a function
   1895 0000E9DC 00 11                   	lw		r1,#0
   1896 0000E9DE 1D AF                   	call	TSTV		
   1897 0000E9E0 04 A8                   	beq     XP41        ; nor a variable
   1898 0000E9E2 10 F1                   	lw		r1,[r1]		; if a variable, return its value in r1
   1899 0000E9E4 E0 FF                   	lw      lr,[sp]
   1900 0000E9E6 06 6E                   	add     sp,sp,#6
   1901 0000E9E8 F0 80                   	ret
   1902 0000E9EA                        XP41
   1903 0000E9EA 33 40 01 AF             	call	TSTNUM		; or is it a number?
   1904 0000E9EE 26 22                   	or		r2,r2		; (if not, # of digits will be zero)
   1905 0000E9F0 01 A9                   	bne		XP46		; if so, return it in r1
   1906 0000E9F2 03 AF                   	call    PARN        ; check for (EXPR)
   1907 0000E9F4                        XP46
   1908 0000E9F4 E0 FF                   	lw      lr,[sp]
   1909 0000E9F6 06 6E                   	add     sp,sp,#6
   1910 0000E9F8 F0 80                   	ret
                                        
                                        
                                        ; Check for a parenthesized expression
   1914 0000E9FA                        PARN
   1915 0000E9FA FE 6E                   	sub		sp,sp,#2
   1916 0000E9FC E0 DF                   	sw		lr,[sp]
   1917 0000E9FE 31 40 05 AF             	call	TSTC		; else look for ( OREXPR )
   1918 0000EA02 28 10                   	db	'(',XP43-*+1
   1919 0000EA04 26 BF                   	call	OREXPR
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 33
noc_boot41.a
   1920 0000EA06 31 40 01 AF             	call	TSTC
   1921 0000EA0A 29 08                   	db	')',XP43-*+1
   1922 0000EA0C                        XP42
   1923 0000EA0C E0 FF                   	lw		lr,[sp]
   1924 0000EA0E 02 6E                   	add		sp,sp,#2
   1925 0000EA10 F0 80                   	ret
   1926 0000EA12                        XP43
   1927 0000EA12 31 4F 0B 11             	lea		r1,msgWhat
   1928 0000EA16 16 40 05 AE             	br		ERROR
                                        
                                        
                                        ; ===== Test for a valid variable name.  Returns Z=1 if not
                                        ;	found, else returns Z=0 and the address of the
                                        ;	variable in r1.
                                        ; Parameters
                                        ;	r1 = 1 = allocate if not found
                                        ; Returns
                                        ;	r1 = address of variable, zero if not found
                                        
   1939 0000EA1A                        TSTV
   1940 0000EA1A FA 6E                   	sub		sp,sp,#6
   1941 0000EA1C E0 DF                   	sw		lr,[sp]
   1942 0000EA1E E2 D5                   	sw		r5,2[sp]
   1943 0000EA20 10 15                   	lw		r5,r1		; allocate flag
   1944 0000EA22 33 40 06 AF             	call	IGNBLK
   1945 0000EA26 80 E1                   	lb		r1,[r8]		; look at the program text
   1946 0000EA28 FC 4F 10 10             	cmp     r1,#'@'
   1947 0000EA2C 1C A0                   	blt     tstv_notfound   ; C=1: not a variable
   1948 0000EA2E 12 A9                   	bne		TV1			; brnch if not "@" array
   1949 0000EA30 01 68                   	add		r8,r8,#1	; If it is, it should be
   1950 0000EA32 E3 BF                   	call	PARN		; followed by (EXPR) as its index.
   1951 0000EA34 81 31                   	shl     r1,#1
   1952 0000EA36 81 31                   	shl     r1,#1
                                        ;	BCS.L	QHOW		say "How?" if index is too big
   1954 0000EA38 E4 D1                       sw      r1,4[sp]    ; save the index
   1955 0000EA3A F4 6E                       sub		sp,sp,#12
   1956 0000EA3C E0 DF                       sw		lr,[sp]
   1957 0000EA3E 10 40 07 AF             	call	SIZEX		; get amount of free memory
   1958 0000EA42 E4 F2                   	lw      r2,4[sp]    ; get back the index
   1959 0000EA44 1D 22                   	cmp     r2,r1       ; see if there's enough memory
   1960 0000EA46 02 A4                   	bltu	TV2
   1961 0000EA48 14 40 07 AE             	jmp    	QSORRY		; if not, say "Sorry"
   1962 0000EA4C                        TV2
   1963 0000EA4C 12 40 08 F1             	lw      r1,VARBGN   ; put address of array element...
   1964 0000EA50 22 21                   	sub     r1,r2       ; into r1 (neg. offset is used)
   1965 0000EA52 05 AE                   	br      TSTVRT
   1966 0000EA54                        TV1	
   1967 0000EA54 0D AF                       call    getVarName      ; get variable name
   1968 0000EA56 07 A8                       beq     tstv_notfound   ; if not, set Z=1 and return
   1969 0000EA58 50 12                       lw		r2,r5
   1970 0000EA5A 45 AF                       call    findVar     ; find or allocate
   1971 0000EA5C 04 A8                       beq		tstv_notfound
   1972 0000EA5E                        TSTVRT
   1973 0000EA5E E2 F5                   	lw		r5,2[sp]
   1974 0000EA60 E0 FF                   	lw		lr,[sp]
   1975 0000EA62 06 6E                   	add		sp,sp,#6    ; Z=0 (found)
   1976 0000EA64 F0 80                   	ret
   1977 0000EA66                        tstv_notfound
   1978 0000EA66 E2 F5                   	lw		r5,2[sp]
   1979 0000EA68 E0 FF                       lw      lr,[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 34
noc_boot41.a
   1980 0000EA6A 06 6E                       add     sp,sp,#6
   1981 0000EA6C 00 11                       lw      r1,#0       ; Z=1 if not found
   1982 0000EA6E F0 80                       ret
                                        
                                        
                                        ; Returns
                                        ;   r1 = 3 character variable name + type
                                        ;
   1988 0000EA70                        getVarName
   1989 0000EA70 FA 6E                       sub     sp,sp,#6
   1990 0000EA72 E0 DF                       sw      lr,[sp]
   1991 0000EA74 E4 D5                       sw		r5,4[sp]
                                        
   1993 0000EA76 80 E1                       lb      r1,[r8]     ; get first character
   1994 0000EA78 E2 D1                       sw		r1,2[sp]	; save off current name
   1995 0000EA7A 19 BF                       call    isAlpha
   1996 0000EA7C 2F A8                       beq     gvn1
   1997 0000EA7E 02 15                       lw      r5,#2       ; loop twice more
                                        
                                        	; check for second/third character
   2000 0000EA80                        gvn4
   2001 0000EA80 01 68                   	add     r8,r8,#1
   2002 0000EA82 80 E1                   	lb      r1,[r8]     ; do we have another char ?
   2003 0000EA84 24 BF                   	call    isAlnum
   2004 0000EA86 12 A8                   	beq     gvn2        ; nope
   2005 0000EA88 E2 F1                   	lw      r1,2[sp]    ; get varname
   2006 0000EA8A 81 31                   	shl     r1,#1       ; shift left by eight
   2007 0000EA8C 81 31                   	shl     r1,#1       ; shift left by eight
   2008 0000EA8E 81 31                   	shl     r1,#1       ; shift left by eight
   2009 0000EA90 81 31                   	shl     r1,#1       ; shift left by eight
   2010 0000EA92 81 31                   	shl     r1,#1       ; shift left by eight
   2011 0000EA94 81 31                   	shl     r1,#1       ; shift left by eight
   2012 0000EA96 81 31                   	shl     r1,#1       ; shift left by eight
   2013 0000EA98 81 31                   	shl     r1,#1       ; shift left by eight
   2014 0000EA9A 80 E2                   	lb      r2,[r8]
   2015 0000EA9C 26 21                   	or      r1,r2       ; add in new char
   2016 0000EA9E E2 D1                       sw      r1,2[sp]   ; save off name again
   2017 0000EAA0 FF 65                       sub		r5,r5,#1
   2018 0000EAA2 EE B9                       bne     gvn4
                                        
                                            ; now ignore extra variable name characters
   2021 0000EAA4                        gvn6
   2022 0000EAA4 01 68                       add     r8,r8,#1
   2023 0000EAA6 80 E1                       lb      r1,[r8]
   2024 0000EAA8 12 BF                       call    isAlnum
   2025 0000EAAA FC B9                       bne     gvn6        ; keep looping as long as we have identifier chars
                                            
   2027 0000EAAC                        gvn2
   2028 0000EAAC 80 E1                   	lb		r1,[r8]
   2029 0000EAAE FD 4F 1B 10                 cmp     r1,#'%'
   2030 0000EAB2 05 A8                       beq     gvn3
   2031 0000EAB4 FD 4F 1C 10                 cmp     r1,#'$'
   2032 0000EAB8 02 A8                       beq     gvn3
   2033 0000EABA 00 11                       lw      r1,#0
   2034 0000EABC FF 68                       sub     r8,r8,#1
                                        
                                            ; insert variable type indicator and return
   2037 0000EABE                        gvn3
   2038 0000EABE 01 68                       add     r8,r8,#1
   2039 0000EAC0 E2 F2                       lw      r2,2[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 35
noc_boot41.a
   2040 0000EAC2 81 32                       shl     r2,#1
   2041 0000EAC4 81 32                       shl     r2,#1
   2042 0000EAC6 81 32                       shl     r2,#1
   2043 0000EAC8 81 32                       shl     r2,#1
   2044 0000EACA 81 32                       shl     r2,#1
   2045 0000EACC 81 32                       shl     r2,#1
   2046 0000EACE 81 32                       shl     r2,#1
   2047 0000EAD0 81 32                       shl     r2,#1
   2048 0000EAD2 26 21                       or      r1,r2       ; add in variable type
   2049 0000EAD4 E0 FF                       lw      lr,[sp]
   2050 0000EAD6 E4 F5                       lw		r5,4[sp]
   2051 0000EAD8 06 6E                       add     sp,sp,#6   ; return Z = 0, r1 = varname
   2052 0000EADA F0 80                       ret
                                        
                                            ; not a variable name
   2055 0000EADC                        gvn1
   2056 0000EADC E0 FF                       lw      lr,[sp]
   2057 0000EADE E4 F5                       lw		r5,4[sp]
   2058 0000EAE0 06 6E                       add     sp,sp,#6
   2059 0000EAE2 00 11                       lw      r1,#0       ; return Z = 1 if not a varname
   2060 0000EAE4 F0 80                       ret
                                        
                                        
                                        ; Find variable
                                        ;   r1 = varname
                                        ;	r2 = allocate flag
                                        ; Returns
                                        ;   r1 = variable address, Z =0 if found / allocated, Z=1 if not found
                                        
   2069 0000EAE6                        findVar
   2070 0000EAE6 FC 6E                       sub     sp,sp,#4
   2071 0000EAE8 E0 DF                       sw      lr,[sp]
   2072 0000EAEA E2 D7                       sw      r7,2[sp]
   2073 0000EAEC 12 40 08 F3                 lw      r3,VARBGN
   2074 0000EAF0                        fv4
   2075 0000EAF0 30 F7                       lw      r7,[r3]     ; get varname / type
   2076 0000EAF2 0A A8                       beq     fv3         ; no more vars ?
   2077 0000EAF4 7D 21                       cmp     r1,r7       ; match ?
   2078 0000EAF6 0B A8                       beq     fv1
   2079 0000EAF8 08 63                       add     r3,r3,#8    ; move to next var
   2080 0000EAFA 13 40 00 F7                 lw      r7,STKBOT
   2081 0000EAFE 7D 23                       cmp     r3,r7
   2082 0000EB00 F7 B0                       blt     fv4         ; loop back to look at next var
                                        
                                            ; variable not found
                                            ; no more memory
   2086 0000EB02 36 4F 0E 11                 lea     r1,msgVarSpace
   2087 0000EB06 EE AE                       br      ERROR
                                        ;    lw      lr,[sp]
                                        ;    lw      r7,2[sp]
                                        ;    add     sp,sp,#4
                                        ;    lw      r1,#0
                                        ;    ret
                                        
                                            ; variable not found
                                            ; allocate new ?
   2096 0000EB08                        fv3
   2097 0000EB08 26 22                   	or		r2,r2
   2098 0000EB0A 06 A8                   	beq		fv2
   2099 0000EB0C 30 D1                       sw      r1,[r3]     ; save varname / type
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 36
noc_boot41.a
                                            ; found variable
                                            ; return address
   2102 0000EB0E                        fv1
   2103 0000EB0E 34 11                       add     r1,r3,#4
   2104 0000EB10 E0 FF                       lw      lr,[sp]
   2105 0000EB12 E2 F7                       lw      r7,2[sp]
   2106 0000EB14 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   2107 0000EB16 F0 80                       ret
                                        
                                            ; didn't find var and not allocating
   2110 0000EB18                        fv2
   2111 0000EB18 E0 FF                       lw      lr,[sp]
   2112 0000EB1A E2 F7                       lw      r7,2[sp]
   2113 0000EB1C 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   2114 0000EB1E 00 11                   	lw		r1,#0		; Z = 1, r1 = 0
   2115 0000EB20 F0 80                       ret
                                        
                                        
                                        ; ===== Multiplies the 32 bit values in r1 and r2, returning
                                        ;	the 32 bit result in r1.
                                        ;
                                        
   2122 0000EB22                        MULT32
   2123 0000EB22 FA 6E                   	sub		sp,sp,#6
   2124 0000EB24 E0 D5                   	sw		r5,[sp]		; w
   2125 0000EB26 E2 D6                   	sw		r6,2[sp]	; s
   2126 0000EB28 E4 D7                   	sw		r7,4[sp]
                                        
   2128 0000EB2A 00 15                   	lw		r5,#0		; w = 0;
   2129 0000EB2C 10 16                   	lw		r6,r1
   2130 0000EB2E 24 26                   	xor		r6,r2		; s = a ^ b
   2131 0000EB30 16 21                   	or		r1,r1
   2132 0000EB32 01 AB                   	bpl		mult1
   2133 0000EB34 20 31                   	neg		r1
   2134 0000EB36                        mult1
   2135 0000EB36 26 22                   	or		r2,r2
   2136 0000EB38 01 AB                   	bpl		mult2
   2137 0000EB3A 20 32                   	neg		r2
   2138 0000EB3C                        mult2
   2139 0000EB3C 10 17                   	lw		r7,r1
   2140 0000EB3E 51 37                   	and		r7,#1
   2141 0000EB40 01 A8                   	beq		mult3
   2142 0000EB42 20 25                   	add		r5,r2		; w += b
   2143 0000EB44                        mult3
   2144 0000EB44 81 32                   	shl		r2,#1		; b <<= 1
   2145 0000EB46 A1 31                   	shr		r1,#1		; a >>= 1
   2146 0000EB48 F9 B9                   	bne		mult2       ; a = 0 ?
   2147 0000EB4A                        mult4
   2148 0000EB4A 66 26                       or      r6,r6
   2149 0000EB4C 01 AB                   	bpl		mult5
   2150 0000EB4E 20 35                   	neg		r5
   2151 0000EB50                        mult5
   2152 0000EB50 50 11                   	lw		r1,r5
   2153 0000EB52 E4 F7                   	lw		r7,4[sp]
   2154 0000EB54 E2 F6                   	lw		r6,2[sp]
   2155 0000EB56 E0 F5                   	lw		r5,[sp]
   2156 0000EB58 06 6E                   	add		sp,sp,#6
   2157 0000EB5A F0 80                   	ret
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 37
noc_boot41.a
                                        ; ===== Divide the 32 bit value in r2 by the 32 bit value in r3.
                                        ;	Returns the 32 bit quotient in r1, remainder in r2
                                        ;
                                        ; r2 = a
                                        ; r3 = b
                                        ; r6 = remainder
                                        ; r7 = iteration count
                                        ; r8 = sign
                                        ;
                                        
                                        ; q = a / b
                                        ; a = r1
                                        ; b = r2
                                        ; q = r2
                                        
   2175 0000EB5C                        DIV32
   2176 0000EB5C 26 22                       or      r2,r2       ; check for divide-by-zero
   2177 0000EB5E 03 A9                       bne		div6
   2178 0000EB60 35 4F 0B 11                 lea		r1,msgDivZero
   2179 0000EB64 BF AE                       br		ERROR		; divide by zero error
   2180 0000EB66                        div6
   2181 0000EB66 FA 6E                   	sub		sp,sp,#6
   2182 0000EB68 E0 D6                   	sw		r6,[sp]
   2183 0000EB6A E2 D7                   	sw		r7,2[sp]
   2184 0000EB6C E4 D8                   	sw		r8,4[sp]
                                        
   2186 0000EB6E 02 40 00 18                 lw      r8,#32      ; iteration count for 32 bits
   2187 0000EB72 00 16                   	lw		r6,#0		; r = 0
   2188 0000EB74 20 17                       lw      r7,r2       ; r7 = sign of result
   2189 0000EB76 14 27                       xor     r7,r1
   2190 0000EB78 16 21                   	or	    r1,r1	    ; take absolute value of r1 (a)
   2191 0000EB7A 01 AB                   	bpl     div1
   2192 0000EB7C 20 31                   	neg     r1
   2193 0000EB7E                        div1
   2194 0000EB7E 26 22                       or      r2,r2	    ; take absolute value of r2 (b)
   2195 0000EB80 01 AB                   	bpl	    div2
   2196 0000EB82 20 32                   	neg     r2
   2197 0000EB84                        div2
   2198 0000EB84 81 31                   	shl		r1,#1		; a <<= 1
   2199 0000EB86 61 26                   	adc		r6,r6		; r <<= 1
   2200 0000EB88 6D 22                   	cmp		r2,r6		; b < r ?
   2201 0000EB8A 02 A7                   	bgtu	div4
   2202 0000EB8C 22 26                   	sub		r6,r2		; r -= b
   2203 0000EB8E 61 31                   	or      r1,#1       ; a |= 1
   2204 0000EB90                        div4
   2205 0000EB90 FF 68                   	sub		r8,r8,#1
   2206 0000EB92 F8 B9                       bne     div2        ; n--
   2207 0000EB94 76 27                   	or      r7,r7
   2208 0000EB96 01 AB                   	bpl     div5
   2209 0000EB98 20 31                   	neg     r1
   2210 0000EB9A                        div5
   2211 0000EB9A 60 12                   	lw		r2,r6		; r2 = r
   2212 0000EB9C E2 F7                   	lw		r7,2[sp]
   2213 0000EB9E E4 F8                   	lw		r8,4[sp]
   2214 0000EBA0 E0 F6                   	lw		r6,[sp]
   2215 0000EBA2 06 6E                   	add		sp,sp,#6
   2216 0000EBA4 F0 80                   	ret
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 38
noc_boot41.a
                                        ;
   2221 0000EBA6                        PEEK
   2222 0000EBA6 29 BF                   	call	PARN		; get the memory address
   2223 0000EBA8 10 E1                   	lb		r1,[r1]		; get the addressed byte
   2224 0000EBAA 0E 21                   	zxb		r1			; upper 3 bytes will be zero
   2225 0000EBAC E0 FF                   	lw		lr,[sp]	; and return it
   2226 0000EBAE 06 6E                   	add		sp,sp,#6
   2227 0000EBB0 F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   2233 0000EBB2                        PEEKW
   2234 0000EBB2 23 BF                   	call	PARN		; get the memory address
   2235 0000EBB4 5E 31                   	and		r1,#-2		; align to word address
   2236 0000EBB6 10 F1                   	lw		r1,[r1]		; get the addressed word
   2237 0000EBB8 E0 FF                   	lw		lr,[sp]	; and return it
   2238 0000EBBA 06 6E                   	add		sp,sp,#6
   2239 0000EBBC F0 80                   	ret
                                        
                                        
                                        ; user function call
                                        ; call the user function with argument in r1
   2244 0000EBBE                        USRX
   2245 0000EBBE 1D BF                   	call	PARN		; get expression value
   2246 0000EBC0 E2 D8                   	sw		r8,2[sp]	; save the text pointer
   2247 0000EBC2 02 40 04 F2             	lw      r2,usrJmp   ; get usr vector
   2248 0000EBC6 20 8F                   	call	[r2]		; jump to the subroutine
   2249 0000EBC8 E2 F8                   	lw		r8,2[sp]	; restore the text pointer
   2250 0000EBCA E0 FF                   	lw		lr,[sp]
   2251 0000EBCC 06 6E                   	add		sp,sp,#6
   2252 0000EBCE F0 80                   	ret
                                        
                                        
                                        ; ===== The RND function returns a random number from 1 to
                                        ;	the value of the following expression in D0.
                                        ;
   2258 0000EBD0                        RND
   2259 0000EBD0 14 BF                   	call	PARN		; get the upper limit
   2260 0000EBD2 16 21                   	or		r1,r1		; it must be positive and non-zero
   2261 0000EBD4 0E A8                   	beq		rnd2
   2262 0000EBD6 0A AA                   	bmi		rnd1
   2263 0000EBD8 10 12                   	lw		r2,r1
   2264 0000EBDA CA 4D 04 D0             	sh		r0,RAND+4	; read command
   2265 0000EBDE CA 4D 00 F1             	lw		r1,RAND		; get a number
   2266 0000EBE2 0E AF                   	call	modu4		; RND(n)=MOD(number,n)+1
   2267 0000EBE4 01 61                   	add		r1,r1,#1
   2268 0000EBE6 E0 FF                   	lw		lr,[sp]
   2269 0000EBE8 06 6E                   	add		sp,sp,#6
   2270 0000EBEA F0 80                   	ret
   2271 0000EBEC                        rnd1
   2272 0000EBEC 3D 4F 0F 11             	lea		r1,msgRNDBad
   2273 0000EBF0 79 AE                   	br		ERROR
   2274 0000EBF2                        rnd2
   2275 0000EBF2 CA 4D 04 D0             	sh		r0,RAND+4
   2276 0000EBF6 CA 4D 00 F1             	lw		r1,RAND
   2277 0000EBFA E0 FF                   	lw		lr,[sp]
   2278 0000EBFC 06 6E                   	add		sp,sp,#6
   2279 0000EBFE F0 80                   	ret
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 39
noc_boot41.a
                                        
                                        
                                        ; r = a mod b
                                        ; a = r2
                                        ; b = r3
                                        ; r = r1
   2286 0000EC00                        modu4
   2287 0000EC00 FA 6E                   	sub		sp,sp,#6
   2288 0000EC02 E0 D5                   	sw		r5,[sp]
   2289 0000EC04 E2 D6                   	sw		r6,2[sp]
   2290 0000EC06 E4 D7                   	sw		r7,4[sp]
   2291 0000EC08 02 40 00 17             	lw      r7,#32		; n = 32
   2292 0000EC0C 00 15                   	lw		r5,#0		; w = 0
   2293 0000EC0E 00 16                   	lw		r6,#0		; r = 0
   2294 0000EC10                        mod2
   2295 0000EC10 81 31                   	shl		r1,#1		; a <<= 1
   2296 0000EC12 61 26                   	adc		r6,r6		; r <<= 1
   2297 0000EC14 6D 22                   	cmp		r2,r6		; b < r ?
   2298 0000EC16 01 A7                   	bgtu	mod1
   2299 0000EC18 22 26                   	sub		r6,r2		; r -= b
   2300 0000EC1A                        mod1
   2301 0000EC1A FF 67                   	sub		r7,r7,#1
   2302 0000EC1C F9 B9                       bne     mod2        ; n--
   2303 0000EC1E 60 11                   	lw		r1,r6
   2304 0000EC20 E0 F5                   	lw		r5,[sp]
   2305 0000EC22 E2 F6                   	lw		r6,2[sp]
   2306 0000EC24 E4 F7                   	lw		r7,4[sp]
   2307 0000EC26 06 6E                   	add		sp,sp,#6
   2308 0000EC28 F0 80                   	ret
                                        
                                        
                                        
                                        ; ===== The ABS function returns an absolute value in r2.
                                        ;
   2314 0000EC2A                        ABS
   2315 0000EC2A EE 4F 06 AF             	call	PARN		; get the following expr.'s value
   2316 0000EC2E 16 21                   	or		r1,r1
   2317 0000EC30 01 AB                   	bpl		abs1
   2318 0000EC32 20 31                   	neg		r1			; if negative, complement it
                                        ;	bmi		QHOW		; if still negative, it was too big
   2320 0000EC34                        abs1
   2321 0000EC34 E0 FF                   	lw		lr,[sp]
   2322 0000EC36 06 6E                   	add		sp,sp,#6
   2323 0000EC38 F0 80                   	ret
                                        
                                        
                                        ; ===== The SGN function returns the sign in r1. +1,0, or -1
                                        ;
   2328 0000EC3A                        SGN
   2329 0000EC3A ED 4F 0E AF             	call	PARN		; get the following expr.'s value
   2330 0000EC3E 16 21                   	or		r1,r1
   2331 0000EC40 04 A8                   	beq		sgn1
   2332 0000EC42 02 AB                   	bpl		sgn2
   2333 0000EC44 0F 11                   	lw		r1,#-1
   2334 0000EC46 01 AE                   	br		sgn1
   2335 0000EC48                        sgn2
   2336 0000EC48 01 11                   	lw		r1,#1
   2337 0000EC4A                        sgn1
   2338 0000EC4A E0 FF                   	lw		lr,[sp]
   2339 0000EC4C 06 6E                   	add		sp,sp,#6
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 40
noc_boot41.a
   2340 0000EC4E F0 80                   	ret
                                        
                                        
                                        ; ===== The SIZE function returns the size of free memory in r1.
                                        ;
   2345 0000EC50                        SIZEX
   2346 0000EC50 12 40 08 F1             	lw		r1,VARBGN	; get the number of free bytes...
   2347 0000EC54 12 40 06 F2             	lw		r2,TXTUNF	; between 'TXTUNF' and 'VARBGN'
   2348 0000EC58 22 21                   	sub		r1,r2
   2349 0000EC5A E0 FF                   	lw		lr,[sp]
   2350 0000EC5C 06 6E                   	add		sp,sp,#6
   2351 0000EC5E F0 80                   	ret					; return the number in r2
                                        
                                        ; ==== Return the node number that the code is running on
                                        ;
   2355 0000EC60                        NODENUM
   2356 0000EC60 E4 31                   	tsr		r1,ID
   2357 0000EC62 E0 FF                   	lw		lr,[sp]
   2358 0000EC64 06 6E                   	add		sp,sp,#6
   2359 0000EC66 F0 80                   	ret
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                                        ;
                                        ; 'SETVAL' expects a variable, followed by an equal sign and then
                                        ; an expression.  It evaluates the expression and sets the variable
                                        ; to that value.
                                        ;
                                        ; 'FIN' checks the end of a command.  If it ended with ":",
                                        ; execution continues.	If it ended with a CR, it finds the
                                        ; the next line and continues from there.
                                        ;
                                        ; 'ENDCHK' checks if a command is ended with a CR. This is
                                        ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                                        ;
                                        ; 'ERROR' prints the string pointed to by A0. It then prints the
                                        ; line pointed to by CURRNT with a "?" inserted at where the
                                        ; old text pointer (should be on top of the stack) points to.
                                        ; Execution of Tiny BASIC is stopped and a warm start is done.
                                        ; If CURRNT is zero (indicating a direct command), the direct
                                        ; command is not printed. If CURRNT is -1 (indicating
                                        ; 'INPUT' command in progress), the input line is not printed
                                        ; and execution is not terminated but continues at 'INPERR'.
                                        ;
                                        ; Related to 'ERROR' are the following:
                                        ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                                        ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                                        ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                                        ; 'QHOW' and 'AHOW' also do this for "How?".
                                        ;
                                        
                                        ; returns
                                        ; r2 = variable's address
                                        ;
   2395 0000EC68                        SETVAL
   2396 0000EC68 FC 6E                       sub     sp,sp,#4
   2397 0000EC6A E0 DF                       sw      lr,[sp]
   2398 0000EC6C 01 11                       lw		r1,#1		; allocate var
   2399 0000EC6E ED 4F 04 AF                 call	TSTV		; variable name?
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 41
noc_boot41.a
   2400 0000EC72 03 A9                       bne		sv2
   2401 0000EC74 3C 4F 08 11                	lea		r1,msgVar
   2402 0000EC78 35 AE                      	br		ERROR 
   2403 0000EC7A                        sv2
   2404 0000EC7A E2 D1                   	sw      r1,2[sp]    ; save the variable's address
   2405 0000EC7C 1D 40 06 AF             	call	TSTC		; get past the "=" sign
   2406 0000EC80 3D 12                   	db	'=',SV1-*+1
   2407 0000EC82 DE 4F 06 AF             	call	OREXPR		; evaluate the expression
   2408 0000EC86 E2 F2                   	lw      r2,2[sp]    ; get back the variable's address
   2409 0000EC88 20 D1                   	sw      r1,[r2]     ; and save value in the variable
   2410 0000EC8A 20 11                   	lw		r1,r2		; return r1 = variable address
   2411 0000EC8C E0 FF                   	lw      lr,[sp]
   2412 0000EC8E 04 6E                   	add     sp,sp,#4
   2413 0000EC90 F0 80                   	ret
   2414 0000EC92                        SV1
   2415 0000EC92 26 AE                       br	    QWHAT		; if no "=" sign
                                        
                                        
   2418 0000EC94                        FIN
   2419 0000EC94 FE 6E                   	sub		sp,sp,#2
   2420 0000EC96 E0 DF                   	sw		lr,[sp]
   2421 0000EC98 1C 40 08 AF             	call	TSTC		; *** FIN ***
   2422 0000EC9C 3A 08                   	db	':',FI1-*+1
   2423 0000EC9E 02 6E                   	add		sp,sp,#2	; if ":", discard return address
   2424 0000ECA0 BF 4F 0D AE             	br		RUNSML		; continue on the same line
   2425 0000ECA4                        FI1
   2426 0000ECA4 1C 40 02 AF             	call	TSTC		; not ":", is it a CR?
   2427 0000ECA8 0D 0A                   	db	CR,FI2-*+1
   2428 0000ECAA E0 FF                   	lw		lr,[sp]	; else return to the caller
   2429 0000ECAC 02 6E                   	add		sp,sp,#2	; yes, purge return address
   2430 0000ECAE BE 4F 0B AE             	br		RUNNXL		; execute the next line
   2431 0000ECB2                        FI2
   2432 0000ECB2 E0 FF                   	lw		lr,[sp]	; else return to the caller
   2433 0000ECB4 02 6E                   	add		sp,sp,#2
   2434 0000ECB6 F0 80                   	ret
                                        
                                        
                                        ; Check that there is nothing else on the line
                                        ; Registers Affected
                                        ;   r1
                                        ;
   2441 0000ECB8                        ENDCHK
   2442 0000ECB8 FE 6E                   	sub		sp,sp,#2
   2443 0000ECBA E0 DF                   	sw		lr,[sp]
   2444 0000ECBC 1E 40 09 AF             	call	IGNBLK
   2445 0000ECC0 80 E1                   	lb		r1,[r8]
   2446 0000ECC2 FF 4F 13 10             	cmp		r1,#CR		; does it end with a CR?
   2447 0000ECC6 03 A8                   	beq		ec1
   2448 0000ECC8 4A 4F 02 11             	lea		r1,msgExtraChars
   2449 0000ECCC 0B AE                   	jmp		ERROR
   2450 0000ECCE                        ec1
   2451 0000ECCE E0 FF                   	lw		lr,[sp]
   2452 0000ECD0 02 6E                   	add		sp,sp,#2
   2453 0000ECD2 F0 80                   	ret
                                        
                                        
   2456 0000ECD4                        TOOBIG
   2457 0000ECD4 48 4F 0D 11             	lea		r1,msgTooBig
   2458 0000ECD8 05 AE                   	br		ERROR
   2459 0000ECDA                        QSORRY
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 42
noc_boot41.a
   2460 0000ECDA 32 4F 03 11                 lea     r1,SRYMSG
   2461 0000ECDE 02 AE                   	br	    ERROR
   2462 0000ECE0                        QWHAT
   2463 0000ECE0 31 4F 0B 11             	lea		r1,msgWhat
   2464 0000ECE4                        ERROR
   2465 0000ECE4 21 40 0D AF             	call	PRMESG		; display the error message
   2466 0000ECE8 11 40 06 F1             	lw		r1,CURRNT	; get the current line number
   2467 0000ECEC B0 4F 0A A8             	beq		WSTART		; if zero, do a warm start
   2468 0000ECF0 11 10                   	cmp		r1,#-1		; is the line no. pointer = -1?
   2469 0000ECF2 CD 4F 0A A8             	beq		INPERR		; if so, redo input
   2470 0000ECF6 80 E5                   	lb		r5,[r8]		; save the char. pointed to
   2471 0000ECF8 80 C0                   	sb		r0,[r8]		; put a zero where the error is
   2472 0000ECFA 11 40 06 F1             	lw		r1,CURRNT	; point to start of current line
   2473 0000ECFE 17 40 07 AF             	call	PRTLN		; display the line in error up to the 0
   2474 0000ED02 10 16                   	lw      r6,r1       ; save off end pointer
   2475 0000ED04 80 C5                   	sb		r5,[r8]		; restore the character
   2476 0000ED06 03 40 0F 11             	lw		r1,#'?'		; display a "?"
   2477 0000ED0A AD 4F 05 AF             	call	GOOUT
   2478 0000ED0E 00 12                   	lw      r2,#0       ; stop char = 0
   2479 0000ED10 6F 11                   	sub		r1,r6,#1	; point back to the error char.
   2480 0000ED12 B6 AF                   	call	PRTSTG		; display the rest of the line
   2481 0000ED14 AF 4F 06 AE             	jmp	    WSTART		; and do a warm start
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** GETLN *** FNDLN (& friends) ***
                                        ;
                                        ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                                        ; the character in r3 (given by the caller), then it fills the
                                        ; buffer and echos. It ignores LF's but still echos
                                        ; them back. Control-H is used to delete the last character
                                        ; entered (if there is one), and control-X is used to delete the
                                        ; whole line and start over again. CR signals the end of a line,
                                        ; and causes 'GETLN' to return.
                                        ;
                                        ;
   2497 0000ED18                        GETLN
   2498 0000ED18 FC 6E                   	sub		sp,sp,#4
   2499 0000ED1A E0 DF                   	sw		lr,[sp]
   2500 0000ED1C E2 D5                   	sw		r5,2[sp]
   2501 0000ED1E AC 4F 0B AF             	call	GOOUT		; display the prompt
   2502 0000ED22 01 11                   	lw		r1,#1		; turn on cursor flash
   2503 0000ED24 0F 40 00 C1             	sb		r1,cursFlash
   2504 0000ED28 02 40 00 11             	lw		r1,#' '		; and a space
   2505 0000ED2C AC 4F 04 AF             	call	GOOUT
   2506 0000ED30 13 40 0E 18             	lea		r8,BUFFER	; r8 is the buffer pointer
   2507 0000ED34                        GL1
   2508 0000ED34 1E 40 03 AF             	call	CHKIO		; check keyboard
   2509 0000ED38 FD B8                   	beq		GL1			; wait for a char. to come in
   2510 0000ED3A FF 4F 18 10             	cmp		r1,#CTRLH	; delete last character?
   2511 0000ED3E 14 A8                   	beq		GL3			; if so
   2512 0000ED40 FE 4F 18 10             	cmp		r1,#CTRLX	; delete the whole line?
   2513 0000ED44 20 A8                   	beq		GL4			; if so
   2514 0000ED46 FF 4F 13 10             	cmp		r1,#CR		; accept a CR
   2515 0000ED4A 03 A8                   	beq		GL2
   2516 0000ED4C FE 4F 10 10             	cmp		r1,#' '		; if other control char., discard it
   2517 0000ED50 F1 B4                   	bltu	GL1
   2518 0000ED52                        GL2
   2519 0000ED52 80 C1                   	sb		r1,[r8]		; save the char.
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 43
noc_boot41.a
   2520 0000ED54 01 68                   	add		r8,r8,#1
   2521 0000ED56 AA 4F 0F AF             	call	GOOUT		; echo the char back out
   2522 0000ED5A 8F E1                   	lb      r1,-1[r8]   ; get char back (GOOUT destroys r1)
   2523 0000ED5C FF 4F 13 10             	cmp		r1,#CR		; if it's a CR, end the line
   2524 0000ED60 25 A8                   	beq		GL7
   2525 0000ED62 E7 4F 83 10             	cmp		r8,#(BUFFER+BUFLEN-1)	; any more room?
   2526 0000ED66 E6 B4                   	bltu	GL1			; yes: get some more, else delete last char.
                                        
   2528 0000ED68                        GL3
   2529 0000ED68 08 11                   	lw		r1,#CTRLH	; delete a char. if possible
   2530 0000ED6A AA 4F 05 AF             	call	GOOUT
   2531 0000ED6E 02 40 00 11             	lw		r1,#' '
   2532 0000ED72 AA 4F 01 AF             	call	GOOUT
   2533 0000ED76 EC 4F 82 10             	cmp		r8,#BUFFER	; any char.'s left?
   2534 0000ED7A DC B6                   	bleu	GL1			; if not
   2535 0000ED7C 08 11                   	lw		r1,#CTRLH	; if so, finish the BS-space-BS sequence
   2536 0000ED7E A9 4F 0B AF             	call	GOOUT
   2537 0000ED82 FF 68                   	sub		r8,r8,#1	; decrement the text pointer
   2538 0000ED84 D7 BE                   	br		GL1			; back for more
                                        
   2540 0000ED86                        GL4
   2541 0000ED86 80 11                   	lw		r1,r8		; delete the whole line
   2542 0000ED88 EC 4F 12 15             	sub		r5,r1,#BUFFER   ; figure out how many backspaces we need
   2543 0000ED8C 0C A8                   	beq		GL6			; if none needed, brnch
   2544 0000ED8E                        GL5	
   2545 0000ED8E 08 11                   	lw		r1,#CTRLH	; and display BS-space-BS sequences
   2546 0000ED90 A9 4F 02 AF             	call	GOOUT
   2547 0000ED94 02 40 00 11             	lw		r1,#' '
   2548 0000ED98 A8 4F 0E AF             	call	GOOUT
   2549 0000ED9C 08 11                   	lw		r1,#CTRLH
   2550 0000ED9E A8 4F 0B AF             	call	GOOUT
   2551 0000EDA2 FF 65                   	sub		r5,r5,#1
   2552 0000EDA4 F4 B9                   	bne     GL5
   2553 0000EDA6                        GL6
   2554 0000EDA6 13 40 0E 18             	lea		r8,BUFFER	; reinitialize the text pointer
   2555 0000EDAA C4 BE                   	br		GL1			; and go back for more
   2556 0000EDAC                        GL7
   2557 0000EDAC 00 11                   	lw		r1,#0		; turn off cursor flash
   2558 0000EDAE 0F 40 00 C1             	sb		r1,cursFlash
   2559 0000EDB2 0A 11                   	lw		r1,#LF		; echo a LF for the CR
   2560 0000EDB4 A8 4F 00 AF             	call	GOOUT
   2561 0000EDB8 E0 FF                   	lw		lr,[sp]
   2562 0000EDBA E2 F5                   	lw		r5,2[sp]
   2563 0000EDBC 04 6E                   	add		sp,sp,#4
   2564 0000EDBE F0 80                   	ret
                                        
                                        
                                        ; 'FNDLN' finds a line with a given line no. (in r1) in the
                                        ; text save area.  r9 is used as the text pointer. If the line
                                        ; is found, r9 will point to the beginning of that line
                                        ; (i.e. the high byte of the line no.), and flags are Z.
                                        ; If that line is not there and a line with a higher line no.
                                        ; is found, r9 points there and flags are NC & NZ. If we reached
                                        ; the end of the text save area and cannot find the line, flags
                                        ; are C & NZ.
                                        ; Z=1 if line found
                                        ; N=1 if end of text save area
                                        ; Z=0 & N=0 if higher line found
                                        ;
                                        ; 'FNDLN' will initialize r9 to the beginning of the text save
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 44
noc_boot41.a
                                        ; area to start the search. Some other entries of this routine
                                        ; will not initialize r9 and do the search.
                                        ; 'FNDLNP' will start with r9 and search for the line no.
                                        ; 'FNDNXT' will bump r9 by 2, find a CR and then start search.
                                        ; 'FNDSKP' uses r9 to find a CR, and then starts the search.
                                        ; return Z=1 if line is found, r9 = pointer to line
                                        ;
                                        ; Parameters
                                        ;	r1 = line number to find
                                        ;
   2590 0000EDC0                        FNDLN
   2591 0000EDC0 00 40 11 10             	cmp		r1,#0xFFFF	; line no. must be < 65535
   2592 0000EDC4 03 A6                   	bleu	fl1
   2593 0000EDC6 3B 4F 02 11             	lea		r1,msgLineRange
   2594 0000EDCA 8C BE                   	br		ERROR
   2595 0000EDCC                        fl1
   2596 0000EDCC 2C 4E 0C F9             	lw		r9,TXTBGN	; init. the text save pointer
                                        
   2598 0000EDD0                        FNDLNP
   2599 0000EDD0 12 40 06 FA             	lw		r10,TXTUNF	; check if we passed the end
   2600 0000EDD4 FF 6A                   	sub		r10,r10,#1
   2601 0000EDD6 AD 29                   	cmp		r9,r10
   2602 0000EDD8 0F A7                   	bgtu	FNDRET		; if so, return with Z=0 & C=1
   2603 0000EDDA 90 E3                   	lb		r3,[r9]		; get low order byte of line number
   2604 0000EDDC 0E 23                   	zxb		r3
   2605 0000EDDE 91 E2                   	lb		r2,1[r9]	; get high order byte
   2606 0000EDE0 0E 22                   	zxb		r2
   2607 0000EDE2 81 32                   	shl		r2,#1
   2608 0000EDE4 81 32                   	shl		r2,#1
   2609 0000EDE6 81 32                   	shl		r2,#1
   2610 0000EDE8 81 32                   	shl		r2,#1
   2611 0000EDEA 81 32                   	shl		r2,#1
   2612 0000EDEC 81 32                   	shl		r2,#1
   2613 0000EDEE 81 32                   	shl		r2,#1
   2614 0000EDF0 81 32                   	shl		r2,#1
   2615 0000EDF2 36 22                   	or		r2,r3		; build whole line number
   2616 0000EDF4 2D 21                   	cmp		r1,r2		; is this the line we want?
   2617 0000EDF6 01 A7                   	bgtu	FNDNXT		; no, not there yet
   2618 0000EDF8                        FNDRET
   2619 0000EDF8 F0 80                   	ret			; return the cond. codes
                                        
   2621 0000EDFA                        FNDNXT
   2622 0000EDFA 02 69                   	add		r9,r9,#2	; find the next line
                                        
   2624 0000EDFC                        FNDSKP
   2625 0000EDFC 90 E2                   	lb		r2,[r9]
   2626 0000EDFE 01 69                   	add		r9,r9,#1
   2627 0000EE00 FF 4F 23 10             	cmp		r2,#CR		; try to find a CR
   2628 0000EE04 FB B9                   	bne		FNDSKP		; keep looking
   2629 0000EE06 E4 BE                   	br		FNDLNP		; check if end of text
                                        
                                        
                                        ;******************************************************************
                                        ; 'MVUP' moves a block up from where r1 points to where r2 points
                                        ; until r1=r3
                                        ;
   2636 0000EE08                        MVUP1
   2637 0000EE08 10 E4                   	lb		r4,[r1]
   2638 0000EE0A 20 C4                   	sb		r4,[r2]
   2639 0000EE0C 01 61                   	add		r1,r1,#1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 45
noc_boot41.a
   2640 0000EE0E 01 62                   	add		r2,r2,#1
   2641 0000EE10                        MVUP
   2642 0000EE10 3D 21                   	cmp		r1,r3
   2643 0000EE12 FA B9                   	bne		MVUP1
   2644 0000EE14                        MVRET
   2645 0000EE14 F0 80                   	ret
                                        
                                        
                                        ; 'MVDOWN' moves a block down from where r1 points to where r2
                                        ; points until r1=r3
                                        ;
   2651 0000EE16                        MVDOWN1
   2652 0000EE16 FF 61                   	sub		r1,r1,#1
   2653 0000EE18 FF 62                   	sub		r2,r2,#1
   2654 0000EE1A 10 E4                   	lb		r4,[r1]
   2655 0000EE1C 20 C4                   	sb		r4,[r2]
   2656 0000EE1E                        MVDOWN
   2657 0000EE1E 3D 21                   	cmp		r1,r3
   2658 0000EE20 FA B9                   	bne		MVDOWN1
   2659 0000EE22 F0 80                   	ret
                                        
                                        
                                        ; 'POPA' restores the 'FOR' loop variable save area from the stack
                                        ;
                                        ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                                        ;
                                        ; Note: a single zero word is stored on the stack in the
                                        ; case that no FOR loops need to be saved. This needs to be
                                        ; done because PUSHA / POPA is called all the time.
                                        
   2670 0000EE24                        POPA
   2671 0000EE24 E0 F1                   	lw		r1,[sp]		; restore LOPVAR, but zero means no more
   2672 0000EE26 11 40 0C D1             	sw		r1,LOPVAR
   2673 0000EE2A 0E A8                   	beq		PP1
   2674 0000EE2C E8 F1                   	lw		r1,8[sp]	; if not zero, restore the rest
   2675 0000EE2E 12 40 04 D1             	sw		r1,LOPPT
   2676 0000EE32 E6 F1                   	lw		r1,6[sp]
   2677 0000EE34 12 40 02 D1             	sw		r1,LOPLN
   2678 0000EE38 E4 F1                   	lw		r1,4[sp]
   2679 0000EE3A 12 40 00 D1             	sw		r1,LOPLMT
   2680 0000EE3E E2 F1                   	lw		r1,2[sp]
   2681 0000EE40 11 40 0E D1             	sw		r1,LOPINC
   2682 0000EE44 0A 6E                   	add		sp,sp,#10
   2683 0000EE46 F0 80                   	ret
   2684 0000EE48                        PP1
   2685 0000EE48 02 6E                   	add		sp,sp,#2
   2686 0000EE4A F0 80                   	ret
                                        
                                        
   2689 0000EE4C                        PUSHA
   2690 0000EE4C 13 40 00 F1             	lw		r1,STKBOT	; Are we running out of stack room?
   2691 0000EE50 0A 61                   	add		r1,r1,#10	; we might need this many bytes
   2692 0000EE52 1D 2E                   	cmp		sp,r1
   2693 0000EE54 42 B4                   	bltu	QSORRY		; out of stack space
   2694 0000EE56 11 40 0C F1             	lw		r1,LOPVAR	; save loop variables
   2695 0000EE5A 0F A8                   	beq		PU1			; if LOPVAR is zero, that's all
   2696 0000EE5C F6 6E                   	sub		sp,sp,#10
   2697 0000EE5E E0 D1                   	sw		r1,[sp]
   2698 0000EE60 12 40 04 F1             	lw		r1,LOPPT
   2699 0000EE64 E8 D1                   	sw		r1,8[sp]	; else save all the others
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 46
noc_boot41.a
   2700 0000EE66 12 40 02 F1             	lw		r1,LOPLN
   2701 0000EE6A E6 D1                   	sw		r1,6[sp]
   2702 0000EE6C 12 40 00 F1             	lw		r1,LOPLMT
   2703 0000EE70 E4 D1                   	sw		r1,4[sp]
   2704 0000EE72 11 40 0E F1             	lw		r1,LOPINC
   2705 0000EE76 E2 D1                   	sw		r1,2[sp]
   2706 0000EE78 F0 80                   	ret
   2707 0000EE7A                        PU1
   2708 0000EE7A FE 6E                   	sub		sp,sp,#2
   2709 0000EE7C E0 D1                   	sw		r1,[sp]
   2710 0000EE7E F0 80                   	ret
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                                        ;
                                        ; 'PRTSTG' prints a string pointed to by r3. It stops printing
                                        ; and returns to the caller when either a CR is printed or when
                                        ; the next byte is the same as what was passed in r4 by the
                                        ; caller.
                                        ;
                                        ; 'QTSTG' looks for an underline (back-arrow on some systems),
                                        ; single-quote, or double-quote.  If none of these are found, returns
                                        ; to the caller.  If underline, outputs a CR without a LF.  If single
                                        ; or double quote, prints the quoted string and demands a matching
                                        ; end quote.  After the printing, the next 2 bytes of the caller are
                                        ; skipped over (usually a short brnch instruction).
                                        ;
                                        ; 'PRTNUM' prints the 32 bit number in r3, leading blanks are added if
                                        ; needed to pad the number of spaces to the number in r4.
                                        ; However, if the number of digits is larger than the no. in
                                        ; r4, all digits are printed anyway. Negative sign is also
                                        ; printed and counted in, positive sign is not.
                                        ;
                                        ; 'PRTLN' prints the saved text line pointed to by r3
                                        ; with line no. and all.
                                        ;
                                        
                                        ; r1 = pointer to string
                                        ; r2 = stop character
                                        ; return r1 = pointer to end of line + 1
                                        
   2743 0000EE80                        PRTSTG
   2744 0000EE80 F8 6E                       sub     sp,sp,#8
   2745 0000EE82 E0 DF                       sw      lr,[sp]
   2746 0000EE84 E2 D5                       sw      r5,2[sp]
   2747 0000EE86 E4 D6                       sw      r6,4[sp]
   2748 0000EE88 E6 D7                       sw      r7,6[sp]
   2749 0000EE8A 10 15                       lw      r5,r1       ; r5 = pointer
   2750 0000EE8C 20 16                       lw      r6,r2       ; r6 = stop char
   2751 0000EE8E                        PS1
   2752 0000EE8E 50 E7                       lb      r7,[r5]     ; get a text character
   2753 0000EE90 01 65                       add     r5,r5,#1
   2754 0000EE92 6D 27                   	cmp     r7,r6		; same as stop character?
   2755 0000EE94 09 A8                   	beq	    PRTRET		; if so, return
   2756 0000EE96 70 11                   	lw      r1,r7
   2757 0000EE98 A0 4F 0E AF             	call	GOOUT		; display the char.
   2758 0000EE9C FF 4F 73 10             	cmp     r7,#CR      ; is it a C.R.?
   2759 0000EEA0 F6 B9                   	bne	    PS1		    ; no, go back for more
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 47
noc_boot41.a
   2760 0000EEA2 0A 11                   	lw      r1,#LF      ; yes, add a L.F.
   2761 0000EEA4 A0 4F 08 AF             	call	GOOUT
   2762 0000EEA8                        PRTRET
   2763 0000EEA8 70 12                       lw      r2,r7       ; return r2 = stop char
   2764 0000EEAA 50 11                   	lw		r1,r5		; return r1 = line pointer
   2765 0000EEAC E2 F5                       lw      r5,2[sp]
   2766 0000EEAE E4 F6                       lw      r6,4[sp]
   2767 0000EEB0 E6 F7                       lw      r7,6[sp]
   2768 0000EEB2 E0 FF                       lw      lr,[sp]
   2769 0000EEB4 08 6E                       add     sp,sp,#8
   2770 0000EEB6 F0 80                       ret			        ; then return
                                        
                                        
   2773 0000EEB8                        QTSTG
   2774 0000EEB8 FE 6E                   	sub		sp,sp,#2
   2775 0000EEBA E0 DF                   	sw		lr,[sp]
   2776 0000EEBC B7 AF                   	call	TSTC		; *** QTSTG ***
   2777 0000EEBE 22 18                   	db	'"',QT3-*+1
   2778 0000EEC0 02 40 02 12             	lw		r2,#'"'		; it is a "
   2779 0000EEC4                        QT1
   2780 0000EEC4 80 11                   	lw		r1,r8
   2781 0000EEC6 DC BF                   	call	PRTSTG		; print until another
   2782 0000EEC8 10 18                   	lw		r8,r1
   2783 0000EECA FF 4F 26 10             	cmp		r2,#LF		; was last one a CR?
   2784 0000EECE 0E A9                   	bne		QT2
   2785 0000EED0 02 6E                   	add		sp,sp,#2
   2786 0000EED2 AD 4F 09 AE             	br		RUNNXL		; if so, run next line
   2787 0000EED6                        QT3
   2788 0000EED6 AA AF                   	call	TSTC		; is it a single quote?
   2789 0000EED8 27 08                   	db	"'",QT4-*+1
   2790 0000EEDA 02 40 07 12             	lw		r2,#''''	; if so, do same as above
   2791 0000EEDE F2 BE                   	br		QT1
   2792 0000EEE0                        QT4
   2793 0000EEE0 A5 AF                   	call	TSTC		; is it an underline?
   2794 0000EEE2 5F 10                   	db	'_',QT5-*+1
   2795 0000EEE4 00 40 0D 11             	lw		r1,#CR		; if so, output a CR without LF
   2796 0000EEE8 9E 4F 06 AF             	call	GOOUT
   2797 0000EEEC                        QT2
   2798 0000EEEC E0 FF                   	lw		lr,[sp]
   2799 0000EEEE 02 6E                   	add		sp,sp,#2
   2800 0000EEF0 F2 80                   	jmp		2[lr]		; skip over 2 bytes when returning
   2801 0000EEF2                        QT5						; not " ' or _
   2802 0000EEF2 E0 FF                   	lw		lr,[sp]
   2803 0000EEF4 02 6E                   	add		sp,sp,#2
   2804 0000EEF6 F0 80                   	ret
                                        
                                        
                                        ; Output a CR LF sequence
                                        ;
   2809 0000EEF8                        prCRLF
   2810 0000EEF8 FE 6E                   	sub		sp,sp,#2
   2811 0000EEFA E0 DF                   	sw		lr,[sp]
   2812 0000EEFC 00 40 0D 11             	lw		r1,#CR
   2813 0000EF00 9D 4F 0A AF             	call	GOOUT
   2814 0000EF04 0A 11                   	lw		r1,#LF
   2815 0000EF06 9D 4F 07 AF             	call	GOOUT
   2816 0000EF0A E0 FF                   	lw		lr,[sp]
   2817 0000EF0C 02 6E                   	add		sp,sp,#2
   2818 0000EF0E F0 80                   	ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 48
noc_boot41.a
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
                                        ; Register Usage
                                        ;	r5 = number of padding spaces
   2825 0000EF10                        PRTNUM
   2826 0000EF10 F8 6E                   	sub		sp,sp,#8
   2827 0000EF12 E0 DF                   	sw		lr,[sp]
   2828 0000EF14 E2 D5                   	sw		r5,2[sp]
   2829 0000EF16 E4 D6                   	sw		r6,4[sp]
   2830 0000EF18 E6 D7                   	sw		r7,6[sp]
                                        
   2832 0000EF1A 13 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2833 0000EF1E 10 16                   	lw		r6,r1		; save number for later
   2834 0000EF20 20 15                   	lw		r5,r2		; r5 = min number of chars
   2835 0000EF22 16 21                   	
   2836 0000EF24 02 AB                   	bpl		PN1			; if not
   2837 0000EF26 20 31                   	neg		r1			; else make it positive
   2838 0000EF28 FF 65                   	sub		r5,r5,#1	; one less for width count
   2839 0000EF2A                        PN1
   2840 0000EF2A 0A 12                   	lw		r2,#10		; divide by 10
   2841 0000EF2C E1 4F 06 AF             	call	DIV32
   2842 0000EF30 30 62                   	add		r2,r2,#'0'	; convert remainder to ascii
   2843 0000EF32 70 C2                   	sb		r2,[r7]		; and store in buffer
   2844 0000EF34 01 67                   	add		r7,r7,#1
   2845 0000EF36 FF 65                   	sub		r5,r5,#1	; decrement width
   2846 0000EF38 10 10                   	cmp		r1,#0
   2847 0000EF3A F7 B9                   	bne		PN1
   2848 0000EF3C                        PN6
   2849 0000EF3C 56 25                   	or		r5,r5		; test pad count
   2850 0000EF3E 06 A2                   	ble		PN4			; skip padding if not needed
   2851 0000EF40                        PN3
   2852 0000EF40 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2853 0000EF44 9B 4F 08 AF             	call	GOOUT
   2854 0000EF48 FF 65                   	sub		r5,r5,#1
   2855 0000EF4A FA B9                   	bne		PN3
   2856 0000EF4C                        PN4
   2857 0000EF4C 66 26                   	or		r6,r6		; is number negative?
   2858 0000EF4E 04 AB                   	bpl		PN5
   2859 0000EF50 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2860 0000EF54 9B 4F 00 AF             	call	GOOUT
   2861 0000EF58                        PN5
   2862 0000EF58 FF 67                   	sub		r7,r7,#1
   2863 0000EF5A 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2864 0000EF5C 9A 4F 0C AF             	call	GOOUT
   2865 0000EF60 EC 4F 7E 10             	cmp		r7,#NUMWKA
   2866 0000EF64 F9 B7                   	bgtu	PN5
   2867 0000EF66                        PNRET
   2868 0000EF66 E0 FF                   	lw		lr,[sp]
   2869 0000EF68 E2 F5                   	lw		r5,2[sp]
   2870 0000EF6A E4 F6                   	lw		r6,4[sp]
   2871 0000EF6C E6 F7                   	lw		r7,6[sp]
   2872 0000EF6E 08 6E                   	add		sp,sp,#8
   2873 0000EF70 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
   2878 0000EF72                        PRTHEXNUM
   2879 0000EF72 F6 6E                   	sub		sp,sp,#10
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 49
noc_boot41.a
   2880 0000EF74 E0 DF                   	sw		lr,[sp]
   2881 0000EF76 E2 D5                   	sw		r5,2[sp]
   2882 0000EF78 E4 D6                   	sw		r6,4[sp]
   2883 0000EF7A E6 D7                   	sw		r7,6[sp]
   2884 0000EF7C E8 D8                   	sw		r8,8[sp]
                                        
   2886 0000EF7E 13 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2887 0000EF82 10 16                   	lw		r6,r1		; save number for later
   2888 0000EF84 0A 15                   	lw		r5,#10		; r5 = min number of chars
   2889 0000EF86 10 14                   	lw		r4,r1
   2890 0000EF88 46 24                   	
   2891 0000EF8A 03 AB                   	bpl		PHN1		; if not
   2892 0000EF8C 20 34                   	neg		r4			; else make it positive
   2893 0000EF8E FF 65                   	sub		r5,r5,#1	; one less for width count
   2894 0000EF90 0A 18                   	lw		r8,#10		; maximum of 10 digits
   2895 0000EF92                        PHN1
   2896 0000EF92 40 11                   	lw		r1,r4
   2897 0000EF94 00 40 5F 31             	and		r1,#15
   2898 0000EF98 FF 4F 16 10             	cmp		r1,#10
   2899 0000EF9C 02 A0                   	blt		PHN7
   2900 0000EF9E 37 61                   	add		r1,r1,#'A'-10
   2901 0000EFA0 01 AE                   	br		PHN8
   2902 0000EFA2                        PHN7
   2903 0000EFA2 30 61                   	add		r1,r1,#'0'		; convert remainder to ascii
   2904 0000EFA4                        PHN8
   2905 0000EFA4 70 C1                   	sb		r1,[r7]		; and store in buffer
   2906 0000EFA6 01 67                   	add		r7,r7,#1
   2907 0000EFA8 FF 65                   	sub		r5,r5,#1	; decrement width
   2908 0000EFAA A1 34                   	shr		r4,#1
   2909 0000EFAC A1 34                   	shr		r4,#1
   2910 0000EFAE A1 34                   	shr		r4,#1
   2911 0000EFB0 A1 34                   	shr		r4,#1
   2912 0000EFB2 02 A8                   	beq		PHN6			; is it zero yet ?
   2913 0000EFB4 FF 68                   	sub		r8,r8,#1	; safety
   2914 0000EFB6 ED B9                   	bne		PHN1
   2915 0000EFB8                        PHN6
   2916 0000EFB8 56 25                   	or		r5,r5		; test pad count
   2917 0000EFBA 06 A2                   	ble		PHN4			; skip padding if not needed
   2918 0000EFBC                        PHN3
   2919 0000EFBC 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2920 0000EFC0 97 4F 0A AF             	call	GOOUT
   2921 0000EFC4 FF 65                   	sub		r5,r5,#1
   2922 0000EFC6 FA B9                   	bne		PHN3
   2923 0000EFC8                        PHN4
   2924 0000EFC8 66 26                   	or		r6,r6		; is number negative?
   2925 0000EFCA 04 AB                   	bpl		PHN5
   2926 0000EFCC 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2927 0000EFD0 97 4F 02 AF             	call	GOOUT
   2928 0000EFD4                        PHN5
   2929 0000EFD4 FF 67                   	sub		r7,r7,#1
   2930 0000EFD6 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2931 0000EFD8 96 4F 0E AF             	call	GOOUT
   2932 0000EFDC EC 4F 7E 10             	cmp		r7,#NUMWKA
   2933 0000EFE0 F9 B7                   	bgtu	PHN5
   2934 0000EFE2                        PHNRET
   2935 0000EFE2 E0 FF                   	lw		lr,[sp]
   2936 0000EFE4 E2 F5                   	lw		r5,2[sp]
   2937 0000EFE6 E4 F6                   	lw		r6,4[sp]
   2938 0000EFE8 E6 F7                   	lw		r7,6[sp]
   2939 0000EFEA E8 F8                   	lw		r8,8[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 50
noc_boot41.a
   2940 0000EFEC 0A 6E                   	add		sp,sp,#10
   2941 0000EFEE F0 80                   	ret
                                        
                                        
                                        ; r1 = pointer to line
                                        ; returns r1 = pointer to end of line + 1
   2946 0000EFF0                        PRTLN
   2947 0000EFF0 FC 6E                       sub     sp,sp,#4
   2948 0000EFF2 E0 DF                       sw      lr,[sp]
   2949 0000EFF4 E2 D5                       sw      r5,2[sp]
   2950 0000EFF6 12 15                       add     r5,r1,#2
   2951 0000EFF8 5E E1                       lb		r1,-2[r5]	; get the binary line number
   2952 0000EFFA 0E 21                       zxb		r1
   2953 0000EFFC 5F E2                       lb		r2,-1[r5]
   2954 0000EFFE 0E 22                       zxb		r2
   2955 0000F000 81 32                       shl		r2,#1
   2956 0000F002 81 32                       shl		r2,#1
   2957 0000F004 81 32                       shl		r2,#1
   2958 0000F006 81 32                       shl		r2,#1
   2959 0000F008 81 32                       shl		r2,#1
   2960 0000F00A 81 32                       shl		r2,#1
   2961 0000F00C 81 32                       shl		r2,#1
   2962 0000F00E 81 32                       shl		r2,#1
   2963 0000F010 26 21                       or		r1,r2
   2964 0000F012 00 12                       lw      r2,#0       ; display a 0 or more digit line no.
   2965 0000F014 7D BF                   	call	PRTNUM
   2966 0000F016 02 40 00 11             	lw      r1,#' '     ; followed by a blank
   2967 0000F01A 94 4F 0D AF             	call	GOOUT
   2968 0000F01E 00 12                   	lw      r2,#0       ; stop char. is a zero
   2969 0000F020 50 11                   	lw      r1,r5
   2970 0000F022 2E BF                   	call    PRTSTG		; display the rest of the line
   2971 0000F024 E2 F5                   	lw      r5,2[sp]
   2972 0000F026 E0 FF                   	lw      lr,[sp]
   2973 0000F028 04 6E                   	add     sp,sp,#4
   2974 0000F02A F0 80                   	ret
                                        
                                        
                                        ; ===== Test text byte following the call to this subroutine. If it
                                        ;	equals the byte pointed to by r8, return to the code following
                                        ;	the call. If they are not equal, brnch to the point
                                        ;	indicated by the offset byte following the text byte.
                                        ;
                                        ; Registers Affected
                                        ;   r3,r8
                                        ; Returns
                                        ;	r8 = updated text pointer
                                        ;
   2987 0000F02C                        TSTC
   2988 0000F02C FC 6E                   	sub		sp,sp,#4
   2989 0000F02E E0 DF                   	sw		lr,[sp]
   2990 0000F030 E2 D1                   	sw		r1,2[sp]
   2991 0000F032 2F AF                   	call	IGNBLK		; ignore leading blanks
   2992 0000F034 E0 FF                   	lw		lr,[sp]	; get the return address
   2993 0000F036 F0 E3                   	lb		r3,[lr]	; get the byte to compare
   2994 0000F038 80 E1                   	lb		r1,[r8]
   2995 0000F03A 1D 23                   	cmp		r3,r1		; is it = to what r8 points to?
   2996 0000F03C 05 A8                   	beq		TC1			; if so
                                        						; If not, add the second
   2998 0000F03E F1 E3                   	lb		r3,1[lr]	; byte following the call to
   2999 0000F040 30 2F                   	add		lr,r3		; the return address.
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 51
noc_boot41.a
   3000 0000F042 E2 F1                   	lw		r1,2[sp]
   3001 0000F044 04 6E                   	add		sp,sp,#4
   3002 0000F046 F0 80                   	ret					; jump to the routine
   3003 0000F048                        TC1
   3004 0000F048 01 68                   	add		r8,r8,#1	; if equal, bump text pointer
   3005 0000F04A E2 F1                   	lw		r1,2[sp]
   3006 0000F04C 04 6E                   	add     sp,sp,#4
   3007 0000F04E F2 80                   	jmp		2[lr]		; Skip the 2 bytes following
                                        						; the call and continue.
                                        
                                        
                                        ; ===== See if the text pointed to by r8 is a number. If so,
                                        ;	return the number in r2 and the number of digits in r3,
                                        ;	else return zero in r2 and r3.
                                        ; Registers Affected
                                        ;   r1,r2,r3,r4
                                        ; Returns
                                        ; 	r1 = number
                                        ;	r2 = number of digits in number
                                        ;	r8 = updated text pointer
                                        ;
   3021 0000F050                        TSTNUM
   3022 0000F050 FE 6E                   	sub		sp,sp,#2
   3023 0000F052 E0 DF                   	sw		lr,[sp]
   3024 0000F054 1E AF                   	call	IGNBLK		; skip over blanks
   3025 0000F056 00 11                   	lw		r1,#0		; initialize return parameters
   3026 0000F058 00 12                   	lw		r2,#0
   3027 0000F05A                        TN1
   3028 0000F05A 80 E3                   	lb		r3,[r8]
   3029 0000F05C FD 4F 30 10             	cmp		r3,#'0'		; is it less than zero?
   3030 0000F060 15 A4                   	bltu	TSNMRET 	; if so, that's all
   3031 0000F062 FC 4F 37 10             	cmp		r3,#'9'		; is it greater than nine?
   3032 0000F066 12 A7                   	bgtu	TSNMRET 	; if so, return
   3033 0000F068 33 43 14 10             	cmp		r1,#214748364	; see if there's room for new digit
   3034 0000F06C 04 A6                   	bleu	TN2
   3035 0000F06E 34 4F 07 11             	lea		r1,msgNumTooBig
   3036 0000F072 E3 4F 07 AE             	br		ERROR		; if not, we've overflowd
   3037 0000F076                        TN2
   3038 0000F076 10 14                   	lw		r4,r1		; quickly multiply result by 10
   3039 0000F078 81 31                   	shl		r1,#1		; * 2
   3040 0000F07A 81 31                   	shl		r1,#1		; * 4
   3041 0000F07C 40 21                   	add		r1,r4		; * 5
   3042 0000F07E 81 31                   	shl		r1,#1		; * 10
   3043 0000F080 01 68                   	add		r8,r8,#1	; adjust text pointer
   3044 0000F082 00 40 5F 33             	and		r3,#0xF		; add in the new digit
   3045 0000F086 30 21                   	add		r1,r3
   3046 0000F088 01 62                   	add		r2,r2,#1	; increment the no. of digits
   3047 0000F08A E7 BE                   	br		TN1
   3048 0000F08C                        TSNMRET
   3049 0000F08C E0 FF                   	lw		lr,[sp]
   3050 0000F08E 02 6E                   	add		sp,sp,#2
   3051 0000F090 F0 80                   	ret
                                        
                                        
                                        ;===== Skip over blanks in the text pointed to by r8.
                                        ;
                                        ; Registers Affected:
                                        ;	r8
                                        ; Returns
                                        ;	r8 = pointer updateded past any spaces or tabs
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 52
noc_boot41.a
                                        ;
   3061 0000F092                        IGNBLK
   3062 0000F092 FE 6E                   	sub		sp,sp,#2
   3063 0000F094 E0 D1                   	sw		r1,[sp]
   3064 0000F096                        IGB2
   3065 0000F096 80 E1                   	lb		r1,[r8]			; get char
   3066 0000F098 FE 4F 10 10             	cmp		r1,#' '			; see if it's a space
   3067 0000F09C 03 A8                   	beq		IGB1			; if so, swallow it
   3068 0000F09E FF 4F 17 10             	cmp		r1,#'\t'		; or a tab
   3069 0000F0A2 02 A9                   	bne		IGBRET
   3070 0000F0A4                        IGB1
   3071 0000F0A4 01 68                   	add		r8,r8,#1		; increment the text pointer
   3072 0000F0A6 F7 BE                   	br		IGB2
   3073 0000F0A8                        IGBRET
   3074 0000F0A8 E0 F1                   	lw		r1,[sp]
   3075 0000F0AA 02 6E                   	add		sp,sp,#2
   3076 0000F0AC F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the line of text in the input buffer to upper
                                        ;	case (except for stuff between quotes).
                                        ;
                                        ; Registers Affected
                                        ;   r1,r3
                                        ; Returns
                                        ;	r8 = pointing to end of text in buffer
                                        ;
   3087 0000F0AE                        TOUPBUF
   3088 0000F0AE FE 6E                   	sub		sp,sp,#2
   3089 0000F0B0 E0 DF                   	sw		lr,[sp]
   3090 0000F0B2 13 40 0E 18             	lea		r8,BUFFER	; set up text pointer
   3091 0000F0B6 00 13                   	lw		r3,#0		; clear quote flag
   3092 0000F0B8                        TOUPB1
   3093 0000F0B8 80 E1                   	lb		r1,[r8]		; get the next text char.
   3094 0000F0BA 01 68                   	add		r8,r8,#1
   3095 0000F0BC FF 4F 13 10             	cmp		r1,#CR		; is it end of line?
   3096 0000F0C0 13 A8                   	beq		TOUPBRT 	; if so, return
   3097 0000F0C2 FD 4F 1E 10             	cmp		r1,#'"'		; a double quote?
   3098 0000F0C6 08 A8                   	beq		DOQUO
   3099 0000F0C8 FD 4F 19 10             	cmp		r1,#''''	; or a single quote?
   3100 0000F0CC 05 A8                   	beq		DOQUO
   3101 0000F0CE 30 10                   	cmp		r3,#0		; inside quotes?
   3102 0000F0D0 F3 B9                   	bne		TOUPB1		; if so, do the next one
   3103 0000F0D2 0D AF                   	call	toUpper 	; convert to upper case
   3104 0000F0D4 8F C1                   	sb		r1,-1[r8]	; store it
   3105 0000F0D6 F0 BE                   	br		TOUPB1		; and go back for more
   3106 0000F0D8                        DOQUO
   3107 0000F0D8 30 10                   	cmp		r3,#0		; are we inside quotes?
   3108 0000F0DA 02 A9                   	bne		DOQUO1
   3109 0000F0DC 10 13                   	lw		r3,r1		; if not, toggle inside-quotes flag
   3110 0000F0DE EC BE                   	br		TOUPB1
   3111 0000F0E0                        DOQUO1
   3112 0000F0E0 1D 23                   	cmp		r3,r1		; make sure we're ending proper quote
   3113 0000F0E2 EA B9                   	bne		TOUPB1		; if not, ignore it
   3114 0000F0E4 00 13                   	lw		r3,#0		; else clear quote flag
   3115 0000F0E6 E8 BE                   	br		TOUPB1
   3116 0000F0E8                        TOUPBRT
   3117 0000F0E8 E0 FF                   	lw		lr,[sp]
   3118 0000F0EA 02 6E                   	add		sp,sp,#2
   3119 0000F0EC F0 80                   	ret
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 53
noc_boot41.a
                                        
                                        
                                        ; ===== Convert the character in r1 to upper case
                                        ;
   3124 0000F0EE                        toUpper
   3125 0000F0EE F9 4F 1F 10             	cmp		r1,#'a'		; is it < 'a'?
   3126 0000F0F2 04 A0                   	blt	    TOUPRET
   3127 0000F0F4 F8 4F 16 10             	cmp		r1,#'z'		; or > 'z'?
   3128 0000F0F8 01 A3                   	bgt	    TOUPRET
   3129 0000F0FA E0 61                   	sub		r1,r1,#32	; if not, make it upper case
   3130 0000F0FC                        TOUPRET
   3131 0000F0FC F0 80                   	ret
                                        
                                        
                                        ; 'CHKIO' checks the input. If there's no input, it will return
                                        ; to the caller with the Z flag set. If there is input, the Z
                                        ; flag is cleared and the input byte is in r2. However, if a
                                        ; control-C is read, 'CHKIO' will warm-start BASIC and will not
                                        ; return to the caller.
                                        ;
   3140 0000F0FE                        CHKIO
   3141 0000F0FE FE 6E                   	sub		sp,sp,#2	; save link reg
   3142 0000F100 E0 DF                   	sw		lr,[sp]
   3143 0000F102 8D 4F 0B AF             	call	GOIN		; get input if possible
   3144 0000F106 07 A8                   	beq		CHKRET2		; if Zero, no input
   3145 0000F108 1D 10                   	cmp		r1,#CTRLC	; is it control-C?
   3146 0000F10A 02 A9                   	bne		CHKRET		; if not
   3147 0000F10C 8F 4F 0A AE             	jmp		WSTART		; if so, do a warm start
   3148 0000F110                        CHKRET
   3149 0000F110 E0 FF                   	lw		lr,[sp]
   3150 0000F112 02 6E                   	add		sp,sp,#2	; Z=0
   3151 0000F114 F0 80                   	ret
   3152 0000F116                        CHKRET2
   3153 0000F116 E0 FF                   	lw		lr,[sp]
   3154 0000F118 02 6E                   	add		sp,sp,#2
   3155 0000F11A 00 11                   	lw		r1,#0		; Z=1
   3156 0000F11C F0 80                   	ret
                                        
                                        
                                        ; ===== Display a CR-LF sequence
                                        ;
   3161 0000F11E                        CRLF
   3162 0000F11E 32 4F 09 11             	lea		r1,CLMSG
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r4
                                        ;
   3169 0000F122                        PRMESG
   3170 0000F122 FC 6E                   	sub		sp,sp,#4
   3171 0000F124 E0 DF                   	sw		lr,[sp]
   3172 0000F126 E2 D5                   	sw		r5,2[sp]
   3173 0000F128 10 15                   	lw      r5,r1       ; r5 = pointer to message
   3174 0000F12A                        PRMESG1
   3175 0000F12A 01 65                   	add		r5,r5,#1
   3176 0000F12C 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   3177 0000F12E 03 A8                   	beq		PRMRET
   3178 0000F130 8C 4F 02 AF             	call	GOOUT		;else display it trashes r4
   3179 0000F134 FA BE                   	br		PRMESG1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 54
noc_boot41.a
   3180 0000F136                        PRMRET
   3181 0000F136 50 11                   	lw		r1,r5
   3182 0000F138 E2 F5                   	lw		r5,2[sp]
   3183 0000F13A E0 FF                   	lw		lr,[sp]
   3184 0000F13C 04 6E                   	add		sp,sp,#4
   3185 0000F13E F0 80                   	ret
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r3
                                        ;
   3192 0000F140                        PRMESGAUX
   3193 0000F140 FC 6E                   	sub		sp,sp,#4
   3194 0000F142 E0 DF                   	sw		lr,[sp]
   3195 0000F144 E2 D5                   	sw		r5,2[sp]
   3196 0000F146 10 15                   	lw      r5,r1       ; r3 = pointer
   3197 0000F148                        PRMESGA1
   3198 0000F148 01 65                   	add		r5,r5,#1
   3199 0000F14A 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   3200 0000F14C 03 A8                   	beq		PRMRETA
   3201 0000F14E 8B 4F 07 AF             	call	GOAUXO		;else display it
   3202 0000F152 FA BE                   	br		PRMESGA1
   3203 0000F154                        PRMRETA
   3204 0000F154 50 11                   	lw		r1,r5
   3205 0000F156 E2 F5                   	lw		r5,2[sp]
   3206 0000F158 E0 FF                   	lw		lr,[sp]
   3207 0000F15A 04 6E                   	add		sp,sp,#4
   3208 0000F15C F0 80                   	ret
                                        
                                        ;*****************************************************
                                        ; The following routines are the only ones that need *
                                        ; to be changed for a different I/O environment.     *
                                        ;*****************************************************
                                        
                                        
                                        ; ===== Output character to the console (Port 1) from register D0
                                        ;	(Preserves all registers.)
                                        ;
   3219 0000F15E                        OUTC
   3220 0000F15E FF BE                   	jmp		_putChar
                                        
                                        
                                        ; ===== Input a character from the console into register D0 (or
                                        ;	return Zero status if there's no character available).
                                        ;
   3226 0000F160                        INC
   3227 0000F160 FE 6E                   	add		sp,sp,#-2
   3228 0000F162 E0 DF                   	sw		lr,[sp]
   3229 0000F164 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   3230 0000F168 04 A8                   	beq		INC1
   3231 0000F16A 77 4F 0E AF             	call	Recv
   3232 0000F16E 7A 4F 03 AF             	call	RecvDispatch
   3233 0000F172                        INC1
                                        ; get char from keyboard
                                        ; returns char in r1
   3236 0000F172                        _getChar
   3237 0000F172 C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   3238 0000F176 08 AB                   	bpl		gc1
   3239 0000F178 C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 55
noc_boot41.a
   3240 0000F17C 05 AA                   	bmi		gc1			; was it a keyup event ? (ignore)
   3241 0000F17E 07 40 5F 31             	and		r1,#0x7f
   3242 0000F182 E0 FF                   	lw		lr,[sp]
   3243 0000F184 02 6E                   	add		sp,sp,#2
   3244 0000F186 F0 80                   	ret
   3245 0000F188                        gc1
   3246 0000F188 E0 FF                   	lw		lr,[sp]
   3247 0000F18A 02 6E                   	add		sp,sp,#2
   3248 0000F18C 00 11                   	lw		r1,#0		; return Z=1 (no character)
   3249 0000F18E F0 80                   	ret
                                        
                                        
                                        ; get char from keyboard
                                        ; returns char in r1
   3254 0000F190                        _getCharWait
   3255 0000F190                        gc2
   3256 0000F190 C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   3257 0000F194 FD BB                   	bpl		gc2
   3258 0000F196 C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   3259 0000F19A FA BA                   	bmi		gc2			; was it a keyup event ? (ignore)
   3260 0000F19C 07 40 5F 31             	and		r1,#0x7f
   3261 0000F1A0 F0 80                   	ret
                                        
                                        
                                        ; Trigger a load operation on the target node.
                                        
   3266 0000F1A2                        TriggerTgtLoad:
   3267 0000F1A2 72 4F 0D AF             	call	zeroTxBuf
   3268 0000F1A6 0E 40 0A E2             	lb		r2,tgtNode
   3269 0000F1AA 02 40 0E C2             	sb		r2,txBuf+MSG_DST
   3270 0000F1AE 01 40 01 12             	lw		r2,#$11
   3271 0000F1B2 02 40 0C C2             	sb		r2,txBuf+MSG_SRC
   3272 0000F1B6 0A 12                   	lw		r2,#10				; trigger load on target node
   3273 0000F1B8 02 40 08 C2             	sb		r2,txBuf+MSG_TYPE
   3274 0000F1BC 73 4F 07 AF             	call	Xmit
   3275 0000F1C0 E2 F2                   	lw		r2,2[sp]
   3276 0000F1C2 E0 FF                   	lw		lr,[sp]
   3277 0000F1C4 F0 80                   	ret
                                        
                                        ; ===== Output character to the host (Port 2) from register r1
                                        ;	(Preserves all registers.)
                                        ;
   3282 0000F1C6                        AUXOUT
   3283 0000F1C6 FC 6E                   	add		sp,sp,#-4
   3284 0000F1C8 E0 DF                   	sw		lr,[sp]
   3285 0000F1CA E2 D2                   	sw		r2,2[sp]
   3286 0000F1CC 0E 40 0A E2             	lb		r2,tgtNode
                                        	cmp		#$11
   3288 0000F1D0 05 A9                   	bne		auxout1
   3289 0000F1D2 31 48 0A AF             	call	putSerial	; call boot rom routine
   3290 0000F1D6 E2 F2                   	lw		r2,2[sp]
   3291 0000F1D8 E0 FF                   	lw		lr,[sp]
   3292 0000F1DA F0 80                   	ret
   3293 0000F1DC                        auxout1:
   3294 0000F1DC 71 4F 00 AF             	call	zeroTxBuf
   3295 0000F1E0 02 40 00 C1             	sb		r1,txBuf
   3296 0000F1E4 0E 40 0A E2             	lb		r2,tgtNode
   3297 0000F1E8 02 40 0E C2             	sb		r2,txBuf+MSG_DST
   3298 0000F1EC 01 40 01 12             	lw		r2,#$11
   3299 0000F1F0 02 40 0C C2             	sb		r2,txBuf+MSG_SRC
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 56
noc_boot41.a
   3300 0000F1F4 0B 12                   	lw		r2,#11				; recieve BASIC program char
   3301 0000F1F6 02 40 08 C2             	sb		r2,txBuf+MSG_TYPE
   3302 0000F1FA 71 4F 08 AF             	call	Xmit
   3303 0000F1FE E2 F2                   	lw		r2,2[sp]
   3304 0000F200 E0 FF                   	lw		lr,[sp]
   3305 0000F202 F0 80                   	ret
                                        ;
                                        ; ===== Input a character from the host into register D0 (or
                                        ;	return negative status if there's no character available).
                                        ;
   3310 0000F204                        AUXIN
                                        ; get character from serial port
                                        ; return  N=1 if no character available
   3313 0000F204 2F 48 0F AE             	jmp		peekSerial
                                        
                                        
   3316 0000F208                        _scrollScreen
   3317 0000F208 FC 6E                   	sub		sp,sp,#4
   3318 0000F20A E0 D5                   	sw		r5,[sp]
   3319 0000F20C 60 40 00 13             	lw		r3,#1536	; number of chars to move - 1
   3320 0000F210 00 42 00 12             	lw		r2,#VIDEORAM
   3321 0000F214 0E 40 04 E1             	lb		r1,txtWidth
   3322 0000F218 81 31                   	shl		r1,#1
   3323 0000F21A 81 31                   	shl		r1,#1
   3324 0000F21C                        ss1:
   3325 0000F21C 20 15                   	lw		r5,r2
   3326 0000F21E 10 25                   	add		r5,r1
   3327 0000F220 50 F4                   	lw		r4,[r5]		; char at next line
   3328 0000F222 20 D4                   	sw		r4,[r2]		; goes to this line
   3329 0000F224 04 62                   	add		r2,r2,#4
   3330 0000F226 FF 63                   	sub		r3,r3,#1
   3331 0000F228 F9 B9                   	bne     ss1
                                        	; blank out last line
   3333 0000F22A 02 40 00 13             	lw		r3,#' '
   3334 0000F22E 0E 40 0C D3             	sh		r3,charToPrint
   3335 0000F232 0E 40 04 E3             	lb		r3,txtWidth
   3336 0000F236 0E 40 0C F4             	lw		r4,charToPrint	; and colors
   3337 0000F23A                        ss2
   3338 0000F23A 20 D4                   	sw		r4,[r2]
   3339 0000F23C 04 62                   	add		r2,r2,#4
   3340 0000F23E FF 63                   	sub		r3,r3,#1
   3341 0000F240 FC B9                   	bne     ss2
   3342 0000F242 E0 F5                   	lw		r5,[sp]
   3343 0000F244 04 6E                   	add		sp,sp,#4
   3344 0000F246 F0 80                   	ret
                                        
                                        
                                        ; flash the character at the screen position
                                        ;   r1: 1 = flash, 0 = no flash
   3349 0000F248                        _flashCursor
   3350 0000F248 00 42 00 12             	lw		r2,#VIDEORAM
   3351 0000F24C 0E 40 08 F3             	lh		r3,pos
   3352 0000F250 81 33                   	shl		r3,#1
   3353 0000F252 81 33                   	shl		r3,#1
   3354 0000F254 20 23                   	add		r3,r2		; r3 = scr[pos]
                                        
   3356 0000F256 16 21                   	or		r1,r1
   3357 0000F258 04 A8                   	beq		fc1
   3358 0000F25A 33 E2                   	lb		r2,3[r3]	; get background color
   3359 0000F25C 08 40 60 32             	or		r2,#0x80	; set flash indicator
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 57
noc_boot41.a
   3360 0000F260 03 AE                   	br		fcx
   3361 0000F262                        fc1
   3362 0000F262 33 E2                   	lb		r2,3[r3]	; get background color
   3363 0000F264 07 40 5F 32             	and		r2,#0x7f	; clear flash indicator
   3364 0000F268                        fcx:
   3365 0000F268 33 C2                   	sb		r2,3[r3]
   3366 0000F26A F0 80                   	ret
                                        
                                        
                                        ; ===== Return to the resident monitor, operating system, etc.
                                        ;
   3371 0000F26C                        BYEBYE
   3372 0000F26C 11 40 04 FE             	lw		sp,OSSP
   3373 0000F270 E0 FF                       lw      lr,[sp]
   3374 0000F272 02 6E                       add		sp,sp,#2
   3375 0000F274 F0 80                   	ret
                                        
                                        ; Set the message address fields
                                        
   3379 0000F276                        SetMsgAddr:
   3380 0000F276 E4 31                   	tsr		r1,ID
   3381 0000F278 02 40 0C C1             	sb		r1,txBuf+MSG_SRC
   3382 0000F27C 01 40 01 11             	lw		r1,#$11
   3383 0000F280 02 40 0E C1             	sb		r1,txBuf+MSG_DST
   3384 0000F284 F0 80                   	ret
                                        
   3386 0000F286                        EXIT
   3387 0000F286 AE 4F 04 AF             	call	OREXPR
   3388 0000F28A 6B 4F 09 AF             	call	zeroTxBuf
   3389 0000F28E 02 40 00 D1             	sw		r1,txBuf
   3390 0000F292 F1 BF                   	call	SetMsgAddr
   3391 0000F294 00 40 0D 11             	lw		r1,#MT_BASIC_EXIT
   3392 0000F298 02 40 08 C1             	sb		r1,txBuf+MSG_TYPE
   3393 0000F29C 6C 4F 07 AF             	call	Xmit
   3394 0000F2A0 83 4F 00 AE             	jmp		WSTART
                                        
   3396 0000F2A4                        RequestOutputFocus:
   3397 0000F2A4 FE 6E                   	add		sp,sp,#-2
   3398 0000F2A6 E0 DF                   	sw		lr,[sp]
   3399 0000F2A8 6A 4F 0A AF             	call	zeroTxBuf
   3400 0000F2AC E4 BF                   	call	SetMsgAddr
   3401 0000F2AE 00 40 0F 11             	lw		r1,#MT_REQ_OUT_FOCUS
   3402 0000F2B2 02 40 08 C1             	sb		r1,txBuf+MSG_TYPE
   3403 0000F2B6 6B 4F 0A AF             	call	Xmit
   3404 0000F2BA                        ROF1:
   3405 0000F2BA 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   3406 0000F2BE FD B8                   	beq		ROF1
   3407 0000F2C0 6D 4F 03 AF             	call	Recv
   3408 0000F2C4 6F 4F 08 AF             	call	RecvDispatch
   3409 0000F2C8 03 40 08 E1             	lb		r1,rxBuf+MSG_TYPE
   3410 0000F2CC FF 4F 10 10             	cmp		r1,#MT_GRNT_OUT_FOCUS
   3411 0000F2D0 F4 B9                   	bne		ROF1
   3412 0000F2D2 E0 FF                   	lw		lr,[sp]
   3413 0000F2D4 02 6E                   	add		sp,sp,#2
   3414 0000F2D6 F0 80                   	ret
                                        
                                        ;	MOVE.B	#228,D7 	return to Tutor
                                        ;	TRAP	#14
                                        
   3419 0000F2D8 0D 0A 42 75 74 74      msgInit db	CR,LF,"Butterfly Tiny BASIC v1.1",CR,LF,"(C) 2005-2017  Robert Finch",CR,LF,LF,0
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 58
noc_boot41.a
   3419 0000F2DE 65 72 66 6C 79 20 54  
   3419 0000F2E5 69 6E 79 20 42 41 53  
   3419 0000F2EC 49 43 20 76 31 2E 31  
   3419 0000F2F3 0D 0A 28 43 29 20 32  
   3419 0000F2FA 30 30 35 2D 32 30 31  
   3419 0000F301 37 20 20 52 6F 62 65  
   3419 0000F308 72 74 20 46 69 6E 63  
   3419 0000F30F 68 0D 0A 0A 00        
   3420 0000F314 0D 0A 4F 4B 0D 0A      OKMSG	db	CR,LF,"OK",CR,LF,0
   3420 0000F31A 00                    
   3421 0000F31B 57 68 61 74 3F 0D      msgWhat	db	"What?",CR,LF,0
   3421 0000F321 0A 00                 
   3422 0000F323 53 6F 72 72 79 2E      SRYMSG	db	"Sorry."
                                      
   3423 0000F329 0D 0A 00               CLMSG	db	CR,LF,0
   3424 0000F32C 43 6F 6D 70 61 63      msgReadError	db	"Compact FLASH read error",CR,LF,0
   3424 0000F332 74 20 46 4C 41 53 48  
   3424 0000F339 20 72 65 61 64 20 65  
   3424 0000F340 72 72 6F 72 0D 0A 00  
                                      
   3425 0000F347 4E 75 6D 62 65 72      msgNumTooBig	db	"Number is too big",CR,LF,0
   3425 0000F34D 20 69 73 20 74 6F 6F  
   3425 0000F354 20 62 69 67 0D 0A 00  
                                      
   3426 0000F35B 44 69 76 69 73 69      msgDivZero		db	"Division by zero",CR,LF,0
   3426 0000F361 6F 6E 20 62 79 20 7A  
   3426 0000F368 65 72 6F 0D 0A 00     
   3427 0000F36E 4F 75 74 20 6F 66      msgVarSpace     db  "Out of variable space",CR,LF,0
   3427 0000F374 20 76 61 72 69 61 62  
   3427 0000F37B 6C 65 20 73 70 61 63  
   3427 0000F382 65 0D 0A 00           
   3428 0000F386 20 62 79 74 65 73      msgBytesFree	db	" bytes free",CR,LF,0
   3428 0000F38C 20 66 72 65 65 0D 0A  
   3428 0000F393 00                    
   3429 0000F394 0D 0A 52 65 61 64      msgReady		db	CR,LF,"Ready",CR,LF,0
   3429 0000F39A 79 0D 0A 00           
   3430 0000F39E 45 78 70 65 63 74      msgComma		db	"Expecting a comma",CR,LF,0
   3430 0000F3A4 69 6E 67 20 61 20 63  
   3430 0000F3AB 6F 6D 6D 61 0D 0A 00  
                                      
   3431 0000F3B2 4C 69 6E 65 20 6E      msgLineRange	db	"Line number too big",CR,LF,0
   3431 0000F3B8 75 6D 62 65 72 20 74  
   3431 0000F3BF 6F 6F 20 62 69 67 0D  
   3431 0000F3C6 0A 00                 
   3432 0000F3C8 45 78 70 65 63 74      msgVar			db	"Expecting a variable",CR,LF,0
   3432 0000F3CE 69 6E 67 20 61 20 76  
   3432 0000F3D5 61 72 69 61 62 6C 65  
   3432 0000F3DC 0D 0A 00              
   3433 0000F3DF 52 4E 44 20 62 61      msgRNDBad		db	"RND bad parameter",CR,LF,0
   3433 0000F3E5 64 20 70 61 72 61 6D  
   3433 0000F3EC 65 74 65 72 0D 0A 00  
                                      
   3434 0000F3F3 53 59 53 20 62 61      msgSYSBad		db	"SYS bad address",CR,LF,0
   3434 0000F3F9 64 20 61 64 64 72 65  
   3434 0000F400 73 73 0D 0A 00        
   3435 0000F405 49 4E 50 55 54 20      msgInputVar		db	"INPUT expecting a variable",CR,LF,0
   3435 0000F40B 65 78 70 65 63 74 69  
   3435 0000F412 6E 67 20 61 20 76 61  
   3435 0000F419 72 69 61 62 6C 65 0D  
   3435 0000F420 0A 00                 
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 59
noc_boot41.a
   3436 0000F422 4E 45 58 54 20 77      msgNextFor		db	"NEXT without FOR",CR,LF,0
   3436 0000F428 69 74 68 6F 75 74 20  
   3436 0000F42F 46 4F 52 0D 0A 00     
   3437 0000F435 4E 45 58 54 20 65      msgNextVar		db	"NEXT expecting a defined variable",CR,LF,0
   3437 0000F43B 78 70 65 63 74 69 6E  
   3437 0000F442 67 20 61 20 64 65 66  
   3437 0000F449 69 6E 65 64 20 76 61  
   3437 0000F450 72 69 61 62 6C 65 0D  
   3437 0000F457 0A 00                 
   3438 0000F459 47 4F 54 4F 2F 47      msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LF,0
   3438 0000F45F 4F 53 55 42 20 62 61  
   3438 0000F466 64 20 6C 69 6E 65 20  
   3438 0000F46D 6E 75 6D 62 65 72 0D  
   3438 0000F474 0A 00                 
   3439 0000F476 52 45 54 55 52 4E      msgRetWoGosub   db	"RETURN without GOSUB",CR,LF,0
   3439 0000F47C 20 77 69 74 68 6F 75  
   3439 0000F483 74 20 47 4F 53 55 42  
   3439 0000F48A 0D 0A 00              
   3440 0000F48D 50 72 6F 67 72 61      msgTooBig		db	"Program is too big",CR,LF,0
   3440 0000F493 6D 20 69 73 20 74 6F  
   3440 0000F49A 6F 20 62 69 67 0D 0A  
   3440 0000F4A1 00                    
   3441 0000F4A2 45 78 74 72 61 20      msgExtraChars	db	"Extra characters on line ignored",CR,LF,0
   3441 0000F4A8 63 68 61 72 61 63 74  
   3441 0000F4AF 65 72 73 20 6F 6E 20  
   3441 0000F4B6 6C 69 6E 65 20 69 67  
   3441 0000F4BD 6E 6F 72 65 64 0D 0A  
   3441 0000F4C4 00                    
                                        
   3443 0000F4C5 FF FF FF                	.align	4
   3510 = 0000F4C8                      LSTROM	equ	*		; end of possible ROM area
                                        ;
                                        ; Internal variables follow:
                                        ;
                                        		bss
                                        ;		org		0x0030
   3450 000000E4                        txtWidth	db	0		; BIOS var =60
   3451 000000E5                        txtHeight	db	0		; BIOS var =27
   3452 000000E6                        cursx	db		0		; cursor x position
   3453 000000E7                        cursy	db		0		; cursor y position
   3454 000000E8                        pos		dw		0		; text screen position
   3455 000000EA                        tgtNode	db		0
   3456 000000EB                        srcNode	db		0
                                        ;		org		0x0038
   3458 000000EC                        charToPrint		dw		0
   3459 000000EE                        fgColor			db		0
   3460 000000EF                        bkColor			db		0
   3461 000000F0                        cursFlash		db		0	; flash the cursor ?
   3462 000000F1                         				db		0
   3463 000000F2                        NormAttr		dw		0
                                        
   3465 000000F4                        lineLinkTbl		fill.b	25,0	; screen line link table
   3466 0000010D                         	align 4
                                        
                                        ;		org		0x0080
   3469 00000110                        typef   db      0   ; variable / expression type
   3470 00000111                                 align   4
   3471 00000114                        OSSP	dw	1	; OS value of sp
   3472 00000116                        CURRNT	dw	1	;	Current line pointer
   3473 00000118                        STKGOS	dw	1	;	Saves stack pointer in 'GOSUB'
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 60
noc_boot41.a
   3474 0000011A                        STKINP	dw	1	;	Saves stack pointer during 'INPUT'
   3475 0000011C                        LOPVAR	dw	1	;	'FOR' loop save area
   3476 0000011E                        LOPINC	dw	1	;	increment
   3477 00000120                        LOPLMT	dw	1	;	limit
   3478 00000122                        LOPLN	dw	1	;	line number
   3479 00000124                        LOPPT	dw	1	;	text pointer
   3480 00000126                        TXTUNF	dw	1	;	points to unfilled text area
   3481 00000128                        VARBGN	dw	1	;	points to variable area
   3482 0000012A                        IVARBGN dw  1   ;   points to integer variable area
   3483 0000012C                        SVARBGN dw  1   ;   points to string variable area
   3484 0000012E                        FVARBGN dw  1   ;   points to float variable area
   3485 00000130                        STKBOT	dw	1	;	holds lower limit for stack growth
   3486 00000132                        NUMWKA	fill.b	12,0			; numeric work area
   3487 0000013E                        BUFFER	fill.b	BUFLEN,0x00		;		Keyboard input buffer
                                        
                                                bss
                                                org     0x2000
   3491 00002000                        textScr1
                                                org     0x2000
                                        ;	END
                                        
                                        ; Operation of an ordinary (worker) node is pretty simple. It just waits in
                                        ; loop polling for recieved messages which are then dispatched.
                                        
                                        		.code
   3499 0000F4C8                        start:
   3500 0000F4C8 FF 41 0E 1E             		lw		sp,#$1FFE
   3501 0000F4CC 0A AF                   		call	ResetNode
   3502 0000F4CE                        start2:
   3503 0000F4CE FF 41 0E 1E             		lw		sp,#$1FFE
   3504 0000F4D2                        noMsg1:
   3505 0000F4D2 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
   3506 0000F4D6 FD B8                   		beq		noMsg1
   3507 0000F4D8 5C 4F 07 AF             		call	Recv
   3508 0000F4DC 5E 4F 0C AF             		call	RecvDispatch
   3509 0000F4E0 F6 BE                   		bra		start2
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Reset the node.
                                        ;----------------------------------------------------------------------------
                                        
   3515 0000F4E2                        ResetNode:
   3516 0000F4E2 FE 6E                   		add		sp,sp,#-2
   3517 0000F4E4 E0 DF                   		sw		lr,[sp]
   3518 0000F4E6 04 AF                   		call	CpyDCB
   3519 0000F4E8 74 AF                   		call	rtcInit
   3520 0000F4EA E0 FF                   		lw		lr,[sp]
   3521 0000F4EC 02 6E                   		add		sp,sp,#2
   3522 0000F4EE F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Copy the DCB tables to ram.
                                        ;----------------------------------------------------------------------------
                                        
   3528 0000F4F0                        CpyDCB:
   3529 0000F4F0 00 13                   		lw		r3,#0
   3530 0000F4F2                        CpyDCB1:
   3531 0000F4F2 6E 4F 3E F1             		lw		r1,DCBTbl[r3]
   3532 0000F4F6 08 40 30 D1             		sw		r1,NodeDCB[r3]
   3533 0000F4FA 02 63                   		add		r3,r3,#2
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 61
noc_boot41.a
   3534 0000F4FC FA 4F 30 10             		cmp		r3,#48*nDCB
   3535 0000F500 F8 B4                   		bltu	CpyDCB1
   3536 0000F502 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Message command processor for node.
                                        ;
                                        ; Executes different message handlers based on the message type.
                                        ;----------------------------------------------------------------------------
                                        
   3544 0000F504                        NodeCmdProc:
   3545 0000F504 F8 6E                   		add		sp,sp,#-8
   3546 0000F506 E0 DF                   		sw		lr,[sp]
   3547 0000F508 E2 D1                   		sw		r1,2[sp]
   3548 0000F50A E4 D2                   		sw		r2,4[sp]
   3549 0000F50C E6 D3                   		sw		r3,6[sp]
                                        
   3551 0000F50E 60 4F 0F AF             		call	StdMsgHandlers
                                        
   3553 0000F512 E0 FF                   		lw		lr,[sp]
   3554 0000F514 E2 F1                   		lw		r1,2[sp]
   3555 0000F516 E4 F2                   		lw		r2,4[sp]
   3556 0000F518 E6 F3                   		lw		r3,6[sp]
   3557 0000F51A 08 6E                   		add		sp,sp,#8
   3558 0000F51C F0 80                   		ret
                                        
                                        ;============================================================================
                                        ;============================================================================
                                        
   3563 0000F51E                        RTCCmdProc:
   3564 0000F51E FE 6E                   		sub		sp,sp,#2
   3565 0000F520 E0 DF                   		sw		lr,[sp]
   3566 0000F522 03 40 08 E1             		lb		r1,rxBuf+MSG_TYPE
   3567 0000F526 FB 4F 1E 10             		cmp		r1,#DVC_Initialize
   3568 0000F52A 0C A8                   		beq		RTCCmdProcInitialize
   3569 0000F52C FB 4F 12 10             		cmp		r1,#DVC_SetPosition
   3570 0000F530 2F A8                   		beq		RTCCmdProcSetPosition
   3571 0000F532 FB 4F 11 10             		cmp		r1,#DVC_ReadBlock
   3572 0000F536 09 A8                   		beq		RTCCmdProcReadBlock
   3573 0000F538 FB 4F 10 10             		cmp		r1,#DVC_WriteBlock
   3574 0000F53C 28 A8                   		beq		RTCCmdProcWriteBlock
   3575 0000F53E                        RTCCmdProcXit:
   3576 0000F53E E0 FF                   		lw		lr,[sp]
   3577 0000F540 02 6E                   		add		sp,sp,#2
   3578 0000F542 F0 80                   		ret
                                        
   3580 0000F544                        RTCCmdProcInitialize:
   3581 0000F544 46 AF                   		call	rtcInit
   3582 0000F546 4A AF                   		call	rtcRead
   3583 0000F548 FA BE                   		br		RTCCmdProcXit
                                        
   3585 0000F54A                        RTCCmdProcReadBlock:
   3586 0000F54A 0E 40 00 F2             		lw		r2,RTCPos
   3587 0000F54E 00 48 20 10             		cmp		r2,#$8000
   3588 0000F552 23 A8                   		beq		RTCGetDateTime
   3589 0000F554 20 10                   		cmp		r2,#0
   3590 0000F556 02 A8                   		beq		RTCCmdProcReadBlock1
   3591 0000F558 F2 BE                   		br		RTCCmdProcXit
   3592 0000F55A 00 12                   		lw		r2,#0
   3593 0000F55C                        RTCCmdProcReadBlock1:
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 62
noc_boot41.a
   3594 0000F55C 55 4F 00 AF             		call	zeroTxBuf
   3595 0000F560 56 4F 00 AF             		call	SetDestFromRx
   3596 0000F564 04 40 20 F1             		lw		r1,RTCBuf[r2]
   3597 0000F568 02 40 00 D1             		sw		r1,txBuf
   3598 0000F56C 04 40 22 F1             		lw		r1,RTCBuf+2[r2]
   3599 0000F570 02 40 02 D1             		sw		r1,txBuf+2
   3600 0000F574 02 40 04 D2             		sw		r2,txBuf+4
   3601 0000F578 02 40 00 11             		lw		r1,#MT_DATA
   3602 0000F57C 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
   3603 0000F580 55 4F 05 AF             		call	Xmit
   3604 0000F584 04 62                   		add		r2,r2,#4
   3605 0000F586 FC 4F 20 10             		cmp		r2,#64
   3606 0000F58A E8 B4                   		bltu	RTCCmdProcReadBlock1
   3607 0000F58C D8 BE                   		br		RTCCmdProcXit
                                        
   3609 0000F58E                        RTCCmdProcWriteBlock:
   3610 0000F58E D7 BE                   		br		RTCCmdProcXit
                                        
   3612 0000F590                        RTCCmdProcSetPosition:
   3613 0000F590 03 40 00 F1             		lw		r1,rxBuf
   3614 0000F594 0E 40 00 D1             		sw		r1,RTCPos
   3615 0000F598 D2 BE                   		br		RTCCmdProcXit
                                        
   3617 0000F59A                        RTCGetDateTime:
   3618 0000F59A 53 4F 01 AF             		call	zeroTxBuf
   3619 0000F59E 54 4F 01 AF             		call	SetDestFromRx
   3620 0000F5A2 01 40 01 11             		lw		r1,#$11
   3621 0000F5A6 5C 4F 06 C1             		sb		r1,txBuf+MSG_GDS
   3622 0000F5AA 02 40 00 11             		lw		r1,#MT_DATA
   3623 0000F5AE 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
   3624 0000F5B2 14 AF                   		call	rtcRead
   3625 0000F5B4 04 40 06 E1             		lb		r1,RTCBuf+6
   3626 0000F5B8 02 40 06 C1             		sb		r1,txBuf+6
   3627 0000F5BC 04 40 05 E1             		lb		r1,RTCBuf+5
   3628 0000F5C0 02 40 05 C1             		sb		r1,txBuf+5
   3629 0000F5C4 04 40 04 E1             		lb		r1,RTCBuf+4
   3630 0000F5C8 02 40 04 C1             		sb		r1,txBuf+4
   3631 0000F5CC 52 4F 0F AF             		call	Xmit
   3632 0000F5D0 B6 BE                   		br		RTCCmdProcXit
                                        
                                        ;============================================================================
                                        ;============================================================================
                                        
                                        ;------------------------------------------------------------------------------
                                        ;------------------------------------------------------------------------------
                                        ; RTC driver for MCP7941x
                                        ;------------------------------------------------------------------------------
                                        ;------------------------------------------------------------------------------
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Initialize the I2C controller. Not much to do here other than set the
                                        ; I2C frequency control.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	r1
                                        ;----------------------------------------------------------------------------
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 63
noc_boot41.a
                                        
   3655 0000F5D2                        rtcInit:
   3656 0000F5D2 01 40 0C 11             		lw		r1,#28					; constant for 400kHz I2C from 57MHz
   3657 0000F5D6 30 4B 00 D1             		sw		r1,I2C_PRESCALE_LO
   3658 0000F5DA F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Read all the RTC sram registers into a buffer.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	r1,r2,r3
                                        ;----------------------------------------------------------------------------
                                        
   3671 0000F5DC                        rtcRead:
   3672 0000F5DC FE 6E                   		add		sp,sp,#-2
   3673 0000F5DE E0 DF                   		sw		lr,[sp]
   3674 0000F5E0 08 40 00 11             		lw		r1,#$80				; enable I2C
   3675 0000F5E4 30 4B 02 C1             		sb		r1,I2C_CONTROL
   3676 0000F5E8 0D 40 0E 11             		lw		r1,#$DE				; read address, write op
   3677 0000F5EC 09 40 00 12             		lw		r2,#$90				; STA + wr bit
   3678 0000F5F0 37 AF                   		call	rtcWrCmd
   3679 0000F5F2 2C AA                   		bmi		rtcReadErr
   3680 0000F5F4 00 11                   		lw		r1,#$00				; address zero
   3681 0000F5F6 01 40 00 12             		lw		r2,#$10				; wr bit
   3682 0000F5FA 32 AF                   		call	rtcWrCmd
   3683 0000F5FC 27 AA                   		bmi		rtcReadErr
   3684 0000F5FE 0D 40 0F 11             		lw		r1,#$DF				; read address, read op
   3685 0000F602 09 40 00 12             		lw		r2,#$90				; STA + wr bit
   3686 0000F606 2C AF                   		call	rtcWrCmd
   3687 0000F608 21 AA                   		bmi		rtcReadErr
   3688 0000F60A 00 13                   		lw		r3,#0
   3689 0000F60C                        rtcRead1:
   3690 0000F60C 02 40 00 11             		lw		r1,#$20				; rd bit
   3691 0000F610 30 4B 04 C1             		sb		r1,I2C_CMD
   3692 0000F614 20 AF                   		call	rtcWaitTip
   3693 0000F616 30 4B 04 E1             		lb		r1,I2C_STAT
   3694 0000F61A 18 AA                   		bmi		rtcReadErr
   3695 0000F61C 30 4B 03 E1             		lb		r1,I2C_RX
                                        		sb		RTCBuf[r3]
   3697 0000F620 01 63                   		add		r3,r3,#1
   3698 0000F622 FA 4F 31 10             		cmp		r3,#$5F
   3699 0000F626 F2 B9                   		bne		rtcRead1
   3700 0000F628 06 40 08 11             		lw		r1,#$68				; STO, rd bit + nack
   3701 0000F62C 30 4B 04 C1             		sb		r1,I2C_CMD
   3702 0000F630 12 AF                   		call	rtcWaitTip
   3703 0000F632 30 4B 04 E1             		lb		r1,I2C_STAT
   3704 0000F636 0A AA                   		bmi		rtcReadErr
   3705 0000F638 30 4B 03 E1             		lb		r1,I2C_RX
   3706 0000F63C 04 40 30 C1             		sb		r1,RTCBuf[r3]
   3707 0000F640 00 11                   		lw		r1,#0				; disable I2C and return 0
   3708 0000F642 30 4B 02 C1             		sb		r1,I2C_CONTROL
   3709 0000F646 E0 FF                   		lw		lr,[sp]
   3710 0000F648 02 6E                   		add		sp,sp,#2
   3711 0000F64A F0 80                   		ret
   3712 0000F64C                        rtcReadErr:
   3713 0000F64C 30 4B 02 C0             		sb		r0,I2C_CONTROL		; disable I2C and return status
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 64
noc_boot41.a
   3714 0000F650 E0 FF                   		lw		lr,[sp]
   3715 0000F652 02 6E                   		add		sp,sp,#2
   3716 0000F654 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Wait for the I2C transfer to complete. Determined by polling the transfer
                                        ; in progress bit of the status register.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	r1
                                        ;----------------------------------------------------------------------------
   3729 0000F656                        	
   3730 0000F656                        rtcWaitTip1:
   3731 0000F656 30 4B 04 E1             		lb		r1,I2C_STAT
   3732 0000F65A 54 31                   		and		r1,#$4				; transmit in progress bit
   3733 0000F65C FC B9                   		bne		rtcWaitTip
   3734 0000F65E F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Write a command to the I2C controller.
                                        ;
                                        ; Parameters:
                                        ;	r1 = byte to transfer to I2C slave
                                        ;	r2 = command code for I2C master
                                        ; Returns:
                                        ;	r1 = I2C status
                                        ;	flags set according to I2C status
                                        ; Registers Affected:
                                        ;	r1
                                        ;----------------------------------------------------------------------------
                                        
   3749 0000F660                        rtcWrCmd:
   3750 0000F660 FE 6E                   		add		sp,sp,#-2
   3751 0000F662 E0 DF                   		sw		lr,[sp]
   3752 0000F664 30 4B 03 C1             		sb		r1,I2C_TX
   3753 0000F668 30 4B 04 C2             		sb		r2,I2C_CMD
   3754 0000F66C F4 BF                   		call	rtcWaitTip
   3755 0000F66E 30 4B 04 E1             		lb		r1,I2C_STAT
   3756 0000F672 E0 FF                   		lw		lr,[sp]
   3757 0000F674 02 6E                   		add		sp,sp,#2
   3758 0000F676 16 21                   		or		r1,r1
   3759 0000F678 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Write buffer contents back to RTC chip.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	r1,r2,r3
                                        ;----------------------------------------------------------------------------
                                        
   3772 0000F67A                        rtcWrite:
   3773 0000F67A FE 6E                   		add		sp,sp,#-2
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 65
noc_boot41.a
   3774 0000F67C E0 DF                   		sw		lr,[sp]
   3775 0000F67E 08 40 00 11             		lw		r1,#$80				; enable I2C
   3776 0000F682 30 4B 02 C1             		sb		r1,I2C_CONTROL
   3777 0000F686 0D 40 0E 11             		lw		r1,#$DE				; read address, write op
   3778 0000F68A 09 40 00 12             		lw		r2,#$90				; STA + wr bit
   3779 0000F68E E8 BF                   		call	rtcWrCmd
   3780 0000F690 1C AA                   		bmi		rtcWriteErr
   3781 0000F692 00 11                   		lw		r1,#$00				; address zero
   3782 0000F694 01 40 00 12             		lw		r2,#$10				; wr bit
   3783 0000F698 E3 BF                   		call	rtcWrCmd
   3784 0000F69A 17 AA                   		bmi		rtcWriteErr
   3785 0000F69C 00 13                   		lw		r3,#0
   3786 0000F69E                        rtcWrite1:
   3787 0000F69E 04 40 30 E1             		lb		r1,RTCBuf[r3]
   3788 0000F6A2 01 40 00 12             		lw		r2,#$10
   3789 0000F6A6 DC BF                   		call	rtcWrCmd
   3790 0000F6A8 10 AA                   		bmi		rtcWriteErr
   3791 0000F6AA 01 63                   		add		r3,r3,#1
   3792 0000F6AC FA 4F 31 10             		cmp		r3,#$5F
   3793 0000F6B0 F6 B9                   		bne		rtcWrite1
   3794 0000F6B2 04 40 30 E1             		lb		r1,RTCBuf[r3]
   3795 0000F6B6 05 40 00 12             		lw		r2,#$50				; STO, wr bit
   3796 0000F6BA D2 BF                   		call	rtcWrCmd
   3797 0000F6BC 06 AA                   		bmi		rtcWriteErr
   3798 0000F6BE 00 11                   		lw		r1,#0				; disable I2C and return 0
   3799 0000F6C0 30 4B 02 C1             		sb		r1,I2C_CONTROL
   3800 0000F6C4 E0 FF                   		lw		lr,[sp]
   3801 0000F6C6 02 6E                   		add		sp,sp,#2
   3802 0000F6C8 F0 80                   		ret
   3803 0000F6CA                        rtcWriteErr:
   3804 0000F6CA 30 4B 02 C0             		sb		r0,I2C_CONTROL		; disable I2C and return status
   3805 0000F6CE E0 FF                   		lw		lr,[sp]
   3806 0000F6D0 02 6E                   		add		sp,sp,#2
   3807 0000F6D2 F0 80                   		ret
                                        
   3809 0000F6D4                        msgRtcReadFail:
   3810 0000F6D4 52 54 43 20 72 65 61    	.byte	"RTC read/write failed.",$0D,$0A,$00
   3810 0000F6DB 64 2F 77 72 69 74 65  
   3810 0000F6E2 20 66 61 69 6C 65 64  
   3810 0000F6E9 2E 0D 0A 00           
                                        
   3812 0000F6ED FF                      	align	2
   3813 0000F6EE                        DCBTbl:
   3814 0000F6EE 06 4E 4F 44 34 31 31    	db	6,"NOD411",0,0,0,0,0
   3814 0000F6F5 00 00 00 00 00        
   3815 0000F6FA 00 00                   	dw	0						; type
   3816 0000F6FC 00 00                   	dw  0						; nBPB
   3817 0000F6FE 00 00                   	dw	0						; LastErc
   3818 0000F700 00 00                   	dw	0						; reserved
   3819 0000F702 00 00                   	dw	0						; start block low
   3820 0000F704 00 00                   	dw	0						; start block high
   3821 0000F706 00 00                   	dw	0						; number of blocks
   3822 0000F708 00 00                   	dw	0						;	"
   3823 0000F70A 04 F5                   	dw	NodeCmdProc				; pCmdProc
   3824 0000F70C 00 00                   	dw	0						; reserved
   3825 0000F70E 00                      	db	0						; reentry count
   3826 0000F70F 00                      	db	0						; single user flag
   3827 0000F710 00 00                   	dw	0						; hJob
   3828 0000F712 00 00                   	dw	0						; hMbx
   3829 0000F714 00 00                   	dw	0						; hSemaphore
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 66
noc_boot41.a
   3830 0000F716 00 00 00 00 00 00 00    	fill.b	8,0					; reserved
   3830 0000F71D 00                    
   3831 0000F71E 03 52 54 43 00 00 00    		
   3831 0000F725 00 00 00 00 00        
   3832 0000F72A 00 00                   	dw	0						; type
   3833 0000F72C 00 00                   	dw  0						; nBPB
   3834 0000F72E 00 00                   	dw	0						; LastErc
   3835 0000F730 00 00                   	dw	0						; reserved
   3836 0000F732 00 00                   	dw	0						; start block low
   3837 0000F734 00 00                   	dw	0						; start block high
   3838 0000F736 00 00                   	dw	0						; number of blocks
   3839 0000F738 00 00                   	dw	0						;	"
   3840 0000F73A 1E F5                   	dw	RTCCmdProc				; pCmdProc
   3841 0000F73C 00 00                   	dw	0						; reserved
   3842 0000F73E 00                      	db	0						; reentry count
   3843 0000F73F 00                      	db	0						; single user flag
   3844 0000F740 00 00                   	dw	0						; hJob
   3845 0000F742 00 00                   	dw	0						; hMbx
   3846 0000F744 00 00                   	dw	0						; hSemaphore
   3847 0000F746 00 00 00 00 00 00 00    	fill.b	8,0					; reserved
   3847 0000F74D 00                    
                                        
                                        
   3850 0000F74E FF FF FF FF FF FF FF    		org		0xFFFE
   3850 0000F755 FF FF FF FF FF FF FF  
   3850 0000F75C FF FF FF FF FF FF FF  
   3850 0000F763 FF FF FF FF FF FF FF  
   3850 0000F76A FF FF FF FF FF FF FF  
   3850 0000F771 FF FF FF FF FF FF FF  
   3850 0000F778 FF FF FF FF FF FF FF  
   3850 0000F77F FF FF FF FF FF FF FF  
   3850 0000F786 FF FF FF FF FF FF FF  
   3850 0000F78D FF FF FF FF FF FF FF  
   3850 0000F794 FF FF FF FF FF FF FF  
   3850 0000F79B FF FF FF FF FF FF FF  
   3850 0000F7A2 FF FF FF FF FF FF FF  
   3850 0000F7A9 FF FF FF FF FF FF FF  
   3850 0000F7B0 FF FF FF FF FF FF FF  
   3850 0000F7B7 FF FF FF FF FF FF FF  
   3850 0000F7BE FF FF FF FF FF FF FF  
   3850 0000F7C5 FF FF FF FF FF FF FF  
   3850 0000F7CC FF FF FF FF FF FF FF  
   3850 0000F7D3 FF FF FF FF FF FF FF  
   3850 0000F7DA FF FF FF FF FF FF FF  
   3850 0000F7E1 FF FF FF FF FF FF FF  
   3850 0000F7E8 FF FF FF FF FF FF FF  
   3850 0000F7EF FF FF FF FF FF FF FF  
   3850 0000F7F6 FF FF FF FF FF FF FF  
   3850 0000F7FD FF FF FF FF FF FF FF  
   3850 0000F804 FF FF FF FF FF FF FF  
   3850 0000F80B FF FF FF FF FF FF FF  
   3850 0000F812 FF FF FF FF FF FF FF  
   3850 0000F819 FF FF FF FF FF FF FF  
   3850 0000F820 FF FF FF FF FF FF FF  
   3850 0000F827 FF FF FF FF FF FF FF  
   3850 0000F82E FF FF FF FF FF FF FF  
   3850 0000F835 FF FF FF FF FF FF FF  
   3850 0000F83C FF FF FF FF FF FF FF  
   3850 0000F843 FF FF FF FF FF FF FF  
   3850 0000F84A FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 67
noc_boot41.a
   3850 0000F851 FF FF FF FF FF FF FF  
   3850 0000F858 FF FF FF FF FF FF FF  
   3850 0000F85F FF FF FF FF FF FF FF  
   3850 0000F866 FF FF FF FF FF FF FF  
   3850 0000F86D FF FF FF FF FF FF FF  
   3850 0000F874 FF FF FF FF FF FF FF  
   3850 0000F87B FF FF FF FF FF FF FF  
   3850 0000F882 FF FF FF FF FF FF FF  
   3850 0000F889 FF FF FF FF FF FF FF  
   3850 0000F890 FF FF FF FF FF FF FF  
   3850 0000F897 FF FF FF FF FF FF FF  
   3850 0000F89E FF FF FF FF FF FF FF  
   3850 0000F8A5 FF FF FF FF FF FF FF  
   3850 0000F8AC FF FF FF FF FF FF FF  
   3850 0000F8B3 FF FF FF FF FF FF FF  
   3850 0000F8BA FF FF FF FF FF FF FF  
   3850 0000F8C1 FF FF FF FF FF FF FF  
   3850 0000F8C8 FF FF FF FF FF FF FF  
   3850 0000F8CF FF FF FF FF FF FF FF  
   3850 0000F8D6 FF FF FF FF FF FF FF  
   3850 0000F8DD FF FF FF FF FF FF FF  
   3850 0000F8E4 FF FF FF FF FF FF FF  
   3850 0000F8EB FF FF FF FF FF FF FF  
   3850 0000F8F2 FF FF FF FF FF FF FF  
   3850 0000F8F9 FF FF FF FF FF FF FF  
   3850 0000F900 FF FF FF FF FF FF FF  
   3850 0000F907 FF FF FF FF FF FF FF  
   3850 0000F90E FF FF FF FF FF FF FF  
   3850 0000F915 FF FF FF FF FF FF FF  
   3850 0000F91C FF FF FF FF FF FF FF  
   3850 0000F923 FF FF FF FF FF FF FF  
   3850 0000F92A FF FF FF FF FF FF FF  
   3850 0000F931 FF FF FF FF FF FF FF  
   3850 0000F938 FF FF FF FF FF FF FF  
   3850 0000F93F FF FF FF FF FF FF FF  
   3850 0000F946 FF FF FF FF FF FF FF  
   3850 0000F94D FF FF FF FF FF FF FF  
   3850 0000F954 FF FF FF FF FF FF FF  
   3850 0000F95B FF FF FF FF FF FF FF  
   3850 0000F962 FF FF FF FF FF FF FF  
   3850 0000F969 FF FF FF FF FF FF FF  
   3850 0000F970 FF FF FF FF FF FF FF  
   3850 0000F977 FF FF FF FF FF FF FF  
   3850 0000F97E FF FF FF FF FF FF FF  
   3850 0000F985 FF FF FF FF FF FF FF  
   3850 0000F98C FF FF FF FF FF FF FF  
   3850 0000F993 FF FF FF FF FF FF FF  
   3850 0000F99A FF FF FF FF FF FF FF  
   3850 0000F9A1 FF FF FF FF FF FF FF  
   3850 0000F9A8 FF FF FF FF FF FF FF  
   3850 0000F9AF FF FF FF FF FF FF FF  
   3850 0000F9B6 FF FF FF FF FF FF FF  
   3850 0000F9BD FF FF FF FF FF FF FF  
   3850 0000F9C4 FF FF FF FF FF FF FF  
   3850 0000F9CB FF FF FF FF FF FF FF  
   3850 0000F9D2 FF FF FF FF FF FF FF  
   3850 0000F9D9 FF FF FF FF FF FF FF  
   3850 0000F9E0 FF FF FF FF FF FF FF  
   3850 0000F9E7 FF FF FF FF FF FF FF  
   3850 0000F9EE FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 68
noc_boot41.a
   3850 0000F9F5 FF FF FF FF FF FF FF  
   3850 0000F9FC FF FF FF FF FF FF FF  
   3850 0000FA03 FF FF FF FF FF FF FF  
   3850 0000FA0A FF FF FF FF FF FF FF  
   3850 0000FA11 FF FF FF FF FF FF FF  
   3850 0000FA18 FF FF FF FF FF FF FF  
   3850 0000FA1F FF FF FF FF FF FF FF  
   3850 0000FA26 FF FF FF FF FF FF FF  
   3850 0000FA2D FF FF FF FF FF FF FF  
   3850 0000FA34 FF FF FF FF FF FF FF  
   3850 0000FA3B FF FF FF FF FF FF FF  
   3850 0000FA42 FF FF FF FF FF FF FF  
   3850 0000FA49 FF FF FF FF FF FF FF  
   3850 0000FA50 FF FF FF FF FF FF FF  
   3850 0000FA57 FF FF FF FF FF FF FF  
   3850 0000FA5E FF FF FF FF FF FF FF  
   3850 0000FA65 FF FF FF FF FF FF FF  
   3850 0000FA6C FF FF FF FF FF FF FF  
   3850 0000FA73 FF FF FF FF FF FF FF  
   3850 0000FA7A FF FF FF FF FF FF FF  
   3850 0000FA81 FF FF FF FF FF FF FF  
   3850 0000FA88 FF FF FF FF FF FF FF  
   3850 0000FA8F FF FF FF FF FF FF FF  
   3850 0000FA96 FF FF FF FF FF FF FF  
   3850 0000FA9D FF FF FF FF FF FF FF  
   3850 0000FAA4 FF FF FF FF FF FF FF  
   3850 0000FAAB FF FF FF FF FF FF FF  
   3850 0000FAB2 FF FF FF FF FF FF FF  
   3850 0000FAB9 FF FF FF FF FF FF FF  
   3850 0000FAC0 FF FF FF FF FF FF FF  
   3850 0000FAC7 FF FF FF FF FF FF FF  
   3850 0000FACE FF FF FF FF FF FF FF  
   3850 0000FAD5 FF FF FF FF FF FF FF  
   3850 0000FADC FF FF FF FF FF FF FF  
   3850 0000FAE3 FF FF FF FF FF FF FF  
   3850 0000FAEA FF FF FF FF FF FF FF  
   3850 0000FAF1 FF FF FF FF FF FF FF  
   3850 0000FAF8 FF FF FF FF FF FF FF  
   3850 0000FAFF FF FF FF FF FF FF FF  
   3850 0000FB06 FF FF FF FF FF FF FF  
   3850 0000FB0D FF FF FF FF FF FF FF  
   3850 0000FB14 FF FF FF FF FF FF FF  
   3850 0000FB1B FF FF FF FF FF FF FF  
   3850 0000FB22 FF FF FF FF FF FF FF  
   3850 0000FB29 FF FF FF FF FF FF FF  
   3850 0000FB30 FF FF FF FF FF FF FF  
   3850 0000FB37 FF FF FF FF FF FF FF  
   3850 0000FB3E FF FF FF FF FF FF FF  
   3850 0000FB45 FF FF FF FF FF FF FF  
   3850 0000FB4C FF FF FF FF FF FF FF  
   3850 0000FB53 FF FF FF FF FF FF FF  
   3850 0000FB5A FF FF FF FF FF FF FF  
   3850 0000FB61 FF FF FF FF FF FF FF  
   3850 0000FB68 FF FF FF FF FF FF FF  
   3850 0000FB6F FF FF FF FF FF FF FF  
   3850 0000FB76 FF FF FF FF FF FF FF  
   3850 0000FB7D FF FF FF FF FF FF FF  
   3850 0000FB84 FF FF FF FF FF FF FF  
   3850 0000FB8B FF FF FF FF FF FF FF  
   3850 0000FB92 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 69
noc_boot41.a
   3850 0000FB99 FF FF FF FF FF FF FF  
   3850 0000FBA0 FF FF FF FF FF FF FF  
   3850 0000FBA7 FF FF FF FF FF FF FF  
   3850 0000FBAE FF FF FF FF FF FF FF  
   3850 0000FBB5 FF FF FF FF FF FF FF  
   3850 0000FBBC FF FF FF FF FF FF FF  
   3850 0000FBC3 FF FF FF FF FF FF FF  
   3850 0000FBCA FF FF FF FF FF FF FF  
   3850 0000FBD1 FF FF FF FF FF FF FF  
   3850 0000FBD8 FF FF FF FF FF FF FF  
   3850 0000FBDF FF FF FF FF FF FF FF  
   3850 0000FBE6 FF FF FF FF FF FF FF  
   3850 0000FBED FF FF FF FF FF FF FF  
   3850 0000FBF4 FF FF FF FF FF FF FF  
   3850 0000FBFB FF FF FF FF FF FF FF  
   3850 0000FC02 FF FF FF FF FF FF FF  
   3850 0000FC09 FF FF FF FF FF FF FF  
   3850 0000FC10 FF FF FF FF FF FF FF  
   3850 0000FC17 FF FF FF FF FF FF FF  
   3850 0000FC1E FF FF FF FF FF FF FF  
   3850 0000FC25 FF FF FF FF FF FF FF  
   3850 0000FC2C FF FF FF FF FF FF FF  
   3850 0000FC33 FF FF FF FF FF FF FF  
   3850 0000FC3A FF FF FF FF FF FF FF  
   3850 0000FC41 FF FF FF FF FF FF FF  
   3850 0000FC48 FF FF FF FF FF FF FF  
   3850 0000FC4F FF FF FF FF FF FF FF  
   3850 0000FC56 FF FF FF FF FF FF FF  
   3850 0000FC5D FF FF FF FF FF FF FF  
   3850 0000FC64 FF FF FF FF FF FF FF  
   3850 0000FC6B FF FF FF FF FF FF FF  
   3850 0000FC72 FF FF FF FF FF FF FF  
   3850 0000FC79 FF FF FF FF FF FF FF  
   3850 0000FC80 FF FF FF FF FF FF FF  
   3850 0000FC87 FF FF FF FF FF FF FF  
   3850 0000FC8E FF FF FF FF FF FF FF  
   3850 0000FC95 FF FF FF FF FF FF FF  
   3850 0000FC9C FF FF FF FF FF FF FF  
   3850 0000FCA3 FF FF FF FF FF FF FF  
   3850 0000FCAA FF FF FF FF FF FF FF  
   3850 0000FCB1 FF FF FF FF FF FF FF  
   3850 0000FCB8 FF FF FF FF FF FF FF  
   3850 0000FCBF FF FF FF FF FF FF FF  
   3850 0000FCC6 FF FF FF FF FF FF FF  
   3850 0000FCCD FF FF FF FF FF FF FF  
   3850 0000FCD4 FF FF FF FF FF FF FF  
   3850 0000FCDB FF FF FF FF FF FF FF  
   3850 0000FCE2 FF FF FF FF FF FF FF  
   3850 0000FCE9 FF FF FF FF FF FF FF  
   3850 0000FCF0 FF FF FF FF FF FF FF  
   3850 0000FCF7 FF FF FF FF FF FF FF  
   3850 0000FCFE FF FF FF FF FF FF FF  
   3850 0000FD05 FF FF FF FF FF FF FF  
   3850 0000FD0C FF FF FF FF FF FF FF  
   3850 0000FD13 FF FF FF FF FF FF FF  
   3850 0000FD1A FF FF FF FF FF FF FF  
   3850 0000FD21 FF FF FF FF FF FF FF  
   3850 0000FD28 FF FF FF FF FF FF FF  
   3850 0000FD2F FF FF FF FF FF FF FF  
   3850 0000FD36 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 70
noc_boot41.a
   3850 0000FD3D FF FF FF FF FF FF FF  
   3850 0000FD44 FF FF FF FF FF FF FF  
   3850 0000FD4B FF FF FF FF FF FF FF  
   3850 0000FD52 FF FF FF FF FF FF FF  
   3850 0000FD59 FF FF FF FF FF FF FF  
   3850 0000FD60 FF FF FF FF FF FF FF  
   3850 0000FD67 FF FF FF FF FF FF FF  
   3850 0000FD6E FF FF FF FF FF FF FF  
   3850 0000FD75 FF FF FF FF FF FF FF  
   3850 0000FD7C FF FF FF FF FF FF FF  
   3850 0000FD83 FF FF FF FF FF FF FF  
   3850 0000FD8A FF FF FF FF FF FF FF  
   3850 0000FD91 FF FF FF FF FF FF FF  
   3850 0000FD98 FF FF FF FF FF FF FF  
   3850 0000FD9F FF FF FF FF FF FF FF  
   3850 0000FDA6 FF FF FF FF FF FF FF  
   3850 0000FDAD FF FF FF FF FF FF FF  
   3850 0000FDB4 FF FF FF FF FF FF FF  
   3850 0000FDBB FF FF FF FF FF FF FF  
   3850 0000FDC2 FF FF FF FF FF FF FF  
   3850 0000FDC9 FF FF FF FF FF FF FF  
   3850 0000FDD0 FF FF FF FF FF FF FF  
   3850 0000FDD7 FF FF FF FF FF FF FF  
   3850 0000FDDE FF FF FF FF FF FF FF  
   3850 0000FDE5 FF FF FF FF FF FF FF  
   3850 0000FDEC FF FF FF FF FF FF FF  
   3850 0000FDF3 FF FF FF FF FF FF FF  
   3850 0000FDFA FF FF FF FF FF FF FF  
   3850 0000FE01 FF FF FF FF FF FF FF  
   3850 0000FE08 FF FF FF FF FF FF FF  
   3850 0000FE0F FF FF FF FF FF FF FF  
   3850 0000FE16 FF FF FF FF FF FF FF  
   3850 0000FE1D FF FF FF FF FF FF FF  
   3850 0000FE24 FF FF FF FF FF FF FF  
   3850 0000FE2B FF FF FF FF FF FF FF  
   3850 0000FE32 FF FF FF FF FF FF FF  
   3850 0000FE39 FF FF FF FF FF FF FF  
   3850 0000FE40 FF FF FF FF FF FF FF  
   3850 0000FE47 FF FF FF FF FF FF FF  
   3850 0000FE4E FF FF FF FF FF FF FF  
   3850 0000FE55 FF FF FF FF FF FF FF  
   3850 0000FE5C FF FF FF FF FF FF FF  
   3850 0000FE63 FF FF FF FF FF FF FF  
   3850 0000FE6A FF FF FF FF FF FF FF  
   3850 0000FE71 FF FF FF FF FF FF FF  
   3850 0000FE78 FF FF FF FF FF FF FF  
   3850 0000FE7F FF FF FF FF FF FF FF  
   3850 0000FE86 FF FF FF FF FF FF FF  
   3850 0000FE8D FF FF FF FF FF FF FF  
   3850 0000FE94 FF FF FF FF FF FF FF  
   3850 0000FE9B FF FF FF FF FF FF FF  
   3850 0000FEA2 FF FF FF FF FF FF FF  
   3850 0000FEA9 FF FF FF FF FF FF FF  
   3850 0000FEB0 FF FF FF FF FF FF FF  
   3850 0000FEB7 FF FF FF FF FF FF FF  
   3850 0000FEBE FF FF FF FF FF FF FF  
   3850 0000FEC5 FF FF FF FF FF FF FF  
   3850 0000FECC FF FF FF FF FF FF FF  
   3850 0000FED3 FF FF FF FF FF FF FF  
   3850 0000FEDA FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 29 00:05:13 2017     Page 71
noc_boot41.a
   3850 0000FEE1 FF FF FF FF FF FF FF  
   3850 0000FEE8 FF FF FF FF FF FF FF  
   3850 0000FEEF FF FF FF FF FF FF FF  
   3850 0000FEF6 FF FF FF FF FF FF FF  
   3850 0000FEFD FF FF FF FF FF FF FF  
   3850 0000FF04 FF FF FF FF FF FF FF  
   3850 0000FF0B FF FF FF FF FF FF FF  
   3850 0000FF12 FF FF FF FF FF FF FF  
   3850 0000FF19 FF FF FF FF FF FF FF  
   3850 0000FF20 FF FF FF FF FF FF FF  
   3850 0000FF27 FF FF FF FF FF FF FF  
   3850 0000FF2E FF FF FF FF FF FF FF  
   3850 0000FF35 FF FF FF FF FF FF FF  
   3850 0000FF3C FF FF FF FF FF FF FF  
   3850 0000FF43 FF FF FF FF FF FF FF  
   3850 0000FF4A FF FF FF FF FF FF FF  
   3850 0000FF51 FF FF FF FF FF FF FF  
   3850 0000FF58 FF FF FF FF FF FF FF  
   3850 0000FF5F FF FF FF FF FF FF FF  
   3850 0000FF66 FF FF FF FF FF FF FF  
   3850 0000FF6D FF FF FF FF FF FF FF  
   3850 0000FF74 FF FF FF FF FF FF FF  
   3850 0000FF7B FF FF FF FF FF FF FF  
   3850 0000FF82 FF FF FF FF FF FF FF  
   3850 0000FF89 FF FF FF FF FF FF FF  
   3850 0000FF90 FF FF FF FF FF FF FF  
   3850 0000FF97 FF FF FF FF FF FF FF  
   3850 0000FF9E FF FF FF FF FF FF FF  
   3850 0000FFA5 FF FF FF FF FF FF FF  
   3850 0000FFAC FF FF FF FF FF FF FF  
   3850 0000FFB3 FF FF FF FF FF FF FF  
   3850 0000FFBA FF FF FF FF FF FF FF  
   3850 0000FFC1 FF FF FF FF FF FF FF  
   3850 0000FFC8 FF FF FF FF FF FF FF  
   3850 0000FFCF FF FF FF FF FF FF FF  
   3850 0000FFD6 FF FF FF FF FF FF FF  
   3850 0000FFDD FF FF FF FF FF FF FF  
   3850 0000FFE4 FF FF FF FF FF FF FF  
   3850 0000FFEB FF FF FF FF FF FF FF  
   3850 0000FFF2 FF FF FF FF FF FF FF  
   3850 0000FFF9 FF FF FF FF FF        
   3851 0000FFFE C8 F4                   		dw		start
