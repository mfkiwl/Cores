Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 1
tb.asm

                                        ;****************************************************************;
                                        ;                                                                ;
                                        ;		Tiny BASIC for the Bird Computer Butterfly               ;
                                        ;                                                                ;
                                        ; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                                        ; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                                        ; Adapted to the 68000 by:                                       ;
                                        ;	Gordon brndly						                         ;
                                        ;	12147 - 51 Street					                         ;
                                        ;	Edmonton AB  T5W 3G8					                     ;
                                        ;	Canada							                             ;
                                        ;	(updated mailing address for 1996)			                 ;
                                        ;                                                                ;
                                        ; Adapted to the Butterfly by:                                    ;
                                        ;    Robert Finch                                                ;
                                        ;    Ontario, Canada                                             ;
                                        ;	 rob@birdcomputer.ca		                                 ;  
                                        ;****************************************************************;
                                        ;    Copyright (C) 2005 by Robert Finch. This program may be	 ;
                                        ;    freely distributed for personal use only. All commercial	 ;
                                        ;		       rights are reserved.			                     ;
                                        ;****************************************************************;
                                        ;
                                        ; Register Usage
                                        ; r8 = text pointer (global usage)
                                        ; r3,r4 = inputs parameters to subroutines
                                        ; r2 = return value
                                        ;
                                        ;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                                        ;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                                        ;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                                        
                                        ;	OPT	FRS,BRS 	forward ref.'s & brnches default to short
                                        
                                        ;XMIT_FULL		equ	0x40		; the transmit buffer is full
                                        ;DATA_PRESENT	equ	0x08		; there is data preset at the serial port bc_uart3
     37 = 01                            DATA_PRESENT	equ	0x01		; there is data preset at the serial port bc_uart3
     38 = 20                            XMIT_NOT_FULL	equ	0x20
                                        
     40 = 00000000FFFFDC40                              TS_TIMER	equ		0xFFFFDC40		; system time slice timer
     41 = 00000000FFFFDC50                              KBD			equ		0xFFFFDC50
                                        
     43 = 00000000FFFFDCA0                              RAND		equ		0xFFFFDCA0
     44 = 00000000FFFFDCC0                              ATA			equ		0xFFFFDCC0
     45 = 00000000FFFFD800                              VIC			equ		0xFFFFD800
                                        
     47 = 1000                          VIDEORAM	equ		0x00001000
                                        
                                        ; BOOT ROM routines
                                        
     51 = 0000000FFFFFF804                              getSerial	equ		0xFFFFFF804	; get a serial port character
     52 = 0000000FFFFFF808                              peekSerial	equ		0xFFFFFF808	; get a serial port character
     53 = 0000000FFFFFF80C                              putSerial	equ		0xFFFFFF80C	; put a character to serial port
     54 = 0000000FFFFFF82C                              clearScreen	equ		0xFFFFFF82C	; clear the screen
     55 = 0000000FFFFFF840                              getKbdCharWait	equ	0xFFFFFF840
     56 = 0000000FFFFFF844                              getKbdChar		equ	0xFFFFFF844
                                        
     58 = 20                            warmStart   equ     0x20
     59 = 24                            usrJmp      equ     0x24
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 2
tb.asm
                                        
     61 = 0D                            CR		equ	0x0D		; ASCII equates
     62 = 0A                            LF		equ	0x0A
     63 = 09                            TAB		equ	0x09
     64 = 03                            CTRLC	equ	0x03
     65 = 08                            CTRLH	equ	0x08
     66 = 13                            CTRLS	equ	0x13
     67 = 18                            CTRLX	equ	0x18
                                        
     69 = 50                            BUFLEN	equ	80	;	length of keyboard input buffer
                                        
                                        	code
                                        	org	0xF0000	;
                                        ;
                                        ; Standard jump table. You can change these addresses if you are
                                        ; customizing this interpreter for a different environment.
                                        ;
     78 000F0000 0F AE                  START	jmp	CSTART	;	Cold Start entry point
     79 000F0002 4F AE                  GOWARM	jmp	WSTART	;	Warm Start entry point
     80 000F0004 89 40 0C AE            GOOUT	jmp	OUTC	;	Jump to character-out routine
     81 000F0008 89 40 0B AE            GOIN	jmp	INC		;Jump to character-in routine
     82 000F000C 8A 40 0D AE            GOAUXO	jmp	AUXOUT	;	Jump to auxiliary-out routine
     83 000F0010 8A 40 0E AE            GOAUXI	jmp	AUXIN	;	Jump to auxiliary-in routine
     84 000F0014 A4 40 0C AE            GOBYE	jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                                        ;
                                        ; Modifiable system constants:
                                        ;
     88 000F0018 00 30 00 00            TXTBGN	dw	TXT		;beginning of program memory
     89 000F001C FC FF 0E 00            ENDMEM	dw	0xEfffc	;	end of available memory
                                        ;
                                        ; The main interpreter starts here:
                                        ;
                                        ; Usage
                                        ; r1 = temp
                                        ; r8 = text buffer pointer
                                        ; r12 = end of text in text buffer
                                        ;
     98 000F0020                        CSTART
                                        	; First save off the link register and OS sp value
    100 000F0020 FC 6E                   	sub		sp,sp,#4
    101 000F0022 E1 DF                   	sw		lr,[sp]
    102 000F0024 08 40 05 DE             	sw		sp,OSSP
    103 000F0028 01 50 0F 00 0D FE       	lw		sp,ENDMEM	; initialize stack pointer
    104 000F002E E1 DF                   	sw      lr,[sp]    ; save off return address
                                        ;	lw		r1,#TXT_WIDTH
                                        ;	sb		r1,txtWidth
                                        ;	lw		r1,#TXT_HEIGHT
                                        ;	sb		r1,txtHeight
    109 000F0030 03 40 02 C0             	sb		r0,cursx	; set screen output
    110 000F0034 03 40 03 C0             	sb		r0,cursy
    111 000F0038 03 40 0C C0             	sb		r0,cursFlash
    112 000F003C 03 40 05 D0             	sw		r0,pos
    113 000F0040 02 50 00 10 00 12       	lw		r2,#0x10000020	; black chars, yellow background
    114 000F0046 03 40 09 D2             	sw		r2,charToPrint
    115 000F004A BE 57 F8 FF 0E AF       	call	clearScreen
    116 000F0050 4B 51 0F 00 0A 11       	lea		r1,msgInit	;	tell who we are
    117 000F0056 86 40 04 AF             	call	PRMESGAUX
    118 000F005A 4B 51 0F 00 0A 11       	lea		r1,msgInit	;	tell who we are
    119 000F0060 85 40 00 AF             	call	PRMESG
    120 000F0064 01 50 0F 00 09 F1       	lw		r1,TXTBGN	;	init. end-of-program pointer
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 3
tb.asm
    121 000F006A 0A 40 09 D1             	sw		r1,TXTUNF
    122 000F006E 01 50 0F 00 0D F1       	lw		r1,ENDMEM	;	get address of end of memory
    123 000F0074 80 4F 10 11             	sub		r1,r1,#2048	; 	reserve 2K for the stack
    124 000F0078 0B 40 0D D1             	sw		r1,STKBOT
    125 000F007C 00 4E 10 11             	sub     r1,r1,#8192 ;   1000 vars
    126 000F0080 0A 40 0D D1             	sw      r1,VARBGN
    127 000F0084 17 40 0E AF             	call    clearVars   ; clear the variable area
    128 000F0088 0A 40 0D F1             	lw      r1,VARBGN   ; calculate number of bytes free
    129 000F008C 0A 40 09 F3             	lw		r3,TXTUNF
    130 000F0090 32 21                   	sub     r1,r3
    131 000F0092 00 12                   	lw		r2,#0
    132 000F0094 72 40 04 AF             	call	PRTNUM
    133 000F0098 56 51 0F 00 03 11       	lea		r1,msgBytesFree
    134 000F009E 83 40 01 AF             	call	PRMESG
    135 000F00A2                        WSTART
    136 000F00A2 09 40 05 D0             	sw		r0,LOPVAR   ; initialize internal variables
    137 000F00A6 08 40 0D D0             	sw		r0,STKGOS
    138 000F00AA 08 40 09 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    139 000F00AE 01 50 0F 00 0D FE       	lw		sp,ENDMEM	;	init S.P. again, just in case
    140 000F00B4 57 51 0F 00 01 11       	lea		r1,msgReady	;	display "Ready"
    141 000F00BA 82 40 03 AF             	call	PRMESG
    142 000F00BE                        ST3
    143 000F00BE 03 40 0E 11             	lw		r1,#'>'		; Prompt with a '>' and
    144 000F00C2 60 40 08 AF             	call	GETLN		; read a line.
    145 000F00C6 7E 40 02 AF             	call	TOUPBUF 	; convert to upper case
    146 000F00CA 80 1C                   	lw		r12,r8		; save pointer to end of line
    147 000F00CC 0C 40 0C 18             	lea		r8,BUFFER	; point to the beginning of line
    148 000F00D0 7A 40 0C AF             	call	TSTNUM		; is there a number there?
    149 000F00D4 7C 40 0D AF             	call	IGNBLK		; skip trailing blanks
    150 000F00D8 16 21                   	or      r1,r1       ; does line no. exist? (or nonzero?)
    151 000F00DA F4 A8                   	beq		DIRECT		; if not, it's a direct statement
    152 000F00DC 00 50 FF FF 11 10       	cmp		r1,#0xFFFF	; see if line no. is <= 16 bits
    153 000F00E2 05 A6                   	bleu	ST2
    154 000F00E4 58 51 0F 00 0F 11       	lea		r1,msgLineRange	; if not, we've overflowed
    155 000F00EA 5D 40 0A AE             	br		ERROR
    156 000F00EE                        ST2
                                            ; ugliness - store a character at potentially an
                                            ; odd address (unaligned).
    159 000F00EE 10 12                   	lw		r2,r1       ; r2 = line number
    160 000F00F0 8E C2                   	sb		r2,-2[r8]
    161 000F00F2 A1 32                   	shr		r2,#1
    162 000F00F4 A1 32                   	shr		r2,#1
    163 000F00F6 A1 32                   	shr		r2,#1
    164 000F00F8 A1 32                   	shr		r2,#1
    165 000F00FA A1 32                   	shr		r2,#1
    166 000F00FC A1 32                   	shr		r2,#1
    167 000F00FE A1 32                   	shr		r2,#1
    168 000F0100 A1 32                   	shr		r2,#1
    169 000F0102 8F C2                   	sb		r2,-1[r8]	; store the binary line no.
    170 000F0104 FE 68                   	sub		r8,r8,#2
    171 000F0106 63 40 0A AF             	call	FNDLN		; find this line in save area
    172 000F010A E0 31                   	tsr		r1,sr
    173 000F010C 90 1D                   	lw		r13,r9		; save possible line pointer
    174 000F010E F0 31                   	trs		r1,sr
    175 000F0110 11 A9                   	bne		ST4			; if not found, insert
                                        	; here we found the line, so we're replacing the line
                                        	; in the text area
                                        	; first step - delete the line
    179 000F0112 00 11                   	lw		r1,#0
    180 000F0114 65 40 03 AF             	call	FNDNXT		; find the next line (into r9)
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 4
tb.asm
    181 000F0118 0A A7                   	bgtu	ST6			; no more lines
    182 000F011A 90 11                   	lw		r1,r9		; r1 = pointer to next line
    183 000F011C D0 12                   	lw		r2,r13		; pointer to line to be deleted
    184 000F011E 0A 40 09 F3             	lw		r3,TXTUNF	; points to top of save area
    185 000F0122 65 40 07 AF             	call	MVUP		; move up to delete
    186 000F0126 0A 40 09 D2             	sw		r2,TXTUNF	; update the end pointer
                                        	; we moved the lines of text after the line being
                                        	; deleted down, so the pointer to the next line
                                        	; needs to be reset
    190 000F012A D0 19                   	lw		r9,r13
    191 000F012C 03 AE                   	br		ST4
                                        	; here there were no more lines, so just move the
                                        	; end of text pointer down
    194 000F012E                        ST6
    195 000F012E 0A 40 09 DD             	sw		r13,TXTUNF
    196 000F0132 D0 19                   	lw		r9,r13
    197 000F0134                        ST4
                                        	; here we're inserting because the line wasn't found
                                        	; or it was deleted	from the text area
    200 000F0134 C0 11                   	lw		r1,r12		; calculate the length of new line
    201 000F0136 82 21                   	sub		r1,r8
    202 000F0138 1D 10                   	cmp		r1,#3		; is it just a line no. & CR?
    203 000F013A C1 B2                   	ble		ST3			; if so, it was just a delete
                                        
    205 000F013C 0A 40 09 FB             	lw		r11,TXTUNF	; compute new end of text
    206 000F0140 B0 1A                   	lw		r10,r11		; r10 = old TXTUNF
    207 000F0142 10 2B                   	add		r11,r1		; r11 = new top of TXTUNF (r1=line length)
                                        
    209 000F0144 0A 40 0D F1             	lw		r1,VARBGN	; see if there's enough room
    210 000F0148 1D 2B                   	cmp		r11,r1
    211 000F014A 05 A4                   	bltu	ST5
    212 000F014C 66 51 0F 00 0A 11       	lea		r1,msgTooBig	; if not, say so
    213 000F0152 5A 40 06 AE             	jmp		ERROR
                                        
                                        	; open a space in the text area
    216 000F0156                        ST5
    217 000F0156 0A 40 09 DB             	sw		r11,TXTUNF	; if so, store new end position
    218 000F015A A0 11                   	lw		r1,r10		; points to old end of text
    219 000F015C B0 12                   	lw		r2,r11		; points to new end of text
    220 000F015E 90 13                   	lw		r3,r9       ; points to start of line after insert line
    221 000F0160 63 40 0F AF             	call	MVDOWN		; move things out of the way
                                        
                                        	; copy line into text space
    224 000F0164 80 11                   	lw		r1,r8		; set up to do the insertion; move from buffer
    225 000F0166 D0 12                   	lw		r2,r13		; to vacated space
    226 000F0168 C0 13                   	lw		r3,r12		; until end of buffer
    227 000F016A 63 40 03 AF             	call	MVUP		; do it
    228 000F016E A7 BE                   	br		ST3			; go back and get another line
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** Tables *** DIRECT *** EXEC ***
                                        ;
                                        ; This section of the code tests a string against a table. When
                                        ; a match is found, control is transferred to the section of
                                        ; code according to the table.
                                        ;
                                        ; At 'EXEC', r8 should point to the string, r9 should point to
                                        ; the character table, and r10 should point to the execution
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 5
tb.asm
                                        ; table. At 'DIRECT', r8 should point to the string, r9 and
                                        ; r10 will be set up to point to TAB1 and TAB1_1, which are
                                        ; the tables of all direct and statement commands.
                                        ;
                                        ; A '.' in the string will terminate the test and the partial
                                        ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                                        ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                                        ;
                                        ; There are two tables: the character table and the execution
                                        ; table. The character table consists of any number of text items.
                                        ; Each item is a string of characters with the last character's
                                        ; high bit set to one. The execution table holds a 32-bit
                                        ; execution addresses that correspond to each entry in the
                                        ; character table.
                                        ;
                                        ; The end of the character table is a 0 byte which corresponds
                                        ; to the default routine in the execution table, which is
                                        ; executed if none of the other table items are matched.
                                        ;
                                        ; Character-matching tables:
    261 000F0170                        TAB1
    262 000F0170 4C 49 53 D4             	db	"LIS",('T'+0x80)        ; Direct commands
    263 000F0174 4C 4F 41 C4             	db	"LOA",('D'+0x80)
    264 000F0178 4E 45 D7                	db	"NE",('W'+0x80)
    265 000F017B 52 55 CE                	db	"RU",('N'+0x80)
    266 000F017E 53 41 56 C5             	db	"SAV",('E'+0x80)
    267 000F0182                        TAB2
    268 000F0182 4E 45 58 D4             	db	"NEX",('T'+0x80)         ; Direct / statement
    269 000F0186 4C 45 D4                	db	"LE",('T'+0x80)
    270 000F0189 49 C6                   	db	"I",('F'+0x80)
    271 000F018B 47 4F 54 CF             	db	"GOT",('O'+0x80)
    272 000F018F 47 4F 53 55 C2          	db	"GOSU",('B'+0x80)
    273 000F0194 52 45 54 55 52 CE       	db	"RETUR",('N'+0x80)
    274 000F019A 52 45 CD                	db	"RE",('M'+0x80)
    275 000F019D 46 4F D2                	db	"FO",('R'+0x80)
    276 000F01A0 49 4E 50 55 D4          	db	"INPU",('T'+0x80)
    277 000F01A5 50 52 49 4E D4          	db	"PRIN",('T'+0x80)
    278 000F01AA 50 4F 4B 45 C3          	db	"POKE",('C'+0x80)
    279 000F01AF 50 4F 4B 45 D7          	db	"POKE",('W'+0x80)
    280 000F01B4 50 4F 4B C5             	db	"POK",('E'+0x80)
    281 000F01B8 53 54 4F D0             	db	"STO",('P'+0x80)
    282 000F01BC 42 59 C5                	db	"BY",('E'+0x80)
    283 000F01BF 53 59 D3                	db	"SY",('S'+0x80)
    284 000F01C2 43 4C D3                	db	"CL",('S'+0x80)
    285 000F01C5 43 4C D2                    db  "CL",('R'+0x80)
    286 000F01C8 52 44 43 C6                 db	"RDC",('F'+0x80)
    287 000F01CC 00                      	db	0
    288 000F01CD                        TAB4
    289 000F01CD 50 45 45 4B C3          	db	"PEEK",('C'+0x80)        ;Functions
    290 000F01D2 50 45 45 4B D7          	db	"PEEK",('W'+0x80)        ;Functions
    291 000F01D7 50 45 45 CB             	db	"PEE",('K'+0x80)         ;Functions
    292 000F01DB 52 4E C4                	db	"RN",('D'+0x80)
    293 000F01DE 41 42 D3                	db	"AB",('S'+0x80)
    294 000F01E1 53 49 5A C5             	db	"SIZ",('E'+0x80)
    295 000F01E5 55 53 D2                	db  "US",('R'+0x80)
    296 000F01E8 00                      	db	0
    297 000F01E9                        TAB5
    298 000F01E9 54 CF                   	db	"T",('O'+0x80)           ;"TO" in "FOR"
    299 000F01EB 00                      	db	0
    300 000F01EC                        TAB6
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 6
tb.asm
    301 000F01EC 53 54 45 D0             	db	"STE",('P'+0x80)         ;"STEP" in "FOR"
    302 000F01F0 00                      	db	0
    303 000F01F1                        TAB8
    304 000F01F1 3E BD                   	db	'>',('='+0x80)           ;Relational operators
    305 000F01F3 3C BE                   	db	'<',('>'+0x80)
    306 000F01F5 BE                      	db	('>'+0x80)
    307 000F01F6 BD                      	db	('='+0x80)
    308 000F01F7 3C BD                   	db	'<',('='+0x80)
    309 000F01F9 BC                      	db	('<'+0x80)
    310 000F01FA 00                      	db	0
    311 000F01FB                        TAB9
    312 000F01FB 41 4E C4                    db  "AN",('D'+0x80)
    313 000F01FE 00                          db  0
    314 000F01FF                        TAB10
    315 000F01FF 4F D2                       db  "O",('R'+0x80)
    316 000F0201 00                          db  0
                                        
    318 000F0202 FF FF                   	.align	4
                                        
                                        ;* Execution address tables:
    321 000F0204                        TAB1_1
    322 000F0204 A2 03 0F 00             	dw	LISTX			;Direct commands
    323 000F0208 20 06 0F 00             	dw	LOAD
    324 000F020C 10 03 0F 00             	dw	NEW
    325 000F0210 28 03 0F 00             	dw	RUN
    326 000F0214 B6 06 0F 00             	dw	SAVE
    327 000F0218                        TAB2_1
    328 000F0218 06 05 0F 00             	dw	NEXT		;	Direct / statement
    329 000F021C 12 06 0F 00             	dw	LET
    330 000F0220 64 05 0F 00             	dw	IF
    331 000F0224 64 03 0F 00             	dw	GOTO
    332 000F0228 3C 04 0F 00             	dw	GOSUB
    333 000F022C 6E 04 0F 00             	dw	RETURN
    334 000F0230 6E 05 0F 00             	dw	IF2			; REM
    335 000F0234 9A 04 0F 00             	dw	FOR
    336 000F0238 8C 05 0F 00             	dw	INPUT
    337 000F023C D8 03 0F 00             	dw	PRINT
    338 000F0240 92 07 0F 00             	dw	POKEC
    339 000F0244 AA 07 0F 00             	dw	POKEW
    340 000F0248 70 07 0F 00             	dw	POKE
    341 000F024C 20 03 0F 00             	dw	STOP
    342 000F0250 14 00 0F 00             	dw	GOBYE
    343 000F0254 C2 07 0F 00             	dw	SYSX
    344 000F0258 FC 12 0F 00             	dw	_cls
    345 000F025C 80 03 0F 00             	dw  _clr
    346 000F0260 48 13 0F 00             	dw	_rdcf
    347 000F0264 0A 06 0F 00             	dw	DEFLT
    348 000F0268                        TAB4_1
    349 000F0268 5A 0B 0F 00             	dw  PEEKC
    350 000F026C 68 0B 0F 00             	dw  PEEKW
    351 000F0270 4E 0B 0F 00             	dw	PEEK			;Functions
    352 000F0274 8A 0B 0F 00             	dw	RND
    353 000F0278 E6 0B 0F 00             	dw	ABS
    354 000F027C 0C 0C 0F 00             	dw	SIZEX
    355 000F0280 74 0B 0F 00             	dw  USRX
    356 000F0284 7E 09 0F 00             	dw	XP40
    357 000F0288                        TAB5_1
    358 000F0288 B4 04 0F 00             	dw	FR1			;"TO" in "FOR"
    359 000F028C 9C 0C 0F 00             	dw	QWHAT
    360 000F0290                        TAB6_1
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 7
tb.asm
    361 000F0290 CA 04 0F 00             	dw	FR2			;"STEP" in "FOR"
    362 000F0294 D0 04 0F 00             	dw	FR3
    363 000F0298                        TAB8_1
    364 000F0298 9C 08 0F 00             	dw	XP11	;>=		Relational operators
    365 000F029C A6 08 0F 00             	dw	XP12	;<>
    366 000F02A0 B0 08 0F 00             	dw	XP13	;>
    367 000F02A4 C4 08 0F 00             	dw	XP15	;=
    368 000F02A8 BA 08 0F 00             	dw	XP14	;<=
    369 000F02AC CE 08 0F 00             	dw	XP16	;<
    370 000F02B0 E8 08 0F 00             	dw	XP17
    371 000F02B4                        TAB9_1
    372 000F02B4 24 08 0F 00                 dw  XP_AND
    373 000F02B8 2C 08 0F 00                 dw  XP_ANDX
    374 000F02BC                        TAB10_1
    375 000F02BC FC 07 0F 00                 dw  XP_OR
    376 000F02C0 04 08 0F 00                 dw  XP_ORX
                                        
                                        ;*
                                        ; r3 = match flag (trashed)
                                        ; r9 = text table
                                        ; r10 = exec table
                                        ; r11 = trashed
    383 000F02C4                        DIRECT
    384 000F02C4 17 50 0F 00 00 19       	lea		r9,TAB1
    385 000F02CA 20 50 0F 00 04 1A       	lea		r10,TAB1_1
    386 000F02D0                        EXEC
    387 000F02D0 F0 1B                   	lw		r11,lr		; save link reg
    388 000F02D2 6C 40 0E AF             	call	IGNBLK		; ignore leading blanks
    389 000F02D6 B0 1F                   	lw		lr,r11		; restore link reg
    390 000F02D8 80 1B                   	lw		r11,r8		; save the pointer
    391 000F02DA 00 13                   	lw		r3,#0		; clear match flag
    392 000F02DC                        EXLP
    393 000F02DC 80 E1                   	lb		r1,[r8]		; get the program character
    394 000F02DE 01 68                   	add		r8,r8,#1
    395 000F02E0 90 E2                   	lb		r2,[r9]		; get the table character
    396 000F02E2 02 A9                   	bne		EXNGO		; If end of table,
    397 000F02E4 B0 18                   	lw		r8,r11		;	restore the text pointer and...
    398 000F02E6 12 AE                   	br		EXGO		;   execute the default.
    399 000F02E8                        EXNGO
    400 000F02E8 3D 21                   	cmp		r1,r3		; Else check for period...
    401 000F02EA 10 A8                   	beq		EXGO		; if so, execute
    402 000F02EC 07 40 5F 32             	and		r2,#0x7f	; ignore the table's high bit
    403 000F02F0 1D 22                   	cmp		r2,r1		;		is there a match?
    404 000F02F2 07 A8                   	beq		EXMAT
    405 000F02F4 04 6A                   	add		r10,r10,#4	;if not, try the next entry
    406 000F02F6 B0 18                   	lw		r8,r11		; reset the program pointer
    407 000F02F8 00 13                   	lw		r3,#0		; sorry, no match
    408 000F02FA                        EX1
    409 000F02FA 01 69                   	add		r9,r9,#1
    410 000F02FC 9F E1                   	lb		r1,-1[r9]	; get to the end of the entry
    411 000F02FE FD BB                   	bpl		EX1
    412 000F0300 ED BE                   	br		EXLP		; back for more matching
    413 000F0302                        EXMAT
    414 000F0302 02 40 0E 13             	lw		r3,#'.'		; we've got a match so far
    415 000F0306 01 69                   	add		r9,r9,#1
    416 000F0308 9F E1                   	lb		r1,-1[r9]	; end of table entry?
    417 000F030A E8 BB                   	bpl		EXLP		; if not, go back for more
    418 000F030C                        EXGO
    419 000F030C A1 FB                   	lw		r11,[r10]	; execute the appropriate routine
    420 000F030E B0 80                   	jmp		[r11]
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 8
tb.asm
                                        
                                        
                                        ;    lb      r1,[r8]     ; get token from text space
                                        ;    bpl
                                        ;    and     r1,#0x7f
                                        ;    shl     r1,#2       ; * 4 - word offset
                                        ;    add     r1,r1,#TAB1_1
                                        ;    lw      r1,[r1]
                                        ;    jmp     [r1]
                                        
                                            
                                        ;
                                        ; What follows is the code to execute direct and statement
                                        ; commands. Control is transferred to these points via the command
                                        ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                                        ; After the command is executed, control is transferred to other
                                        ; sections as follows:
                                        ;
                                        ; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                                        ; For 'RUN': go execute the first stored line if any; else go
                                        ; back to the warm start point.
                                        ; For 'GOTO' and 'GOSUB': go execute the target line.
                                        ; For 'RETURN' and 'NEXT'; go back to saved return line.
                                        ; For all others: if 'CURRNT' is 0, go to warm start; else go
                                        ; execute next command. (This is done in 'FINISH'.)
                                        ;
                                        ;******************************************************************
                                        ;
                                        ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                                        ;
                                        ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                                        ;
                                        ; 'STOP<CR>' goes back to WSTART
                                        ;
                                        ; 'RUN<CR>' finds the first stored line, stores its address
                                        ; in CURRNT, and starts executing it. Note that only those
                                        ; commands in TAB2 are legal for a stored program.
                                        ;
                                        ; There are 3 more entries in 'RUN':
                                        ; 'RUNNXL' finds next line, stores it's address and executes it.
                                        ; 'RUNTSL' stores the address of this line and executes it.
                                        ; 'RUNSML' continues the execution on same line.
                                        ;
                                        ; 'GOTO expr<CR>' evaluates the expression, finds the target
                                        ; line, and jumps to 'RUNTSL' to do it.
                                        ;
    467 000F0310                        NEW
    468 000F0310 4A 40 0D AF             	call	ENDCHK
    469 000F0314 01 50 0F 00 09 F1       	lw		r1,TXTBGN
    470 000F031A 0A 40 09 D1             	sw		r1,TXTUNF	;	set the end pointer
    471 000F031E 32 AF                   	call    clearVars
                                        
    473 000F0320                        STOP
    474 000F0320 4A 40 05 AF             	call	ENDCHK
    475 000F0324 EB 4F 0D AE             	br		WSTART		; WSTART will reset the stack
                                        
    477 000F0328                        RUN
    478 000F0328 4A 40 01 AF             	call	ENDCHK
    479 000F032C 01 50 0F 00 09 F8       	lw		r8,TXTBGN	;	set pointer to beginning
    480 000F0332 08 40 09 D8             	sw		r8,CURRNT
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 9
tb.asm
    481 000F0336 26 AF                   	call    clearVars
                                        
    483 000F0338                        RUNNXL					; RUN <next line>
    484 000F0338 08 40 09 F1             	lw		r1,CURRNT	; executing a program?
    485 000F033C EB 4F 01 A8             	beq		WSTART		; if not, we've finished a direct stat.
    486 000F0340 00 11                   	lw		r1,#0	    ; else find the next line number
    487 000F0342 80 19                   	lw		r9,r8
    488 000F0344 52 40 06 AF             	call	FNDLNP		; search for the next line
    489 000F0348 EA 4F 0B A7             	bgtu	WSTART		; if we've fallen off the end, stop
                                        
    491 000F034C                        RUNTSL					; RUN <this line>
    492 000F034C 08 40 09 D9             	sw		r9,CURRNT	; set CURRNT to point to the line no.
    493 000F0350 92 18                   	lea		r8,2[r9]	; set the text pointer to
                                        
    495 000F0352                        RUNSML                  ; RUN <same line>
    496 000F0352 6C 40 04 AF             	call	CHKIO		; see if a control-C was pressed
    497 000F0356 18 50 0F 00 02 19       	lea		r9,TAB2		; find command in TAB2
    498 000F035C 21 50 0F 00 08 1A       	lea		r10,TAB2_1
    499 000F0362 B6 BE                   	br		EXEC		; and execute it
                                        
    501 000F0364                        GOTO
    502 000F0364 23 40 0E AF             	call	OREXPR		;evaluate the following expression
    503 000F0368 10 15                   	lw      r5,r1
    504 000F036A 48 40 00 AF             	call	ENDCHK		;must find end of line
    505 000F036E 50 11                   	lw      r1,r5
    506 000F0370 50 40 05 AF             	call	FNDLN		; find the target line
    507 000F0374 EB B8                   	beq		RUNTSL		; go do it
    508 000F0376 63 51 0F 00 06 11       	lea		r1,msgBadGotoGosub
    509 000F037C 49 40 01 AE             	br		ERROR		; no such line no.
                                        
                                        
    512 000F0380                        _clr
    513 000F0380 01 AF                       call    clearVars
    514 000F0382 58 AE                       br      FINISH
                                        
                                        ; Clear the variable area of memory
    517 000F0384                        clearVars
    518 000F0384 F8 6E                       sub     sp,sp,#8
    519 000F0386 E1 DF                       sw      lr,[sp]
    520 000F0388 E5 D6                       sw      r6,4[sp]
    521 000F038A 80 40 00 16                 lw      r6,#2048    ; number of words to clear
    522 000F038E 0A 40 0D F1                 lw      r1,VARBGN
    523 000F0392                        cv1
    524 000F0392 11 D0                       sw      r0,[r1]
    525 000F0394 04 61                       add     r1,r1,#4
    526 000F0396 FF 66                       sub		r6,r6,#1
    527 000F0398 FC B9                       bne     cv1
    528 000F039A E1 FF                       lw      lr,[sp]
    529 000F039C E5 F6                       lw      r6,4[sp]
    530 000F039E 08 6E                       add     sp,sp,#8
    531 000F03A0 F0 80                       ret    
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; LIST
                                        ;
                                        ; LISTX has two forms:
                                        ; 'LIST<CR>' lists all saved lines
                                        ; 'LIST #<CR>' starts listing at the line #
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 10
tb.asm
                                        ; Control-S pauses the listing, control-C stops it.
                                        ;
                                        
    544 000F03A2                        LISTX
    545 000F03A2 64 40 03 AF             	call	TSTNUM		; see if there's a line no.
    546 000F03A6 10 15                   	lw      r5,r1
    547 000F03A8 46 40 01 AF             	call	ENDCHK		; if not, we get a zero
    548 000F03AC 50 11                   	lw      r1,r5
    549 000F03AE 4E 40 06 AF             	call	FNDLN		; find this or next line
    550 000F03B2                        LS1
    551 000F03B2 E7 4F 06 A7             	bgtu	WSTART		; warm start if we passed the end
                                        
    553 000F03B6 90 11                   	lw		r1,r9
    554 000F03B8 60 40 08 AF             	call	PRTLN		; print the line
    555 000F03BC 10 19                   	lw		r9,r1		; set pointer for next
    556 000F03BE 68 40 0E AF             	call	CHKIO		; check for listing halt request
    557 000F03C2 06 A8                   	beq		LS3
    558 000F03C4 FE 4F 1D 10             	cmp		r1,#CTRLS	; pause the listing?
    559 000F03C8 03 A9                   	bne		LS3
    560 000F03CA                        LS2
    561 000F03CA 68 40 08 AF             	call	CHKIO		; if so, wait for another keypress
    562 000F03CE FD B8                   	beq		LS2
    563 000F03D0                        LS3
    564 000F03D0 00 11                   	lw		r1,#0
    565 000F03D2 4D 40 0F AF             	call	FNDLNP		; find the next line
    566 000F03D6 ED BE                   	br		LS1
                                        
                                        
                                        ;******************************************************************
                                        ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                                        ; where '....' is a list of expressions, formats, back-arrows,
                                        ; and strings.	These items a separated by commas.
                                        ;
                                        ; A format is a pound sign followed by a number.  It controls
                                        ; the number of spaces the value of an expression is going to
                                        ; be printed in.  It stays effective for the rest of the print
                                        ; command unless changed by another format.  If no format is
                                        ; specified, 11 positions will be used.
                                        ;
                                        ; A string is quoted in a pair of single- or double-quotes.
                                        ;
                                        ; An underline (back-arrow) means generate a <CR> without a <LF>
                                        ;
                                        ; A <CR LF> is generated after the entire list has been printed
                                        ; or if the list is empty.  If the list ends with a semicolon,
                                        ; however, no <CR LF> is generated.
                                        ;
                                        
    589 000F03D8                        PRINT
    590 000F03D8 0B 15                   	lw		r5,#11		; D4 = number of print spaces
    591 000F03DA 61 40 05 AF             	call	TSTC		; if null list and ":"
    592 000F03DE 3A 08                   	db	':',PR2-*+1
    593 000F03E0 68 40 0D AF             	call	CRLF		; give CR-LF and continue
    594 000F03E4 B6 BE                   	br		RUNSML		;		execution on the same line
    595 000F03E6                        PR2
    596 000F03E6 60 40 0F AF             	call	TSTC		;if null list and <CR>
    597 000F03EA 0D 08                   	db	CR,PR0-*+1
    598 000F03EC 68 40 07 AF             	call	CRLF		;also give CR-LF and
    599 000F03F0 A3 BE                   	br		RUNNXL		;execute the next line
    600 000F03F2                        PR0
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 11
tb.asm
    601 000F03F2 60 40 09 AF             	call	TSTC		;else is it a format?
    602 000F03F6 23 0A                   	db	'#',PR1-*+1
    603 000F03F8 1F 40 04 AF             	call	OREXPR		; yes, evaluate expression
    604 000F03FC 10 15                   	lw		r5,r1		; and save it as print width
    605 000F03FE 0B AE                   	br		PR3		; look for more to print
    606 000F0400                        PR1
    607 000F0400 60 40 02 AF             	call	TSTC	;	is character expression? (MRL)
    608 000F0404 24 0C                   	db	'$',PR4-*+1
    609 000F0406 1E 40 0D AF             	call	OREXPR	;	yep. Evaluate expression (MRL)
    610 000F040A DF 4F 0B AF             	call	GOOUT	;	print low byte (MRL)
    611 000F040E 03 AE                   	br		PR3		;look for more. (MRL)
    612 000F0410                        PR4
    613 000F0410 53 40 0A AF             	call	QTSTG	;	is it a string?
                                        	; the following branch must occupy only two bytes!
    615 000F0414 09 AE                   	br		PR8		;	if not, must be an expression
    616 000F0416                        PR3
    617 000F0416 5F 40 07 AF             	call	TSTC	;	if ",", go find next
    618 000F041A 2C 08                   	db	',',PR6-*+1
    619 000F041C 41 40 05 AF             	call	FIN		;in the list.
    620 000F0420 E8 BE                   	br		PR0
    621 000F0422                        PR6
    622 000F0422 66 40 0C AF             	call	CRLF		;list ends here
    623 000F0426 06 AE                   	br		FINISH
    624 000F0428                        PR8
    625 000F0428 1D 40 0C AF             	call	OREXPR		; evaluate the expression
    626 000F042C 50 12                   	lw		r2,r5		; set the width
    627 000F042E 55 40 07 AF             	call	PRTNUM		; print its value
    628 000F0432 F1 BE                   	br		PR3			; more to print?
                                        
    630 000F0434                        FINISH
    631 000F0434 40 40 09 AF             	call	FIN		; Check end of command
    632 000F0438 43 40 00 AE             	jmp		QWHAT	; print "What?" if wrong
                                        
                                        
                                        ;*******************************************************************
                                        ;
                                        ; *** GOSUB *** & RETURN ***
                                        ;
                                        ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                                        ; except that the current text pointer, stack pointer, etc. are
                                        ; saved so that execution can be continued after the subroutine
                                        ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                                        ; recursive), the save area must be stacked.  The stack pointer
                                        ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                                        ; If we are in the main routine, 'STKGOS' is zero (this was done
                                        ; in the initialization section of the interpreter), but we still
                                        ; save it as a flag for no further 'RETURN's.
                                        ;
    649 000F043C                        GOSUB
    650 000F043C 4E 40 0A AF             	call	PUSHA		; save the current 'FOR' parameters
    651 000F0440 1D 40 00 AF             	call	OREXPR		; get line number
    652 000F0444 49 40 0B AF             	call	FNDLN		; find the target line
    653 000F0448 05 A8                   	beq		gosub1
    654 000F044A 63 51 0F 00 06 11       	lea		r1,msgBadGotoGosub
    655 000F0450 42 40 07 AE             	br		ERROR		; if not there, say "How?"
    656 000F0454                        gosub1
    657 000F0454 F4 6E                   	sub		sp,sp,#12
    658 000F0456 E1 D8                   	sw		r8,[sp]		; save text pointer
    659 000F0458 08 40 09 F1             	lw		r1,CURRNT
    660 000F045C E5 D1                   	sw		r1,4[sp]	; found it, save old 'CURRNT'...
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 12
tb.asm
    661 000F045E 08 40 0D F1             	lw		r1,STKGOS
    662 000F0462 E9 D1                   	sw		r1,8[sp]	; and 'STKGOS'
    663 000F0464 09 40 05 D0             	sw		r0,LOPVAR	; load new values
    664 000F0468 08 40 0D DE             	sw		sp,STKGOS
    665 000F046C 6F BE                   	br		RUNTSL
                                        
                                        
                                        ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                                        ; returns the execution to the command after the most recent
                                        ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                                        ; a 'GOSUB' and is thus an error.
                                        ;
    673 000F046E                        RETURN
    674 000F046E 3F 40 0E AF             	call	ENDCHK		; there should be just a <CR>
    675 000F0472 08 40 0D F1             	lw		r1,STKGOS	; get old stack pointer
    676 000F0476 05 A9                   	bne		return1
    677 000F0478 65 51 0F 00 03 11       	lea		r1,msgRetWoGosub
    678 000F047E 41 40 00 AE             	br		ERROR		; if zero, it doesn't exist
    679 000F0482                        return1
    680 000F0482 10 1E                   	lw		sp,r1		; else restore it
    681 000F0484 E9 F1                   	lw		r1,8[sp]
    682 000F0486 08 40 0D D1             	sw		r1,STKGOS	; and the old 'STKGOS'
    683 000F048A E5 F1                   	lw		r1,4[sp]
    684 000F048C 08 40 09 D1             	sw		r1,CURRNT	; and the old 'CURRNT'
    685 000F0490 E1 F8                   	lw		r8,[sp]		; and the old text pointer
    686 000F0492 0C 6E                   	add		sp,sp,#12
    687 000F0494 4A 40 08 AF             	call	POPA		;and the old 'FOR' parameters
    688 000F0498 CD BE                   	br		FINISH		;and we are back home
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** FOR *** & NEXT ***
                                        ;
                                        ; 'FOR' has two forms:
                                        ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                                        ; The second form means the same thing as the first form with a
                                        ; STEP of positive 1.  The interpreter will find the variable 'var'
                                        ; and set its value to the current value of 'exp1'.  It also
                                        ; evaluates 'exp2' and 'exp1' and saves all these together with
                                        ; the text pointer, etc. in the 'FOR' save area, which consisits of
                                        ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                                        ; already something in the save area (indicated by a non-zero
                                        ; 'LOPVAR'), then the old save area is saved on the stack before
                                        ; the new values are stored.  The interpreter will then dig in the
                                        ; stack and find out if this same variable was used in another
                                        ; currently active 'FOR' loop.  If that is the case, then the old
                                        ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                                        ;
    710 000F049A                        FOR
    711 000F049A 4B 40 0B AF             	call	PUSHA		; save the old 'FOR' save area
    712 000F049E 3B 40 0D AF             	call	SETVAL		; set the control variable
    713 000F04A2 09 40 05 D1             	sw		r1,LOPVAR	; save its address
    714 000F04A6 1E 50 0F 00 09 19       	lea		r9,TAB5		; use 'EXEC' to test for 'TO'
    715 000F04AC 28 50 0F 00 08 1A       	lea		r10,TAB5_1
    716 000F04B2 0E BE                   	jmp		EXEC
    717 000F04B4                        FR1
    718 000F04B4 19 40 06 AF             	call	OREXPR		; evaluate the limit
    719 000F04B8 09 40 0D D1             	sw		r1,LOPLMT	; save that
    720 000F04BC 1E 50 0F 00 0C 19       	lea		r9,TAB6		; use 'EXEC' to look for the
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 13
tb.asm
    721 000F04C2 29 50 0F 00 00 1A       	lea		r10,TAB6_1	; word 'STEP'
    722 000F04C8 03 BE                   	jmp		EXEC
    723 000F04CA                        FR2
    724 000F04CA 18 40 0B AF             	call	OREXPR		; found it, get the step value
    725 000F04CE 01 AE                   	br		FR4
    726 000F04D0                        FR3
    727 000F04D0 01 11                   	lw		r1,#1		; not found, step defaults to 1
    728 000F04D2                        FR4
    729 000F04D2 09 40 09 D1             	sw		r1,LOPINC	; save that too
                                        
    731 000F04D6                        FR5
    732 000F04D6 08 40 09 F2             	lw		r2,CURRNT
    733 000F04DA 0A 40 01 D2             	sw		r2,LOPLN	; save address of current line number
    734 000F04DE 0A 40 05 D8             	sw		r8,LOPPT	; and text pointer
                                        
                                        
    737 000F04E2 E0 13                   	lw		r3,sp		; dig into the stack to find 'LOPVAR'
    738 000F04E4 09 40 05 F6             	lw		r6,LOPVAR
    739 000F04E8 02 AE                   	br		FR7
    740 000F04EA                        FR6
    741 000F04EA 01 40 34 13             	lea		r3,20[r3]	; look at next stack frame
    742 000F04EE                        FR7
    743 000F04EE 31 F2                   	lw		r2,[r3]		; is it zero?
    744 000F04F0 09 A8                   	beq		FR8			; if so, we're done
    745 000F04F2 6D 22                   	cmp		r2,r6		; same as current LOPVAR?
    746 000F04F4 FA B9                   	bne		FR6			; nope, look some more
                                        
    748 000F04F6 30 11                       lw      r1,r3       ; Else remove 5 long words from...
    749 000F04F8 01 40 34 12             	lea		r2,20[r3]   ; inside the stack.
    750 000F04FC E0 13                   	lw		r3,sp		
    751 000F04FE 47 40 00 AF             	call	MVDOWN
    752 000F0502 14 6E                   	add		sp,sp,#20	; set the SP 5 long words up
    753 000F0504                        FR8
    754 000F0504 97 BE                       br	    FINISH		; and continue execution
                                        
                                        
                                        ; 'NEXT var' serves as the logical (not necessarily physical) end
                                        ; of the 'FOR' loop.  The control variable 'var' is checked with
                                        ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                                        ; the stack to find the right one and purges all those that didn't
                                        ; match.  Either way, it then adds the 'STEP' to that variable and
                                        ; checks the result with against the limit value.  If it is within
                                        ; the limit, control loops back to the command following the
                                        ; 'FOR'.  If it's outside the limit, the save area is purged and
                                        ; execution continues.
                                        ;
    767 000F0506                        NEXT
    768 000F0506 00 11                   	lw		r1,#0		; don't allocate it
    769 000F0508 25 40 09 AF             	call	TSTV		; get address of variable
    770 000F050C 05 A9                   	bne		NX4
    771 000F050E 61 51 0F 00 02 11       	lea		r1,msgNextVar
    772 000F0514 3C 40 05 AE             	br		ERROR		; if no variable, say "What?"
    773 000F0518                        NX4
    774 000F0518 10 19                   	lw		r9,r1		; save variable's address
    775 000F051A                        NX0
    776 000F051A 09 40 05 F1             	lw		r1,LOPVAR	; If 'LOPVAR' is zero, we never...
    777 000F051E 05 A9                   	bne		NX5         ; had a FOR loop
    778 000F0520 5F 51 0F 00 0F 11       	lea		r1,msgNextFor
    779 000F0526 3B 40 0C AE             	br		ERROR		
    780 000F052A                        NX5
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 14
tb.asm
    781 000F052A 9D 21                   	cmp		r1,r9		; else we check them
    782 000F052C 03 A8                   	beq		NX2			; OK, they agree
    783 000F052E 45 40 0B AF             	call	POPA		; nope, let's see the next frame
    784 000F0532 F3 BE                   	br		NX0
    785 000F0534                        NX2
    786 000F0534 91 F1                   	lw		r1,[r9]		; get control variable's value
    787 000F0536 09 40 09 F2             	lw		r2,LOPINC
    788 000F053A 20 21                   	add		r1,r2		; add in loop increment
                                        ;	BVS.L	QHOW		say "How?" for 32-bit overflow
    790 000F053C 91 D1                   	sw		r1,[r9]		; save control variable's new value
    791 000F053E 09 40 0D F3             	lw		r3,LOPLMT	; get loop's limit value
    792 000F0542 26 22                   	or		r2,r2       ; check loop increment
    793 000F0544 03 AB                   	bpl		NX1			; branch if loop increment is positive
    794 000F0546 3D 21                   	cmp		r1,r3		; test against limit
    795 000F0548 0A A0                   	blt		NXPurge
    796 000F054A 02 AE                   	br      NX3
    797 000F054C                        NX1
    798 000F054C 3D 21                   	cmp		r1,r3
    799 000F054E 07 A3                   	bgt		NXPurge
    800 000F0550                        NX3	
    801 000F0550 0A 40 01 F8             	lw		r8,LOPLN	; Within limit, go back to the...
    802 000F0554 08 40 09 D8             	sw		r8,CURRNT
    803 000F0558 0A 40 05 F8             	lw		r8,LOPPT	; saved 'CURRNT' and text pointer.
    804 000F055C 6B BE                   	br		FINISH
                                        
    806 000F055E                        NXPurge
    807 000F055E 44 40 03 AF                 call    POPA        ; purge this loop
    808 000F0562 68 BE                       br      FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                                        ;
                                        ; 'REM' can be followed by anything and is ignored by the
                                        ; interpreter.
                                        ;
                                        ;REM
                                        ;    br	    IF2		    ; skip the rest of the line
                                        
                                        ; 'IF' is followed by an expression, as a condition and one or
                                        ; more commands (including other 'IF's) separated by colons.
                                        ; Note that the word 'THEN' is not used.  The interpreter evaluates
                                        ; the expression.  If it is non-zero, execution continues.  If it
                                        ; is zero, the commands that follow are ignored and execution
                                        ; continues on the next line.
                                        ;
    828 000F0564                        IF
    829 000F0564 13 40 0E AF                 call	OREXPR		; evaluate the expression
    830 000F0568                        IF1
    831 000F0568 16 21                       or      r1,r1       ; is it zero?
    832 000F056A EF 4F 02 A9                 bne	    RUNSML		; if not, continue
    833 000F056E                        IF2
    834 000F056E 80 19                       lw		r9,r8		; set lookup pointer
    835 000F0570 00 11                   	lw		r1,#0		; find line #0 (impossible)
    836 000F0572 42 40 05 AF             	call	FNDSKP		; if so, skip the rest of the line
    837 000F0576 D9 4F 04 A7             	bgtu	WSTART		; if no next line, do a warm start
    838 000F057A                        IF3
    839 000F057A EE 4F 07 AE             	br		RUNTSL		; run the next line
                                        
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 15
tb.asm
                                        
                                        ; INPUT is called first and establishes a stack frame
    843 000F057E                        INPERR
    844 000F057E 09 40 01 FE             	lw		sp,STKINP	; restore the old stack pointer
    845 000F0582 E9 F8                   	lw		r8,8[sp]
    846 000F0584 08 40 09 D8             	sw		r8,CURRNT	; and old 'CURRNT'
    847 000F0588 E5 F8                   	lw		r8,4[sp]	; and old text pointer
    848 000F058A 14 6E                   	add		sp,sp,#20	; fall through will subtract 20
                                        
                                        ; 'INPUT' is like the 'PRINT' command, and is followed by a list
                                        ; of items.  If the item is a string in single or double quotes,
                                        ; or is an underline (back arrow), it has the same effect as in
                                        ; 'PRINT'.  If an item is a variable, this variable name is
                                        ; printed out followed by a colon, then the interpreter waits for
                                        ; an expression to be typed in.  The variable is then set to the
                                        ; value of this expression.  If the variable is preceeded by a
                                        ; string (again in single or double quotes), the string will be
                                        ; displayed followed by a colon.  The interpreter the waits for an
                                        ; expression to be entered and sets the variable equal to the
                                        ; expression's value.  If the input expression is invalid, the
                                        ; interpreter will print "What?", "How?", or "Sorry" and reprint
                                        ; the prompt and redo the input.  The execution will not terminate
                                        ; unless you press control-C.  This is handled in 'INPERR'.
                                        ;
    865 000F058C                        INPUT
    866 000F058C EC 6E                   	sub		sp,sp,#20	; allocate stack frame
    867 000F058E 01 40 E1 D5             	sw      r5,16[sp]
    868 000F0592                        IP6
    869 000F0592 E1 D8                   	sw		r8,[sp]		; save in case of error
    870 000F0594 47 40 08 AF             	call	QTSTG		; is next item a string?
    871 000F0598 06 AE                   	br		IP2			; nope - this branch must take only two bytes
    872 000F059A 01 11                   	lw		r1,#1		; allocate var
    873 000F059C 20 40 0F AF             	call	TSTV		; yes, but is it followed by a variable?
    874 000F05A0 2C A8                   	beq     IP4		    ; if not, brnch
    875 000F05A2 10 1A                   	lw		r10,r1		; put away the variable's address
    876 000F05A4 11 AE                   	br		IP3			; if so, input to variable
    877 000F05A6                        IP2
    878 000F05A6 E5 D8                   	sw		r8,4[sp]	; save for 'PRTSTG'
    879 000F05A8 01 11                   	lw		r1,#1
    880 000F05AA 20 40 08 AF             	call	TSTV		; must be a variable now
    881 000F05AE 05 A9                   	bne		IP7
    882 000F05B0 5E 51 0F 00 02 11       	lea		r1,msgInputVar
    883 000F05B6 37 40 04 AE             	br		ERROR		; "What?" it isn't?
    884 000F05BA                        IP7
    885 000F05BA 10 1A                   	lw		r10,r1		; put away the variable's address
    886 000F05BC 80 E5                   	lb		r5,[r8]		; get ready for 'PRTSTG' by null terminating
    887 000F05BE 80 C0                   	sb		r0,[r8]
    888 000F05C0 E5 F1                   	lw		r1,4[sp]	; get back text pointer
    889 000F05C2 44 40 03 AF             	call	PRTSTG		; print string as prompt
    890 000F05C6 80 C5                   	sb		r5,[r8]		; un-null terminate
    891 000F05C8                        IP3
    892 000F05C8 E5 D8                   	sw		r8,4[sp]	; save in case of error
    893 000F05CA 08 40 09 F1             	lw		r1,CURRNT
    894 000F05CE E9 D1                   	sw		r1,8[sp]	; also save 'CURRNT'
    895 000F05D0 0F 11                   	lw		r1,#-1
    896 000F05D2 08 40 09 D1             	sw		r1,CURRNT	; flag that we are in INPUT
    897 000F05D6 09 40 01 DE             	sw		sp,STKINP	; save the stack pointer too
    898 000F05DA 00 40 ED DA             	sw		r10,12[sp]	; save the variable address
    899 000F05DE 03 40 0A 11             	lw		r1,#':'		; print a colon first
    900 000F05E2 37 40 08 AF             	call	GETLN		; then get an input line
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 16
tb.asm
    901 000F05E6 0C 40 0C 18             	lea		r8,BUFFER	; point to the buffer
    902 000F05EA FC AF                   	call	OREXPR		; evaluate the input
    903 000F05EC 00 40 ED FA             	lw		r10,12[sp]	; restore the variable address
    904 000F05F0 A1 D1                   	sw		r1,[r10]	; save value in variable
    905 000F05F2 E9 F1                   	lw		r1,8[sp]	; restore old 'CURRNT'
    906 000F05F4 08 40 09 D1             	sw		r1,CURRNT
    907 000F05F8 E5 F8                   	lw		r8,4[sp]	; and the old text pointer
    908 000F05FA                        IP4
    909 000F05FA 50 40 05 AF             	call	TSTC		; is the next thing a comma?
    910 000F05FE 2C 04                   	db	',',IP5-*+1
    911 000F0600 C8 BE                   	br		IP6			; yes, more items
    912 000F0602                        IP5
    913 000F0602 01 40 E1 F5                 lw      r5,16[sp]
    914 000F0606 14 6E                   	add		sp,sp,#20	; clean up the stack
    915 000F0608 15 BE                   	jmp		FINISH
                                        
                                        
    918 000F060A                        DEFLT
    919 000F060A 80 E1                       lb      r1,[r8]
    920 000F060C FF 4F 13 10                 cmp     r1,#CR      ; empty line is OK
    921 000F0610 11 B8                   	beq	    FINISH	    ; else it is 'LET'
                                        
                                        
                                        ; 'LET' is followed by a list of items separated by commas.
                                        ; Each item consists of a variable, an equals sign, and an
                                        ; expression.  The interpreter evaluates the expression and sets
                                        ; the variable to that value.  The interpreter will also handle
                                        ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                                        ;
    930 000F0612                        LET
    931 000F0612 30 40 03 AF                 call	SETVAL		; do the assignment
    932 000F0616 4F 40 07 AF             	call	TSTC		; check for more 'LET' items
    933 000F061A 2C 04                   	db	',',LT1-*+1
    934 000F061C FA BE                   	br	    LET
    935 000F061E                        LT1
    936 000F061E 0A BE                       br	    FINISH		; until we are finished.
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** LOAD *** & SAVE ***
                                        ;
                                        ; These two commands transfer a program to/from an auxiliary
                                        ; device such as a cassette, another computer, etc.  The program
                                        ; is converted to an easily-stored format: each line starts with
                                        ; a colon, the line no. as 4 hex digits, and the rest of the line.
                                        ; At the end, a line starting with an '@' sign is sent.  This
                                        ; format can be read back with a minimum of processing time by
                                        ; the Butterfly.
                                        ;
    951 000F0620                        LOAD
    952 000F0620 01 50 0F 00 09 F8       	lw		r8,TXTBGN	; set pointer to start of prog. area
    953 000F0626 00 40 0D 11             	lw		r1,#CR		; For a CP/M host, tell it we're ready...
    954 000F062A CE 4F 0F AF             	call	GOAUXO		; by sending a CR to finish PIP command.
    955 000F062E                        LOD1
    956 000F062E CE 4F 0F AF             	call	GOAUXI		; look for start of line
    957 000F0632 FD BA                   	bmi		LOD1
    958 000F0634 FC 4F 10 10             	cmp		r1,#'@'		; end of program?
    959 000F0638 1B A8                   	beq		LODEND
    960 000F063A FE 4F 16 10             	cmp     r1,#0x1A    ; or EOF marker
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 17
tb.asm
    961 000F063E 18 A8                   	beq     LODEND
    962 000F0640 FC 4F 16 10             	cmp		r1,#':'		; if not, is it start of line?
    963 000F0644 F4 B9                   	bne		LOD1		; if not, wait for it
    964 000F0646 18 AF                   	call	GCHAR		; get line number
    965 000F0648 80 C1                   	sb		r1,[r8]		; store it
    966 000F064A A1 31                   	shr		r1,#1
    967 000F064C A1 31                   	shr		r1,#1
    968 000F064E A1 31                   	shr		r1,#1
    969 000F0650 A1 31                   	shr		r1,#1
    970 000F0652 A1 31                   	shr		r1,#1
    971 000F0654 A1 31                   	shr		r1,#1
    972 000F0656 A1 31                   	shr		r1,#1
    973 000F0658 A1 31                   	shr		r1,#1
    974 000F065A 81 C1                   	sb		r1,1[r8]
    975 000F065C 02 68                   	add		r8,r8,#2
    976 000F065E                        LOD2
    977 000F065E CD 4F 07 AF             	call	GOAUXI		; get another text char.
    978 000F0662 FD BA                   	bmi		LOD2
    979 000F0664 80 C1                   	sb		r1,[r8]
    980 000F0666 01 68                   	add		r8,r8,#1	; store it
    981 000F0668 FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
    982 000F066C F8 B9                   	bne		LOD2		; if not, go back for more
    983 000F066E DF BE                   	br		LOD1		; if so, start a new line
    984 000F0670                        LODEND
    985 000F0670 0A 40 09 D8             	sw		r8,TXTUNF	; set end-of program pointer
    986 000F0674 D1 4F 05 AE             	br		WSTART		; back to direct mode
                                        
                                        
                                        ; get character from input (16 bit value)
    990 000F0678                        GCHAR
    991 000F0678 F4 6E                   	sub		sp,sp,#12
    992 000F067A E1 DF                   	sw		lr,[sp]
    993 000F067C E5 D5                   	sw		r5,4[sp]
    994 000F067E E9 D6                   	sw		r6,8[sp]
    995 000F0680 04 16                   	lw      r6,#4       ; repeat four times
    996 000F0682 00 15                   	lw		r5,#0
    997 000F0684                        GCHAR1
    998 000F0684 CC 4F 04 AF             	call	GOAUXI		; get a char
    999 000F0688 FD BA                   	bmi		GCHAR1
   1000 000F068A 0D AF                   	call	asciiToHex
   1001 000F068C 81 35                   	shl		r5,#1
   1002 000F068E 81 35                   	shl		r5,#1
   1003 000F0690 81 35                   	shl		r5,#1
   1004 000F0692 81 35                   	shl		r5,#1
   1005 000F0694 16 25                   	or		r5,r1
   1006 000F0696 FF 66                   	sub		r6,r6,#1
   1007 000F0698 F5 B9                   	bne     GCHAR1
   1008 000F069A 50 11                   	lw		r1,r5
   1009 000F069C E1 FF                   	lw		lr,[sp]
   1010 000F069E E5 F5                   	lw		r5,4[sp]
   1011 000F06A0 E9 F6                   	lw		r6,8[sp]
   1012 000F06A2 0C 6E                   	add     sp,sp,#12
   1013 000F06A4 F0 80                   	ret
                                        
                                        
                                        ; convert an ascii char to hex code
                                        ; input
                                        ;	r2 = char to convert
                                        
   1020 000F06A6                        asciiToHex
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 18
tb.asm
   1021 000F06A6 FC 4F 17 10             	cmp		r1,#'9'
   1022 000F06AA 01 A2                   	ble		a2h1		; less than '9'
   1023 000F06AC F9 61                   	sub		r1,r1,#7	; shift 'A' to '9'+1
   1024 000F06AE                        a2h1
   1025 000F06AE D0 61                   	sub		r1,r1,#'0'	;
   1026 000F06B0 00 40 5F 31             	and		r1,#15		; make sure a nybble
   1027 000F06B4 F0 80                   	ret
                                        
                                        
                                        
   1031 000F06B6                        SAVE
   1032 000F06B6 01 50 0F 00 09 F8       	lw		r8,TXTBGN	;set pointer to start of prog. area
   1033 000F06BC 0A 40 09 F9             	lw		r9,TXTUNF	;set pointer to end of prog. area
   1034 000F06C0                        SAVE1
   1035 000F06C0 28 AF                   	call    AUXOCRLF    ; send out a CR & LF (CP/M likes this)
   1036 000F06C2 9D 28                   	cmp		r8,r9		; are we finished?
   1037 000F06C4 1B A5                   	bgeu	SAVEND
   1038 000F06C6 03 40 0A 11             	lw		r1,#':'		; if not, start a line
   1039 000F06CA C9 4F 0F AF             	call	GOAUXO
   1040 000F06CE 80 E1                   	lb		r1,[r8]		; get line number
   1041 000F06D0 0E 21                   	zxb		r1
   1042 000F06D2 81 E2                   	lb		r2,1[r8]
   1043 000F06D4 0E 22                   	zxb		r2
   1044 000F06D6 81 32                   	shl		r2,#1
   1045 000F06D8 81 32                   	shl		r2,#1
   1046 000F06DA 81 32                   	shl		r2,#1
   1047 000F06DC 81 32                   	shl		r2,#1
   1048 000F06DE 81 32                   	shl		r2,#1
   1049 000F06E0 81 32                   	shl		r2,#1
   1050 000F06E2 81 32                   	shl		r2,#1
   1051 000F06E4 81 32                   	shl		r2,#1
   1052 000F06E6 26 21                   	or		r1,r2
   1053 000F06E8 02 68                   	add		r8,r8,#2
   1054 000F06EA 1E AF                   	call	PWORD       ; output line number as 4-digit hex
   1055 000F06EC                        SAVE2
   1056 000F06EC 80 E1                   	lb		r1,[r8]		; get a text char.
   1057 000F06EE 01 68                   	add		r8,r8,#1
   1058 000F06F0 FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
   1059 000F06F4 E5 B8                   	beq		SAVE1		; if so, send CR & LF and start new line
   1060 000F06F6 C8 4F 09 AF             	call	GOAUXO		; send it out
   1061 000F06FA F8 BE                   	br		SAVE2		; go back for more text
   1062 000F06FC                        SAVEND
   1063 000F06FC 04 40 00 11             	lw		r1,#'@'		; send end-of-program indicator
   1064 000F0700 C8 4F 04 AF             	call	GOAUXO
   1065 000F0704 06 AF                   	call    AUXOCRLF    ; followed by a CR & LF
   1066 000F0706 01 40 0A 11             	lw		r1,#0x1A	; and a control-Z to end the CP/M file
   1067 000F070A C7 4F 0F AF             	call	GOAUXO
   1068 000F070E CC 4F 08 AE             	br		WSTART		; then go do a warm start
                                        
                                        
                                        ; output a CR LF sequence to auxillary output
                                        ; Registers Affected
                                        ;   r3 = LF
   1074 000F0712                        AUXOCRLF
   1075 000F0712 FC 6E                       sub     sp,sp,#4
   1076 000F0714 E1 DF                       sw      lr,[sp]
   1077 000F0716 00 40 0D 11                 lw      r1,#CR
   1078 000F071A C7 4F 07 AF                 call    GOAUXO
   1079 000F071E 0A 11                       lw      r1,#LF
   1080 000F0720 C7 4F 04 AF                 call    GOAUXO
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 19
tb.asm
   1081 000F0724 E1 FF                       lw      lr,[sp]
   1082 000F0726 F0 80                       ret
                                        
                                        
                                        ; output a word in hex format
                                        ; tricky because of the need to reverse the order of the chars
   1087 000F0728                        PWORD
   1088 000F0728 F8 6E                   	sub		sp,sp,#8
   1089 000F072A E1 DF                   	sw		lr,[sp]
   1090 000F072C E5 D5                   	sw		r5,4[sp]
   1091 000F072E 0C 40 03 15             	lea     r5,NUMWKA+3
   1092 000F0732 10 14                   	lw		r4,r1		; r4 = value
   1093 000F0734                        pword1
   1094 000F0734 40 11                       lw      r1,r4       ; r1 = value
   1095 000F0736 A1 34                       shr     r4,#1       ; shift over to next nybble
   1096 000F0738 A1 34                       shr     r4,#1
   1097 000F073A A1 34                       shr     r4,#1
   1098 000F073C A1 34                       shr     r4,#1
   1099 000F073E 10 AF                       call    toAsciiHex  ; convert LS nybble to ascii hex
   1100 000F0740 50 C1                       sb      r1,[r5]     ; save in work area
   1101 000F0742 FF 65                       sub     r5,r5,#1
   1102 000F0744 F4 4F 50 10                 cmp     r5,#NUMWKA
   1103 000F0748 F5 B5                       bgeu    pword1
   1104 000F074A                        pword2
   1105 000F074A 01 65                       add     r5,r5,#1
   1106 000F074C 50 E1                       lb      r1,[r5]     ; get char to output
   1107 000F074E C5 4F 0D AF             	call	GOAUXO		; send it
   1108 000F0752 F3 4F 5D 10             	cmp     r5,#NUMWKA+3
   1109 000F0756 F9 B4                   	bltu    pword2
                                        
   1111 000F0758 E5 F5                   	lw		r5,4[sp]
   1112 000F075A E1 FF                   	lw		lr,[sp]
   1113 000F075C 08 6E                   	add		sp,sp,#8
   1114 000F075E F0 80                   	ret
                                        
                                        
                                        ; convert nybble in r2 to ascii hex char2
                                        ; r2 = character to convert
                                        
   1120 000F0760                        toAsciiHex
   1121 000F0760 00 40 5F 31             	and		r1,#15		; make sure it's a nybble
   1122 000F0764 FF 4F 16 10             	cmp		r1,#10		; > 10 ?
   1123 000F0768 01 A0                   	blt		tah1
   1124 000F076A 07 61                   	add		r1,r1,#7	; bump it up to the letter 'A'
   1125 000F076C                        tah1
   1126 000F076C 30 61                   	add		r1,r1,#'0'	; bump up to ascii '0'
   1127 000F076E F0 80                   	ret
                                        
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** POKE *** & SYSX ***
                                        ;
                                        ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                                        ; address specified by 'expr1'.
                                        ;
                                        ; 'SYSX expr' jumps to the machine language subroutine whose
                                        ; starting address is specified by 'expr'.  The subroutine can use
                                        ; all registers but must leave the stack the way it found it.
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 20
tb.asm
                                        ; The subroutine returns to the interpreter by executing an RET.
                                        ;
   1143 000F0770                        POKE
   1144 000F0770 FC 6E                   	sub		sp,sp,#4
   1145 000F0772 38 AF                   	call	OREXPR		; get the memory address
   1146 000F0774 44 40 08 AF             	call	TSTC		; it must be followed by a comma
   1147 000F0778 2C 10                   	db	',',PKER-*+1
   1148 000F077A E1 D1                   	sw		r1,[sp]	    ; save the address
   1149 000F077C 33 AF                   	call	OREXPR		; get the byte to be POKE'd
   1150 000F077E E1 F2                   	lw		r2,[sp]	    ; get the address back
   1151 000F0780 20 C1                   	sb		r1,[r2]		; store the byte in memory
   1152 000F0782 04 6E                   	add		sp,sp,#4
   1153 000F0784 E5 4F 06 AE             	br		FINISH
   1154 000F0788                        PKER
   1155 000F0788 57 51 0F 00 0B 11       	lea		r1,msgComma
   1156 000F078E 28 40 08 AE             	br		ERROR		; if no comma, say "What?"
                                        
                                        
   1159 000F0792                        POKEC
   1160 000F0792 FC 6E                   	sub		sp,sp,#4
   1161 000F0794 27 AF                   	call	OREXPR		; get the memory address
   1162 000F0796 43 40 07 AF             	call	TSTC		; it must be followed by a comma
   1163 000F079A 2C EE                   	db	',',PKER-*+1
   1164 000F079C E1 D1                   	sw		r1,[sp]	    ; save the address
   1165 000F079E 22 AF                   	call	OREXPR		; get the byte to be POKE'd
   1166 000F07A0 E1 F2                   	lw		r2,[sp]	    ; get the address back
   1167 000F07A2 20 D1                   	sh		r1,[r2]		; store the byte in memory
   1168 000F07A4 04 6E                   	add		sp,sp,#4
   1169 000F07A6 E4 4F 05 AE             	jmp		FINISH
                                        
   1171 000F07AA                        POKEW
   1172 000F07AA FC 6E                   	sub		sp,sp,#4
   1173 000F07AC 1B AF                   	call	OREXPR		; get the memory address
   1174 000F07AE 42 40 0B AF             	call	TSTC		; it must be followed by a comma
   1175 000F07B2 2C D6                   	db	',',PKER-*+1
   1176 000F07B4 E1 D1                   	sw		r1,[sp]	    ; save the address
   1177 000F07B6 16 AF                   	call	OREXPR		; get the byte to be POKE'd
   1178 000F07B8 E1 F2                   	lw		r2,[sp]	    ; get the address back
   1179 000F07BA 21 D1                   	sw		r1,[r2]		; store the word in memory
   1180 000F07BC 04 6E                   	add		sp,sp,#4
   1181 000F07BE E3 4F 09 AE             	jmp		FINISH
                                        
                                        
   1184 000F07C2                        SYSX
   1185 000F07C2 FC 6E                   	sub		sp,sp,#4
   1186 000F07C4 0F AF                   	call	OREXPR		; get the subroutine's address
   1187 000F07C6 16 20                   	or		r0,r1		; make sure we got a valid address
   1188 000F07C8 05 A9                   	bne		sysx1
   1189 000F07CA 5D 51 0F 00 00 11       	lea		r1,msgSYSBad
   1190 000F07D0 26 40 07 AE             	br		ERROR
   1191 000F07D4                        sysx1
   1192 000F07D4 E1 D8                   	sw		r8,[sp]	    ; save the text pointer
   1193 000F07D6 C1 57 F8 FF 02 AF       	call	[r1]		; jump to the subroutine
   1194 000F07DC E1 F8                   	lw		r8,[sp]	    ; restore the text pointer
   1195 000F07DE 04 6E                   	add		sp,sp,#4
   1196 000F07E0 E2 4F 08 AE             	br		FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 21
tb.asm
                                        ; *** EXPR ***
                                        ;
                                        ; 'EXPR' evaluates arithmetical or logical expressions.
                                        ; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ; <EXPR>::=<EXPR2>
                                        ;	   <EXPR2><rel.op.><EXPR2>
                                        ; where <rel.op.> is one of the operators in TAB8 and the result
                                        ; of these operations is 1 if true and 0 if false.
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        ; where () are optional and (... are optional repeats.
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                                        ; as an index, functions can have an <EXPR> as arguments, and
                                        ; <EXPR4> can be an <EXPR> in parenthesis.
                                        ;
                                        
                                        
                                        ; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                                        ;
   1224 000F07E4                        OREXPR
   1225 000F07E4 F8 6E                   	sub		sp,sp,#8
   1226 000F07E6 E1 DF                   	sw		lr,[sp]
   1227 000F07E8 11 AF                   	call	ANDEXPR		; get first <ANDEXPR>
   1228 000F07EA                        XP_OR1
   1229 000F07EA E5 D1                   	sw		r1,4[sp]	; save <ANDEXPR> value
   1230 000F07EC 1F 50 0F 00 0F 19       	lea		r9,TAB10		; look up a logical operator
   1231 000F07F2 2B 50 0F 00 0C 1A       	lea		r10,TAB10_1
   1232 000F07F8 D6 4F 0A AE             	jmp		EXEC		; go do it
                                        
   1234 000F07FC                        XP_OR
   1235 000F07FC 07 AF                       call    ANDEXPR
   1236 000F07FE E5 F2                       lw      r2,4[sp]
   1237 000F0800 26 21                       or      r1,r2
   1238 000F0802 F3 BE                       br      XP_OR1
                                        
   1240 000F0804                        XP_ORX
   1241 000F0804 E5 F1                   	lw		r1,4[sp]
   1242 000F0806 E1 FF                       lw      lr,[sp]
   1243 000F0808 08 6E                       add     sp,sp,#8
   1244 000F080A F0 80                       ret
                                        
                                        
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ;
   1249 000F080C                        ANDEXPR
   1250 000F080C F8 6E                   	sub		sp,sp,#8
   1251 000F080E E1 DF                   	sw		lr,[sp]
   1252 000F0810 39 AF                   	call	EXPR		; get first <EXPR>
   1253 000F0812                        XP_AND1
   1254 000F0812 E5 D1                   	sw		r1,4[sp]	; save <EXPR> value
   1255 000F0814 1F 50 0F 00 0B 19       	lea		r9,TAB9		; look up a logical operator
   1256 000F081A 2B 50 0F 00 04 1A       	lea		r10,TAB9_1
   1257 000F0820 D5 4F 06 AE             	jmp		EXEC		; go do it
                                        
   1259 000F0824                        XP_AND
   1260 000F0824 2F AF                       call    EXPR
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 22
tb.asm
   1261 000F0826 E5 F2                       lw      r2,4[sp]
   1262 000F0828 25 21                       and     r1,r2
   1263 000F082A F3 BE                       br      XP_AND1
                                        
   1265 000F082C                        XP_ANDX
   1266 000F082C E5 F1                   	lw		r1,4[sp]
   1267 000F082E E1 FF                       lw      lr,[sp]
   1268 000F0830 08 6E                       add     sp,sp,#8
   1269 000F0832 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a digit
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if digit, otherwise 0
                                        ;
   1278 000F0834                        isDigit
   1279 000F0834 FD 4F 10 10                 cmp     r1,#'0'
   1280 000F0838 05 A0                       blt     isDigitFalse
   1281 000F083A FC 4F 17 10                 cmp     r1,#'9'
   1282 000F083E 02 A3                       bgt     isDigitFalse
   1283 000F0840 01 11                       lw      r1,#1
   1284 000F0842 F0 80                       ret
   1285 000F0844                        isDigitFalse
   1286 000F0844 00 11                       lw      r1,#0
   1287 000F0846 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphabetic
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1296 000F0848                        isAlpha
   1297 000F0848 FB 4F 1F 10                 cmp     r1,#'A'
   1298 000F084C 0B A0                       blt     isAlphaFalse
   1299 000F084E FA 4F 16 10                 cmp     r1,#'Z'
   1300 000F0852 06 A2                       ble     isAlphaTrue
   1301 000F0854 F9 4F 1F 10                 cmp     r1,#'a'
   1302 000F0858 05 A0                       blt     isAlphaFalse
   1303 000F085A F8 4F 16 10                 cmp     r1,#'z'
   1304 000F085E 02 A3                       bgt     isAlphaFalse
   1305 000F0860                        isAlphaTrue
   1306 000F0860 01 11                       lw      r1,#1
   1307 000F0862 F0 80                       ret
   1308 000F0864                        isAlphaFalse
   1309 000F0864 00 11                       lw      r1,#0
   1310 000F0866 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphanumeric
                                        ;   Parameters
                                        ;       r1 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1319 000F0868                        isAlnum
   1320 000F0868 FC 6E                       sub     sp,sp,#4
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 23
tb.asm
   1321 000F086A E1 DF                       sw      lr,[sp]
   1322 000F086C 10 12                       lw      r2,r1		; save test char
   1323 000F086E E2 BF                       call    isDigit
   1324 000F0870 06 A9                       bne		isDigitx	; if it is a digit
   1325 000F0872 20 11                       lw      r1,r2		; get back test char
   1326 000F0874 E9 BF                       call    isAlpha
   1327 000F0876 E1 FF                       lw      lr,[sp]
   1328 000F0878 04 6E                       add		sp,sp,#4
   1329 000F087A 16 21                       or      r1,r1
   1330 000F087C F0 80                       ret
   1331 000F087E                        isDigitx
   1332 000F087E E1 FF                       lw      lr,[sp]
   1333 000F0880 04 6E                       add     sp,sp,#4	; return Z=0
   1334 000F0882 F0 80                       ret
                                        
                                        
   1337 000F0884                        EXPR
   1338 000F0884 F8 6E                   	sub		sp,sp,#8
   1339 000F0886 E1 DF                   	sw		lr,[sp]
   1340 000F0888 3B AF                   	call	EXPR2
   1341 000F088A E5 D1                   	sw		r1,4[sp]	; save <EXPR2> value
   1342 000F088C 1F 50 0F 00 01 19       	lea		r9,TAB8		; look up a relational operator
   1343 000F0892 29 50 0F 00 08 1A       	lea		r10,TAB8_1
   1344 000F0898 D1 4F 0A AE             	jmp		EXEC		; go do it
                                        
   1346 000F089C                        XP11
   1347 000F089C E5 F1                   	lw		r1,4[sp]
   1348 000F089E 28 AF                   	call	XP18	; is it ">="?
   1349 000F08A0 1D 22                   	cmp		r2,r1
   1350 000F08A2 1E A1                   	bge		XPRT1	; no, return r2=1
   1351 000F08A4 19 AE                   	br		XPRT0	; else return r2=0
                                        
   1353 000F08A6                        XP12
   1354 000F08A6 E5 F1                   	lw		r1,4[sp]
   1355 000F08A8 23 AF                   	call	XP18	; is it "<>"?
   1356 000F08AA 1D 22                   	cmp		r2,r1
   1357 000F08AC 19 A9                   	bne		XPRT1	; no, return r2=1
   1358 000F08AE 14 AE                   	br		XPRT0	; else return r2=0
                                        
   1360 000F08B0                        XP13
   1361 000F08B0 E5 F1                   	lw		r1,4[sp]
   1362 000F08B2 1E AF                   	call	XP18	; is it ">"?
   1363 000F08B4 1D 22                   	cmp		r2,r1
   1364 000F08B6 14 A3                   	bgt		XPRT1	; no, return r2=1
   1365 000F08B8 0F AE                   	br		XPRT0	; else return r2=0
                                        
   1367 000F08BA                        XP14
   1368 000F08BA E5 F1                   	lw		r1,4[sp]
   1369 000F08BC 19 AF                   	call	XP18	; is it "<="?
   1370 000F08BE 1D 22                   	cmp		r2,r1
   1371 000F08C0 0F A2                   	ble		XPRT1	; no, return r2=1
   1372 000F08C2 0A AE                   	br		XPRT0	; else return r2=0
                                        
   1374 000F08C4                        XP15
   1375 000F08C4 E5 F1                   	lw		r1,4[sp]
   1376 000F08C6 14 AF                   	call	XP18	; is it "="?
   1377 000F08C8 1D 22                   	cmp		r2,r1
   1378 000F08CA 0A A8                   	beq		XPRT1	; if not, return r2=1
   1379 000F08CC 05 AE                   	br		XPRT0	; else return r2=0
                                        
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 24
tb.asm
                                        
   1382 000F08CE                        XP16
   1383 000F08CE E5 F1                   	lw		r1,4[sp]
   1384 000F08D0 0F AF                   	call	XP18	; is it "<"?
   1385 000F08D2 1D 22                   	cmp		r2,r1
   1386 000F08D4 05 A0                   	blt		XPRT1	; if not, return r2=1
   1387 000F08D6 00 AE                   	br		XPRT0	; else return r2=0
                                        
   1389 000F08D8                        XPRT0
   1390 000F08D8 E1 FF                   	lw		lr,[sp]
   1391 000F08DA 08 6E                   	add		sp,sp,#8
   1392 000F08DC 00 11                   	lw		r1,#0   ; return r1=0 (false)
   1393 000F08DE F0 80                   	ret
                                        
   1395 000F08E0                        XPRT1
   1396 000F08E0 E1 FF                   	lw		lr,[sp]
   1397 000F08E2 08 6E                   	add		sp,sp,#8
   1398 000F08E4 01 11                   	lw		r1,#1	; return r1=1 (true)
   1399 000F08E6 F0 80                   	ret
                                        
   1401 000F08E8                        XP17				; it's not a rel. operator
   1402 000F08E8 E5 F1                   	lw		r1,4[sp]	; return r2=<EXPR2>
   1403 000F08EA E1 FF                   	lw		lr,[sp]
   1404 000F08EC 08 6E                   	add		sp,sp,#8
   1405 000F08EE F0 80                   	ret
                                        
   1407 000F08F0                        XP18
   1408 000F08F0 F8 6E                   	sub		sp,sp,#8
   1409 000F08F2 E1 DF                   	sw		lr,[sp]
   1410 000F08F4 E5 D1                   	sw		r1,4[sp]
   1411 000F08F6 04 AF                   	call	EXPR2		; do a second <EXPR2>
   1412 000F08F8 E5 F2                   	lw		r2,4[sp]
   1413 000F08FA E1 FF                   	lw		lr,[sp]
   1414 000F08FC 08 6E                   	add		sp,sp,#8
   1415 000F08FE F0 80                   	ret
                                        
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        
   1419 000F0900                        EXPR2
   1420 000F0900 F8 6E                   	sub		sp,sp,#8
   1421 000F0902 E1 DF                   	sw		lr,[sp]
   1422 000F0904 38 40 00 AF             	call	TSTC		; negative sign?
   1423 000F0908 2D 08                   	db	'-',XP21-*+1
   1424 000F090A 00 11                   	lw		r1,#0		; yes, fake '0-'
   1425 000F090C E5 D1                   	sw		r1,4[sp]
   1426 000F090E 0F AE                   	br		XP26
   1427 000F0910                        XP21
   1428 000F0910 37 40 0A AF             	call	TSTC		; positive sign? ignore it
   1429 000F0914 2B 02                   	db	'+',XP22-*+1
   1430 000F0916                        XP22
   1431 000F0916 12 AF                   	call	EXPR3		; first <EXPR3>
   1432 000F0918                        XP23
   1433 000F0918 E5 D1                   	sw		r1,4[sp]	; yes, save the value
   1434 000F091A 37 40 05 AF             	call	TSTC		; add?
   1435 000F091E 2B 0A                   	db	'+',XP25-*+1
   1436 000F0920 0D AF                   	call	EXPR3		; get the second <EXPR3>
   1437 000F0922                        XP24
   1438 000F0922 E5 F2                   	lw		r2,4[sp]
   1439 000F0924 20 21                   	add		r1,r2		; add it to the first <EXPR3>
                                        ;	BVS.L	QHOW		brnch if there's an overflow
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 25
tb.asm
   1441 000F0926 F8 BE                   	br		XP23		; else go back for more operations
   1442 000F0928                        XP25
   1443 000F0928 36 40 0E AF             	call	TSTC		; subtract?
   1444 000F092C 2D 08                   	db	'-',XP45-*+1
   1445 000F092E                        XP26
   1446 000F092E 06 AF                   	call	EXPR3		; get second <EXPR3>
   1447 000F0930 20 31                   	neg		r1			; change its sign
   1448 000F0932 F7 BE                   	br		XP24		; and do an addition
                                        
   1450 000F0934                        XP45
   1451 000F0934 E5 F1                   	lw		r1,4[sp]
   1452 000F0936 E1 FF                   	lw		lr,[sp]
   1453 000F0938 08 6E                   	add		sp,sp,#8
   1454 000F093A F0 80                   	ret
                                        
                                        
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        
   1459 000F093C                        EXPR3
   1460 000F093C F8 6E                   	sub		sp,sp,#8
   1461 000F093E E1 DF                   	sw		lr,[sp]
   1462 000F0940 14 AF                   	call	EXPR4		; get first <EXPR4>
   1463 000F0942                        XP31
   1464 000F0942 E5 D1                   	sw		r1,4[sp]	; yes, save that first result
   1465 000F0944 36 40 00 AF             	call	TSTC		; multiply?
   1466 000F0948 2A 0A                   	db	'*',XP34-*+1
   1467 000F094A 0F AF                   	call	EXPR4		; get second <EXPR4>
   1468 000F094C E5 F2                   	lw		r2,4[sp]
   1469 000F094E BC AF                   	call	MULT32		; multiply the two
   1470 000F0950 F8 BE                   	br		XP31		 ; then look for more terms
   1471 000F0952                        XP34
   1472 000F0952 35 40 09 AF             	call	TSTC		; divide?
   1473 000F0956 2F 0C                   	db	'/',XP47-*+1
   1474 000F0958 08 AF                   	call	EXPR4		; get second <EXPR4>
   1475 000F095A 10 12                   	lw      r2,r1
   1476 000F095C E5 F1                   	lw		r1,4[sp]
   1477 000F095E D1 AF                   	call	DIV32		; do the division
   1478 000F0960 F0 BE                   	br		XP31		; go back for any more terms
                                        
   1480 000F0962                        XP47
   1481 000F0962 E5 F1                   	lw		r1,4[sp]
   1482 000F0964 E1 FF                   	lw		lr,[sp]
   1483 000F0966 08 6E                   	add		sp,sp,#8
   1484 000F0968 F0 80                   	ret
                                        
                                        
                                        ; Functions are called through EXPR4
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        
   1492 000F096A                        EXPR4
   1493 000F096A F4 6E                       sub     sp,sp,#12
   1494 000F096C E1 DF                       sw      lr,[sp]
   1495 000F096E 1C 50 0F 00 0D 19       	lea		r9,TAB4		; find possible function
   1496 000F0974 26 50 0F 00 08 1A       	lea		r10,TAB4_1
   1497 000F097A CA 4F 09 AE             	jmp		EXEC        ; branch to function which does subsequent
                                        	                    ; ret for EXPR4
                                        
   1500 000F097E                        XP40                    ; we get here if it wasn't a function
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 26
tb.asm
   1501 000F097E 00 11                   	lw		r1,#0
   1502 000F0980 1E AF                   	call	TSTV		
   1503 000F0982 04 A8                   	beq     XP41        ; nor a variable
   1504 000F0984 11 F1                   	lw		r1,[r1]		; if a variable, return its value in r1
   1505 000F0986 E1 FF                   	lw      lr,[sp]
   1506 000F0988 0C 6E                   	add     sp,sp,#12
   1507 000F098A F0 80                   	ret
   1508 000F098C                        XP41
   1509 000F098C 34 40 0E AF             	call	TSTNUM		; or is it a number?
   1510 000F0990 26 22                   	or		r2,r2		; (if not, # of digits will be zero)
   1511 000F0992 01 A9                   	bne		XP46		; if so, return it in r1
   1512 000F0994 03 AF                   	call    PARN        ; check for (EXPR)
   1513 000F0996                        XP46
   1514 000F0996 E1 FF                   	lw      lr,[sp]
   1515 000F0998 0C 6E                   	add     sp,sp,#12
   1516 000F099A F0 80                   	ret
                                        
                                        
                                        ; Check for a parenthesized expression
   1520 000F099C                        PARN
   1521 000F099C FC 6E                   	sub		sp,sp,#4
   1522 000F099E E1 DF                   	sw		lr,[sp]
   1523 000F09A0 33 40 02 AF             	call	TSTC		; else look for ( OREXPR )
   1524 000F09A4 28 10                   	db	'(',XP43-*+1
   1525 000F09A6 1E BF                   	call	OREXPR
   1526 000F09A8 32 40 0E AF             	call	TSTC
   1527 000F09AC 29 08                   	db	')',XP43-*+1
   1528 000F09AE                        XP42
   1529 000F09AE E1 FF                   	lw		lr,[sp]
   1530 000F09B0 04 6E                   	add		sp,sp,#4
   1531 000F09B2 F0 80                   	ret
   1532 000F09B4                        XP43
   1533 000F09B4 4F 51 0F 00 08 11       	lea		r1,msgWhat
   1534 000F09BA 17 40 02 AE             	br		ERROR
                                        
                                        
                                        ; ===== Test for a valid variable name.  Returns Z=1 if not
                                        ;	found, else returns Z=0 and the address of the
                                        ;	variable in r1.
                                        ; Parameters
                                        ;	r1 = 1 = allocate if not found
                                        ; Returns
                                        ;	r1 = address of variable, zero if not found
                                        
   1545 000F09BE                        TSTV
   1546 000F09BE F4 6E                   	sub		sp,sp,#12
   1547 000F09C0 E1 DF                   	sw		lr,[sp]
   1548 000F09C2 E5 D5                   	sw		r5,4[sp]
   1549 000F09C4 10 15                   	lw		r5,r1		; allocate flag
   1550 000F09C6 35 40 04 AF             	call	IGNBLK
   1551 000F09CA 80 E1                   	lb		r1,[r8]		; look at the program text
   1552 000F09CC FC 4F 10 10             	cmp     r1,#'@'
   1553 000F09D0 1C A0                   	blt     tstv_notfound   ; C=1: not a variable
   1554 000F09D2 12 A9                   	bne		TV1			; brnch if not "@" array
   1555 000F09D4 01 68                   	add		r8,r8,#1	; If it is, it should be
   1556 000F09D6 E2 BF                   	call	PARN		; followed by (EXPR) as its index.
   1557 000F09D8 81 31                   	shl     r1,#1
   1558 000F09DA 81 31                   	shl     r1,#1
                                        ;	BCS.L	QHOW		say "How?" if index is too big
   1560 000F09DC E9 D1                       sw      r1,8[sp]    ; save the index
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 27
tb.asm
   1561 000F09DE F4 6E                       sub		sp,sp,#12
   1562 000F09E0 E1 DF                       sw		lr,[sp]
   1563 000F09E2 11 40 03 AF             	call	SIZEX		; get amount of free memory
   1564 000F09E6 E9 F2                   	lw      r2,8[sp]    ; get back the index
   1565 000F09E8 1D 22                   	cmp     r2,r1       ; see if there's enough memory
   1566 000F09EA 02 A4                   	bltu	TV2
   1567 000F09EC 15 40 02 AE             	jmp    	QSORRY		; if not, say "Sorry"
   1568 000F09F0                        TV2
   1569 000F09F0 0A 40 0D F1             	lw      r1,VARBGN   ; put address of array element...
   1570 000F09F4 22 21                   	sub     r1,r2       ; into r1 (neg. offset is used)
   1571 000F09F6 05 AE                   	br      TSTVRT
   1572 000F09F8                        TV1	
   1573 000F09F8 0D AF                       call    getVarName      ; get variable name
   1574 000F09FA 07 A8                       beq     tstv_notfound   ; if not, set Z=1 and return
   1575 000F09FC 50 12                       lw		r2,r5
   1576 000F09FE 45 AF                       call    findVar     ; find or allocate
   1577 000F0A00 04 A8                       beq		tstv_notfound
   1578 000F0A02                        TSTVRT
   1579 000F0A02 E5 F5                   	lw		r5,4[sp]
   1580 000F0A04 E1 FF                   	lw		lr,[sp]
   1581 000F0A06 0C 6E                   	add		sp,sp,#12    ; Z=0 (found)
   1582 000F0A08 F0 80                   	ret
   1583 000F0A0A                        tstv_notfound
   1584 000F0A0A E5 F5                   	lw		r5,4[sp]
   1585 000F0A0C E1 FF                       lw      lr,[sp]
   1586 000F0A0E 0C 6E                       add     sp,sp,#12
   1587 000F0A10 00 11                       lw      r1,#0       ; Z=1 if not found
   1588 000F0A12 F0 80                       ret
                                        
                                        
                                        ; Returns
                                        ;   r1 = 3 character variable name + type
                                        ;
   1594 000F0A14                        getVarName
   1595 000F0A14 F4 6E                       sub     sp,sp,#12
   1596 000F0A16 E1 DF                       sw      lr,[sp]
   1597 000F0A18 E9 D5                       sw		r5,8[sp]
                                        
   1599 000F0A1A 80 E1                       lb      r1,[r8]     ; get first character
   1600 000F0A1C E5 D1                       sw		r1,4[sp]	; save off current name
   1601 000F0A1E 14 BF                       call    isAlpha
   1602 000F0A20 2F A8                       beq     gvn1
   1603 000F0A22 02 15                       lw      r5,#2       ; loop twice more
                                        
                                        	; check for second/third character
   1606 000F0A24                        gvn4
   1607 000F0A24 01 68                   	add     r8,r8,#1
   1608 000F0A26 80 E1                   	lb      r1,[r8]     ; do we have another char ?
   1609 000F0A28 1F BF                   	call    isAlnum
   1610 000F0A2A 12 A8                   	beq     gvn2        ; nope
   1611 000F0A2C E5 F1                   	lw      r1,4[sp]    ; get varname
   1612 000F0A2E 81 31                   	shl     r1,#1       ; shift left by eight
   1613 000F0A30 81 31                   	shl     r1,#1       ; shift left by eight
   1614 000F0A32 81 31                   	shl     r1,#1       ; shift left by eight
   1615 000F0A34 81 31                   	shl     r1,#1       ; shift left by eight
   1616 000F0A36 81 31                   	shl     r1,#1       ; shift left by eight
   1617 000F0A38 81 31                   	shl     r1,#1       ; shift left by eight
   1618 000F0A3A 81 31                   	shl     r1,#1       ; shift left by eight
   1619 000F0A3C 81 31                   	shl     r1,#1       ; shift left by eight
   1620 000F0A3E 80 E2                   	lb      r2,[r8]
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 28
tb.asm
   1621 000F0A40 26 21                   	or      r1,r2       ; add in new char
   1622 000F0A42 E5 D1                       sw      r1,4[sp]   ; save off name again
   1623 000F0A44 FF 65                       sub		r5,r5,#1
   1624 000F0A46 EE B9                       bne     gvn4
                                        
                                            ; now ignore extra variable name characters
   1627 000F0A48                        gvn6
   1628 000F0A48 01 68                       add     r8,r8,#1
   1629 000F0A4A 80 E1                       lb      r1,[r8]
   1630 000F0A4C 0D BF                       call    isAlnum
   1631 000F0A4E FC B9                       bne     gvn6        ; keep looping as long as we have identifier chars
                                            
   1633 000F0A50                        gvn2
   1634 000F0A50 80 E1                   	lb		r1,[r8]
   1635 000F0A52 FD 4F 1B 10                 cmp     r1,#'%'
   1636 000F0A56 05 A8                       beq     gvn3
   1637 000F0A58 FD 4F 1C 10                 cmp     r1,#'$'
   1638 000F0A5C 02 A8                       beq     gvn3
   1639 000F0A5E 00 11                       lw      r1,#0
   1640 000F0A60 FF 68                       sub     r8,r8,#1
                                        
                                            ; insert variable type indicator and return
   1643 000F0A62                        gvn3
   1644 000F0A62 01 68                       add     r8,r8,#1
   1645 000F0A64 E5 F2                       lw      r2,4[sp]
   1646 000F0A66 81 32                       shl     r2,#1
   1647 000F0A68 81 32                       shl     r2,#1
   1648 000F0A6A 81 32                       shl     r2,#1
   1649 000F0A6C 81 32                       shl     r2,#1
   1650 000F0A6E 81 32                       shl     r2,#1
   1651 000F0A70 81 32                       shl     r2,#1
   1652 000F0A72 81 32                       shl     r2,#1
   1653 000F0A74 81 32                       shl     r2,#1
   1654 000F0A76 26 21                       or      r1,r2       ; add in variable type
   1655 000F0A78 E1 FF                       lw      lr,[sp]
   1656 000F0A7A E9 F5                       lw		r5,8[sp]
   1657 000F0A7C 0C 6E                       add     sp,sp,#12   ; return Z = 0, r1 = varname
   1658 000F0A7E F0 80                       ret
                                        
                                            ; not a variable name
   1661 000F0A80                        gvn1
   1662 000F0A80 E1 FF                       lw      lr,[sp]
   1663 000F0A82 E9 F5                       lw		r5,8[sp]
   1664 000F0A84 0C 6E                       add     sp,sp,#12
   1665 000F0A86 00 11                       lw      r1,#0       ; return Z = 1 if not a varname
   1666 000F0A88 F0 80                       ret
                                        
                                        
                                        ; Find variable
                                        ;   r1 = varname
                                        ;	r2 = allocate flag
                                        ; Returns
                                        ;   r1 = variable address, Z =0 if found / allocated, Z=1 if not found
                                        
   1675 000F0A8A                        findVar
   1676 000F0A8A F8 6E                       sub     sp,sp,#8
   1677 000F0A8C E1 DF                       sw      lr,[sp]
   1678 000F0A8E E5 D7                       sw      r7,4[sp]
   1679 000F0A90 0A 40 0D F3                 lw      r3,VARBGN
   1680 000F0A94                        fv4
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 29
tb.asm
   1681 000F0A94 31 F7                       lw      r7,[r3]     ; get varname / type
   1682 000F0A96 0B A8                       beq     fv3         ; no more vars ?
   1683 000F0A98 7D 21                       cmp     r1,r7       ; match ?
   1684 000F0A9A 0C A8                       beq     fv1
   1685 000F0A9C 08 63                       add     r3,r3,#8    ; move to next var
   1686 000F0A9E 0B 40 0D F7                 lw      r7,STKBOT
   1687 000F0AA2 7D 23                       cmp     r3,r7
   1688 000F0AA4 F7 B0                       blt     fv4         ; loop back to look at next var
                                        
                                            ; variable not found
                                            ; no more memory
   1692 000F0AA6 54 51 0F 00 0B 11           lea     r1,msgVarSpace
   1693 000F0AAC FA AE                       br      ERROR
                                        ;    lw      lr,[sp]
                                        ;    lw      r7,4[sp]
                                        ;    add     sp,sp,#8
                                        ;    lw      r1,#0
                                        ;    ret
                                        
                                            ; variable not found
                                            ; allocate new ?
   1702 000F0AAE                        fv3
   1703 000F0AAE 26 22                   	or		r2,r2
   1704 000F0AB0 06 A8                   	beq		fv2
   1705 000F0AB2 31 D1                       sw      r1,[r3]     ; save varname / type
                                            ; found variable
                                            ; return address
   1708 000F0AB4                        fv1
   1709 000F0AB4 34 11                       add     r1,r3,#4
   1710 000F0AB6 E1 FF                       lw      lr,[sp]
   1711 000F0AB8 E5 F7                       lw      r7,4[sp]
   1712 000F0ABA 08 6E                       add     sp,sp,#8    ; Z = 0, r1 = address
   1713 000F0ABC F0 80                       ret
                                        
                                            ; didn't find var and not allocating
   1716 000F0ABE                        fv2
   1717 000F0ABE E1 FF                       lw      lr,[sp]
   1718 000F0AC0 E5 F7                       lw      r7,4[sp]
   1719 000F0AC2 08 6E                       add     sp,sp,#8    ; Z = 0, r1 = address
   1720 000F0AC4 00 11                   	lw		r1,#0		; Z = 1, r1 = 0
   1721 000F0AC6 F0 80                       ret
                                        
                                        
                                        ; ===== Multiplies the 32 bit values in r1 and r2, returning
                                        ;	the 32 bit result in r1.
                                        ;
                                        
   1728 000F0AC8                        MULT32
   1729 000F0AC8 F4 6E                   	sub		sp,sp,#12
   1730 000F0ACA E1 D5                   	sw		r5,[sp]		; w
   1731 000F0ACC E5 D6                   	sw		r6,4[sp]	; s
   1732 000F0ACE E9 D7                   	sw		r7,8[sp]
                                        
   1734 000F0AD0 00 15                   	lw		r5,#0		; w = 0;
   1735 000F0AD2 10 16                   	lw		r6,r1
   1736 000F0AD4 24 26                   	xor		r6,r2		; s = a ^ b
   1737 000F0AD6 16 21                   	or		r1,r1
   1738 000F0AD8 01 AB                   	bpl		mult1
   1739 000F0ADA 20 31                   	neg		r1
   1740 000F0ADC                        mult1
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 30
tb.asm
   1741 000F0ADC 26 22                   	or		r2,r2
   1742 000F0ADE 01 AB                   	bpl		mult2
   1743 000F0AE0 20 32                   	neg		r2
   1744 000F0AE2                        mult2
   1745 000F0AE2 10 17                   	lw		r7,r1
   1746 000F0AE4 51 37                   	and		r7,#1
   1747 000F0AE6 01 A8                   	beq		mult3
   1748 000F0AE8 20 25                   	add		r5,r2		; w += b
   1749 000F0AEA                        mult3
   1750 000F0AEA 81 32                   	shl		r2,#1		; b <<= 1
   1751 000F0AEC A1 31                   	shr		r1,#1		; a >>= 1
   1752 000F0AEE F9 B9                   	bne		mult2       ; a = 0 ?
   1753 000F0AF0                        mult4
   1754 000F0AF0 66 26                       or      r6,r6
   1755 000F0AF2 01 AB                   	bpl		mult5
   1756 000F0AF4 20 35                   	neg		r5
   1757 000F0AF6                        mult5
   1758 000F0AF6 50 11                   	lw		r1,r5
   1759 000F0AF8 E9 F7                   	lw		r7,8[sp]
   1760 000F0AFA E5 F6                   	lw		r6,4[sp]
   1761 000F0AFC E1 F5                   	lw		r5,[sp]
   1762 000F0AFE 0C 6E                   	add		sp,sp,#12
   1763 000F0B00 F0 80                   	ret
                                        
                                        
                                        ; ===== Divide the 32 bit value in r2 by the 32 bit value in r3.
                                        ;	Returns the 32 bit quotient in r1, remainder in r2
                                        ;
                                        ; r2 = a
                                        ; r3 = b
                                        ; r6 = remainder
                                        ; r7 = iteration count
                                        ; r8 = sign
                                        ;
                                        
                                        ; q = a / b
                                        ; a = r1
                                        ; b = r2
                                        ; q = r2
                                        
   1781 000F0B02                        DIV32
   1782 000F0B02 26 22                       or      r2,r2       ; check for divide-by-zero
   1783 000F0B04 04 A9                       bne		div6
   1784 000F0B06 53 51 0F 00 08 11           lea		r1,msgDivZero
   1785 000F0B0C CA AE                       br		ERROR		; divide by zero error
   1786 000F0B0E                        div6
   1787 000F0B0E F4 6E                   	sub		sp,sp,#12
   1788 000F0B10 E1 D6                   	sw		r6,[sp]
   1789 000F0B12 E5 D7                   	sw		r7,4[sp]
   1790 000F0B14 E9 D8                   	sw		r8,8[sp]
                                        
   1792 000F0B16 02 40 00 18                 lw      r8,#32      ; iteration count for 32 bits
   1793 000F0B1A 00 16                   	lw		r6,#0		; r = 0
   1794 000F0B1C 20 17                       lw      r7,r2       ; r7 = sign of result
   1795 000F0B1E 14 27                       xor     r7,r1
   1796 000F0B20 16 21                   	or	    r1,r1	    ; take absolute value of r1 (a)
   1797 000F0B22 01 AB                   	bpl     div1
   1798 000F0B24 20 31                   	neg     r1
   1799 000F0B26                        div1
   1800 000F0B26 26 22                       or      r2,r2	    ; take absolute value of r2 (b)
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 31
tb.asm
   1801 000F0B28 01 AB                   	bpl	    div2
   1802 000F0B2A 20 32                   	neg     r2
   1803 000F0B2C                        div2
   1804 000F0B2C 81 31                   	shl		r1,#1		; a <<= 1
   1805 000F0B2E 61 26                   	adc		r6,r6		; r <<= 1
   1806 000F0B30 6D 22                   	cmp		r2,r6		; b < r ?
   1807 000F0B32 02 A7                   	bgtu	div4
   1808 000F0B34 22 26                   	sub		r6,r2		; r -= b
   1809 000F0B36 61 31                   	or      r1,#1       ; a |= 1
   1810 000F0B38                        div4
   1811 000F0B38 FF 68                   	sub		r8,r8,#1
   1812 000F0B3A F8 B9                       bne     div2        ; n--
   1813 000F0B3C 76 27                   	or      r7,r7
   1814 000F0B3E 01 AB                   	bpl     div5
   1815 000F0B40 20 31                   	neg     r1
   1816 000F0B42                        div5
   1817 000F0B42 60 12                   	lw		r2,r6		; r2 = r
   1818 000F0B44 E5 F7                   	lw		r7,4[sp]
   1819 000F0B46 E9 F8                   	lw		r8,8[sp]
   1820 000F0B48 E1 F6                   	lw		r6,[sp]
   1821 000F0B4A 0C 6E                   	add		sp,sp,#12
   1822 000F0B4C F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1828 000F0B4E                        PEEK
   1829 000F0B4E 26 BF                   	call	PARN		; get the memory address
   1830 000F0B50 10 E1                   	lb		r1,[r1]		; get the addressed byte
   1831 000F0B52 0E 21                   	zxb		r1			; upper 3 bytes will be zero
   1832 000F0B54 E1 FF                   	lw		lr,[sp]	; and return it
   1833 000F0B56 0C 6E                   	add		sp,sp,#12
   1834 000F0B58 F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1840 000F0B5A                        PEEKC
   1841 000F0B5A 20 BF                   	call	PARN		; get the memory address
   1842 000F0B5C 5E 31                   	and		r1,#-2		; align to char address
   1843 000F0B5E 10 F1                   	lh		r1,[r1]		; get the addressed char
   1844 000F0B60 1E 21                   	zxc		r1
   1845 000F0B62 E1 FF                   	lw		lr,[sp]	; and return it
   1846 000F0B64 0C 6E                   	add		sp,sp,#12
   1847 000F0B66 F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1853 000F0B68                        PEEKW
   1854 000F0B68 19 BF                   	call	PARN		; get the memory address
   1855 000F0B6A 5C 31                   	and		r1,#-4		; align to word address
   1856 000F0B6C 11 F1                   	lw		r1,[r1]		; get the addressed word
   1857 000F0B6E E1 FF                   	lw		lr,[sp]	; and return it
   1858 000F0B70 0C 6E                   	add		sp,sp,#12
   1859 000F0B72 F0 80                   	ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 32
tb.asm
                                        
                                        ; user function call
                                        ; call the user function with argument in r1
   1864 000F0B74                        USRX
   1865 000F0B74 13 BF                   	call	PARN		; get expression value
   1866 000F0B76 E5 D8                   	sw		r8,4[sp]	; save the text pointer
   1867 000F0B78 02 40 05 F2             	lw      r2,usrJmp   ; get usr vector
   1868 000F0B7C A3 57 F8 FF 0F AF       	call	[r2]		; jump to the subroutine
   1869 000F0B82 E5 F8                   	lw		r8,4[sp]	; restore the text pointer
   1870 000F0B84 E1 FF                   	lw		lr,[sp]
   1871 000F0B86 0C 6E                   	add		sp,sp,#12
   1872 000F0B88 F0 80                   	ret
                                        
                                        
                                        ; ===== The RND function returns a random number from 1 to
                                        ;	the value of the following expression in D0.
                                        ;
   1878 000F0B8A                        RND
   1879 000F0B8A 08 BF                   	call	PARN		; get the upper limit
   1880 000F0B8C 16 21                   	or		r1,r1		; it must be positive and non-zero
   1881 000F0B8E 0F A8                   	beq		rnd2
   1882 000F0B90 0A AA                   	bmi		rnd1
   1883 000F0B92 10 12                   	lw		r2,r1
   1884 000F0B94 CA 4D 04 D0             	sh		r0,RAND+4	; read command
   1885 000F0B98 CA 4D 01 F1             	lw		r1,RAND		; get a number
   1886 000F0B9C 0F AF                   	call	modu4		; RND(n)=MOD(number,n)+1
   1887 000F0B9E 01 61                   	add		r1,r1,#1
   1888 000F0BA0 E1 FF                   	lw		lr,[sp]
   1889 000F0BA2 0C 6E                   	add		sp,sp,#12
   1890 000F0BA4 F0 80                   	ret
   1891 000F0BA6                        rnd1
   1892 000F0BA6 5B 51 0F 00 0C 11       	lea		r1,msgRNDBad
   1893 000F0BAC 7A AE                   	br		ERROR
   1894 000F0BAE                        rnd2
   1895 000F0BAE CA 4D 04 D0             	sh		r0,RAND+4
   1896 000F0BB2 CA 4D 01 F1             	lw		r1,RAND
   1897 000F0BB6 E1 FF                   	lw		lr,[sp]
   1898 000F0BB8 0C 6E                   	add		sp,sp,#12
   1899 000F0BBA F0 80                   	ret
                                        
                                        
                                        ; r = a mod b
                                        ; a = r2
                                        ; b = r3
                                        ; r = r1
   1906 000F0BBC                        modu4
   1907 000F0BBC F4 6E                   	sub		sp,sp,#12
   1908 000F0BBE E1 D5                   	sw		r5,[sp]
   1909 000F0BC0 E5 D6                   	sw		r6,4[sp]
   1910 000F0BC2 E9 D7                   	sw		r7,8[sp]
   1911 000F0BC4 02 40 00 17             	lw      r7,#32		; n = 32
   1912 000F0BC8 00 15                   	lw		r5,#0		; w = 0
   1913 000F0BCA 00 16                   	lw		r6,#0		; r = 0
   1914 000F0BCC                        mod2
   1915 000F0BCC 81 31                   	shl		r1,#1		; a <<= 1
   1916 000F0BCE 61 26                   	adc		r6,r6		; r <<= 1
   1917 000F0BD0 6D 22                   	cmp		r2,r6		; b < r ?
   1918 000F0BD2 01 A7                   	bgtu	mod1
   1919 000F0BD4 22 26                   	sub		r6,r2		; r -= b
   1920 000F0BD6                        mod1
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 33
tb.asm
   1921 000F0BD6 FF 67                   	sub		r7,r7,#1
   1922 000F0BD8 F9 B9                       bne     mod2        ; n--
   1923 000F0BDA 60 11                   	lw		r1,r6
   1924 000F0BDC E1 F5                   	lw		r5,[sp]
   1925 000F0BDE E5 F6                   	lw		r6,4[sp]
   1926 000F0BE0 E9 F7                   	lw		r7,8[sp]
   1927 000F0BE2 0C 6E                   	add		sp,sp,#12
   1928 000F0BE4 F0 80                   	ret
                                        
                                        
                                        
                                        ; ===== The ABS function returns an absolute value in r2.
                                        ;
   1934 000F0BE6                        ABS
   1935 000F0BE6 ED 4F 09 AF             	call	PARN		; get the following expr.'s value
   1936 000F0BEA 16 21                   	or		r1,r1
   1937 000F0BEC 01 AB                   	bpl		abs1
   1938 000F0BEE 20 31                   	neg		r1			; if negative, complement it
                                        ;	bmi		QHOW		; if still negative, it was too big
   1940 000F0BF0                        abs1
   1941 000F0BF0 E1 FF                   	lw		lr,[sp]
   1942 000F0BF2 0C 6E                   	add		sp,sp,#12
   1943 000F0BF4 F0 80                   	ret
                                        
                                        
                                        ; ===== The SGN function returns the sign in r1. +1,0, or -1
                                        ;
   1948 000F0BF6                        SGN
   1949 000F0BF6 ED 4F 01 AF             	call	PARN		; get the following expr.'s value
   1950 000F0BFA 16 21                   	or		r1,r1
   1951 000F0BFC 04 A8                   	beq		sgn1
   1952 000F0BFE 02 AB                   	bpl		sgn2
   1953 000F0C00 0F 11                   	lw		r1,#-1
   1954 000F0C02 01 AE                   	br		sgn1
   1955 000F0C04                        sgn2
   1956 000F0C04 01 11                   	lw		r1,#1
   1957 000F0C06                        sgn1
   1958 000F0C06 E1 FF                   	lw		lr,[sp]
   1959 000F0C08 0C 6E                   	add		sp,sp,#12
   1960 000F0C0A F0 80                   	ret
                                        
                                        
                                        ; ===== The SIZE function returns the size of free memory in r1.
                                        ;
   1965 000F0C0C                        SIZEX
   1966 000F0C0C 0A 40 0D F1             	lw		r1,VARBGN	; get the number of free bytes...
   1967 000F0C10 0A 40 09 F2             	lw		r2,TXTUNF	; between 'TXTUNF' and 'VARBGN'
   1968 000F0C14 22 21                   	sub		r1,r2
   1969 000F0C16 E1 FF                   	lw		lr,[sp]
   1970 000F0C18 0C 6E                   	add		sp,sp,#12
   1971 000F0C1A F0 80                   	ret					; return the number in r2
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                                        ;
                                        ; 'SETVAL' expects a variable, followed by an equal sign and then
                                        ; an expression.  It evaluates the expression and sets the variable
                                        ; to that value.
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 34
tb.asm
                                        ;
                                        ; 'FIN' checks the end of a command.  If it ended with ":",
                                        ; execution continues.	If it ended with a CR, it finds the
                                        ; the next line and continues from there.
                                        ;
                                        ; 'ENDCHK' checks if a command is ended with a CR. This is
                                        ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                                        ;
                                        ; 'ERROR' prints the string pointed to by A0. It then prints the
                                        ; line pointed to by CURRNT with a "?" inserted at where the
                                        ; old text pointer (should be on top of the stack) points to.
                                        ; Execution of Tiny BASIC is stopped and a warm start is done.
                                        ; If CURRNT is zero (indicating a direct command), the direct
                                        ; command is not printed. If CURRNT is -1 (indicating
                                        ; 'INPUT' command in progress), the input line is not printed
                                        ; and execution is not terminated but continues at 'INPERR'.
                                        ;
                                        ; Related to 'ERROR' are the following:
                                        ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                                        ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                                        ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                                        ; 'QHOW' and 'AHOW' also do this for "How?".
                                        ;
                                        
                                        ; returns
                                        ; r2 = variable's address
                                        ;
   2008 000F0C1C                        SETVAL
   2009 000F0C1C F8 6E                       sub     sp,sp,#8
   2010 000F0C1E E1 DF                       sw      lr,[sp]
   2011 000F0C20 01 11                       lw		r1,#1		; allocate var
   2012 000F0C22 EC 4F 0C AF                 call	TSTV		; variable name?
   2013 000F0C26 04 A9                       bne		sv2
   2014 000F0C28 5A 51 0F 00 05 11          	lea		r1,msgVar
   2015 000F0C2E 39 AE                      	br		ERROR 
   2016 000F0C30                        sv2
   2017 000F0C30 E5 D1                   	sw      r1,4[sp]    ; save the variable's address
   2018 000F0C32 1E 40 09 AF             	call	TSTC		; get past the "=" sign
   2019 000F0C36 3D 12                   	db	'=',SV1-*+1
   2020 000F0C38 DD 4F 04 AF             	call	OREXPR		; evaluate the expression
   2021 000F0C3C E5 F2                   	lw      r2,4[sp]    ; get back the variable's address
   2022 000F0C3E 21 D1                   	sw      r1,[r2]     ; and save value in the variable
   2023 000F0C40 20 11                   	lw		r1,r2		; return r1 = variable address
   2024 000F0C42 E1 FF                   	lw      lr,[sp]
   2025 000F0C44 08 6E                   	add     sp,sp,#8
   2026 000F0C46 F0 80                   	ret
   2027 000F0C48                        SV1
   2028 000F0C48 29 AE                       br	    QWHAT		; if no "=" sign
                                        
                                        
   2031 000F0C4A                        FIN
   2032 000F0C4A FC 6E                   	sub		sp,sp,#4
   2033 000F0C4C E1 DF                   	sw		lr,[sp]
   2034 000F0C4E 1D 40 0B AF             	call	TSTC		; *** FIN ***
   2035 000F0C52 3A 08                   	db	':',FI1-*+1
   2036 000F0C54 04 6E                   	add		sp,sp,#4	; if ":", discard return address
   2037 000F0C56 B7 4F 0C AE             	br		RUNSML		; continue on the same line
   2038 000F0C5A                        FI1
   2039 000F0C5A 1D 40 05 AF             	call	TSTC		; not ":", is it a CR?
   2040 000F0C5E 0D 0A                   	db	CR,FI2-*+1
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 35
tb.asm
   2041 000F0C60 E1 FF                   	lw		lr,[sp]	; else return to the caller
   2042 000F0C62 04 6E                   	add		sp,sp,#4	; yes, purge return address
   2043 000F0C64 B6 4F 08 AE             	br		RUNNXL		; execute the next line
   2044 000F0C68                        FI2
   2045 000F0C68 E1 FF                   	lw		lr,[sp]	; else return to the caller
   2046 000F0C6A 04 6E                   	add		sp,sp,#4
   2047 000F0C6C F0 80                   	ret
                                        
                                        
                                        ; Check that there is nothing else on the line
                                        ; Registers Affected
                                        ;   r1
                                        ;
   2054 000F0C6E                        ENDCHK
   2055 000F0C6E FC 6E                   	sub		sp,sp,#4
   2056 000F0C70 E1 DF                   	sw		lr,[sp]
   2057 000F0C72 1F 40 0E AF             	call	IGNBLK
   2058 000F0C76 80 E1                   	lb		r1,[r8]
   2059 000F0C78 FF 4F 13 10             	cmp		r1,#CR		; does it end with a CR?
   2060 000F0C7C 04 A8                   	beq		ec1
   2061 000F0C7E 67 51 0F 00 0F 11       	lea		r1,msgExtraChars
   2062 000F0C84 0E AE                   	jmp		ERROR
   2063 000F0C86                        ec1
   2064 000F0C86 E1 FF                   	lw		lr,[sp]
   2065 000F0C88 04 6E                   	add		sp,sp,#4
   2066 000F0C8A F0 80                   	ret
                                        
                                        
   2069 000F0C8C                        TOOBIG
   2070 000F0C8C 66 51 0F 00 0A 11       	lea		r1,msgTooBig
   2071 000F0C92 07 AE                   	br		ERROR
   2072 000F0C94                        QSORRY
   2073 000F0C94 50 51 0F 00 00 11           lea     r1,SRYMSG
   2074 000F0C9A 03 AE                   	br	    ERROR
   2075 000F0C9C                        QWHAT
   2076 000F0C9C 4F 51 0F 00 08 11       	lea		r1,msgWhat
   2077 000F0CA2                        ERROR
   2078 000F0CA2 22 40 0F AF             	call	PRMESG		; display the error message
   2079 000F0CA6 08 40 09 F1             	lw		r1,CURRNT	; get the current line number
   2080 000F0CAA 9F 4F 0A A8             	beq		WSTART		; if zero, do a warm start
   2081 000F0CAE 11 10                   	cmp		r1,#-1		; is the line no. pointer = -1?
   2082 000F0CB0 C6 4F 05 A8             	beq		INPERR		; if so, redo input
   2083 000F0CB4 80 E5                   	lb		r5,[r8]		; save the char. pointed to
   2084 000F0CB6 80 C0                   	sb		r0,[r8]		; put a zero where the error is
   2085 000F0CB8 08 40 09 F1             	lw		r1,CURRNT	; point to start of current line
   2086 000F0CBC 18 40 06 AF             	call	PRTLN		; display the line in error up to the 0
   2087 000F0CC0 10 16                   	lw      r6,r1       ; save off end pointer
   2088 000F0CC2 80 C5                   	sb		r5,[r8]		; restore the character
   2089 000F0CC4 03 40 0F 11             	lw		r1,#'?'		; display a "?"
   2090 000F0CC8 99 4F 0C AF             	call	GOOUT
   2091 000F0CCC 00 12                   	lw      r2,#0       ; stop char = 0
   2092 000F0CCE 6F 11                   	sub		r1,r6,#1	; point back to the error char.
   2093 000F0CD0 BD AF                   	call	PRTSTG		; display the rest of the line
   2094 000F0CD2 9E 4F 06 AE             	jmp	    WSTART		; and do a warm start
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** GETLN *** FNDLN (& friends) ***
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 36
tb.asm
                                        ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                                        ; the character in r3 (given by the caller), then it fills the
                                        ; buffer and echos. It ignores LF's but still echos
                                        ; them back. Control-H is used to delete the last character
                                        ; entered (if there is one), and control-X is used to delete the
                                        ; whole line and start over again. CR signals the end of a line,
                                        ; and causes 'GETLN' to return.
                                        ;
                                        ;
   2110 000F0CD6                        GETLN
   2111 000F0CD6 F8 6E                   	sub		sp,sp,#8
   2112 000F0CD8 E1 DF                   	sw		lr,[sp]
   2113 000F0CDA E5 D5                   	sw		r5,4[sp]
   2114 000F0CDC 99 4F 02 AF             	call	GOOUT		; display the prompt
   2115 000F0CE0 01 11                   	lw		r1,#1		; turn on cursor flash
   2116 000F0CE2 03 40 0C C1             	sb		r1,cursFlash
   2117 000F0CE6 02 40 00 11             	lw		r1,#' '		; and a space
   2118 000F0CEA 98 4F 0B AF             	call	GOOUT
   2119 000F0CEE 0C 40 0C 18             	lea		r8,BUFFER	; r8 is the buffer pointer
   2120 000F0CF2                        GL1
   2121 000F0CF2 1F 40 04 AF             	call	CHKIO		; check keyboard
   2122 000F0CF6 FD B8                   	beq		GL1			; wait for a char. to come in
   2123 000F0CF8 FF 4F 18 10             	cmp		r1,#CTRLH	; delete last character?
   2124 000F0CFC 14 A8                   	beq		GL3			; if so
   2125 000F0CFE FE 4F 18 10             	cmp		r1,#CTRLX	; delete the whole line?
   2126 000F0D02 20 A8                   	beq		GL4			; if so
   2127 000F0D04 FF 4F 13 10             	cmp		r1,#CR		; accept a CR
   2128 000F0D08 03 A8                   	beq		GL2
   2129 000F0D0A FE 4F 10 10             	cmp		r1,#' '		; if other control char., discard it
   2130 000F0D0E F1 B4                   	bltu	GL1
   2131 000F0D10                        GL2
   2132 000F0D10 80 C1                   	sb		r1,[r8]		; save the char.
   2133 000F0D12 01 68                   	add		r8,r8,#1
   2134 000F0D14 97 4F 06 AF             	call	GOOUT		; echo the char back out
   2135 000F0D18 8F E1                   	lb      r1,-1[r8]   ; get char back (GOOUT destroys r1)
   2136 000F0D1A FF 4F 13 10             	cmp		r1,#CR		; if it's a CR, end the line
   2137 000F0D1E 25 A8                   	beq		GL7
   2138 000F0D20 EE 4F 85 10             	cmp		r8,#(BUFFER+BUFLEN-1)	; any more room?
   2139 000F0D24 E6 B4                   	bltu	GL1			; yes: get some more, else delete last char.
                                        
   2141 000F0D26                        GL3
   2142 000F0D26 08 11                   	lw		r1,#CTRLH	; delete a char. if possible
   2143 000F0D28 96 4F 0C AF             	call	GOOUT
   2144 000F0D2C 02 40 00 11             	lw		r1,#' '
   2145 000F0D30 96 4F 08 AF             	call	GOOUT
   2146 000F0D34 F3 4F 84 10             	cmp		r8,#BUFFER	; any char.'s left?
   2147 000F0D38 DC B6                   	bleu	GL1			; if not
   2148 000F0D3A 08 11                   	lw		r1,#CTRLH	; if so, finish the BS-space-BS sequence
   2149 000F0D3C 96 4F 02 AF             	call	GOOUT
   2150 000F0D40 FF 68                   	sub		r8,r8,#1	; decrement the text pointer
   2151 000F0D42 D7 BE                   	br		GL1			; back for more
                                        
   2153 000F0D44                        GL4
   2154 000F0D44 80 11                   	lw		r1,r8		; delete the whole line
   2155 000F0D46 F3 4F 14 15             	sub		r5,r1,#BUFFER   ; figure out how many backspaces we need
   2156 000F0D4A 0C A8                   	beq		GL6			; if none needed, brnch
   2157 000F0D4C                        GL5	
   2158 000F0D4C 08 11                   	lw		r1,#CTRLH	; and display BS-space-BS sequences
   2159 000F0D4E 95 4F 09 AF             	call	GOOUT
   2160 000F0D52 02 40 00 11             	lw		r1,#' '
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 37
tb.asm
   2161 000F0D56 95 4F 05 AF             	call	GOOUT
   2162 000F0D5A 08 11                   	lw		r1,#CTRLH
   2163 000F0D5C 95 4F 02 AF             	call	GOOUT
   2164 000F0D60 FF 65                   	sub		r5,r5,#1
   2165 000F0D62 F4 B9                   	bne     GL5
   2166 000F0D64                        GL6
   2167 000F0D64 0C 40 0C 18             	lea		r8,BUFFER	; reinitialize the text pointer
   2168 000F0D68 C4 BE                   	br		GL1			; and go back for more
   2169 000F0D6A                        GL7
   2170 000F0D6A 00 11                   	lw		r1,#0		; turn off cursor flash
   2171 000F0D6C 03 40 0C C1             	sb		r1,cursFlash
   2172 000F0D70 0A 11                   	lw		r1,#LF		; echo a LF for the CR
   2173 000F0D72 94 4F 07 AF             	call	GOOUT
   2174 000F0D76 E1 FF                   	lw		lr,[sp]
   2175 000F0D78 E5 F5                   	lw		r5,4[sp]
   2176 000F0D7A 08 6E                   	add		sp,sp,#8
   2177 000F0D7C F0 80                   	ret
                                        
                                        
                                        ; 'FNDLN' finds a line with a given line no. (in r1) in the
                                        ; text save area.  r9 is used as the text pointer. If the line
                                        ; is found, r9 will point to the beginning of that line
                                        ; (i.e. the high byte of the line no.), and flags are Z.
                                        ; If that line is not there and a line with a higher line no.
                                        ; is found, r9 points there and flags are NC & NZ. If we reached
                                        ; the end of the text save area and cannot find the line, flags
                                        ; are C & NZ.
                                        ; Z=1 if line found
                                        ; N=1 if end of text save area
                                        ; Z=0 & N=0 if higher line found
                                        ;
                                        ; 'FNDLN' will initialize r9 to the beginning of the text save
                                        ; area to start the search. Some other entries of this routine
                                        ; will not initialize r9 and do the search.
                                        ; 'FNDLNP' will start with r9 and search for the line no.
                                        ; 'FNDNXT' will bump r9 by 2, find a CR and then start search.
                                        ; 'FNDSKP' uses r9 to find a CR, and then starts the search.
                                        ; return Z=1 if line is found, r9 = pointer to line
                                        ;
                                        ; Parameters
                                        ;	r1 = line number to find
                                        ;
   2203 000F0D7E                        FNDLN
   2204 000F0D7E 00 50 FF FF 11 10       	cmp		r1,#0xFFFF	; line no. must be < 65535
   2205 000F0D84 04 A6                   	bleu	fl1
   2206 000F0D86 58 51 0F 00 0F 11       	lea		r1,msgLineRange
   2207 000F0D8C 8A BE                   	br		ERROR
   2208 000F0D8E                        fl1
   2209 000F0D8E 01 50 0F 00 09 F9       	lw		r9,TXTBGN	; init. the text save pointer
                                        
   2211 000F0D94                        FNDLNP
   2212 000F0D94 0A 40 09 FA             	lw		r10,TXTUNF	; check if we passed the end
   2213 000F0D98 FF 6A                   	sub		r10,r10,#1
   2214 000F0D9A AD 29                   	cmp		r9,r10
   2215 000F0D9C 0F A7                   	bgtu	FNDRET		; if so, return with Z=0 & C=1
   2216 000F0D9E 90 E3                   	lb		r3,[r9]		; get low order byte of line number
   2217 000F0DA0 0E 23                   	zxb		r3
   2218 000F0DA2 91 E2                   	lb		r2,1[r9]	; get high order byte
   2219 000F0DA4 0E 22                   	zxb		r2
   2220 000F0DA6 81 32                   	shl		r2,#1
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 38
tb.asm
   2221 000F0DA8 81 32                   	shl		r2,#1
   2222 000F0DAA 81 32                   	shl		r2,#1
   2223 000F0DAC 81 32                   	shl		r2,#1
   2224 000F0DAE 81 32                   	shl		r2,#1
   2225 000F0DB0 81 32                   	shl		r2,#1
   2226 000F0DB2 81 32                   	shl		r2,#1
   2227 000F0DB4 81 32                   	shl		r2,#1
   2228 000F0DB6 36 22                   	or		r2,r3		; build whole line number
   2229 000F0DB8 2D 21                   	cmp		r1,r2		; is this the line we want?
   2230 000F0DBA 01 A7                   	bgtu	FNDNXT		; no, not there yet
   2231 000F0DBC                        FNDRET
   2232 000F0DBC F0 80                   	ret			; return the cond. codes
                                        
   2234 000F0DBE                        FNDNXT
   2235 000F0DBE 02 69                   	add		r9,r9,#2	; find the next line
                                        
   2237 000F0DC0                        FNDSKP
   2238 000F0DC0 90 E2                   	lb		r2,[r9]
   2239 000F0DC2 01 69                   	add		r9,r9,#1
   2240 000F0DC4 FF 4F 23 10             	cmp		r2,#CR		; try to find a CR
   2241 000F0DC8 FB B9                   	bne		FNDSKP		; keep looking
   2242 000F0DCA E4 BE                   	br		FNDLNP		; check if end of text
                                        
                                        
                                        ;******************************************************************
                                        ; 'MVUP' moves a block up from where r1 points to where r2 points
                                        ; until r1=r3
                                        ;
   2249 000F0DCC                        MVUP1
   2250 000F0DCC 10 E4                   	lb		r4,[r1]
   2251 000F0DCE 20 C4                   	sb		r4,[r2]
   2252 000F0DD0 01 61                   	add		r1,r1,#1
   2253 000F0DD2 01 62                   	add		r2,r2,#1
   2254 000F0DD4                        MVUP
   2255 000F0DD4 3D 21                   	cmp		r1,r3
   2256 000F0DD6 FA B9                   	bne		MVUP1
   2257 000F0DD8                        MVRET
   2258 000F0DD8 F0 80                   	ret
                                        
                                        
                                        ; 'MVDOWN' moves a block down from where r1 points to where r2
                                        ; points until r1=r3
                                        ;
   2264 000F0DDA                        MVDOWN1
   2265 000F0DDA FF 61                   	sub		r1,r1,#1
   2266 000F0DDC FF 62                   	sub		r2,r2,#1
   2267 000F0DDE 10 E4                   	lb		r4,[r1]
   2268 000F0DE0 20 C4                   	sb		r4,[r2]
   2269 000F0DE2                        MVDOWN
   2270 000F0DE2 3D 21                   	cmp		r1,r3
   2271 000F0DE4 FA B9                   	bne		MVDOWN1
   2272 000F0DE6 F0 80                   	ret
                                        
                                        
                                        ; 'POPA' restores the 'FOR' loop variable save area from the stack
                                        ;
                                        ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                                        ;
                                        ; Note: a single zero word is stored on the stack in the
                                        ; case that no FOR loops need to be saved. This needs to be
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 39
tb.asm
                                        ; done because PUSHA / POPA is called all the time.
                                        
   2283 000F0DE8                        POPA
   2284 000F0DE8 E1 F1                   	lw		r1,[sp]		; restore LOPVAR, but zero means no more
   2285 000F0DEA 09 40 05 D1             	sw		r1,LOPVAR
   2286 000F0DEE 10 A8                   	beq		PP1
   2287 000F0DF0 01 40 E1 F1             	lw		r1,16[sp]	; if not zero, restore the rest
   2288 000F0DF4 0A 40 05 D1             	sw		r1,LOPPT
   2289 000F0DF8 00 40 ED F1             	lw		r1,12[sp]
   2290 000F0DFC 0A 40 01 D1             	sw		r1,LOPLN
   2291 000F0E00 E9 F1                   	lw		r1,8[sp]
   2292 000F0E02 09 40 0D D1             	sw		r1,LOPLMT
   2293 000F0E06 E5 F1                   	lw		r1,4[sp]
   2294 000F0E08 09 40 09 D1             	sw		r1,LOPINC
   2295 000F0E0C 14 6E                   	add		sp,sp,#20
   2296 000F0E0E F0 80                   	ret
   2297 000F0E10                        PP1
   2298 000F0E10 04 6E                   	add		sp,sp,#4
   2299 000F0E12 F0 80                   	ret
                                        
                                        
   2302 000F0E14                        PUSHA
   2303 000F0E14 0B 40 0D F1             	lw		r1,STKBOT	; Are we running out of stack room?
   2304 000F0E18 14 61                   	add		r1,r1,#20	; we might need this many bytes
   2305 000F0E1A 1D 2E                   	cmp		sp,r1
   2306 000F0E1C 3B B4                   	bltu	QSORRY		; out of stack space
   2307 000F0E1E 09 40 05 F1             	lw		r1,LOPVAR	; save loop variables
   2308 000F0E22 11 A8                   	beq		PU1			; if LOPVAR is zero, that's all
   2309 000F0E24 EC 6E                   	sub		sp,sp,#20
   2310 000F0E26 E1 D1                   	sw		r1,[sp]
   2311 000F0E28 0A 40 05 F1             	lw		r1,LOPPT
   2312 000F0E2C 01 40 E1 D1             	sw		r1,16[sp]	; else save all the others
   2313 000F0E30 0A 40 01 F1             	lw		r1,LOPLN
   2314 000F0E34 00 40 ED D1             	sw		r1,12[sp]
   2315 000F0E38 09 40 0D F1             	lw		r1,LOPLMT
   2316 000F0E3C E9 D1                   	sw		r1,8[sp]
   2317 000F0E3E 09 40 09 F1             	lw		r1,LOPINC
   2318 000F0E42 E5 D1                   	sw		r1,4[sp]
   2319 000F0E44 F0 80                   	ret
   2320 000F0E46                        PU1
   2321 000F0E46 FC 6E                   	sub		sp,sp,#4
   2322 000F0E48 E1 D1                   	sw		r1,[sp]
   2323 000F0E4A F0 80                   	ret
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                                        ;
                                        ; 'PRTSTG' prints a string pointed to by r3. It stops printing
                                        ; and returns to the caller when either a CR is printed or when
                                        ; the next byte is the same as what was passed in r4 by the
                                        ; caller.
                                        ;
                                        ; 'QTSTG' looks for an underline (back-arrow on some systems),
                                        ; single-quote, or double-quote.  If none of these are found, returns
                                        ; to the caller.  If underline, outputs a CR without a LF.  If single
                                        ; or double quote, prints the quoted string and demands a matching
                                        ; end quote.  After the printing, the next 2 bytes of the caller are
                                        ; skipped over (usually a short brnch instruction).
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 40
tb.asm
                                        ;
                                        ; 'PRTNUM' prints the 32 bit number in r3, leading blanks are added if
                                        ; needed to pad the number of spaces to the number in r4.
                                        ; However, if the number of digits is larger than the no. in
                                        ; r4, all digits are printed anyway. Negative sign is also
                                        ; printed and counted in, positive sign is not.
                                        ;
                                        ; 'PRTLN' prints the saved text line pointed to by r3
                                        ; with line no. and all.
                                        ;
                                        
                                        ; r1 = pointer to string
                                        ; r2 = stop character
                                        ; return r1 = pointer to end of line + 1
                                        
   2356 000F0E4C                        PRTSTG
   2357 000F0E4C F0 6E                       sub     sp,sp,#16
   2358 000F0E4E E1 DF                       sw      lr,[sp]
   2359 000F0E50 E5 D5                       sw      r5,4[sp]
   2360 000F0E52 E9 D6                       sw      r6,8[sp]
   2361 000F0E54 00 40 ED D7                 sw      r7,12[sp]
   2362 000F0E58 10 15                       lw      r5,r1       ; r5 = pointer
   2363 000F0E5A 20 16                       lw      r6,r2       ; r6 = stop char
   2364 000F0E5C                        PS1
   2365 000F0E5C 50 E7                       lb      r7,[r5]     ; get a text character
   2366 000F0E5E 01 65                       add     r5,r5,#1
   2367 000F0E60 6D 27                   	cmp     r7,r6		; same as stop character?
   2368 000F0E62 09 A8                   	beq	    PRTRET		; if so, return
   2369 000F0E64 70 11                   	lw      r1,r7
   2370 000F0E66 8C 4F 0D AF             	call	GOOUT		; display the char.
   2371 000F0E6A FF 4F 73 10             	cmp     r7,#CR      ; is it a C.R.?
   2372 000F0E6E F6 B9                   	bne	    PS1		    ; no, go back for more
   2373 000F0E70 0A 11                   	lw      r1,#LF      ; yes, add a L.F.
   2374 000F0E72 8C 4F 07 AF             	call	GOOUT
   2375 000F0E76                        PRTRET
   2376 000F0E76 70 12                       lw      r2,r7       ; return r2 = stop char
   2377 000F0E78 50 11                   	lw		r1,r5		; return r1 = line pointer
   2378 000F0E7A E5 F5                       lw      r5,4[sp]
   2379 000F0E7C E9 F6                       lw      r6,8[sp]
   2380 000F0E7E 00 40 ED F7                 lw      r7,12[sp]
   2381 000F0E82 E1 FF                       lw      lr,[sp]
   2382 000F0E84 10 6E                       add     sp,sp,#16
   2383 000F0E86 F0 80                       ret			        ; then return
                                        
                                        
   2386 000F0E88                        QTSTG
   2387 000F0E88 FC 6E                   	sub		sp,sp,#4
   2388 000F0E8A E1 DF                   	sw		lr,[sp]
   2389 000F0E8C BD AF                   	call	TSTC		; *** QTSTG ***
   2390 000F0E8E 22 18                   	db	'"',QT3-*+1
   2391 000F0E90 02 40 02 12             	lw		r2,#'"'		; it is a "
   2392 000F0E94                        QT1
   2393 000F0E94 80 11                   	lw		r1,r8
   2394 000F0E96 DA BF                   	call	PRTSTG		; print until another
   2395 000F0E98 10 18                   	lw		r8,r1
   2396 000F0E9A FF 4F 26 10             	cmp		r2,#LF		; was last one a CR?
   2397 000F0E9E 0E A9                   	bne		QT2
   2398 000F0EA0 04 6E                   	add		sp,sp,#4
   2399 000F0EA2 A4 4F 09 AE             	br		RUNNXL		; if so, run next line
   2400 000F0EA6                        QT3
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 41
tb.asm
   2401 000F0EA6 B0 AF                   	call	TSTC		; is it a single quote?
   2402 000F0EA8 27 08                   	db	"'",QT4-*+1
   2403 000F0EAA 02 40 07 12             	lw		r2,#''''	; if so, do same as above
   2404 000F0EAE F2 BE                   	br		QT1
   2405 000F0EB0                        QT4
   2406 000F0EB0 AB AF                   	call	TSTC		; is it an underline?
   2407 000F0EB2 5F 10                   	db	'_',QT5-*+1
   2408 000F0EB4 00 40 0D 11             	lw		r1,#CR		; if so, output a CR without LF
   2409 000F0EB8 8A 4F 04 AF             	call	GOOUT
   2410 000F0EBC                        QT2
   2411 000F0EBC E1 FF                   	lw		lr,[sp]
   2412 000F0EBE 04 6E                   	add		sp,sp,#4
   2413 000F0EC0 F2 80                   	jmp		2[lr]		; skip over 2 bytes when returning
   2414 000F0EC2                        QT5						; not " ' or _
   2415 000F0EC2 E1 FF                   	lw		lr,[sp]
   2416 000F0EC4 04 6E                   	add		sp,sp,#4
   2417 000F0EC6 F0 80                   	ret
                                        
                                        
                                        ; Output a CR LF sequence
                                        ;
   2422 000F0EC8                        prCRLF
   2423 000F0EC8 FC 6E                   	sub		sp,sp,#4
   2424 000F0ECA E1 DF                   	sw		lr,[sp]
   2425 000F0ECC 00 40 0D 11             	lw		r1,#CR
   2426 000F0ED0 89 4F 08 AF             	call	GOOUT
   2427 000F0ED4 0A 11                   	lw		r1,#LF
   2428 000F0ED6 89 4F 05 AF             	call	GOOUT
   2429 000F0EDA E1 FF                   	lw		lr,[sp]
   2430 000F0EDC 04 6E                   	add		sp,sp,#4
   2431 000F0EDE F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
                                        ; Register Usage
                                        ;	r5 = number of padding spaces
   2438 000F0EE0                        PRTNUM
   2439 000F0EE0 F0 6E                   	sub		sp,sp,#16
   2440 000F0EE2 E1 DF                   	sw		lr,[sp]
   2441 000F0EE4 E5 D5                   	sw		r5,4[sp]
   2442 000F0EE6 E9 D6                   	sw		r6,8[sp]
   2443 000F0EE8 00 40 ED D7             	sw		r7,12[sp]
                                        
   2445 000F0EEC 0C 40 00 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2446 000F0EF0 10 16                   	lw		r6,r1		; save number for later
   2447 000F0EF2 20 15                   	lw		r5,r2		; r5 = min number of chars
   2448 000F0EF4 16 21                   	
   2449 000F0EF6 02 AB                   	bpl		PN1			; if not
   2450 000F0EF8 20 31                   	neg		r1			; else make it positive
   2451 000F0EFA FF 65                   	sub		r5,r5,#1	; one less for width count
   2452 000F0EFC                        PN1
   2453 000F0EFC 0A 12                   	lw		r2,#10		; divide by 10
   2454 000F0EFE E0 4F 00 AF             	call	DIV32
   2455 000F0F02 30 62                   	add		r2,r2,#'0'	; convert remainder to ascii
   2456 000F0F04 70 C2                   	sb		r2,[r7]		; and store in buffer
   2457 000F0F06 01 67                   	add		r7,r7,#1
   2458 000F0F08 FF 65                   	sub		r5,r5,#1	; decrement width
   2459 000F0F0A 10 10                   	cmp		r1,#0
   2460 000F0F0C F7 B9                   	bne		PN1
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 42
tb.asm
   2461 000F0F0E                        PN6
   2462 000F0F0E 56 25                   	or		r5,r5		; test pad count
   2463 000F0F10 06 A2                   	ble		PN4			; skip padding if not needed
   2464 000F0F12                        PN3
   2465 000F0F12 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2466 000F0F16 87 4F 05 AF             	call	GOOUT
   2467 000F0F1A FF 65                   	sub		r5,r5,#1
   2468 000F0F1C FA B9                   	bne		PN3
   2469 000F0F1E                        PN4
   2470 000F0F1E 66 26                   	or		r6,r6		; is number negative?
   2471 000F0F20 04 AB                   	bpl		PN5
   2472 000F0F22 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2473 000F0F26 86 4F 0D AF             	call	GOOUT
   2474 000F0F2A                        PN5
   2475 000F0F2A FF 67                   	sub		r7,r7,#1
   2476 000F0F2C 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2477 000F0F2E 86 4F 09 AF             	call	GOOUT
   2478 000F0F32 F4 4F 70 10             	cmp		r7,#NUMWKA
   2479 000F0F36 F9 B7                   	bgtu	PN5
   2480 000F0F38                        PNRET
   2481 000F0F38 E1 FF                   	lw		lr,[sp]
   2482 000F0F3A E5 F5                   	lw		r5,4[sp]
   2483 000F0F3C E9 F6                   	lw		r6,8[sp]
   2484 000F0F3E 00 40 ED F7             	lw		r7,12[sp]
   2485 000F0F42 10 6E                   	add		sp,sp,#16
   2486 000F0F44 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
   2491 000F0F46                        PRTHEXNUM
   2492 000F0F46 EC 6E                   	sub		sp,sp,#20
   2493 000F0F48 E1 DF                   	sw		lr,[sp]
   2494 000F0F4A E5 D5                   	sw		r5,4[sp]
   2495 000F0F4C E9 D6                   	sw		r6,8[sp]
   2496 000F0F4E 00 40 ED D7             	sw		r7,12[sp]
   2497 000F0F52 01 40 E1 D8             	sw		r8,16[sp]
                                        
   2499 000F0F56 0C 40 00 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2500 000F0F5A 10 16                   	lw		r6,r1		; save number for later
   2501 000F0F5C 0A 15                   	lw		r5,#10		; r5 = min number of chars
   2502 000F0F5E 10 14                   	lw		r4,r1
   2503 000F0F60 46 24                   	
   2504 000F0F62 03 AB                   	bpl		PHN1		; if not
   2505 000F0F64 20 34                   	neg		r4			; else make it positive
   2506 000F0F66 FF 65                   	sub		r5,r5,#1	; one less for width count
   2507 000F0F68 0A 18                   	lw		r8,#10		; maximum of 10 digits
   2508 000F0F6A                        PHN1
   2509 000F0F6A 40 11                   	lw		r1,r4
   2510 000F0F6C 00 40 5F 31             	and		r1,#15
   2511 000F0F70 FF 4F 16 10             	cmp		r1,#10
   2512 000F0F74 02 A0                   	blt		PHN7
   2513 000F0F76 37 61                   	add		r1,r1,#'A'-10
   2514 000F0F78 01 AE                   	br		PHN8
   2515 000F0F7A                        PHN7
   2516 000F0F7A 30 61                   	add		r1,r1,#'0'		; convert remainder to ascii
   2517 000F0F7C                        PHN8
   2518 000F0F7C 70 C1                   	sb		r1,[r7]		; and store in buffer
   2519 000F0F7E 01 67                   	add		r7,r7,#1
   2520 000F0F80 FF 65                   	sub		r5,r5,#1	; decrement width
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 43
tb.asm
   2521 000F0F82 A1 34                   	shr		r4,#1
   2522 000F0F84 A1 34                   	shr		r4,#1
   2523 000F0F86 A1 34                   	shr		r4,#1
   2524 000F0F88 A1 34                   	shr		r4,#1
   2525 000F0F8A 02 A8                   	beq		PHN6			; is it zero yet ?
   2526 000F0F8C FF 68                   	sub		r8,r8,#1	; safety
   2527 000F0F8E ED B9                   	bne		PHN1
   2528 000F0F90                        PHN6
   2529 000F0F90 56 25                   	or		r5,r5		; test pad count
   2530 000F0F92 06 A2                   	ble		PHN4			; skip padding if not needed
   2531 000F0F94                        PHN3
   2532 000F0F94 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2533 000F0F98 83 4F 04 AF             	call	GOOUT
   2534 000F0F9C FF 65                   	sub		r5,r5,#1
   2535 000F0F9E FA B9                   	bne		PHN3
   2536 000F0FA0                        PHN4
   2537 000F0FA0 66 26                   	or		r6,r6		; is number negative?
   2538 000F0FA2 04 AB                   	bpl		PHN5
   2539 000F0FA4 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2540 000F0FA8 82 4F 0C AF             	call	GOOUT
   2541 000F0FAC                        PHN5
   2542 000F0FAC FF 67                   	sub		r7,r7,#1
   2543 000F0FAE 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2544 000F0FB0 82 4F 08 AF             	call	GOOUT
   2545 000F0FB4 F4 4F 70 10             	cmp		r7,#NUMWKA
   2546 000F0FB8 F9 B7                   	bgtu	PHN5
   2547 000F0FBA                        PHNRET
   2548 000F0FBA E1 FF                   	lw		lr,[sp]
   2549 000F0FBC E5 F5                   	lw		r5,4[sp]
   2550 000F0FBE E9 F6                   	lw		r6,8[sp]
   2551 000F0FC0 00 40 ED F7             	lw		r7,12[sp]
   2552 000F0FC4 01 40 E1 F8             	lw		r8,16[sp]
   2553 000F0FC8 14 6E                   	add		sp,sp,#20
   2554 000F0FCA F0 80                   	ret
                                        
                                        
                                        ; r1 = pointer to line
                                        ; returns r1 = pointer to end of line + 1
   2559 000F0FCC                        PRTLN
   2560 000F0FCC F8 6E                       sub     sp,sp,#8
   2561 000F0FCE E1 DF                       sw      lr,[sp]
   2562 000F0FD0 E5 D5                       sw      r5,4[sp]
   2563 000F0FD2 12 15                       add     r5,r1,#2
   2564 000F0FD4 5E E1                       lb		r1,-2[r5]	; get the binary line number
   2565 000F0FD6 0E 21                       zxb		r1
   2566 000F0FD8 5F E2                       lb		r2,-1[r5]
   2567 000F0FDA 0E 22                       zxb		r2
   2568 000F0FDC 81 32                       shl		r2,#1
   2569 000F0FDE 81 32                       shl		r2,#1
   2570 000F0FE0 81 32                       shl		r2,#1
   2571 000F0FE2 81 32                       shl		r2,#1
   2572 000F0FE4 81 32                       shl		r2,#1
   2573 000F0FE6 81 32                       shl		r2,#1
   2574 000F0FE8 81 32                       shl		r2,#1
   2575 000F0FEA 81 32                       shl		r2,#1
   2576 000F0FEC 26 21                       or		r1,r2
   2577 000F0FEE 00 12                       lw      r2,#0       ; display a 0 or more digit line no.
   2578 000F0FF0 77 BF                   	call	PRTNUM
   2579 000F0FF2 02 40 00 11             	lw      r1,#' '     ; followed by a blank
   2580 000F0FF6 80 4F 05 AF             	call	GOOUT
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 44
tb.asm
   2581 000F0FFA 00 12                   	lw      r2,#0       ; stop char. is a zero
   2582 000F0FFC 50 11                   	lw      r1,r5
   2583 000F0FFE 26 BF                   	call    PRTSTG		; display the rest of the line
   2584 000F1000 E5 F5                   	lw      r5,4[sp]
   2585 000F1002 E1 FF                   	lw      lr,[sp]
   2586 000F1004 08 6E                   	add     sp,sp,#8
   2587 000F1006 F0 80                   	ret
                                        
                                        
                                        ; ===== Test text byte following the call to this subroutine. If it
                                        ;	equals the byte pointed to by r8, return to the code following
                                        ;	the call. If they are not equal, brnch to the point
                                        ;	indicated by the offset byte following the text byte.
                                        ;
                                        ; Registers Affected
                                        ;   r3,r8
                                        ; Returns
                                        ;	r8 = updated text pointer
                                        ;
   2600 000F1008                        TSTC
   2601 000F1008 F8 6E                   	sub		sp,sp,#8
   2602 000F100A E1 DF                   	sw		lr,[sp]
   2603 000F100C E5 D1                   	sw		r1,4[sp]
   2604 000F100E 31 AF                   	call	IGNBLK		; ignore leading blanks
   2605 000F1010 E1 FF                   	lw		lr,[sp]	; get the return address
   2606 000F1012 F0 E3                   	lb		r3,[lr]	; get the byte to compare
   2607 000F1014 80 E1                   	lb		r1,[r8]
   2608 000F1016 1D 23                   	cmp		r3,r1		; is it = to what r8 points to?
   2609 000F1018 05 A8                   	beq		TC1			; if so
                                        						; If not, add the second
   2611 000F101A F1 E3                   	lb		r3,1[lr]	; byte following the call to
   2612 000F101C 30 2F                   	add		lr,r3		; the return address.
   2613 000F101E E5 F1                   	lw		r1,4[sp]
   2614 000F1020 08 6E                   	add		sp,sp,#8
   2615 000F1022 F0 80                   	ret					; jump to the routine
   2616 000F1024                        TC1
   2617 000F1024 01 68                   	add		r8,r8,#1	; if equal, bump text pointer
   2618 000F1026 E5 F1                   	lw		r1,4[sp]
   2619 000F1028 08 6E                   	add     sp,sp,#8
   2620 000F102A F2 80                   	jmp		2[lr]		; Skip the 2 bytes following
                                        						; the call and continue.
                                        
                                        
                                        ; ===== See if the text pointed to by r8 is a number. If so,
                                        ;	return the number in r2 and the number of digits in r3,
                                        ;	else return zero in r2 and r3.
                                        ; Registers Affected
                                        ;   r1,r2,r3,r4
                                        ; Returns
                                        ; 	r1 = number
                                        ;	r2 = number of digits in number
                                        ;	r8 = updated text pointer
                                        ;
   2634 000F102C                        TSTNUM
   2635 000F102C FC 6E                   	sub		sp,sp,#4
   2636 000F102E E1 DF                   	sw		lr,[sp]
   2637 000F1030 20 AF                   	call	IGNBLK		; skip over blanks
   2638 000F1032 00 11                   	lw		r1,#0		; initialize return parameters
   2639 000F1034 00 12                   	lw		r2,#0
   2640 000F1036                        TN1
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 45
tb.asm
   2641 000F1036 80 E3                   	lb		r3,[r8]
   2642 000F1038 FD 4F 30 10             	cmp		r3,#'0'		; is it less than zero?
   2643 000F103C 17 A4                   	bltu	TSNMRET 	; if so, that's all
   2644 000F103E FC 4F 37 10             	cmp		r3,#'9'		; is it greater than nine?
   2645 000F1042 14 A7                   	bgtu	TSNMRET 	; if so, return
   2646 000F1044 33 53 33 F3 14 10       	cmp		r1,#214748364	; see if there's room for new digit
   2647 000F104A 05 A6                   	bleu	TN2
   2648 000F104C 52 51 0F 00 04 11       	lea		r1,msgNumTooBig
   2649 000F1052 E2 4F 06 AE             	br		ERROR		; if not, we've overflowd
   2650 000F1056                        TN2
   2651 000F1056 10 14                   	lw		r4,r1		; quickly multiply result by 10
   2652 000F1058 81 31                   	shl		r1,#1		; * 2
   2653 000F105A 81 31                   	shl		r1,#1		; * 4
   2654 000F105C 40 21                   	add		r1,r4		; * 5
   2655 000F105E 81 31                   	shl		r1,#1		; * 10
   2656 000F1060 01 68                   	add		r8,r8,#1	; adjust text pointer
   2657 000F1062 00 40 5F 33             	and		r3,#0xF		; add in the new digit
   2658 000F1066 30 21                   	add		r1,r3
   2659 000F1068 01 62                   	add		r2,r2,#1	; increment the no. of digits
   2660 000F106A E5 BE                   	br		TN1
   2661 000F106C                        TSNMRET
   2662 000F106C E1 FF                   	lw		lr,[sp]
   2663 000F106E 04 6E                   	add		sp,sp,#4
   2664 000F1070 F0 80                   	ret
                                        
                                        
                                        ;===== Skip over blanks in the text pointed to by r8.
                                        ;
                                        ; Registers Affected:
                                        ;	r8
                                        ; Returns
                                        ;	r8 = pointer updateded past any spaces or tabs
                                        ;
   2674 000F1072                        IGNBLK
   2675 000F1072 FC 6E                   	sub		sp,sp,#4
   2676 000F1074 E1 D1                   	sw		r1,[sp]
   2677 000F1076                        IGB2
   2678 000F1076 80 E1                   	lb		r1,[r8]			; get char
   2679 000F1078 FE 4F 10 10             	cmp		r1,#' '			; see if it's a space
   2680 000F107C 03 A8                   	beq		IGB1			; if so, swallow it
   2681 000F107E FF 4F 17 10             	cmp		r1,#'\t'		; or a tab
   2682 000F1082 02 A9                   	bne		IGBRET
   2683 000F1084                        IGB1
   2684 000F1084 01 68                   	add		r8,r8,#1		; increment the text pointer
   2685 000F1086 F7 BE                   	br		IGB2
   2686 000F1088                        IGBRET
   2687 000F1088 E1 F1                   	lw		r1,[sp]
   2688 000F108A 04 6E                   	add		sp,sp,#4
   2689 000F108C F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the line of text in the input buffer to upper
                                        ;	case (except for stuff between quotes).
                                        ;
                                        ; Registers Affected
                                        ;   r1,r3
                                        ; Returns
                                        ;	r8 = pointing to end of text in buffer
                                        ;
   2700 000F108E                        TOUPBUF
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 46
tb.asm
   2701 000F108E FC 6E                   	sub		sp,sp,#4
   2702 000F1090 E1 DF                   	sw		lr,[sp]
   2703 000F1092 0C 40 0C 18             	lea		r8,BUFFER	; set up text pointer
   2704 000F1096 00 13                   	lw		r3,#0		; clear quote flag
   2705 000F1098                        TOUPB1
   2706 000F1098 80 E1                   	lb		r1,[r8]		; get the next text char.
   2707 000F109A 01 68                   	add		r8,r8,#1
   2708 000F109C FF 4F 13 10             	cmp		r1,#CR		; is it end of line?
   2709 000F10A0 13 A8                   	beq		TOUPBRT 	; if so, return
   2710 000F10A2 FD 4F 1E 10             	cmp		r1,#'"'		; a double quote?
   2711 000F10A6 08 A8                   	beq		DOQUO
   2712 000F10A8 FD 4F 19 10             	cmp		r1,#''''	; or a single quote?
   2713 000F10AC 05 A8                   	beq		DOQUO
   2714 000F10AE 30 10                   	cmp		r3,#0		; inside quotes?
   2715 000F10B0 F3 B9                   	bne		TOUPB1		; if so, do the next one
   2716 000F10B2 0D AF                   	call	toUpper 	; convert to upper case
   2717 000F10B4 8F C1                   	sb		r1,-1[r8]	; store it
   2718 000F10B6 F0 BE                   	br		TOUPB1		; and go back for more
   2719 000F10B8                        DOQUO
   2720 000F10B8 30 10                   	cmp		r3,#0		; are we inside quotes?
   2721 000F10BA 02 A9                   	bne		DOQUO1
   2722 000F10BC 10 13                   	lw		r3,r1		; if not, toggle inside-quotes flag
   2723 000F10BE EC BE                   	br		TOUPB1
   2724 000F10C0                        DOQUO1
   2725 000F10C0 1D 23                   	cmp		r3,r1		; make sure we're ending proper quote
   2726 000F10C2 EA B9                   	bne		TOUPB1		; if not, ignore it
   2727 000F10C4 00 13                   	lw		r3,#0		; else clear quote flag
   2728 000F10C6 E8 BE                   	br		TOUPB1
   2729 000F10C8                        TOUPBRT
   2730 000F10C8 E1 FF                   	lw		lr,[sp]
   2731 000F10CA 04 6E                   	add		sp,sp,#4
   2732 000F10CC F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the character in r1 to upper case
                                        ;
   2737 000F10CE                        toUpper
   2738 000F10CE F9 4F 1F 10             	cmp		r1,#'a'		; is it < 'a'?
   2739 000F10D2 04 A0                   	blt	    TOUPRET
   2740 000F10D4 F8 4F 16 10             	cmp		r1,#'z'		; or > 'z'?
   2741 000F10D8 01 A3                   	bgt	    TOUPRET
   2742 000F10DA E0 61                   	sub		r1,r1,#32	; if not, make it upper case
   2743 000F10DC                        TOUPRET
   2744 000F10DC F0 80                   	ret
                                        
                                        
                                        ; 'CHKIO' checks the input. If there's no input, it will return
                                        ; to the caller with the Z flag set. If there is input, the Z
                                        ; flag is cleared and the input byte is in r2. However, if a
                                        ; control-C is read, 'CHKIO' will warm-start BASIC and will not
                                        ; return to the caller.
                                        ;
   2753 000F10DE                        CHKIO
   2754 000F10DE FC 6E                   	sub		sp,sp,#4	; save link reg
   2755 000F10E0 E1 DF                   	sw		lr,[sp]
   2756 000F10E2 79 4F 01 AF             	call	GOIN		; get input if possible
   2757 000F10E6 07 A8                   	beq		CHKRET2		; if Zero, no input
   2758 000F10E8 1D 10                   	cmp		r1,#CTRLC	; is it control-C?
   2759 000F10EA 02 A9                   	bne		CHKRET		; if not
   2760 000F10EC 7D 4F 09 AE             	jmp		WSTART		; if so, do a warm start
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 47
tb.asm
   2761 000F10F0                        CHKRET
   2762 000F10F0 E1 FF                   	lw		lr,[sp]
   2763 000F10F2 04 6E                   	add		sp,sp,#4	; Z=0
   2764 000F10F4 F0 80                   	ret
   2765 000F10F6                        CHKRET2
   2766 000F10F6 E1 FF                   	lw		lr,[sp]
   2767 000F10F8 04 6E                   	add		sp,sp,#4
   2768 000F10FA 00 11                   	lw		r1,#0		; Z=1
   2769 000F10FC F0 80                   	ret
                                        
                                        
                                        ; ===== Display a CR-LF sequence
                                        ;
   2774 000F10FE                        CRLF
   2775 000F10FE 50 51 0F 00 06 11       	lea		r1,CLMSG
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r4
                                        ;
   2782 000F1104                        PRMESG
   2783 000F1104 F8 6E                   	sub		sp,sp,#8
   2784 000F1106 E1 DF                   	sw		lr,[sp]
   2785 000F1108 E5 D5                   	sw		r5,4[sp]
   2786 000F110A 10 15                   	lw      r5,r1       ; r5 = pointer to message
   2787 000F110C                        PRMESG1
   2788 000F110C 01 65                   	add		r5,r5,#1
   2789 000F110E 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2790 000F1110 03 A8                   	beq		PRMRET
   2791 000F1112 77 4F 07 AF             	call	GOOUT		;else display it trashes r4
   2792 000F1116 FA BE                   	br		PRMESG1
   2793 000F1118                        PRMRET
   2794 000F1118 50 11                   	lw		r1,r5
   2795 000F111A E5 F5                   	lw		r5,4[sp]
   2796 000F111C E1 FF                   	lw		lr,[sp]
   2797 000F111E 08 6E                   	add		sp,sp,#8
   2798 000F1120 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r3
                                        ;
   2805 000F1122                        PRMESGAUX
   2806 000F1122 F8 6E                   	sub		sp,sp,#8
   2807 000F1124 E1 DF                   	sw		lr,[sp]
   2808 000F1126 E5 D5                   	sw		r5,4[sp]
   2809 000F1128 10 15                   	lw      r5,r1       ; r3 = pointer
   2810 000F112A                        PRMESGA1
   2811 000F112A 01 65                   	add		r5,r5,#1
   2812 000F112C 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2813 000F112E 03 A8                   	beq		PRMRETA
   2814 000F1130 76 4F 0C AF             	call	GOAUXO		;else display it
   2815 000F1134 FA BE                   	br		PRMESGA1
   2816 000F1136                        PRMRETA
   2817 000F1136 50 11                   	lw		r1,r5
   2818 000F1138 E5 F5                   	lw		r5,4[sp]
   2819 000F113A E1 FF                   	lw		lr,[sp]
   2820 000F113C 08 6E                   	add		sp,sp,#8
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 48
tb.asm
   2821 000F113E F0 80                   	ret
                                        
                                        ;*****************************************************
                                        ; The following routines are the only ones that need *
                                        ; to be changed for a different I/O environment.     *
                                        ;*****************************************************
                                        
                                        
                                        ; ===== Output character to the console (Port 1) from register D0
                                        ;	(Preserves all registers.)
                                        ;
   2832 000F1140                        OUTC
   2833 000F1140 1A AE                   	jmp		_putChar
                                        
                                        
                                        ; ===== Input a character from the console into register D0 (or
                                        ;	return Zero status if there's no character available).
                                        ;
   2839 000F1142                        INC
                                        
                                        ; get char from keyboard
                                        ; returns char in r1
   2843 000F1142                        _getChar
   2844 000F1142 C5 4D 02 F1             	lh		r1,KBD+2	; get keyboard strobe
   2845 000F1146 06 AB                   	bpl		gc1
   2846 000F1148 C5 4D 00 F1             	lh		r1,KBD		; get character and clear keyboard strobe
   2847 000F114C 03 AA                   	bmi		gc1			; was it a keyup event ? (ignore)
   2848 000F114E 07 40 5F 31             	and		r1,#0x7f
   2849 000F1152 F0 80                   	ret
   2850 000F1154                        gc1
   2851 000F1154 00 11                   	lw		r1,#0		; return Z=1 (no character)
   2852 000F1156 F0 80                   	ret
                                        
                                        
                                        ; get char from keyboard
                                        ; returns char in r1
   2857 000F1158                        _getCharWait
   2858 000F1158                        gc2
   2859 000F1158 C5 4D 02 F1             	lh		r1,KBD+2	; get keyboard strobe
   2860 000F115C FD BB                   	bpl		gc2
   2861 000F115E C5 4D 00 F1             	lh		r1,KBD		; get character and clear keyboard strobe
   2862 000F1162 FA BA                   	bmi		gc2			; was it a keyup event ? (ignore)
   2863 000F1164 07 40 5F 31             	and		r1,#0x7f
   2864 000F1168 F0 80                   	ret
                                        
                                        
                                        ; ===== Output character to the host (Port 2) from register r1
                                        ;	(Preserves all registers.)
                                        ;
   2870 000F116A                        AUXOUT
   2871 000F116A 34 57 F8 FF 0E AE       	jmp		putSerial	; call boot rom routine
                                        
                                        ;
                                        ; ===== Input a character from the host into register D0 (or
                                        ;	return negative status if there's no character available).
                                        ;
   2877 000F1170                        AUXIN
                                        ; get character from serial port
                                        ; return  N=1 if no character available
   2880 000F1170 34 57 F8 FF 09 AE       	jmp		peekSerial
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 49
tb.asm
                                        
                                        ; r1 = char to print
                                        
   2884 000F1176                        _putChar
   2885 000F1176 F4 6E                   	sub		sp,sp,#12
   2886 000F1178 E1 DF                   	sw		lr,[sp]
   2887 000F117A E5 D5                   	sw		r5,4[sp]
   2888 000F117C E9 D6                   	sw		r6,8[sp]
                                        
   2890 000F117E 07 40 5F 31             	and		r1,#0x7f	; mask to ascii
                                        
                                        	; first turn off any flashing cursor - it may be moved
   2893 000F1182 10 14                   	lw		r4,r1
   2894 000F1184 00 11                   	lw		r1,#0
   2895 000F1186 A8 AF                   	call	_flashCursor
   2896 000F1188 40 11                   	lw		r1,r4
                                        
                                        	; process carriage return
   2899 000F118A FF 4F 13 10             	cmp		r1,#CR		; carriage return ?
   2900 000F118E 0A A9                   	bne		pc1
   2901 000F1190 03 40 04 F1             	lh		r1,pos		; subtract X from position
   2902 000F1194 03 40 02 E4             	lb		r4,cursx
   2903 000F1198 42 21                   	sub		r1,r4
   2904 000F119A 03 40 04 D1             	sh		r1,pos
   2905 000F119E 03 40 02 C0             	sb		r0,cursx	; and set X to zero
   2906 000F11A2 72 AE                   	jmp		pc7
                                        
                                        	; process line feed
   2909 000F11A4                        pc1
   2910 000F11A4 FF 4F 16 10             	cmp		r1,#LF		; line feed ?
   2911 000F11A8 14 A9                   	bne		pc2
   2912 000F11AA 03 40 03 E1             	lb		r1,cursy	; past line 23 ?
   2913 000F11AE 03 40 01 E4             	lb		r4,txtHeight
   2914 000F11B2 FE 64                   	sub		r4,r4,#2
   2915 000F11B4 4D 21                   	cmp		r1,r4
   2916 000F11B6 02 A4                   	bltu	pc3			; if we are, then just scroll the screen
   2917 000F11B8 6F AF                   	call	_scrollScreen
   2918 000F11BA 66 AE                   	jmp		pc7
   2919 000F11BC                        pc3
   2920 000F11BC 01 61                   	add		r1,r1,#1	; increment Y
   2921 000F11BE 03 40 03 C1             	sb		r1,cursy
   2922 000F11C2 03 40 04 F1             	lh		r1,pos		; and the cursor position
   2923 000F11C6 03 40 00 E4             	lb		r4,txtWidth
   2924 000F11CA 40 21                   	add		r1,r4
   2925 000F11CC 03 40 04 D1             	sh		r1,pos
   2926 000F11D0 5B AE                   	jmp		pc7
                                        
                                        	; backspace
   2929 000F11D2                        pc2
   2930 000F11D2 FF 4F 18 10             	cmp		r1,#8		; backspace ?
   2931 000F11D6 22 A9                   	bne		pc4
   2932 000F11D8 03 40 02 E1             	lb		r1,cursx	; is cursor.x already zero ?
   2933 000F11DC 01 A9                   	bne		pc5			
   2934 000F11DE 54 AE                   	jmp		pc7			; can't backspace
   2935 000F11E0                        pc5
   2936 000F11E0 FF 61                   	sub		r1,r1,#1
   2937 000F11E2 03 40 02 C1             	sb		r1,cursx
   2938 000F11E6 03 40 04 F4             	lh		r4,pos
   2939 000F11EA FF 64                   	sub		r4,r4,#1
   2940 000F11EC 03 40 04 D4             	sh		r4,pos
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 50
tb.asm
                                        	; shift remaining characters on line over
   2942 000F11F0 81 34                   	shl		r4,#1		; r4 = n
   2943 000F11F2 81 34                   	shl		r4,#1		; r4 = n
   2944 000F11F4 00 41 00 16             	lw		r6,#VIDEORAM
   2945 000F11F8 40 26                   	add		r6,r4		; r6 = target pos
   2946 000F11FA 03 40 00 E4             	lb		r4,txtWidth
   2947 000F11FE FE 64                   	sub		r4,r4,#2
   2948 000F1200                        pc6
   2949 000F1200 65 F5                   	lw		r5,4[r6]	; shift next char
   2950 000F1202 61 D5                   	sw		r5,[r6]		; over to this one
   2951 000F1204 04 66                   	add		r6,r6,#4
   2952 000F1206 01 61                   	add		r1,r1,#1	; until X = 39
   2953 000F1208 4D 21                   	cmp		r1,r4
   2954 000F120A FA B4                   	bltu	pc6
                                        	; blank trailing character
   2956 000F120C 02 40 00 15             	lw		r5,#' '
   2957 000F1210 03 40 08 D5             	sh		r5,charToPrint
   2958 000F1214 03 40 09 F5             	lw		r5,charToPrint
   2959 000F1218 61 D5                   	sw		r5,[r6]
   2960 000F121A 36 AE                   	jmp		pc7
                                        
                                        	; control charater (non-printable)
   2963 000F121C                        pc4
   2964 000F121C FE 4F 10 10             	cmp		r1,#' '
   2965 000F1220 01 A5                   	bgeu	pc11
   2966 000F1222 32 AE                   	jmp		pc7
                                        
                                        
                                        	; some other character
                                        	; put the character to the screen, then advance cursor
   2971 000F1224                        pc11
   2972 000F1224 03 40 08 D1             	sh		r1,charToPrint
   2973 000F1228 00 41 00 14             	lw		r4,#VIDEORAM
   2974 000F122C 03 40 04 F5             	lh		r5,pos
   2975 000F1230 81 35                   	shl		r5,#1		; pos * 4
   2976 000F1232 81 35                   	shl		r5,#1		; pos * 4
   2977 000F1234 50 24                   	add		r4,r5		; scr[pos]
   2978 000F1236 03 40 09 F5             	lw		r5,charToPrint
   2979 000F123A 41 D5                   	sw		r5,[r4]		; = char
                                        	; advance cursor
   2981 000F123C 03 40 04 F5             	lh		r5,pos
   2982 000F1240 03 40 00 E1             	lb		r1,txtWidth
   2983 000F1244 FE 61                   	sub		r1,r1,#2
   2984 000F1246 03 40 02 E4             	lb		r4,cursx
   2985 000F124A 1D 24                   	cmp		r4,r1		; would we be at end of line ?
   2986 000F124C 17 A6                   	bleu	pc8
   2987 000F124E 42 25                   	sub		r5,r4		; pos -= cursx
   2988 000F1250 03 40 04 D5             	sh		r5,pos
   2989 000F1254 03 40 02 C0             	sb		r0,cursx	; cursor.x = 0
   2990 000F1258 03 40 03 E4             	lb		r4,cursy
   2991 000F125C 03 40 01 E1             	lb		r1,txtHeight
   2992 000F1260 FE 61                   	sub		r1,r1,#2
   2993 000F1262 1D 24                   	cmp		r4,r1		; at last line of screen ?
   2994 000F1264 02 A6                   	bleu	pc9
   2995 000F1266 18 AF                   	call	_scrollScreen	; yes, scroll
   2996 000F1268 0F AE                   	br		pc7
   2997 000F126A                        pc9
   2998 000F126A 01 64                   	add		r4,r4,#1	; cursor.y++
   2999 000F126C 03 40 03 C4             	sb		r4,cursy
   3000 000F1270 03 40 00 E1             	lb		r1,txtWidth
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 51
tb.asm
   3001 000F1274 10 25                   	add		r5,r1		; pos += txtWidth
   3002 000F1276 03 40 04 D5             	sh		r5,pos
   3003 000F127A 06 AE                   	br		pc7
   3004 000F127C                        pc8						; not at EOL
   3005 000F127C 01 64                   	add		r4,r4,#1	; cursor.x++
   3006 000F127E 03 40 02 C4             	sb		r4,cursx
   3007 000F1282 01 65                   	add		r5,r5,#1	; pos++
   3008 000F1284 03 40 04 D5             	sh		r5,pos
                                        
   3010 000F1288                        pc7
   3011 000F1288 03 40 0C E1             	lb		r1,cursFlash	; flash or don't flash the cursor
   3012 000F128C 25 AF                   	call	_flashCursor
   3013 000F128E E1 FF                   	lw		lr,[sp]
   3014 000F1290 E5 F5                   	lw		r5,4[sp]
   3015 000F1292 E9 F6                   	lw		r6,8[sp]
   3016 000F1294 0C 6E                   	add		sp,sp,#12
   3017 000F1296 F0 80                   	ret
                                        
                                        
   3020 000F1298                        _scrollScreen
   3021 000F1298 FC 6E                   	sub		sp,sp,#4
   3022 000F129A E1 D5                   	sw		r5,[sp]
   3023 000F129C 60 40 00 13             	lw		r3,#1536	; number of chars to move - 1
   3024 000F12A0 00 41 00 12             	lw		r2,#VIDEORAM
   3025 000F12A4 03 40 00 E1             	lb		r1,txtWidth
   3026 000F12A8 81 31                   	shl		r1,#1
   3027 000F12AA 81 31                   	shl		r1,#1
   3028 000F12AC                        ss1:
   3029 000F12AC 20 15                   	lw		r5,r2
   3030 000F12AE 10 25                   	add		r5,r1
   3031 000F12B0 51 F4                   	lw		r4,[r5]		; char at next line
   3032 000F12B2 21 D4                   	sw		r4,[r2]		; goes to this line
   3033 000F12B4 04 62                   	add		r2,r2,#4
   3034 000F12B6 FF 63                   	sub		r3,r3,#1
   3035 000F12B8 F9 B9                   	bne     ss1
                                        	; blank out last line
   3037 000F12BA 02 40 00 13             	lw		r3,#' '
   3038 000F12BE 03 40 08 D3             	sh		r3,charToPrint
   3039 000F12C2 03 40 00 E3             	lb		r3,txtWidth
   3040 000F12C6 03 40 09 F4             	lw		r4,charToPrint	; and colors
   3041 000F12CA                        ss2
   3042 000F12CA 21 D4                   	sw		r4,[r2]
   3043 000F12CC 04 62                   	add		r2,r2,#4
   3044 000F12CE FF 63                   	sub		r3,r3,#1
   3045 000F12D0 FC B9                   	bne     ss2
   3046 000F12D2 E1 F5                   	lw		r5,[sp]
   3047 000F12D4 04 6E                   	add		sp,sp,#4
   3048 000F12D6 F0 80                   	ret
                                        
                                        
                                        ; flash the character at the screen position
                                        ;   r1: 1 = flash, 0 = no flash
   3053 000F12D8                        _flashCursor
   3054 000F12D8 00 41 00 12             	lw		r2,#VIDEORAM
   3055 000F12DC 03 40 04 F3             	lh		r3,pos
   3056 000F12E0 81 33                   	shl		r3,#1
   3057 000F12E2 81 33                   	shl		r3,#1
   3058 000F12E4 20 23                   	add		r3,r2		; r3 = scr[pos]
                                        
   3060 000F12E6 16 21                   	or		r1,r1
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 52
tb.asm
   3061 000F12E8 04 A8                   	beq		fc1
   3062 000F12EA 33 E2                   	lb		r2,3[r3]	; get background color
   3063 000F12EC 08 40 60 32             	or		r2,#0x80	; set flash indicator
   3064 000F12F0 03 AE                   	br		fcx
   3065 000F12F2                        fc1
   3066 000F12F2 33 E2                   	lb		r2,3[r3]	; get background color
   3067 000F12F4 07 40 5F 32             	and		r2,#0x7f	; clear flash indicator
   3068 000F12F8                        fcx:
   3069 000F12F8 33 C2                   	sb		r2,3[r3]
   3070 000F12FA F0 80                   	ret
                                        
                                        
   3073 000F12FC                        _cls
   3074 000F12FC 29 57 F8 FF 05 AF       	call	clearScreen
   3075 000F1302 89 4F 07 AE             	br		FINISH
                                        
                                        
                                        ;_clearScreen
                                        ;	lw		r3,#1680    ; number of chars to clear
                                        ;	lw		r2,VIC+4
                                        ;
                                        ;	lw		r4,#' '
                                        ;	sh		r4,charToPrint
                                        ;	lw		r4,charToPrint
                                        ;cls1
                                        ;	sw		r4,[r2]
                                        ;
                                        ;	add		r2,r2,#4
                                        ;	sub		r3,r3,#1
                                        ;	bne     cls1
                                        ;
                                        ;	sb		r0,cursx	; reset cursor position
                                        ;	sb		r0,cursy
                                        ;	sh		r0,pos
                                        ;
                                        ;	ret
                                        ;
                                        
   3099 000F1306                        _wait10
   3100 000F1306 20 00                   	nop
   3101 000F1308 20 00                   	nop
   3102 000F130A 20 00                   	nop
   3103 000F130C 20 00                   	nop
   3104 000F130E 20 00                   	nop
   3105 000F1310 20 00                   	nop
   3106 000F1312 20 00                   	nop
   3107 000F1314 20 00                   	nop
   3108 000F1316 20 00                   	nop
   3109 000F1318 20 00                   	nop
   3110 000F131A F0 80                   	ret
                                        
                                        
   3113 000F131C                        _getATAStatus
   3114 000F131C FC 6E                   	sub		sp,sp,#4
   3115 000F131E E1 DF                   	sw		lr,[sp]
   3116 000F1320                        gas1
   3117 000F1320 ED 4F 0D AF             	call	CHKIO
   3118 000F1324 CD 4D 0E E1             	lb		r1,ATA+30	; "prefetch" read status reg
   3119 000F1328 EE BF                   	call	_wait10		; wait 10 clocks
   3120 000F132A CC 4D 04 E1             	lb		r1,ATA+4	; now *really* read the status reg
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 53
tb.asm
   3121 000F132E F8 BA                   	bmi		gas1		; BSY=0 and
   3122 000F1330 E1 FF                   	lw		lr,[sp]
   3123 000F1332 04 6E                   	add		sp,sp,#4
   3124 000F1334 F0 80                   	ret
                                        
   3126 000F1336                        	
   3127 000F1336 FC 6E                   	sub		sp,sp,#4
   3128 000F1338 E1 DF                   	sw		lr,[sp]
   3129 000F133A                        wcf1
   3130 000F133A F0 BF                   	call	_getATAStatus
   3131 000F133C 04 40 50 31             	and		r1,#0x40	; DRDY=1
   3132 000F1340 FC B8                   	beq		wcf1
   3133 000F1342 E1 FF                   	lw		lr,[sp]
   3134 000F1344 04 6E                   	add		sp,sp,#4
   3135 000F1346 F0 80                   	ret
                                        
                                        
   3138 000F1348                        _rdcf
   3139 000F1348 A4 4F 0C AF             	call	OREXPR		; get the linear block address
   3140 000F134C 10 15                   	lw		r5,r1
   3141 000F134E F3 BF                   	call	_waitCFNotBusy
   3142 000F1350 09 40 01 11             	lw		r1,#0x91	; IDEInitDriveParamCmd
   3143 000F1354 CD 4D 0E D1             	sh		r1,ATA+30
   3144 000F1358 04 40 01 11             	lw		r1,#'A'
   3145 000F135C 65 4F 02 AF             	call	GOOUT
   3146 000F1360 D2 BF                   	call	_wait10
   3147 000F1362 E9 BF                   	call	_waitCFNotBusy
                                        	; set LBA mode, select device 0 (master)
   3149 000F1364 0E 40 00 11             	lw		r1,#0xe0	; SelectMasterLBA
   3150 000F1368 CD 4D 0C D1             	sh		r1,ATA+28	; write device/head register
   3151 000F136C 04 40 02 11             	lw		r1,#'B'
   3152 000F1370 64 4F 08 AF             	call	GOOUT
   3153 000F1374 C8 BF                   	call	_wait10
                                        	; disable device interrupt requests INTRQ; set and reset SRST
   3155 000F1376 06 11                   	lw		r1,#6		; AlterStatusSoftRst
   3156 000F1378 CC 4D 0C D1             	sh		r1,ATA+12	; write AlternateStatusRegister
   3157 000F137C 04 40 03 11             	lw		r1,#'C'
   3158 000F1380 64 4F 00 AF             	call	GOOUT
   3159 000F1384 C0 BF                   	call	_wait10
   3160 000F1386 02 11                   	lw		r1,#2		; AlterStatusSoftRst
   3161 000F1388 CC 4D 0C D1             	sh		r1,ATA+12	; write AlternateStatusRegister
   3162 000F138C 04 40 04 11             	lw		r1,#'D'
   3163 000F1390 63 4F 08 AF             	call	GOOUT
   3164 000F1394 B8 BF                   	call	_wait10
   3165 000F1396 CF BF                   	call	_waitCFNotBusy
                                        
                                        	; set LBA mode, select device 0 (master)
   3168 000F1398 04 40 05 11             	lw		r1,#'E'
   3169 000F139C 63 4F 02 AF             	call	GOOUT
   3170 000F13A0 0E 40 00 11             	lw		r1,#0xe0	; SelectMasterLBA
   3171 000F13A4 CD 4D 0C D1             	sh		r1,ATA+28	; write device/head register
   3172 000F13A8 AE BF                   	call	_wait10
   3173 000F13AA 04 40 06 11             	lw		r1,#'F'
   3174 000F13AE 62 4F 09 AF             	call	GOOUT
   3175 000F13B2 21 AE                   	br		rdcf6
                                        
                                        	; this little section of code issues an "identify drive"
                                        	; command. Useful for testing the interface to get it
                                        	; working
   3180 000F13B4 0E 40 0C 11             	lw		r1,#0xec	; identify drive command
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 54
tb.asm
   3181 000F13B8 CD 4D 0E D1             	sh		r1,ATA+30
   3182 000F13BC A4 BF                   	call	_wait10
                                        
   3184 000F13BE                        rdcf4
   3185 000F13BE AE BF                   	call	_getATAStatus	; wait for device to be ready
   3186 000F13C0 58 31                   	and		r1,#8		; check the DRQ bit
   3187 000F13C2 FD B8                   	beq		rdcf4
                                        
   3189 000F13C4 10 40 00 15             	lw		r5,#256
   3190 000F13C8                        rdcf5
   3191 000F13C8 CD 4D 00 F1             	lh		r1,ATA+16
   3192 000F13CC 9C BF                   	call	_wait10
   3193 000F13CE CC 4D 04 F1             	lh		r1,ATA+4
   3194 000F13D2 10 16                   	lw		r6,r1
   3195 000F13D4 A1 31                   	shr		r1,#1
   3196 000F13D6 A1 31                   	shr		r1,#1
   3197 000F13D8 A1 31                   	shr		r1,#1
   3198 000F13DA A1 31                   	shr		r1,#1
   3199 000F13DC A1 31                   	shr		r1,#1
   3200 000F13DE A1 31                   	shr		r1,#1
   3201 000F13E0 A1 31                   	shr		r1,#1
   3202 000F13E2 A1 31                   	shr		r1,#1
   3203 000F13E4 60 4F 0E AF             	call	GOOUT
   3204 000F13E8 60 11                   	lw		r1,r6
   3205 000F13EA 60 4F 0B AF             	call	GOOUT
   3206 000F13EE FF 65                   	sub		r5,r5,#1
   3207 000F13F0 EB B9                   	bne		rdcf5
   3208 000F13F2 81 4F 0F AE             	br		FINISH
                                        
                                        
   3211 000F13F6                        rdcf6
                                        	; set sector count to one
   3213 000F13F6 01 11                   	lw		r1,#1
   3214 000F13F8 CD 4D 04 D1             	sh		r1,ATA+20	; sector count reg
   3215 000F13FC 04 40 07 11             	lw		r1,#'G'
   3216 000F1400 60 4F 00 AF             	call	GOOUT
   3217 000F1404 80 BF                   	call	_wait10
   3218 000F1406 CD 4D 08 D5             	sh		r5,ATA+24	; cylinder low reg (LBA low)
   3219 000F140A 04 40 08 11             	lw		r1,#'H'
   3220 000F140E 5F 4F 09 AF             	call	GOOUT
   3221 000F1412 A1 35                   	shr		r5,#1		; wait 10 cycles - shifts do it
   3222 000F1414 A1 35                   	shr		r5,#1
   3223 000F1416 A1 35                   	shr		r5,#1
   3224 000F1418 A1 35                   	shr		r5,#1
   3225 000F141A A1 35                   	shr		r5,#1
   3226 000F141C A1 35                   	shr		r5,#1
   3227 000F141E A1 35                   	shr		r5,#1
   3228 000F1420 A1 35                   	shr		r5,#1
   3229 000F1422 A1 35                   	shr		r5,#1
   3230 000F1424 A1 35                   	shr		r5,#1
   3231 000F1426 A1 35                   	shr		r5,#1
   3232 000F1428 A1 35                   	shr		r5,#1
   3233 000F142A A1 35                   	shr		r5,#1
   3234 000F142C A1 35                   	shr		r5,#1
   3235 000F142E A1 35                   	shr		r5,#1
   3236 000F1430 A1 35                   	shr		r5,#1
   3237 000F1432 CD 4D 0A D5             	sh		r5,ATA+26	; cylinder high (LBA high)
   3238 000F1436 04 40 09 11             	lw		r1,#'I'
   3239 000F143A 5E 4F 03 AF             	call	GOOUT
   3240 000F143E 0E 40 00 11             	lw		r1,#0xe0
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 55
tb.asm
   3241 000F1442 CD 4D 0C D1             	sh		r1,ATA+28	; write to device head reg
   3242 000F1446 04 40 0A 11             	lw		r1,#'J'
   3243 000F144A 5D 4F 0B AF             	call	GOOUT
   3244 000F144E 5B BF                   	call	_wait10
   3245 000F1450 02 40 00 11             	lw		r1,#0x20	; IDE "read" command (read sectors with retry)
   3246 000F1454 CD 4D 0E D1             	sh		r1,ATA+30	; write to status/command reg
   3247 000F1458 04 40 0B 11             	lw		r1,#'K'
   3248 000F145C 5D 4F 02 AF             	call	GOOUT
   3249 000F1460 52 BF                   	call	_wait10
   3250 000F1462                        rdcf1
   3251 000F1462 04 40 0C 11             	lw		r1,#'L'
   3252 000F1466 5C 4F 0D AF             	call	GOOUT
   3253 000F146A 58 BF                   	call	_getATAStatus	; wait for device to be ready
   3254 000F146C 58 31                   	and		r1,#8		; check the DRQ bit
   3255 000F146E F9 B8                   	beq		rdcf1
   3256 000F1470 10 40 00 15             	lw		r5,#256
   3257 000F1474                        rdcf2
   3258 000F1474 04 40 0D 11             	lw		r1,#'M'
   3259 000F1478 5C 4F 04 AF             	call	GOOUT
   3260 000F147C 4F BF                   	call	_getATAStatus	; wait for device to be ready
   3261 000F147E 58 31                   	and		r1,#8		; check DRQ bit
   3262 000F1480 0A A8                   	beq		rdcf3
                                        	; read 256 half-words from the data reg
   3264 000F1482 CD 4D 00 F1             	lh		r1,ATA+16	; read data reg
   3265 000F1486 3F BF                   	call	_wait10
   3266 000F1488 CC 4D 04 F1             	lh		r1,ATA+4
   3267 000F148C 05 12                   	lw		r2,#5
   3268 000F148E D5 4F 0A AF             	call	PRTHEXNUM	; print the data out
   3269 000F1492 FF 65                   	sub		r5,r5,#1
   3270 000F1494 EF B9                   	bne		rdcf2
   3271 000F1496                        rdcf3
   3272 000F1496 04 40 0E 11             	lw		r1,#'N'
   3273 000F149A 5B 4F 03 AF             	call	GOOUT
   3274 000F149E 3E BF                   	call	_getATAStatus	; wait for device to be ready
   3275 000F14A0 51 31                   	and		r1,#1		; check for error
   3276 000F14A2 7C 4F 07 A8             	beq		FINISH
   3277 000F14A6 50 51 0F 00 09 11       	lea		r1,msgReadError
   3278 000F14AC BF 4F 09 AE             	br		ERROR
                                        
                                        
                                        ; ===== Return to the resident monitor, operating system, etc.
                                        ;
   3283 000F14B0                        BYEBYE
   3284 000F14B0 08 40 05 FE             	lw		sp,OSSP
   3285 000F14B4 E1 FF                       lw      lr,[sp]
   3286 000F14B6 04 6E                       add		sp,sp,#4
   3287 000F14B8 F0 80                   	ret
                                        
                                        ;	MOVE.B	#228,D7 	return to Tutor
                                        ;	TRAP	#14
                                        
   3292 000F14BA 0D 0A 42 75 74 74      msgInit db	CR,LF,"Butterfly Tiny BASIC v1.0",CR,LF,"(C) 2005  Robert Finch",CR,LF,LF,0
   3292 000F14C0 65 72 66 6C 79 20 54  
   3292 000F14C7 69 6E 79 20 42 41 53  
   3292 000F14CE 49 43 20 76 31 2E 30  
   3292 000F14D5 0D 0A 28 43 29 20 32  
   3292 000F14DC 30 30 35 20 20 52 6F  
   3292 000F14E3 62 65 72 74 20 46 69  
   3292 000F14EA 6E 63 68 0D 0A 0A 00  
                                      
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 56
tb.asm
   3293 000F14F1 0D 0A 4F 4B 0D 0A      OKMSG	db	CR,LF,"OK",CR,LF,0
   3293 000F14F7 00                    
   3294 000F14F8 57 68 61 74 3F 0D      msgWhat	db	"What?",CR,LF,0
   3294 000F14FE 0A 00                 
   3295 000F1500 53 6F 72 72 79 2E      SRYMSG	db	"Sorry."
                                      
   3296 000F1506 0D 0A 00               CLMSG	db	CR,LF,0
   3297 000F1509 43 6F 6D 70 61 63      msgReadError	db	"Compact FLASH read error",CR,LF,0
   3297 000F150F 74 20 46 4C 41 53 48  
   3297 000F1516 20 72 65 61 64 20 65  
   3297 000F151D 72 72 6F 72 0D 0A 00  
                                      
   3298 000F1524 4E 75 6D 62 65 72      msgNumTooBig	db	"Number is too big",CR,LF,0
   3298 000F152A 20 69 73 20 74 6F 6F  
   3298 000F1531 20 62 69 67 0D 0A 00  
                                      
   3299 000F1538 44 69 76 69 73 69      msgDivZero		db	"Division by zero",CR,LF,0
   3299 000F153E 6F 6E 20 62 79 20 7A  
   3299 000F1545 65 72 6F 0D 0A 00     
   3300 000F154B 4F 75 74 20 6F 66      msgVarSpace     db  "Out of variable space",CR,LF,0
   3300 000F1551 20 76 61 72 69 61 62  
   3300 000F1558 6C 65 20 73 70 61 63  
   3300 000F155F 65 0D 0A 00           
   3301 000F1563 20 62 79 74 65 73      msgBytesFree	db	" bytes free",CR,LF,0
   3301 000F1569 20 66 72 65 65 0D 0A  
   3301 000F1570 00                    
   3302 000F1571 0D 0A 52 65 61 64      msgReady		db	CR,LF,"Ready",CR,LF,0
   3302 000F1577 79 0D 0A 00           
   3303 000F157B 45 78 70 65 63 74      msgComma		db	"Expecting a comma",CR,LF,0
   3303 000F1581 69 6E 67 20 61 20 63  
   3303 000F1588 6F 6D 6D 61 0D 0A 00  
                                      
   3304 000F158F 4C 69 6E 65 20 6E      msgLineRange	db	"Line number too big",CR,LF,0
   3304 000F1595 75 6D 62 65 72 20 74  
   3304 000F159C 6F 6F 20 62 69 67 0D  
   3304 000F15A3 0A 00                 
   3305 000F15A5 45 78 70 65 63 74      msgVar			db	"Expecting a variable",CR,LF,0
   3305 000F15AB 69 6E 67 20 61 20 76  
   3305 000F15B2 61 72 69 61 62 6C 65  
   3305 000F15B9 0D 0A 00              
   3306 000F15BC 52 4E 44 20 62 61      msgRNDBad		db	"RND bad parameter",CR,LF,0
   3306 000F15C2 64 20 70 61 72 61 6D  
   3306 000F15C9 65 74 65 72 0D 0A 00  
                                      
   3307 000F15D0 53 59 53 20 62 61      msgSYSBad		db	"SYS bad address",CR,LF,0
   3307 000F15D6 64 20 61 64 64 72 65  
   3307 000F15DD 73 73 0D 0A 00        
   3308 000F15E2 49 4E 50 55 54 20      msgInputVar		db	"INPUT expecting a variable",CR,LF,0
   3308 000F15E8 65 78 70 65 63 74 69  
   3308 000F15EF 6E 67 20 61 20 76 61  
   3308 000F15F6 72 69 61 62 6C 65 0D  
   3308 000F15FD 0A 00                 
   3309 000F15FF 4E 45 58 54 20 77      msgNextFor		db	"NEXT without FOR",CR,LF,0
   3309 000F1605 69 74 68 6F 75 74 20  
   3309 000F160C 46 4F 52 0D 0A 00     
   3310 000F1612 4E 45 58 54 20 65      msgNextVar		db	"NEXT expecting a defined variable",CR,LF,0
   3310 000F1618 78 70 65 63 74 69 6E  
   3310 000F161F 67 20 61 20 64 65 66  
   3310 000F1626 69 6E 65 64 20 76 61  
   3310 000F162D 72 69 61 62 6C 65 0D  
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 57
tb.asm
   3310 000F1634 0A 00                 
   3311 000F1636 47 4F 54 4F 2F 47      msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LF,0
   3311 000F163C 4F 53 55 42 20 62 61  
   3311 000F1643 64 20 6C 69 6E 65 20  
   3311 000F164A 6E 75 6D 62 65 72 0D  
   3311 000F1651 0A 00                 
   3312 000F1653 52 45 54 55 52 4E      msgRetWoGosub   db	"RETURN without GOSUB",CR,LF,0
   3312 000F1659 20 77 69 74 68 6F 75  
   3312 000F1660 74 20 47 4F 53 55 42  
   3312 000F1667 0D 0A 00              
   3313 000F166A 50 72 6F 67 72 61      msgTooBig		db	"Program is too big",CR,LF,0
   3313 000F1670 6D 20 69 73 20 74 6F  
   3313 000F1677 6F 20 62 69 67 0D 0A  
   3313 000F167E 00                    
   3314 000F167F 45 78 74 72 61 20      msgExtraChars	db	"Extra characters on line ignored",CR,LF,0
   3314 000F1685 63 68 61 72 61 63 74  
   3314 000F168C 65 72 73 20 6F 6E 20  
   3314 000F1693 6C 69 6E 65 20 69 67  
   3314 000F169A 6E 6F 72 65 64 0D 0A  
   3314 000F16A1 00                    
                                        
   3316 000F16A2 FF FF                   	.align	4
   3382 = 000F16A4                      LSTROM	equ	*		; end of possible ROM area
                                        ;
                                        ; Internal variables follow:
                                        ;
                                        		bss
                                        		org		0x0030
   3323 00000030                        txtWidth	db	0		; BIOS var =60
   3324 00000031                        txtHeight	db	0		; BIOS var =27
   3325 00000032                        cursx	db		0		; cursor x position
   3326 00000033                        cursy	db		0		; cursor y position
   3327 00000034                        pos		dh		0		; text screen position
                                        		org		0x0038
   3329 00000038                        charToPrint		dh		0
   3330 0000003A                        fgColor			db		0
   3331 0000003B                        bkColor			db		0
   3332 0000003C                        cursFlash		db		0	; flash the cursor ?
                                        
   3334 0000003D                        lineLinkTbl		fill.b	25,0	; screen line link table
   3335 00000056                         	align 4
                                        
                                        		org		0x0080
   3338 00000080                        typef   db      0   ; variable / expression type
   3339 00000081                                 align   4
   3340 00000084                        OSSP	dw	1	; OS value of sp
   3341 00000088                        CURRNT	dw	1	;	Current line pointer
   3342 0000008C                        STKGOS	dw	1	;	Saves stack pointer in 'GOSUB'
   3343 00000090                        STKINP	dw	1	;	Saves stack pointer during 'INPUT'
   3344 00000094                        LOPVAR	dw	1	;	'FOR' loop save area
   3345 00000098                        LOPINC	dw	1	;	increment
   3346 0000009C                        LOPLMT	dw	1	;	limit
   3347 000000A0                        LOPLN	dw	1	;	line number
   3348 000000A4                        LOPPT	dw	1	;	text pointer
   3349 000000A8                        TXTUNF	dw	1	;	points to unfilled text area
   3350 000000AC                        VARBGN	dw	1	;	points to variable area
   3351 000000B0                        IVARBGN dw  1   ;   points to integer variable area
   3352 000000B4                        SVARBGN dw  1   ;   points to string variable area
   3353 000000B8                        FVARBGN dw  1   ;   points to float variable area
   3354 000000BC                        STKBOT	dw	1	;	holds lower limit for stack growth
Bird Computer Butterfly assembler   version 1.0.2   Mon Jun 12 18:20:31 2017     Page 58
tb.asm
   3355 000000C0                        NUMWKA	fill.b	12,0			; numeric work area
   3356 000000CC                        BUFFER	fill.b	BUFLEN,0x00		;		Keyboard input buffer
                                        
                                                bss
                                                org     0x1000
   3360 00001000                        textScr1
                                                org     0x2000
   3362 00002000                        textScr2
                                                org     0x3000
   3429 = 00003000                      TXT		equ	*		; Beginning of program area
                                        ;	END
