                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_UNDEAD   EQU   64
                        	TS_RUNNING	EQU		128
                        	
                        	AS_NONE     EQU   0
                        	AS_LIVE     EQU   1
                        	AS_DEAD     EQU   2
                        	AS_UNDEAD   EQU   4
                        	
                        	PRI_NORMAL  EQU   2
                        	PRI_LOW     EQU   3
                        	
                        	OST_WHITE   EQU   0
                        	OST_GREY    EQU   1
                        	OST_BLACK   EQU   2
                        	OST_UNDEAD  EQU   64    ; no longer alive, but not dead yet (finalizer hasn't been called)
                        	OST_DEAD    EQU   128   ; completely dead, finalizer called already
                        	
                        	TCB_MAGIC     EQU   ((' ' << 24) | ('T' << 16) | ('C' << 8) | 'B')
ACB_MAGIC     EQU   ((' ' << 24) | ('A' << 16) | ('C' << 8) | 'B')
MSG_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('S' << 8) | 'G')
MBX_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('B' << 8) | 'X')

                        	UNDEADQ     EQU   7
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_Func  =   0x02
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadDCBOffset = 0x1A
                        	E_Busy = 0x1B
                        	E_BadAppId = 0x1C
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	E_BadTcbPointer = 0x27
                        	E_BadTid = 0x28
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	= 0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMoreAppIds = 0x46
                        	E_NoMem = 0x47
                        	
                        	CSR_SATP		= $180
                        	CSR_MSTATUS = $300
                        	CSR_MEPC    = $341
                        	CSR_TRACECTRL = $7A0
                        	CSR_REGSET  = $7C0
                        	CSR_MSEMA   = $7C1
                        	CSR_TASKID  = $7C2
                        	CSR_RSSTACK = $7C3
                        	CSR_PMSTACK = $7C4
                        	CSR_IMSTACK = $7C5
                        	TCBPTR_MASK = $FFF803FF
                        	
                        	; Message types
                        	MT_ANNOUNCE = $00000010
                        	MT_IRQ      = $FFFFFFFF
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/types.r5a",1
                        	.file "../fmtk/types.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	OBJMagic    EQU   0
                        	OBJSize     EQU   8
                        	OBJTypenum  EQU   16
                        	OBJID       EQU   20
                        	OBJState    EQU   24    ; WHITE, GREY, BLACK
                        	OBJScavcnt  EQU   25    ; scavange count
                        	OBJOwningMap  EQU   26
                        	OBJPad1       EQU   27
                        	OBJCollectionIndex  EQU   28
                        	OBJUsedInMap  EQU   32    ; used in map
                        	OBJPad3       EQU   36
                        	OBJFWAddr     EQU   40    ; forwarding address
                        	OBJFinalizer  EQU   48
                        	OBJ_SIZE      EQU   64
                        	
                        	; Task Control Block
                        	TCBObject   EQU   $000    ; Object structure, state
                        	TCBIntRegs  EQU   $040    ; integer register set storage area (room for 64-bit)
                        	TCBxRA      EQU   $048
                        	TCBxSP      EQU   $050
                        	TCBxGP      EQU   $058
                        	TCBxTP      EQU   $060
                        	TCBxT0      EQU   $068
                        	TCBxT1      EQU   $070
                        	TCBxT2      EQU   $078
                        	TCBxFP      EQU   $080
                        	TCBxS1      EQU   $088
                        	TCBxA0      EQU   $090
                        	TCBxA1      EQU   $098
                        	TCBxA2      EQU   $0A0
                        	TCBxA3      EQU   $0A8
                        	TCBxA4      EQU   $0B0
                        	TCBxA5      EQU   $0B8
                        	TCBxA6      EQU   $0C0
                        	TCBxA7      EQU   $0C8
                        	TCBxS2      EQU   $0D0
                        	TCBxS3      EQU   $0D8
                        	TCBxS4      EQU   $0E0
                        	TCBxS5      EQU   $0E8
                        	TCBxS6      EQU   $0F0
                        	TCBxS7      EQU   $0F8
                        	TCBxS8      EQU   $100
                        	TCBxS9      EQU   $108
                        	TCBxS10     EQU   $110
                        	TCBxS11     EQU   $118
                        	TCBxT3      EQU   $120
                        	TCBxT4      EQU   $128
                        	TCBxT5      EQU   $130
                        	TCBxT6      EQU   $138
                        	TCBFltRegs  EQU   $140    ; float register set storage area
                        	TCBRegsEnd  EQU   $240
                        	; First 128 bytes are for integer register set
                        	; Second 128 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBbases  	EQU		$240		; base register storage
                        	TCBepc  		EQU		$2C0
                        	TCBStatus		EQU		$2C8
                        	TCBPriority	EQU		$2C9
                        	TCBWaitMbx	EQU		$2CA
                        	TCBRegset   EQU   $2CC
                        	TCBHasFocus EQU   $2CD
                        	TCBStackBot	EQU		$2D0
                        	TCBMsgD1		EQU		$2D8
                        	TCBMsgD2		EQU		$2E0
                        	TCBMsgD3		EQU		$2E8
                        	TCBStartTick	EQU	$2D0
                        	TCBEndTick	EQU		$2D8
                        	TCBTicks		EQU		$300
                        	TCBException	EQU	$308
                        	TCBNext			EQU		$310
                        	TCBPrev			EQU		$318
                        	TCBTimeout	EQU		$320
                        	TCBtid      EQU   $338
                        	TCBmid      EQU   $340
                        	TCBappid    EQU   $342
                        	TCBOpMode   EQU   $344
                        	TCBImMask		EQU		$345
                        	TCBMbxNext  EQU   $348
                        	TCBMbxPrev  EQU   $350
                        	TCBTaskNum  EQU   $358
                        	TCBName			EQU		$360
                        	
                        	; Application Control Block
                        	ACBObject     EQU   0
                        	ACBpData      EQU   64
                        	ACBDataSize   EQU   72
                        	ACBpUIData    EQU   80
                        	ACBUIDataSize EQU   88
                        	ACBGCRoots    EQU   96
                        	ACBGCRootCnt  EQU   104
                        	ACBGCNdx      EQU   112
                        	ACBGCMarkingQue EQU   120
                        	ACBGCMarkingQueFull   EQU   128
                        	ACBGCMarkingQueEmpty  EQU   129
                        	ACBGCOverflow EQU   130
                        	ACBpCode      EQU   134
                        	ACBObjectList EQU   144
                        	ACBGarbageList  EQU   152
                        	ACBHeap       EQU   160   ; 640+ bytes for heap object info
                        	ACBiofNext    EQU   824
                        	ACBiofPrev    EQU   832
                        	ACBUserName   EQU   840   ; 2 byte index of string in string area
                        	ACBPath       EQU   842   ; 2 byte index of string in string area
                        	ACBExitRunFile  EQU   844 ; 2 byte index of string in string area
                        	ACBCommandLine  EQU   846 ; 2 byte index of string in string area
                        	ACBpVidMem    EQU   848
                        	ACBpVirtVidMem  EQU 856
                        	ACBVideoRows  EQU   864
                        	ACBVideoCols  EQU   865
                        	ACBCursorRow  EQU   866
                        	ACBCursorCol  EQU   867
                        	ACBNormAttr   EQU   868
                        	ACBKeyState1  EQU   872
                        	ACBKeyState2  EQU   874
                        	ACBKeybdWaitFlag  EQU   876
                        	ACBKeybdHead  EQU   878
                        	ACBKeybdTail  EQU   879
                        	ACBKeybdBuffer  EQU   880
                        	ACBnumber     EQU   944
                        	ACBNext       EQU   952
                        	ACBTask       EQU   960
                        	ACBHasFocus   EQU   962
                        	ACBmid        EQU   964
                        	ACBStatus     EQU   966
                        	ACBTemplates  EQU   968   ; 256 * 8 bytes reserved for template pointers
                        	ACBPad        EQU   3016
                        	ACBStrings    EQU   3072  ; start of 1kB string area
                        	ACBEnd        EQU   4096
                        	
                        	; Application startup record
                        	ASRPageSize   EQU   0
                        	ASRPriority   EQU   1
                        	ASRRegset     EQU   2
                        	ASRmid        EQU   3
                        	ASRAffinity   EQU   4
                        	ASRCodeSize   EQU   8
                        	ASRDataSize   EQU   16
                        	ASRUIDataSize EQU   24
                        	ASRHeapSize   EQU   32
                        	ASRStackSize  EQU   40
                        	ASRpCode      EQU   48
                        	ASRpData      EQU   56
                        	ASRpUIData    EQU   64
                        	ASR_SIZE      EQU   72
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	;MBX_WTIDS			equ		4		; tasks waiting at mailbox
                        	MBX_LINK      equ   4
                        	MBX_TQHEAD    equ   4   ; link field for free list shared with task queue head
                        	MBX_TQTAIL    equ   8
                        	MBX_MQHEAD		equ		12		
                        	MBX_MQTAIL		equ		16
                        	MBX_SIZE			equ		20
                        	
                        	MSG_LINK	  equ		0
                        	MSG_RETADR  equ   4
                        	MSG_TGTADR  equ   5
                        	MSG_TYPE    equ   6
                        	MSG_D1		  equ		8
                        	MSG_D2		  equ		12
                        	MSG_D3		  equ		16
                        	MSG_SIZE	  equ		20
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	MAX_TID		EQU		15
                        	NR_TCB		EQU		32
                        	NTASK     EQU   32    ; number of tasks allowed
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		10
                        	LOG_ACBSZ EQU   12
                        	OSPAGES		EQU		16		; pages of memory dedicated to OS
                        	PAGESZ    EQU   1024  ; size of a page of memory
                        	MEMSZ     EQU   512   ; 512 pages
                        	MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_pIRQProc		EQU		0x38		; pointer to IRQ processing routine
                        	DCB_ReentCount		EQU		0x40		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x41
                        	DCB_fUI       EQU   0x42    ; user interface device
                        	DCB_hJob			EQU		0x48		; handle to associated job
                        	DCB_Mbx				EQU		0x50
                        	DCB_pSema			EQU		0x58		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x60		; 96 bytes
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	DVC_IsUI          EQU   27
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Front Panel 		FP
                        	;11
                        	;12		Hard disk				HD1
                        	;13		Hard disk				HD2
                        	;14
                        	;15   Time slice / GP	VIA
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; disable interrupts
                        	macro mDI
  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
endm
                        	
                        	; disable interrupts
                        	macro mEI
  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
endm
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		a0,#-1
	stt		a0,adr
endm
                        	
                        	macro mGetCurrentTid
  csrrw $a0,#CSR_TASKID,$x0
endm
                        	
                        	macro	mHasFocus
	ldi		$a0,#20
	ecall
endm
                        	
                        	macro mSleep(tm)
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#tm
	ecall
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   a1 = device # to check
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
  mov   $t2,$a1
	
	ldi		$a0,#20
	ecall
bnez	$a1,.HasFocus@
	ldi   $a0,#26             ; FMTK_IO
	mov   $a1,$t2
	ldi   $a2,#9              ; peekchar function
	ecall
	ldi		$t3,#$14						; CTRL-T
	bne		$a0,$t3,.WFF2@
	; eat up the CTRL-T
	ldi		$a0,#26							; FMTK_IO
	mov   $a1,$t2
	ldi		$a2,#8							; getchar function
	ecall
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
		ldi				$a0,#5                        ; FMTK Sleep() function
		ldi				$a1,#1
		ecall

	bra		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = mailbox handle
                        	; Modifies:
                        	;   $t0
                        	; Returns:
                        	;   $a0 = mailbox pointer
                        	;------------------------------------------------------------------------------
                        	
                        	macro mMbxHandleToPointer
  srl   $t0,$a0,#8    ; extract collection index
  sll   $t0,$t0,#2
  ldt   $t0,MbxBlockPtr[$t0]
  and   $a0,$a0,#$FF
  sll   $a0,$a0,#2
  or    $a0,$a0,$t0
endm
                        	
                        	macro mMbxHandleToPointer2(handle,temp)
  srl   temp,handle,#8    ; extract collection index
  sll   temp,temp,#2
  ldt   temp,MbxBlockPtr[temp]
  and   handle,handle,#$FF
  sll   handle,handle,#2
  or    handle,handle,temp
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list pointer to TCB
                        	;------------------------------------------------------------------------------
                        	
                        	;macro mPopTimeoutList
                        	;	lbu		$v1,TCBStatus[$v0]		; no longer a waiting status
                        	;	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
                        	;	beqz	$t1,.noWait@
                        	;	ldbu  $a0,TCBtid[$v0]
                        	;	mMbxRemoveTask							; remove task from mailbox list
                        	.noWait@:
                        	;	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
                        	;	stb		$v1,TCBStatus[$v0]
                        	;	ldt		$v1,TCBNext[$v0]			; get next task on timeout list
                        	;	stt		$v1,TimeoutList				; update list head
                        	;	beqz	$v1,.done@
                        	;	stt		$x0,TCBPrev[$v1]			; TimeoutList->prev = 0
                        	.done@:
                        	;	stt		$x0,TCBNext[$v0]
                        	;	stt		$x0,TCBPrev[$v0]
                        	endm
                        	
                        	macro mGetAppMid
  sll   $a0,$a0,#LOG_PGSZ
  ldb   $a0,ACBmid[$a0]
endm
                        	
                        	; Macros to enable and disable time-slice interrupts
                        	macro mTimeSliceEI
	ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
	stt		$t0,VIA_IER+VIA
endm
                        	
                        	macro mTimeSliceEI2(tm)
	ldi		$t0,#$000180|(tm<<24)		; enable timer3 interrupts after tm cycles
	stt		$t0,VIA_IER+VIA
endm
                        	
                        	macro mTimeSliceDI
	ldi		$t0,#$100						; disable timer3 (time slice) interrupts
	stt		$t0,VIA_IER+VIA
	nop                   ; make sure disable has time for effect
	nop
endm
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/globals.r5a",1
                        	.file "../fmtk/globals.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	INBUF				equ		$0100
                        	switchflag	equ		$0200
                        	milliseconds	equ		$0208
                        	CurrentTid  equ   $210
                        	TaskNum     equ   $220
                        	
                        	ACBPtrs EQU $0280
                        	APPID_POOL  EQU   $02F0
                        	NPAGES	equ		$0300
                        	QNDX		EQU		$0304
                        	READYQ	EQU		$0308
                        	TID_POOL  EQU		$0310
                        	missed_ticks	equ		$0320
                        	TimeoutList		equ		$0328
                        	Tick		EQU		$0330
                        	SysSema	EQU		$0340
                        	MEPC0   EQU   $0350
                        	MEPC1   EQU   $0358
                        	MEPC2   EQU   $0360
                        	MEPC3   EQU   $0368
                        	CURIN   EQU   $0370
                        	CUROUT  EQU   $0371
                        	CHAINA0 EQU   $0378
                        	CHAINA1 EQU   $0380
                        	CHAINA2 EQU   $0388
                        	CHAINA3 EQU   $0390
                        	CHAINA4 EQU   $0398
                        	CHAINA5 EQU   $03A0
                        	READYQ  EQU   $0400
                        	HEADRDY		EQU		$0400
                        	HEADRDY0	EQU		$0400
                        	HEADRDY1	EQU		$0404
                        	HEADRDY2	EQU		$0408
                        	HEADRDY3	EQU		$040C
                        	HEADRDY4	EQU		$0410
                        	HEADRDY5	EQU		$0414
                        	HEADRDY6	EQU		$0418
                        	HEADRDY7	EQU		$041C	; Undead queue
                        	TAILRDY		EQU		$0420
                        	TAILRDY0	EQU		$0420
                        	TAILRDY1	EQU		$0424
                        	TAILRDY2	EQU		$0428
                        	TAILRDY3	EQU		$042C
                        	TAILRDY4	EQU		$0430
                        	TAILRDY5	EQU		$0434
                        	TAILRDY6	EQU		$0438
                        	TAILRDY7	EQU		$043C	; Undead queue
                        	RDYQ1		EQU		$0500
                        	RDYQ2		EQU		$0600
                        	RDYQ3		EQU		$0700
                        	mbxs		EQU		$0800
                        	mbxs_end	EQU	$0C00
                        	FreeMsg	EQU		$0C00
                        	FreeMbx EQU   $0C08
                        	IdleTaskMbx EQU   $0C10
                        	IdleTaskMsgD1 EQU   $0C18
                        	IdleTaskMsgD2 EQU   $0C20
                        	IdleTaskMsgD3 EQU   $0C28
                        	IdleTaskId    EQU   $0C2A
                        	PAMPtr  EQU   $0FF8
                        	PAM     EQU   $1000
                        	PAMend  EQU   $1080
                        	IOFocusNdx		EQU		$1080
                        	IOFocusTbl		EQU		$1088
                        	IRQFlag   EQU $1090
                        	IRQCause  EQU $1098
                        	MbxBlockPtr EQU   $10A0
                        	MbxBlockPtrEnd  EQU MbxBlockPtr + MBX_BLOCKPTR_BUFSZ * 4
                        	MbxBlockCounter EQU $10E0
                        	RegsetTid   EQU   $10F0
                        	SerRcvBuf		EQU		$1400
                        	SerXmitBuf	EQU		$1800
                        	SerHeadRcv	EQU		$1C00
                        	SerTailRcv	EQU		$1C04
                        	SerHeadXmit	EQU		$1C08
                        	SerTailXmit	EQU		$1C0C
                        	SerRcvXon		EQU		$1C10
                        	SerRcvXoff	EQU		$1C11
                        	; The following must be at least 128 byte aligned
                        	DVF_Base		EQU		$2000
                        	DVF_Limit		EQU		$3000
                        	DCB_Base    EQU   $3000
                        	DCB_Limit   EQU   $3C00
                        	
                        	SysHeapStart  EQU   $4000
                        	SysHeapEnd    EQU   $20000
                        	
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	
                        	CTRLC				equ		$03
                        	CTRLT       equ   $14
                        	BS					equ		$08
                        	LF					equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	EOF         equ   $1A
                        	DEL					equ		$7F
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_T2CL    equ   $20
                        	VIA_T2CH    equ   $24
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        	OS_SEMA			equ		$FFDB0000
                        	
                        	CSR_UIE     equ   $004
                        	
                        	.file "cs01rom.r5a",32
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0000				; user mode exception
FFFC0000 5110006F		jmp		IRQRout
FFFC0004 00000000		org 	$FFFC00C0				; machine mode exception
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 00000000
FFFC0044 00000000
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 00000000
FFFC0084 00000000
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 4510006F		jmp		IRQRout
FFFC00C4 00000000		org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F		jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; Reset starting address.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0100
                        	MachineStart:
FFFC0100 000002B7		ldi   $t0,#$FFFFFC1C  		; select register set #28, user register set #0
FFFC0104 C1C28293
FFFC0108 7C329073		csrrw $x0,#CSR_RSSTACK,$t0
FFFC010C 2007E137		ldi		$sp,#$2007E800-4		; setup machine mode stack pointer
FFFC0110 7FC10113
FFFC0114 7A00E073		csrrs $x0,#CSR_TRACECTRL,#1 ; turn on tracing
FFFC0118 00106293		ldi		$t0,#1
FFFC011C FFDB48B7		stt		$t0,OS_SEMA+$4000		; prime OS semaphore = 1
FFFC0120 00088893
FFFC0124 000888B3
FFFC0128 0058A023
FFFC012C 00006293		ldi		$t0,#0
FFFC0130 7C129073		csrrw $x0,#CSR_MSEMA,$t0  ; turn off semaphores
FFFC0134 7C229073		csrrw $x0,#CSR_TASKID,$t0 ; clear task id
FFFC0138 348010EF		call	MMUInit					; initialize MMU for address space zero.
FFFC013C 3B4020EF		call	FMTKInit
FFFC0140 1E0020EF		call	ViaSetup
FFFC0144 34D010EF		call	SerialSetup
FFFC0148 00506293		ldi   $t0,#5          ; set current input and output to serial port
FFFC014C 36500823		stb   $t0,CURIN
FFFC0150 365008A3		stb   $t0,CUROUT
FFFC0154 FFFC02B7		ldi		$t0,#$FFFC0000
FFFC0158 00028293
FFFC015C 30129073		csrrw $x0,#$301,$t0		; set tvec
FFFC0160 FFFC02B7		ldi		$t0,#UserStart
FFFC0164 1A828293
FFFC0168 34129073		csrrw	$x0,#$341,$t0		; set mepc
FFFC016C 34502C23		stt   $t0,MEPC1
FFFC0170 00106513	  ldi   $a0,#1          ; start task
FFFC0174 00006593	  ldi   $a1,#0
FFFC0178 00006613	  ldi   $a2,#0
FFFC017C FFFC06B7	  ldi   $a3,#UserStart2
FFFC0180 1B468693
FFFC0184 00006713	  ldi   $a4,#$00				; register set (bits 0 to 7), operating mode (bits 8 to 9)
FFFC0188 109020EF	  call  OSOCall
FFFC018C 7C259073	  csrrw $x0,#CSR_TASKID,$a1
FFFC0190 7C501573	  csrrw	$a0,#CSR_IMSTACK,$x0
FFFC0194 F0057513	  and		$a0,$a0,#$FFFFFF00
FFFC0198 7C551073		csrrw	$x0,#CSR_IMSTACK,$a0	; set lowest IRQ level on return
FFFC019C 7C446073	  csrrs $x0,#CSR_PMSTACK,#8 	; enable interrupts on return
                        	;	csrrc $x0,#CSR_TRACECTRL,#0 ; turn off tracing
FFFC01A0 251030EF		call	DumpReadyQueue
FFFC01A4 30200073		mret                      	; switch to user mode
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	; First thing to do is start a task so that the startup code may run on the
                        	; first task switch.
                        	;------------------------------------------------------------------------------
                        	UserStart:
                        	;	ldi		$sp,#$2007fff0
                        	;  call  DumpTraceQueue
FFFC01A8 20080137		ldi		$sp,#$2007FFF8-4		; setup machine mode stack pointer
FFFC01AC FF410113
FFFC01B0 1C1010EF		call	PAMDump
                        	;  wfi                   ; wait for task switch
                        	UserStart2:
FFFC01B4 00C06513	  ldi   $a0,#12         ; start app
FFFC01B8 FFFC15B7	  ldi   $a1,#SystemASR
FFFC01BC EDC58593
FFFC01C0 00000073	  ecall
                        	.appBad:
FFFC01C4 00051063	  bnez  $a0,.appBad
FFFC01C8 0005E4B3	  mov   $s1,$a1
FFFC01CC 00E06513	  ldi   $a0,#14         ; get current tid
FFFC01D0 00000073	  ecall                 ; $a1 = task id
FFFC01D4 0005E933	  mov		$s2,$a1
FFFC01D8 000018B7	  stw		$s2,IdleTaskId
FFFC01DC C2A88893
FFFC01E0 000888B3
FFFC01E4 01289023
FFFC01E8 01E06513	  ldi   $a0,#30         ; set task's app id
FFFC01EC 0004E633	  mov   $a2,$s1         ; $a2 = app id
FFFC01F0 00000073	  ecall
                        	
FFFC01F4 0005E4B3	  mov   $s1,$a1         ; s1 = app id
FFFC01F8 2007A137		ldi		$sp,#$2007A000-4  ; setup user mode stack pointer
FFFC01FC FFC10113
                        	
FFFC0200 00C06513	  ldi   $a0,#12         ; start app
FFFC0204 FFFC15B7	  ldi   $a1,#TinyBasicASR
FFFC0208 F2458593
FFFC020C 00000073	  ecall
FFFC0210 00106513		ldi		$a0,#1          ; Start finalizer task, task #1
FFFC0214 0004E5B3		mov   $a1,$s1
FFFC0218 00006613		ldi		$a2,#0
FFFC021C FFFC46B7		ldi		$a3,#Finalizer
FFFC0220 32068693
FFFC0224 00B06713		ldi   $a4,#$0B        ; user mode, regset 11
FFFC0228 00000073		ecall
FFFC022C 00C06513	  ldi   $a0,#12         ; start app
FFFC0230 FFFC15B7	  ldi   $a1,#MonitorASR
FFFC0234 E9458593
FFFC0238 00000073	  ecall
                        	;	ldi		$a0,#1          ; Start task for monitor, task #2
                        	;	mov   $a1,$s1
                        	;	ldi		$a2,#0
                        	;	ldi		$a3,#MonEntry
                        	;	ldi   $a4,#$0A        ; user mode, regset 10
                        	;	ecall
FFFC023C 01906513	  ldi   $a0,#25         ; map OS vars
FFFC0240 00000073	  ecall
FFFC0244 0005E1B3	  mov   $gp,$a1
                        	
                        	UserStart3:
FFFC0248 20079137		ldi		$sp,#$20079800-4  ; setup user mode stack pointer
FFFC024C 7FC10113
FFFC0250 01806513		ldi		$a0,#24							; RequestIOFocus
FFFC0254 0004E5B3		mov   $a1,$s1
FFFC0258 00000073		ecall
                        	;	ldi		$sp,#$70000		      ; setup temporary user mode stack pointer
                        	;	mov   $a0,$a1             ; $a0 = tid
                        	;	call  AllocStack
                        	;	add   $sp,$v1,#1020       ; place stack pointer at top of allocated region
FFFC025C 00806293		ldi		$t0,#$08						; turn on the LED
FFFC0260 FFDC08B7		stt		$t0,VIA+VIA_PARAW
FFFC0264 63C88893
FFFC0268 000888B3
FFFC026C 0058A023
FFFC0270 01006913		ldi		$s2,#16							; send an XON just in case
                        	.0004:
FFFC0274 01106693		ldi		$a3,#XON
FFFC0278 168000EF		call	Putch
FFFC027C FFF90913		sub		$s2,$s2,#1
FFFC0280 FE091AE3		bnez	$s2,.0004
                        	.0002:
                        	;  ldi   $a0,#25             ; Map OS vars
                        	;  ecall
                        	;  mov   $gp,$a1
                        	  ; Request that the idle task announce itself.
                        	;  ldi   $a0,#9              ; SendMsg
                        	;  ldwu  $a1,IdleTaskMbx[$gp]
                        	;  beqz  $a1,.noMbx
                        	;  ldi   $a2,#MT_ANNOUNCE
                        	;  ldi   $a3,#0
                        	;  ldi   $a4,#0
                        	;  ecall
                        	.noMbx:
FFFC0284 FFFC1537		ldi		$a0,#msgStart				; spit out a startup message
FFFC0288 F6C50513
FFFC028C 155000EF		call	PutString
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		ecall
FFFC0290 161030EF		call	DumpReadyQueue
FFFC0294 2640006F		jmp		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#9							; peekchar function
                        	;	ecall
                        	;	mov   $v0,$v1
                        	;	bltz	$v1,.0003
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#8							; getchar function
                        	;	ecall
                        	;	mov		$a3,$v1
                        	;	mov   $a0,$a3
                        	;	call  PutHexByte
                        	;	bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	; This task runs only if nothing else can run. It must run at the machine
                        	; operating mode.
                        	; Search for ready tasks and add them back into the ready queue.
                        	;------------------------------------------------------------------------------
FFFC0298 00000000	  align 1
FFFC029C 00000000
                        	
                        	IdleTask:
                        	;  ldi   $a0,#6                ; alloc mailbox
                        	;  ldi   $a1,#0                ; app #0
                        	;  ecall
FFFC02A0 000018B7	  stw   $a1,IdleTaskMbx[$gp]  ; save mailbox handle off
FFFC02A4 C1088893
FFFC02A8 003888B3
FFFC02AC 00B89023
                        	.loop2:
FFFC02B0 10100073		wfi
FFFC02B4 000042B7	  ldi   $t0,#$4000
FFFC02B8 00028293
FFFC02BC 00106313	  ldi   $t1,#1
                        	.loop:
FFFC02C0 00B06513	  ldi   $a0,#11               ; PeekMsg
FFFC02C4 000018B7	  ldwu  $a1,IdleTaskMbx[$gp]
FFFC02C8 C1088893
FFFC02CC 003888B3
FFFC02D0 0008D583
FFFC02D4 00001637	  ldi   $a2,#IdleTaskMsgD1
FFFC02D8 C1860613
FFFC02DC 000016B7	  ldi   $a3,#IdleTaskMsgD2
FFFC02E0 C2068693
FFFC02E4 00001737	  ldi   $a4,#IdleTaskMsgD3
FFFC02E8 C2870713
FFFC02EC 00106793	  ldi   $a5,#1                ; remove from queue if present
                        	;  ecall
                        	;  bnez  $a0,.noMsg
                        	;  ldt   $a0,IdleTaskMsgD1
                        	;  xor   $t1,$a0,#MT_ANNOUNCE
                        	;  bnez  $t1,.noAnnounce
FFFC02F0 FFFC0537	  ldi   $a0,#msgIdleAnnounce
FFFC02F4 39050513
FFFC02F8 0E9000EF	  call  PutString
                        	.noAnnounce:
                        	.noMsg:
FFFC02FC 01106513	  ldi   $a0,#17               ; run as OS
FFFC0300 FFFC05B7	  ldi   $a1,#.IdleCode
FFFC0304 32858593
FFFC0308 0002E633	  mov   $a2,$t0
FFFC030C 00000073	  ecall
FFFC0310 40028293	  add   $t0,$t0,#PAGESZ
FFFC0314 000808B7	  slt   $t2,$t0,#MEMSZ*1024
FFFC0318 00088893
FFFC031C 0058A3B3
FFFC0320 FA0390E3	  bnez  $t2,.loop
FFFC0324 F80006E3		bra		.loop2
                        	  ; This section of code runs as part of the OS
                        	  ; Don't call any functions though as there's no stack available
                        	.IdleCode:
FFFC0328 00006613		ldi		$a2,#$00
                        	.nxtObj:
FFFC032C 40060613		add		$a2,$a2,#$400					; 1k blocks
FFFC0330 00080E37		ldi		$t3,#$80000
FFFC0334 000E0E13
FFFC0338 05C60863		beq		$a2,$t3,.0001
                        		; Check if block contains a TCB
FFFC033C 00062283	  ldt   $t0,OBJMagic[$a2]
FFFC0340 20544E37	  ldi   $t3,#TCB_MAGIC
FFFC0344 342E0E13
FFFC0348 FFC292E3	  bne   $t0,$t3,.nxtObj
                        	  ; Is it ready?
FFFC034C 2C83CE03	  ldbu  $t3,TCBStatus[$t2]    ; get status
FFFC0350 001E7E13	  and   $t3,$t3,#TS_READY
FFFC0354 FC0E0CE3	  beqz  $t3,.nxtObj
                        	  ; On Ready queue?
FFFC0358 3103AE03	  ldt		$t3,TCBNext[$t2]
FFFC035C 000E0863	  beqz	$t3,.addToReady
FFFC0360 2C8E2E03	  ldt		$t3,TCBStatus[$t3]
FFFC0364 001E7E13	  and		$t3,$t3,#TS_READY
FFFC0368 FC0E12E3	  bnez	$t3,.nxtObj
                        	  ; The task was ready, but not found in the ready queue. So add it
                        	.addToReady:
FFFC036C 00066533	  mov		$a0,$a2
FFFC0370 FFC10113	  sub		$sp,$sp,#4
FFFC0374 00112023	  stt		$ra,[$sp]
FFFC0378 618030EF	  call	InsertIntoReadyQueue
FFFC037C 00012083	  ldt		$ra,[$sp]
FFFC0380 00410113	  add		$sp,$sp,#4
FFFC0384 FA0004E3	  bra		.nxtObj
                        	.0001:
FFFC0388 00006513	  ldi   $a0,#E_Ok
FFFC038C 00008067	  ret
                        	
                        	msgIdleAnnounce:
FFFC0390 656C6449	  db  "Idle task running.",CR,0
FFFC0394 73617420
FFFC0398 7572206B
FFFC039C 6E696E6E
FFFC03A0 000D2E67
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		$a0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
FFFC03A4 00000000	  align 1
FFFC03A8 00000000
FFFC03AC 00000000
                        	
                        	Getch:
FFFC03B0 FF410113		sub		$sp,$sp,#12
FFFC03B4 00112023		stt		$ra,[$sp]
FFFC03B8 00B12423		stt		$a1,8[$sp]
FFFC03BC 00506593		ldi   $a1,#5  ;CURIN
FFFC03C0 0D0000EF		call  fgetc
FFFC03C4 00012083		ldt		$ra,[$sp]
FFFC03C8 00812583		ldt		$a1,8[$sp]
FFFC03CC 00C10113		add		$sp,$sp,#12
FFFC03D0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = character to put
                        	;------------------------------------------------------------------------------
FFFC03D4 00000000	  align 1
FFFC03D8 00000000
FFFC03DC 00000000
                        	
                        	Putch:
FFFC03E0 FEC10113		sub		$sp,$sp,#20
FFFC03E4 00112023		stt		$ra,[$sp]
FFFC03E8 00D12423		stt		$a3,8[$sp]
FFFC03EC 00B12823		stt		$a1,16[$sp]
FFFC03F0 000566B3		mov		$a3,$a0
FFFC03F4 00506593		ldi		$a1,#5  ;CUROUT    ; serial port
FFFC03F8 018000EF		call	fputc
FFFC03FC 00012083		ldt		$ra,[$sp]
FFFC0400 00812683		ldt		$a3,8[$sp]
FFFC0404 01012583		ldt		$a1,16[$sp]
FFFC0408 01410113		add		$sp,$sp,#20
FFFC040C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   EOF if error occurred, otherwise character to put
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	fputc:
FFFC0410 FE410113		sub		$sp,$sp,#28
FFFC0414 00112023		stt		$ra,[$sp]
FFFC0418 00A12423		stt		$a0,8[$sp]
FFFC041C 00B12823		stt		$a1,16[$sp]
FFFC0420 00C12A23		stt		$a2,20[$sp]
FFFC0424 00D12C23		stt		$a3,24[$sp]
FFFC0428 04284813		xor   $a6,$a6,#'B'
FFFC042C 00081263		bnez  $a6,.noBypass
                        	;	call  SerialPutChar
                        	;	jmp   .xit
                        	.noBypass:
                        		; If the device is a UI device there may be multiple owning jobs. It doesn't
                        		; do any good to check for ownership. Instead the I/O focus is checked to
                        		; see if it's present.
                        	;	bra		.0001
FFFC0430 4C1030EF		call  GetUIFlag
FFFC0434 00058863		beqz  $a1,.checkOwner
FFFC0438 01012583	  ldt   $a1,16[$sp]
FFFC043C 435030EF		call  WaitForIOFocus
FFFC0440 00000663		bra   .0001
                        	.checkOwner:
FFFC0444 66D030EF	  call  CheckDevOwner
FFFC0448 02051A63	  bnez  $a0,.notOwner
                        	.0001:
                        	;	call	SerialPutCharEx
FFFC044C 01012583	  ldt   $a1,16[$sp]
FFFC0450 01812683	  ldt		$a3,24[$sp]
FFFC0454 01A06513		ldi		$a0,#26							; FMTK_IO
FFFC0458 00D06613		ldi		$a2,#13							; putchar function
FFFC045C 00000073		ecall
                        	.xit:
FFFC0460 00012083		ldt		$ra,[$sp]
FFFC0464 00812503		ldt		$a0,8[$sp]
FFFC0468 01012583		ldt		$a1,16[$sp]
FFFC046C 01412603		ldt		$a2,20[$sp]
FFFC0470 01812683		ldt		$a3,24[$sp]
FFFC0474 01C10113		add		$sp,$sp,#28
FFFC0478 00008067		ret
                        	.notOwner:
FFFC047C 01A06513	  ldi   $a0,#EOF
FFFC0480 FE0000E3	  bra   .xit
                        	 
                        	;------------------------------------------------------------------------------
                        	; fgetc - get a character from an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device getchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		a0 character, -1 if none available
                        	;------------------------------------------------------------------------------
FFFC0484 00000000	  align 1
FFFC0488 00000000
FFFC048C 00000000
                        	
                        	fgetc:
FFFC0490 FE810113		sub		$sp,$sp,#24
FFFC0494 00112023		stt		$ra,[$sp]
FFFC0498 00A12423		stt		$a0,8[$sp]
FFFC049C 00B12823		stt		$a1,16[$sp]
FFFC04A0 00C12A23		stt		$a2,20[$sp]
FFFC04A4 44D030EF		call  GetUIFlag
FFFC04A8 00058863		beqz  $a1,.checkOwner
FFFC04AC 01012583		ldt		$a1,16[$sp]
FFFC04B0 3C1030EF		call  WaitForIOFocus
FFFC04B4 00000863		bra   .0001
                        	.checkOwner:
FFFC04B8 01012583		ldt		$a1,16[$sp]
FFFC04BC 5F5030EF	  call  CheckDevOwner
FFFC04C0 02051863	  bnez  $a0,.notOwner
                        	.0001:
                        	;	call	SerialPeekChar
                        	;	bltz	$a1,.0003
                        	;	call	SerialGetChar
FFFC04C4 01A06513		ldi		$a0,#26							; FMTK_IO
FFFC04C8 01012583		ldt		$a1,16[$sp]
FFFC04CC 00806613		ldi		$a2,#8							; getchar function
FFFC04D0 00000073		ecall
                        	.0003:
FFFC04D4 0005E533		mov   $a0,$a1
                        	.0002:
FFFC04D8 00012083		ldt		$ra,[$sp]
FFFC04DC 00812503		ldt		$a0,8[$sp]
FFFC04E0 01012583		ldt		$a1,16[$sp]
FFFC04E4 01412603		ldt		$a2,20[$sp]
FFFC04E8 01810113		add		$sp,$sp,#24
FFFC04EC 00008067		ret
                        	.notOwner:
FFFC04F0 FFF06513	  ldi   $a0,#-1
FFFC04F4 FE0002E3	  bra   .0002
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;  ldi   $a0,#25         ; map OS vars
                        	;  ecall
                        	;  mov   $gp,$a1
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC04F8 00A06513			ldi		$a0,#10
FFFC04FC 00606613			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
FFFC0500 02606513		ldi		$a0,#38					; Get current app id
FFFC0504 00000073		ecall
FFFC0508 01806513		ldi		$a0,#24					; request I/O focus
FFFC050C 00000073		ecall
                        	
                        	Monitor:
                        	.getFocus:
FFFC0510 02606513		ldi		$a0,#38					; Get current app id
FFFC0514 00000073		ecall
FFFC0518 01406513		ldi   $a0,#20       	; has IO focus
FFFC051C 00000073		ecall
FFFC0520 00059863		bnez  $a1,.hasFocus
FFFC0524 01506513		ldi   $a0,#21       	; switch focus
FFFC0528 00000073		ecall
FFFC052C FE0002E3		bra   .getFocus
                        	.hasFocus:
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFC0530 00006493		ldi		$s1,#0					; s1 = input pointer
FFFC0534 00D06513		ldi		$a0,#CR
FFFC0538 EA9FF0EF		call	Putch
FFFC053C 00006513		ldi		$a0,#LF
	call	Putch
FFFC0540 EA1FF0EF
FFFC0544 02406513		ldi		$a0,#'$'
FFFC0548 E99FF0EF		call	Putch
                        	.0001:
FFFC054C E65FF0EF		call	Getch						; wait until character pressed
FFFC0550 FE054EE3		bltz	$a0,.0001
FFFC0554 00054293		xor		$t0,$a0,#LF			; ignore line feed
	beqz	$t0,.procLine
FFFC0558 08028263
FFFC055C 00D54293		xor		$t0,$a0,#CR
FFFC0560 06028E63		beqz	$t0,.procLine
FFFC0564 00854293		xor		$t0,$a0,#BS
FFFC0568 04028263		beqz	$t0,.doBackspace
FFFC056C 07F54293		xor		$t0,$a0,#DEL
FFFC0570 00028A63		beqz	$t0,.doDelete
FFFC0574 10A48023		stb		$a0,INBUF[$s1]
FFFC0578 00148493		add		$s1,$s1,#1
FFFC057C E65FF0EF		call	Putch
FFFC0580 FC0006E3		bra		.0001
                        	.doDelete:
FFFC0584 0004E933		mov		$s2,$s1
FFFC0588 00190913		add		$s2,$s2,#1
                        	.0002:
FFFC058C 10090283		ldb		$t0,INBUF[$s2]
FFFC0590 0E590FA3		stb		$t0,INBUF-1[$s2]
FFFC0594 00190913		add		$s2,$s2,#1
FFFC0598 10090293		add		$t0,$s2,#INBUF
FFFC059C 17F2A293		slt		$t0,$t0,#INBUF+$7F
FFFC05A0 FE0296E3		bne		$t0,$x0,.0002
FFFC05A4 10090023		stb		$x0,INBUF[$s2]
FFFC05A8 FA0002E3		bra		.0001
                        	.doBackspace:
FFFC05AC FA0480E3		beq		$s1,$x0,.0001		; can't backspace anymore
FFFC05B0 E31FF0EF		call	Putch           ; show the backspace
FFFC05B4 FFF48493		sub		$s1,$s1,#1
FFFC05B8 0004E933		mov		$s2,$s1
                        	.0003:
FFFC05BC 10190283		ldb		$t0,INBUF+1[$s2]
FFFC05C0 10590023		stb		$t0,INBUF[$s2]
FFFC05C4 00190913		add		$s2,$s2,#1
FFFC05C8 10090293		add		$t0,$s2,#INBUF
FFFC05CC 17F2A293		slt		$t0,$t0,#INBUF+$7F
FFFC05D0 FE0296E3		bne		$t0,$x0,.0003
FFFC05D4 10090023		stb		$x0,INBUF[$s2]
FFFC05D8 F6000AE3		bra		.0001
                        	.procLine:
FFFC05DC 10048023		stb		$x0,INBUF[$s1]
FFFC05E0 00006493		ldi		$s1,#0
                        	.skip:
FFFC05E4 10048283		ldb		$t0,INBUF[$s1]
FFFC05E8 14028E63		beq		$t0,$x0,.0005
FFFC05EC 03E2C313		xor		$t1,$t0,#'>'
FFFC05F0 00031663		bne		$t1,$x0,.0004
                        	.skip2:
FFFC05F4 00148493		add		$s1,$s1,#1
FFFC05F8 FE0006E3		bra		.skip
                        	.0004:
FFFC05FC 0202C313		xor		$t1,$t0,#' '
FFFC0600 FE030AE3		beq		$t1,$x0,.skip2
FFFC0604 0092C313		xor		$t1,$t0,#'\t'
FFFC0608 FE0306E3		beq		$t1,$x0,.skip2
FFFC060C 0582C313		xor   $t1,$t0,#'X'  ; exit from monitor
FFFC0610 00031663		bnez  $t1,.notX
FFFC0614 00006513		ldi   $a0,#E_Ok
FFFC0618 00008067		ret
                        	.notX:
FFFC061C 04D2C313		xor		$t1,$t0,#'M'
FFFC0620 12030863		beqz	$t1,doMem
FFFC0624 0562C313		xor   $t1,$t0,#'V'
FFFC0628 22030C63		beqz  $t1,doVMem
FFFC062C 0502C313		xor   $t1,$t0,#'P'
FFFC0630 28030863		beqz  $t1,doPStat
FFFC0634 04206313		ldi		$t1,#'B'
FFFC0638 06629863		bne		$t0,$t1,.0006
FFFC063C 474000EF		call  GetDecNum
FFFC0640 00051663		bnez  $a0,.basSize
FFFC0644 00008537		ldi   $a0,#32000
FFFC0648 D0050513
                        	.basSize:
FFFC064C 00C06513		ldi		$a0,#12					; Start App
FFFC0650 000005B7		ldi   $a1,#TBASR
FFFC0654 1D658593
FFFC0658 00000073		ecall
FFFC065C 0005E4B3		mov		$s1,$a1					; save v1
FFFC0660 FFFC1537		ldi		$a0,#msgCRLF
FFFC0664 08250513
FFFC0668 578000EF		call	PutString
FFFC066C 0004E533		mov		$a0,$s1					; get back v1
FFFC0670 4F0000EF		call	PutHexByte
FFFC0674 FFFC1537		ldi		$a0,#msgTaskStart
FFFC0678 07450513
FFFC067C 564000EF		call	PutString
FFFC0680 570030EF		call  DumpReadyQueue
                        		; The monitor is running in machine mode. A return instruction is used to
                        		; switch to user mode. The return address must be set to the desired user
                        		; code address.
                        		
FFFC0684 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
                        	; disable interrupts
FFFC0688 FFFC42B7		ldi   $t0,#CSTART       ; pick start of Tiny Basic
FFFC068C 53028293
FFFC0690 34129073		csrrw $x0,#$341,$t0     ; set as return address
FFFC0694 000112B7		ldi   $t0,#$00011111    ; bits to select register set #1
FFFC0698 11128293
FFFC069C 7C029073		csrrw $x0,#CSR_REGSET,$t0     ; select register set #1 (will decrement to zero then on mret)
FFFC06A0 30200073		mret                    ; will begin running Tiny Basic in user mode
                        		;ldi		$a0,#5					; Reschedule task
                        		;ldi		$a1,#1					; sleep(0)
                        		;ecall
FFFC06A4 E6DFF06F		jmp		Monitor
                        	.0006:
FFFC06A8 04406313		ldi		$t1,#'D'
FFFC06AC 02629063		bne		$t0,$t1,.0007
FFFC06B0 10148283		lb		$t0,INBUF+1[$s1]
FFFC06B4 05406313		ldi		$t1,#'T'
FFFC06B8 00629663		bne		$t0,$t1,.noT
FFFC06BC 6C4030EF		call	DumpTimeoutList
FFFC06C0 E51FF06F		jmp		Monitor
                        	.noT:
FFFC06C4 52C030EF		call 	DumpReadyQueue
                        		;ldi		$a0,#15
                        		;ecall
FFFC06C8 E49FF06F		jmp		Monitor
                        	.0007:
FFFC06CC 04506313		ldi		$t1,#'E'
FFFC06D0 00629463		bne		$t0,$t1,.0008
FFFC06D4 16C0006F		jmp		EditMem
                        	.0008:
FFFC06D8 04606313		ldi		$t1,#'F'
FFFC06DC 00629E63		bne		$t0,$t1,.0009
FFFC06E0 10148283		ldb   $t0,INBUF+1[$s1]
FFFC06E4 04906313		ldi   $t1,#'I'
FFFC06E8 00531663		bne   $t1,$t0,.notFind
FFFC06EC 00148493		add   $s1,$s1,#1
FFFC06F0 2400006F		jmp   Find
                        	.notFind:
FFFC06F4 20C0006F		jmp		FillMem
                        	.0009:
FFFC06F8 05306313		ldi		$t1,#'S'
FFFC06FC 00629A63		bne		$t0,$t1,.0010
FFFC0700 00506513		ldi		$a0,#5					; sleep(0)
FFFC0704 00106593		ldi		$a1,#1
FFFC0708 00000073		ecall
FFFC070C E05FF06F		jmp		Monitor
                        	.0010:
FFFC0710 04B06313		ldi		$t1,#'K'
FFFC0714 00629C63		bne		$t0,$t1,.0011
FFFC0718 2F8000EF		call	GetHexNum
FFFC071C 000565B3		mov		$a1,$a0					; a0 = pid
FFFC0720 00306513		ldi		$a0,#3					; kill task
FFFC0724 00000073		ecall
FFFC0728 DE9FF06F		jmp		Monitor
                        	.0011:
FFFC072C 03F06313		ldi		$t1,#'?'
FFFC0730 00629A63		bne		$t0,$t1,.0012
FFFC0734 FFFC1537		ldi		$a0,#msgMonHelp
FFFC0738 F8250513
FFFC073C 4A4000EF		call	PutString
FFFC0740 DD1FF06F		jmp		Monitor
                        	.0012:
                        	.0005:
FFFC0744 DCDFF06F		jmp		Monitor
                        	
FFFC0748 00000000	  align 1
FFFC074C 00000000
                        	
                        	doMem:
FFFC0750 FFC1310D		gcsub	$sp,$sp,#4
FFFC0754 00148493		add		$s1,$s1,#1
FFFC0758 10048283		ldb		$t0,INBUF[$s1]
FFFC075C 04F2C293		xor   $t0,$t0,#'O'
FFFC0760 00029463		bnez  $t0,.0001
FFFC0764 00148493		add		$s1,$s1,#1
                        	.0001:
FFFC0768 00912023		stt		$s1,[$sp]
FFFC076C 00D06513		ldi		$a0,#CR
FFFC0770 C71FF0EF		call	Putch
FFFC0774 10006513		ldi		$a0,#INBUF
FFFC0778 468000EF		call	PutString
FFFC077C 00012483		ldt		$s1,[$sp]
FFFC0780 00410113		add		$sp,$sp,#4
FFFC0784 28C000EF		call	GetHexNum
FFFC0788 000569B3		mov		$s3,$a0
FFFC078C 00056AB3		mov   $s5,$a0
FFFC0790 00148493		add		$s1,$s1,#1
FFFC0794 27C000EF		call	GetHexNum
FFFC0798 01350A33		add		$s4,$a0,$s3
                        	.loop2:
FFFC079C C15FF0EF		call	Getch						; check for ctrl-c
FFFC07A0 00354513		xor		$a0,$a0,#3
FFFC07A4 D60506E3		beq		$a0,$x0,Monitor
FFFC07A8 00D06513		ldi		$a0,#CR
FFFC07AC C35FF0EF		call	Putch
FFFC07B0 0009E533		mov		$a0,$s3
FFFC07B4 34C000EF		call	PutHexWord
FFFC07B8 03A06513		ldi		$a0,#':'
FFFC07BC C25FF0EF		call	Putch
FFFC07C0 00706913		ldi		$s2,#7
                        	.loop:
FFFC07C4 02006513		ldi		$a0,#' '
FFFC07C8 C19FF0EF		call	Putch
FFFC07CC 00029C63		bnez  $t0,.userMem
FFFC07D0 02106513		ldi   $a0,#33         ; Fetch memory word
FFFC07D4 0009E5B3		mov   $a1,$s3
FFFC07D8 00000073		ecall
FFFC07DC 0005E533		mov   $a0,$a1
FFFC07E0 00000463		bra   .0002
                        	.userMem
FFFC07E4 00098503		ldb		$a0,[$s3]
                        	.0002:
FFFC07E8 378000EF		call	PutHexByte
FFFC07EC 00198993		add		$s3,$s3,#1
FFFC07F0 FFF90913		sub		$s2,$s2,#1
FFFC07F4 FC0958E3		bge		$s2,$x0,.loop
FFFC07F8 FB49E2E3		bltu	$s3,$s4,.loop2
FFFC07FC 02006513		ldi		$a0,#' '
FFFC0800 BE1FF0EF		call	Putch
FFFC0804 02006513		ldi		$a0,#' '
FFFC0808 BD9FF0EF		call	Putch
                        	
FFFC080C 000AE9B3		mov   $s3,$s5
                        	.0004:
FFFC0810 0009C503		ldbu  $a0,[$s3]
FFFC0814 02052293		slt   $t0,$a0,#$20
FFFC0818 00029663		bnez  $t0,.unprintable
FFFC081C BC5FF0EF		call  Putch
FFFC0820 00000663		bra   .0003
                        	.unprintable:
FFFC0824 02E06513	  ldi   $a0,#'.'
FFFC0828 BB9FF0EF	  call  Putch
                        	.0003:
FFFC082C 00198993	  add   $s3,$s3,#1
FFFC0830 FF49E0E3	  bltu  $s3,$s4,.0004
FFFC0834 00D06513	  ldi   $a0,#CR
FFFC0838 BA9FF0EF	  call  Putch
FFFC083C CD5FF06F		jmp		Monitor		
                        	
                        	  align 16                        	
                        	EditMem:
FFFC0840 0040E073		csrrs $x0,#CSR_UIE,#1        ; enable gc interrupt
FFFC0844 1CC000EF		call	GetHexNum			; get address to edit
FFFC0848 000569B3		mov		$s3,$a0
FFFC084C 00148493		add		$s1,$s1,#1
FFFC0850 1C0000EF		call	GetHexNum			; get value to set
FFFC0854 01350023		stb		$s3,[$a0]			; update mem
FFFC0858 CB9FF06F		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >V 0
                        	; Displays the virtual memory map for the specified app.
                        	;------------------------------------------------------------------------------
                        	
FFFC085C 00000000	  align 1
                        	
                        	doVMem:
FFFC0860 00148493	  add   $s1,$s1,#1
FFFC0864 24C000EF	  call  GetDecNum
FFFC0868 00006313	  ldi   $t1,#0
FFFC086C 01051293	  sll   $t0,$a0,#16
                        	.0001:
FFFC0870 00337513	  and   $a0,$t1,#3
FFFC0874 00051A63	  bnez  $a0,.notLF
FFFC0878 00D06513	  ldi   $a0,#CR
FFFC087C B65FF0EF	  call  Putch
FFFC0880 00006513	  ldi   $a0,#LF
  call  Putch
FFFC0884 B5DFF0EF
                        	.notLF:
FFFC0888 0002E533	  mov   $a0,$t0
FFFC088C 274000EF	  call  PutHexWord
FFFC0890 03A06513	  ldi   $a0,#':'
FFFC0894 B4DFF0EF	  call  Putch
FFFC0898 0250050D	  mvmap $a0,$x0,$t0
FFFC089C 294000EF	  call  PutHexHalf
FFFC08A0 02006513	  ldi   $a0,#' '
FFFC08A4 B3DFF0EF	  call  Putch
FFFC08A8 00128293	  add   $t0,$t0,#1
FFFC08AC 00130313	  add   $t1,$t1,#1
FFFC08B0 10032513	  slt   $a0,$t1,#256
FFFC08B4 FA051EE3	  bnez  $a0,.0001  
FFFC08B8 C59FF06F	  jmp   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >P
                        	; Display the PAM bits status.
                        	;------------------------------------------------------------------------------
                        	
FFFC08BC 00000000	  align 1
                        	
                        	doPStat:
FFFC08C0 00D06513	  ldi   $a0,#CR
FFFC08C4 B1DFF0EF	  call  Putch
FFFC08C8 00006513	  ldi   $a0,#LF
  call  Putch
FFFC08CC B15FF0EF
FFFC08D0 00006313	  ldi   $t1,#0        ; $a1 = bit number
                        	.0001:
FFFC08D4 02006513	  ldi   $a0,#32       ; Get PAM bit pair
FFFC08D8 00000073	  ecall
FFFC08DC 03058513	  add   $a0,$a1,#'0'
FFFC08E0 B01FF0EF	  call  Putch
FFFC08E4 00130313	  add   $t1,$t1,#1
FFFC08E8 20032513	  slt   $a0,$t1,#MEMSZ
FFFC08EC FE0514E3	  bnez  $a0,.0001
FFFC08F0 C21FF06F	  jmp   Monitor
                        	 
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
FFFC08F4 00000000	  align 1
FFFC08F8 00000000
FFFC08FC 00000000
                        	
                        	FillMem:
FFFC0900 110000EF		call	GetHexNum			; get address
FFFC0904 000569B3		mov		$s3,$a0
FFFC0908 00148493		add		$s1,$s1,#1
FFFC090C 104000EF		call	GetHexNum			; get length
FFFC0910 00056A33		mov		$s4,$a0
FFFC0914 00148493		add		$s1,$s1,#1
FFFC0918 0F8000EF		call	GetHexNum			; get byte to use
                        	.0001:
FFFC091C 00A98023		stb		$a0,[$s3]
FFFC0920 FFFA0A13		sub		$s4,$s4,#1
FFFC0924 FF404CE3		bgt		$s4,$x0,.0001
FFFC0928 BE9FF06F		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; FI Hello
                        	;------------------------------------------------------------------------------
                        	
FFFC092C 00000000	  align 1
                        	
                        	Find:
FFFC0930 00D06513	  ldi   $a0,#CR
FFFC0934 AADFF0EF	  call  Putch
FFFC0938 00006513	  ldi   $a0,#LF
  call  Putch
FFFC093C AA5FF0EF
FFFC0940 0B0000EF	  call  SkipSpaces
FFFC0944 0004E933	  mov   $s2,$s1
                        	.fwe:
FFFC0948 10094283	  ldbu  $t0,INBUF[$s2]
FFFC094C 00028E63	  beqz  $t0,.endOfWord
FFFC0950 02006313	  ldi   $t1,#' '
FFFC0954 00628A63	  beq   $t0,$t1,.endOfWord
FFFC0958 00D06313	  ldi   $t1,#CR
FFFC095C 00628663	  beq   $t0,$t1,.endOfWord
FFFC0960 00190913	  add   $s2,$s2,#1
FFFC0964 FE0002E3	  bra   .fwe
                        	.endOfWord:
FFFC0968 10090023	  stb   $x0,INBUF[$s2]
FFFC096C 0004E933	  mov   $s2,$s1
FFFC0970 00006513	  ldi   $a0,#0
FFFC0974 00006593	  ldi   $a1,#0
                        	.loop:
FFFC0978 A39FF0EF		call	Getch						; check for ctrl-c
FFFC097C 00354513		xor		$a0,$a0,#3
FFFC0980 00051463		bnez	$a0,.0001
FFFC0984 B8DFF06F		jmp   Monitor
                        	.0001:
FFFC0988 00054283	  ldbu  $t0,[$a0]
FFFC098C 10094303	  ldbu  $t1,INBUF[$s2]
FFFC0990 02030A63	  beqz  $t1,.found
FFFC0994 00629863	  bne   $t0,$t1,.next
FFFC0998 00150513	  add   $a0,$a0,#1
FFFC099C 00190913	  add   $s2,$s2,#1
FFFC09A0 FC000CE3	  bra   .loop
                        	.next:
FFFC09A4 0004E933	  mov   $s2,$s1         ; start over again with $s2
FFFC09A8 00158513	  add   $a0,$a1,#1      ; start over again with $a0, but increment by one
FFFC09AC 000803B7	  ldi   $t2,#$80000     ; 512k
FFFC09B0 00038393
FFFC09B4 000565B3	  mov   $a1,$a0         ; remember new starting pos.
FFFC09B8 007523B3	  slt   $t2,$a0,$t2
FFFC09BC FA039EE3	  bnez  $t2,.loop
FFFC09C0 00000E63	  bra   .notFound
                        	.found:
FFFC09C4 13C000EF	  call  PutHexWord
FFFC09C8 00D06513	  ldi   $a0,#CR
FFFC09CC A15FF0EF	  call  Putch
FFFC09D0 00006513	  ldi   $a0,#LF
  call  Putch
FFFC09D4 A0DFF0EF
FFFC09D8 FC0006E3	  bra   .next
                        	.notFound:
FFFC09DC 00D06513	  ldi   $a0,#CR
FFFC09E0 A01FF0EF	  call  Putch
FFFC09E4 00006513	  ldi   $a0,#LF
  call  Putch
FFFC09E8 9F9FF0EF
FFFC09EC B25FF06F	  jmp   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC09F0 10048283		ldb		$t0,INBUF[$s1]
FFFC09F4 0202C313		xor		$t1,$t0,#' '
FFFC09F8 00030863		beqz	$t1,.skip1
FFFC09FC 0092C313		xor		$t1,$t0,#'\t'
FFFC0A00 00030463		beqz	$t1,.skip1
FFFC0A04 00008067		ret
                        	.skip1:
FFFC0A08 00148493		add		$s1,$s1,#1
FFFC0A0C FE0002E3		bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	  align 16                        	
                        	GetHexNum:
FFFC0A10 00006513		ldi		$a0,#0							; a0 = num
FFFC0A14 FFC10113		sub		$sp,$sp,#4
FFFC0A18 00112023		stt		$ra,[$sp]
FFFC0A1C FD5FF0EF		call	SkipSpaces
                        	.next:
FFFC0A20 10048283		ldb		$t0,INBUF[$s1]
FFFC0A24 03006393		ldi		$t2,#'0'
FFFC0A28 0272C663		blt		$t0,$t2,.0001
FFFC0A2C 03A06393		ldi		$t2,#'9'+1
FFFC0A30 0672C063		blt		$t0,$t2,.isDigit
FFFC0A34 04106393		ldi		$t2,#'A'
FFFC0A38 0072CE63		blt		$t0,$t2,.0001
FFFC0A3C 04706393		ldi		$t2,#'F'+1
FFFC0A40 0272C063		blt		$t0,$t2,.isHexUpper
FFFC0A44 06106393		ldi		$t2,#'a'
FFFC0A48 0072C663		blt		$t0,$t2,.0001
FFFC0A4C 06706393		ldi		$t2,#'f'+1
FFFC0A50 0272C463		blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC0A54 00012083		ldt		$ra,[$sp]
FFFC0A58 00410113		add		$sp,$sp,#4
FFFC0A5C 00008067		ret
                        	.isHexUpper:
FFFC0A60 00451513		sll		$a0,$a0,#4
FFFC0A64 FBF28293		sub		$t0,$t0,#'A'
FFFC0A68 00A28293		add		$t0,$t0,#10
FFFC0A6C 00556533		or		$a0,$a0,$t0
FFFC0A70 00148493		add		$s1,$s1,#1
FFFC0A74 FA0006E3		bra		.next
                        	.isHexLower:
FFFC0A78 00451513		sll		$a0,$a0,#4
FFFC0A7C F9F28293		sub		$t0,$t0,#'a'
FFFC0A80 00A28293		add		$t0,$t0,#10
FFFC0A84 00556533		or		$a0,$a0,$t0
FFFC0A88 00148493		add		$s1,$s1,#1
FFFC0A8C F8000AE3		bra		.next
                        	.isDigit:
FFFC0A90 00451513		sll		$a0,$a0,#4
FFFC0A94 FD028293		sub		$t0,$t0,#'0'
FFFC0A98 00556533		or		$a0,$a0,$t0
FFFC0A9C 00148493		add		$s1,$s1,#1
FFFC0AA0 F80000E3		bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a decimal number from the input buffer.
                        	;------------------------------------------------------------------------------
FFFC0AA4 00000000	  align 1
FFFC0AA8 00000000
FFFC0AAC 00000000
                        	
                        	GetDecNum:
FFFC0AB0 00006513		ldi		$a0,#0							; a0 = num
FFFC0AB4 FFC10113		sub		$sp,$sp,#4
FFFC0AB8 00112023		stt		$ra,[$sp]
FFFC0ABC F35FF0EF		call	SkipSpaces
                        	.next:
FFFC0AC0 10048283		ldb		$t0,INBUF[$s1]
FFFC0AC4 03006393		ldi		$t2,#'0'
FFFC0AC8 0072C663		blt		$t0,$t2,.0001
FFFC0ACC 03A06393		ldi		$t2,#'9'+1
FFFC0AD0 0072C863		blt		$t0,$t2,.isDigit
                        	.0001:
FFFC0AD4 00012083		ldt		$ra,[$sp]
FFFC0AD8 00410113		add		$sp,$sp,#4
FFFC0ADC 00008067		ret
                        	.isDigit:
FFFC0AE0 00151393		sll		$t2,$a0,#1    ; multiply by 10
FFFC0AE4 00351513		sll   $a0,$a0,#3    ; * 8
FFFC0AE8 00750533		add   $a0,$a0,$t2   ; + *2
FFFC0AEC FD028293		sub		$t0,$t0,#'0'
FFFC0AF0 00550533		add		$a0,$a0,$t0
FFFC0AF4 00148493		add		$s1,$s1,#1
FFFC0AF8 FC0004E3		bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains word to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
FFFC0AFC 00000000	  align 1
                        	
                        	PutHexWord:
FFFC0B00 FF810113		sub		$sp,$sp,#8
FFFC0B04 00112023		stt		$ra,[$sp]
FFFC0B08 00A12223		stt		$a0,4[$sp]
FFFC0B0C 01055513		srl		$a0,$a0,#16
FFFC0B10 020000EF		call	PutHexHalf
FFFC0B14 00012083		ldt		$ra,[$sp]
FFFC0B18 00412503		ldt		$a0,4[$sp]
FFFC0B1C 00810113		add		$sp,$sp,#8	; fall through to PutHexHalf
FFFC0B20 00000863		bra		PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
FFFC0B24 00000000		align	1
FFFC0B28 00000000
FFFC0B2C 00000000
                        	
                        	PutHexHalf:
FFFC0B30 FF810113		sub		$sp,$sp,#8
FFFC0B34 00112023		stt		$ra,[$sp]
FFFC0B38 00A12223		stt		$a0,4[$sp]
FFFC0B3C 00855513		srl		$a0,$a0,#8
FFFC0B40 020000EF		call	PutHexByte
FFFC0B44 00012083		ldt		$ra,[$sp]
FFFC0B48 00412503		ldt		$a0,4[$sp]		
FFFC0B4C 00810113		add		$sp,$sp,#8	; fall through to PutHexByte
FFFC0B50 00000863		bra		PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
FFFC0B54 00000000		align	1
FFFC0B58 00000000
FFFC0B5C 00000000
                        	
                        	PutHexByte:
FFFC0B60 FF810113		sub		$sp,$sp,#8
FFFC0B64 00112023		stt		$ra,[$sp]
FFFC0B68 00A12223		stt		$a0,4[$sp]
FFFC0B6C 00455513		srl		$a0,$a0,#4		; put the high order nybble first
FFFC0B70 020000EF		call	PutHexNybble
FFFC0B74 00012083		ldt		$ra,[$sp]
FFFC0B78 00412503		ldt		$a0,4[$sp]
FFFC0B7C 00810113		add		$sp,$sp,#8		; fall through to PutHexNybble
FFFC0B80 00000863		bra		PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains nybble to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
FFFC0B84 00000000		align	1
FFFC0B88 00000000
FFFC0B8C 00000000
                        	
                        	PutHexNybble:
FFFC0B90 FF410113		sub		$sp,$sp,#12
FFFC0B94 00112023		stt		$ra,[$sp]
FFFC0B98 00A12223		stt		$a0,4[$sp]
FFFC0B9C 00512423		stt   $t0,8[$sp]
FFFC0BA0 00F57513		and		$a0,$a0,#15		; strip off high order bits
FFFC0BA4 00A06293		ldi		$t0,#10
FFFC0BA8 00554A63		blt		$a0,$t0,.lt10
FFFC0BAC FF650513		sub		$a0,$a0,#10
FFFC0BB0 04150513		add		$a0,$a0,#'A'
FFFC0BB4 82DFF0EF		call	Putch
FFFC0BB8 00000663		bra		.0001
                        	.lt10:
FFFC0BBC 03050513		add		$a0,$a0,#'0'
FFFC0BC0 821FF0EF		call	Putch
                        	.0001:
FFFC0BC4 00012083		ldt		$ra,[$sp]
FFFC0BC8 00412503		ldt		$a0,4[$sp]
FFFC0BCC 00812283		ldt   $t0,8[$sp]
FFFC0BD0 00C10113		add		$sp,$sp,#12
FFFC0BD4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
FFFC0BD8 00000000	  align 1
FFFC0BDC 00000000
                        	
                        	PutString:
FFFC0BE0 FF810113		sub		$sp,$sp,#8				; save link register
FFFC0BE4 00112023		stt		$ra,[$sp]
FFFC0BE8 00A12223		stt		$a0,4[$sp]				; and argument
FFFC0BEC 00056333		mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0BF0 00030503		ldb		$a0,[$t1]
FFFC0BF4 00130313		add		$t1,$t1,#1				; advance pointer to next byte
FFFC0BF8 00050663		beqz	$a0,.done			    ; branch if done
FFFC0BFC FE4FF0EF		call	Putch							; output character
FFFC0C00 FE0008E3		bra		.0001
                        	.done:
FFFC0C04 00012083		ldt		$ra,[$sp]					; restore return address
FFFC0C08 00412503		ldt		$a0,4[$sp]				; and argument
FFFC0C0C 00810113		add		$sp,$sp,#8
FFFC0C10 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	DumpTraceQueue:
FFFC0C14 FFC10113		sub		$sp,$sp,#4
FFFC0C18 00112023		stt		$ra,[$sp]
FFFC0C1C 05806813		ldi   $a6,#'X'        ; bypass='B' in fputc routine
                        	.dmpTrace:
FFFC0C20 00D06513		ldi   $a0,#CR
FFFC0C24 FBCFF0EF		call  Putch
FFFC0C28 00E06593		ldi   $a1,#14         ; processor trace queue
FFFC0C2C 1A05850D		popq  $a0,$a1
	bltz  $a0,.dmpTraceEmpty  ; emptied out?
FFFC0C30 02054063
FFFC0C34 001008B7		and   $a0,$a0,#$FFFFF
FFFC0C38 FFF88893
FFFC0C3C 00A8F533
FFFC0C40 EC1FF0EF		call  PutHexWord
FFFC0C44 02006513		ldi		$a0,#' '
FFFC0C48 F98FF0EF		call	Putch
FFFC0C4C FC000AE3		bra   .dmpTrace
                        	.dmpTraceEmpty:
FFFC0C50 00D06513		ldi   $a0,#CR
FFFC0C54 F8CFF0EF		call  Putch
                        	.inf:
                        	;  bra   .inf
FFFC0C58 00012083		ldt		$ra,[$sp]
FFFC0C5C 00410113		add		$sp,$sp,#4
FFFC0C60 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;
                        	; On incoming the register file has been set to the interrupt register file
                        	; or the machine mode register file.
                        	;------------------------------------------------------------------------------
FFFC0C64 00000000	  align 1
FFFC0C68 00000000
FFFC0C6C 00000000
                        	
                        	; Top of stack for different register sets
                        	StackTbl:
FFFC0C70 00000000	  dw    $0
FFFC0C74 00000000	  dw    $0
FFFC0C78 00000000	  dw    $0
FFFC0C7C 00000000	  dw    $0
FFFC0C80 00000000	  dw    $0
FFFC0C84 00000000	  dw    $0
FFFC0C88 00000000	  dw    $0
FFFC0C8C 00000000	  dw    $0
FFFC0C90 00000000	  dw    $0
FFFC0C94 00000000	  dw    $0
FFFC0C98 00000000	  dw    $0
FFFC0C9C 00000000	  dw    $0
FFFC0CA0 00000000	  dw    $0
FFFC0CA4 00000000	  dw    $0
FFFC0CA8 00000000	  dw    $0
FFFC0CAC 00000000	  dw    $0
FFFC0CB0 00000000	  dw    $0
FFFC0CB4 00000000	  dw    $0
FFFC0CB8 00000000	  dw    $0
FFFC0CBC 00000000	  dw    $0
FFFC0CC0 00000000	  dw    $0
FFFC0CC4 00000000	  dw    $0
FFFC0CC8 00000000	  dw    $0
FFFC0CCC 00000000	  dw    $0
FFFC0CD0 00000000	  dw    $0
FFFC0CD4 00000000	  dw    $0
FFFC0CD8 00000000	  dw    $0
FFFC0CDC 00000000	  dw    $0
FFFC0CE0 2007E7FC	  dw    $2007E800-4
FFFC0CE4 2007EFFC	  dw    $2007F000-4
FFFC0CE8 2007F7FC	  dw    $2007F800-4
FFFC0CEC 2007FFFC	  dw    $20080000-4
                        	
                        	StackTbl2:
FFFC0CF0 2007A7FC		dw		$2007A800-4
FFFC0CF4 2007AFFC		dw		$2007B000-4
FFFC0CF8 2007B7FC		dw		$2007B800-4
FFFC0CFC 2007BFFC		dw		$2007C000-4
FFFC0D00 2007C7FC		dw		$2007C800-4
FFFC0D04 2007CFFC		dw		$2007D000-4
FFFC0D08 2007D7FC		dw		$2007D800-4
FFFC0D0C 2007DFFC		dw		$2007E000-4
                        	
                        	.file "cs01rom.r5a",1122
                        		code
                        		align	16                        	
                        	IRQRout:
FFFC0D10 342012F3		csrrw	$t0,#$342,$x0			; get cause code
FFFC0D14 02028E63		beqz	$t0,.instAlign
FFFC0D18 0602C263		bltz	$t0,.isIRQ		  ; irq or ecall?
FFFC0D1C 0022C393		xor   $t2,$t0,#2      ; illegal instruction?
FFFC0D20 00038863		beqz  $t2,.illegal
FFFC0D24 FFC2F393		and   $t2,$t0,#$FFFFFFFC
FFFC0D28 0083C393		xor   $t2,$t2,#8
FFFC0D2C 02038E63		beqz  $t2,.ecall
                        		; Some other cause
                        	.illegal:
FFFC0D30 2007D137		ldi		$sp,#$2007D000
FFFC0D34 00010113
FFFC0D38 7A00F073		csrrc $x0,#CSR_TRACECTRL,#1 ; turn off tracing
FFFC0D3C 7C40F073		csrrc	$x0,#CSR_PMSTACK,#1		; disable interrupts
FFFC0D40 ED5FF0EF		call	DumpTraceQueue
                        	;	ldi   $t0,#DumpTraceQueue
                        	;	csrrw $x0,#CSR_MEPC,$t0
                        	.illegal1:
FFFC0D44 00000063		bra		.illegal1
FFFC0D48 30200073		mret
                        	.soc:
FFFC0D4C 00000063	  bra   .soc
                        	.instAlign:
FFFC0D50 2007D137		ldi		$sp,#$2007D000
FFFC0D54 00010113
FFFC0D58 7A00F073		csrrc $x0,#CSR_TRACECTRL,#1 ; turn off tracing
FFFC0D5C 7C40F073		csrrc	$x0,#CSR_PMSTACK,#1		; disable interrupts
FFFC0D60 EB5FF0EF		call	DumpTraceQueue
                        	.instAlign1:
FFFC0D64 00000063		bra		.instAlign1
                        	.ecall:
                        	  ; We reset the stack pointer at each call to the OS in case an error causes
                        	  ; it to be messed up.
FFFC0D68 FFFC18B7		ldt		$sp,StackTbl+116	; setup machine mode stack pointer
FFFC0D6C CE488893
FFFC0D70 000888B3
FFFC0D74 0008A103
FFFC0D78 5A90106F		jmp		OSECALL					  ; goto operating system call dispatcher
                        	.isIRQ:
                        	;  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
                        	;  and   $t0,$t0,#31       ; extract register set selection (will be 30)
FFFC0D7C 7C5012F3		csrrw	$t0,#CSR_IMSTACK,$x0
FFFC0D80 0072F293		and		$t0,$t0,#7
FFFC0D84 00229393	  sll   $t2,$t0,#2        ; $t2 = table index
FFFC0D88 FFFC18B7		ldt		$sp,StackTbl2[$t2]	; setup machine mode stack pointer
FFFC0D8C CF088893
FFFC0D90 007888B3
FFFC0D94 0008A103
                        	; Cannot enable interrupts without switching register sets
                        	;	csrrs	$x0,#CSR_PMSTACK,#1	; enable higher-level interrupts
FFFC0D98 342012F3		csrrw	$t0,#$342,$x0			; get cause code
FFFC0D9C 000018B7	  ldt   $t1,IRQFlag     ; update IRQ flag for Tiny Basic
FFFC0DA0 09088893
FFFC0DA4 000888B3
FFFC0DA8 0008A303
FFFC0DAC 00130313	  add   $t1,$t1,#1
FFFC0DB0 000018B7	  stt   $t1,IRQFlag
FFFC0DB4 09088893
FFFC0DB8 000888B3
FFFC0DBC 0068A023
FFFC0DC0 0FF2F293	  and   $t0,$t0,#$FF
FFFC0DC4 000018B7	  stt   $t0,IRQCause    ; update cause code for Tiny Basic
FFFC0DC8 09888893
FFFC0DCC 000888B3
FFFC0DD0 0058A023
FFFC0DD4 FFF28313	  sub   $t1,$t0,#1
FFFC0DD8 04030263	  beqz  $t1,.softwareIrq
FFFC0DDC FFF30313	  sub   $t1,$t1,#1
FFFC0DE0 02030E63	  beqz  $t1,.timerIrq
FFFC0DE4 FFF30313	  sub   $t1,$t1,#1      ; garbage collect interrupt?
FFFC0DE8 08030663	  beqz  $t1,.gcIrq
FFFC0DEC 01F2FE93		and		$t4,$t0,#31			; interrupting device # is low order 5 bits of cause code
FFFC0DF0 00506E13		ldi   $t3,#5          ; try 5 times
                        	.devAgain:
FFFC0DF4 000EEF33		mov   $t5,$t4
FFFC0DF8 007F1F13		sll		$t5,$t5,#7				; 128 bytes per device func table
FFFC0DFC 000028B7		add		$t5,$t5,#DVF_Base+22*4	; load IRQ routine vector from device func table
FFFC0E00 05888893
FFFC0E04 01E88F33
FFFC0E08 000F2F03		ldt		$t5,[$t5]
FFFC0E0C 000F0463		beqz	$t5,.noIRQ	    ; make sure there's an address to go to
FFFC0E10 000F0067		jmp		[$t5]						; jump to the IRQ routine
                        	.noIRQ:
FFFC0E14 FFFE0E13	  sub   $t3,$t3,#1
FFFC0E18 000E1463	  bnez  $t3,.InitDev
                        	.softwareIrq:
                        	.timerIrq:
FFFC0E1C 30200073	  mret
                        		; The device function tables may have been zeroed out, try initializing them.
                        		; The following uses $a0-$a1, $t0-$t2
                        	.InitDev:
FFFC0E20 00506513		ldi		$a0,#5							; serial device
FFFC0E24 03D51263		bne   $a0,$t4,.notSerial
FFFC0E28 FFFC25B7		ldi		$a1,#SerialFuncTbl
FFFC0E2C BA858593
FFFC0E30 410030EF		call	CopyDevFuncTbl
FFFC0E34 00506513		ldi		$a0,#5							; serial device
FFFC0E38 FFFC25B7		ldi   $a1,#SerialDCB
FFFC0E3C C2858593
FFFC0E40 430030EF		call  CopyDevDCB
FFFC0E44 FA0008E3		bra   .devAgain
                        	.notSerial:
FFFC0E48 00F06513		ldi		$a0,#15							; VIA device
FFFC0E4C 03D51263		bne   $a0,$t4,.notVia
FFFC0E50 FFFC25B7		ldi		$a1,#ViaFuncTbl
FFFC0E54 23858593
FFFC0E58 3E8030EF		call	CopyDevFuncTbl
FFFC0E5C 00F06513		ldi		$a0,#15							; VIA device
FFFC0E60 FFFC25B7		ldi		$a1,#ViaDCB
FFFC0E64 2B858593
FFFC0E68 408030EF		call	CopyDevDCB
FFFC0E6C F80004E3		bra   .devAgain
                        	.notVia:
FFFC0E70 30200073	  mret
                        	.gcIrq:
                        	;	ldi		$sp,#$7F800-4		; setup interrupt mode stack pointer
FFFC0E74 5C0030EF	  call  gcIncrement
                        	ERETx2:
                        	;  mDI
                        	;  csrrc $x0,#$7C0,#31   ; select machine regs only
                        	;  csrrw $t0,#$7C0,$x0   ; get register sets
                        	;  srl   $t0,$t0,#5      ; extract register set selection
                        	;  sll   $t0,$t0,#3
                        	;  ldt   $t1,MEPC0[$t0]  ; get it
                        	;  csrrw $x0,#$341,$t1   ; set mepc
                        	  
FFFC0E78 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC0E7C 00000013	nop
FFFC0E80 00000013	  nop
                        	;  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
                        	;  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
                        	;  sll   $t2,$t0,#2        ; $t2 = table index
                        	;	ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFC0E84 30200073		mret
                        	
                        		; In case the pipeline runs ahead into the following table which will
                        		; result in illegal instructions.
FFFC0E88 00000013		nop
FFFC0E8C 00000013		nop
FFFC0E90 00000013	  nop
                        	
                        		align	4                        	
                        	; Application startup record for Monitor
                        	MonitorASR:
FFFC0E94 0A0A0200	  db    0     ; page size (can't change on this system)
FFFC0E95 000A0A02	  db    2     ; priority normal
FFFC0E96 00000A0A	  db    10    ; register set for startup task
FFFC0E97 0000000A	  db    10    ; memory map #0
FFFC0E98 00000000	  dw    0     ; processor affinity
FFFC0E9C 00000000	  dw    0     ; code size (0 = in ROM, don't move)
FFFC0EA0 00000000	  dw    0     ; reserved
FFFC0EA4 00000000	  dw    0     ; data size (preinitialized data)
FFFC0EA8 00000000	  dw    0     ; reserved
FFFC0EAC 00000000	  dw    0     ; uninitialized data size
FFFC0EB0 00000000	  dw    0     ; reserved
FFFC0EB4 00000000	  dw    0     ; Heap size
FFFC0EB8 00000000	  dw    0     ; reserved
FFFC0EBC 00000400	  dw    1024  ; stack size
FFFC0EC0 00000000	  dw    0     ; reserved
FFFC0EC4 FFFC04F8	  dw    MonEntry  ; pointer to code
FFFC0EC8 00000000	  dw    0       ; reserved
FFFC0ECC 00000000	  dw    0     ; pointer to data
FFFC0ED0 00000000	  dw    0     ; reserved
FFFC0ED4 00000000	  dw    0     ; ui data
FFFC0ED8 00000000	  dw    0     ; reserved
                        	
                        	; Application startup record for system
                        	SystemASR:
FFFC0EDC 1C1C0200	  db    0     ; page size (can't change on this system)
FFFC0EDD 001C1C02	  db    2     ; priority normal
FFFC0EDE 00001C1C	  db    28    ; register set for startup task
FFFC0EDF 0000001C	  db    28    ; memory map #0
FFFC0EE0 00000000	  dw    0     ; processor affinity
FFFC0EE4 00000000	  dw    0     ; code size (0 = in ROM, don't move)
FFFC0EE8 00000000	  dw    0     ; reserved
FFFC0EEC 00000000	  dw    0     ; data size (preinitialized data)
FFFC0EF0 00000000	  dw    0     ; reserved
FFFC0EF4 00000000	  dw    0     ; uninitialized data size
FFFC0EF8 00000000	  dw    0     ; reserved
FFFC0EFC 00000000	  dw    0     ; Heap size
FFFC0F00 00000000	  dw    0     ; reserved
FFFC0F04 00000400	  dw    1024  ; stack size
FFFC0F08 00000000	  dw    0     ; reserved
FFFC0F0C FFFC02A0	  dw    IdleTask  ; pointer to code
FFFC0F10 00000000	  dw    0       ; reserved
FFFC0F14 00000000	  dw    0     ; pointer to data
FFFC0F18 00000000	  dw    0     ; reserved
FFFC0F1C 00000000	  dw    0     ; ui data
FFFC0F20 00000000	  dw    0     ; reserved
                        	
                        	; Application startup record for Tiny Basic
                        	TinyBasicASR:
FFFC0F24 03030200	  db    0     ; page size (can't change on this system)
FFFC0F25 00030302	  db    2     ; priority normal
FFFC0F26 00000303	  db    3     ; register set
FFFC0F27 00000003	  db    3     ; memory map
FFFC0F28 00000000	  dw    0     ; processor affinity
FFFC0F2C 00000000	  dw    0     ; code size (0 = in ROM, don't move)
FFFC0F30 00000000	  dw    0     ; reserved
FFFC0F34 00000000	  dw    0     ; data size (preinitialized data)
FFFC0F38 00000000	  dw    0     ; reserved
FFFC0F3C 00008000	  dw    32768 ; uninitialized data size
FFFC0F40 00000000	  dw    0     ; reserved
FFFC0F44 00000000	  dw    0     ; Heap size
FFFC0F48 00000000	  dw    0     ; reserved
FFFC0F4C 00000800	  dw    2048  ; stack size
FFFC0F50 00000000	  dw    0     ; reserved
FFFC0F54 FFFC4530	  dw    CSTART  ; pointer to code
FFFC0F58 00000000	  dw    0       ; reserved
FFFC0F5C 00000000	  dw    0     ; pointer to data
FFFC0F60 00000000	  dw    0     ; reserved
FFFC0F64 00000000	  dw    0     ; ui data
FFFC0F68 00000000	  dw    0     ; reserved
                        	    
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC0F6C 31305343			db		"CS01 System Starting.",13
FFFC0F70 73795320
FFFC0F74 206D6574
FFFC0F78 72617453
FFFC0F7C 676E6974
FFFC0F80 6F4D0D2E
                        	msgMonHelp:
FFFC0F82 696E6F4D			db		"Monitor Commands",13
FFFC0F86 20726F74
FFFC0F8A 6D6D6F43
FFFC0F8E 73646E61
FFFC0F92 2D20420D
FFFC0F93 202D2042			db		"B - start tiny basic",13
FFFC0F97 72617473
FFFC0F9B 69742074
FFFC0F9F 6220796E
FFFC0FA3 63697361
FFFC0FA7 2D20440D
FFFC0FA8 202D2044			db		"D - dump ready que",13
FFFC0FAC 706D7564
FFFC0FB0 61657220
FFFC0FB4 71207964
FFFC0FB8 450D6575
FFFC0FBB 202D2045			db		"E - edit memory",13
FFFC0FBF 74696465
FFFC0FC3 6D656D20
FFFC0FC7 0D79726F
FFFC0FCB 202D2046			db		"F - fill memory",13
FFFC0FCF 6C6C6966
FFFC0FD3 6D656D20
FFFC0FD7 0D79726F
FFFC0FDB 3C204946			db    "FI <string>- find string in memory",13
FFFC0FDF 69727473
FFFC0FE3 2D3E676E
FFFC0FE7 6E696620
FFFC0FEB 74732064
FFFC0FEF 676E6972
FFFC0FF3 206E6920
FFFC0FF7 6F6D656D
FFFC0FFB 4B0D7972
FFFC0FFE 743C204B			db		"K <tid> - kill task", 13
FFFC1002 203E6469
FFFC1006 696B202D
FFFC100A 74206C6C
FFFC100E 0D6B7361
FFFC1012 733C204D			db		"M <start> <length>	- dump memory",13
FFFC1016 74726174
FFFC101A 6C3C203E
FFFC101E 74676E65
FFFC1022 2D093E68
FFFC1026 6D756420
FFFC102A 656D2070
FFFC102E 79726F6D
FFFC1032 2D20500D
FFFC1033 202D2050			db    "P - display PAM",13
FFFC1037 70736964
FFFC103B 2079616C
FFFC103F 0D4D4150
FFFC1043 202D2053			db		"S - switch task",13
FFFC1047 74697773
FFFC104B 74206863
FFFC104F 0D6B7361
FFFC1053 6D3C2056			db    "V <mid> dump virtual memory map",13
FFFC1057 203E6469
FFFC105B 706D7564
FFFC105F 72697620
FFFC1063 6C617574
FFFC1067 6D656D20
FFFC106B 2079726F
FFFC106F 0D70616D
FFFC1073 61742000			db		0
                        			align 4                        	
                        	msgTaskStart:
FFFC1074 73617420			db		" task started."
FFFC1078 7473206B
FFFC107C 65747261
FFFC1080 0A0D2E64
                        	msgCRLF:
FFFC1082 00000A0D			db		13,10,0
                        	flt50:
FFFC1085 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC1089 00000000
FFFC108D 00000000
FFFC1091 40049000
                        	flt20:
FFFC1095 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC1099 00000000
FFFC109D 00000000
FFFC10A1 40034000
                        	flt10:
FFFC10A5 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC10A9 00000000
FFFC10AD 00000000
FFFC10B1 40024000
                        	
                        	.file "fltToString.r5a",1
                        	.file "fltToString.r5a",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC10B5 00639300			ldi		$t2,#0				; $t2 = 0
FFFC10B9 09055300
FFFC10BA E0090553			fmv		$a0,$f18
FFFC10BE 7F8008B7			and		$t0,$a0,#$7F800000
FFFC10C2 00088893
FFFC10C6 00A8F2B3
FFFC10CA 7F800337			ldi		$t1,#$7F800000
FFFC10CE 00030313
FFFC10D2 04629263			bne		$t0,$t1,.0001
FFFC10D6 008008B7			and		$t0,$a0,#$007FFFFF
FFFC10DA FFF88893
FFFC10DE 00A8F2B3
FFFC10E2 00028E63			beq		$t0,$x0,.inf
FFFC10E6 FFFC18B7			ldt		$t0,msgNan
FFFC10EA 47088893
FFFC10EE 000888B3
FFFC10F2 0008A283
FFFC10F6 20502023			stt		$t0,STRTMP
FFFC10FA 2E000E63			bra		.prt
                        	.inf:
FFFC10FE FFFC18B7			ldt		$t0,msgInf
FFFC1102 46C88893
FFFC1106 000888B3
FFFC110A 0008A283
FFFC110E 20502023			stt		$t0,STRTMP
FFFC1112 2E000263			bra		.prt
                        	.0001:
FFFC1116 800008B7			and		$t0,$a0,#$80000000
FFFC111A 00088893
FFFC111E 00A8F2B3
FFFC1122 00028E63			beq		$t0,$x0,.pos
FFFC1126 02D06293			ldi		$t0,#'-'
FFFC112A 20538023			stb		$t0,STRTMP[$t2]
FFFC112E 00138393			add		$t2,$t2,#1
FFFC1132 800008B7			and		$a0,$a0,#$7FFFFFFF
FFFC1136 FFF88893
FFFC113A 00A8F533
                        	.pos:
FFFC113E 00051A63			bne		$a0,$x0,.notZero
FFFC1142 03006293			ldi		$t0,#'0'
FFFC1146 20538023			stb		$t0,STRTMP[$t2]
FFFC114A 200380A3			stb		$x0,STRTMP+1[$t2]
FFFC114E 2A000463			bra		.prt		
                        	.notZero:
FFFC1152 00006CB3			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC1156 FFFC18B7			flw		$f3,fltOne
FFFC115A 47488893
FFFC115E 000888B3
FFFC1162 0008A187
FFFC1166 F0050053			fmv		$f0,$a0
FFFC116A A03912D3			flt		$t0,$f18,$f3
FFFC116E 02028463			beq		$t0,$x0,.0002
FFFC1172 FFFC18B7			flw		$f4,fltMillion
FFFC1176 47C88893
FFFC117A 000888B3
FFFC117E 0008A207
                        	.0003:
FFFC1182 A03912D3			flt		$t0,$f18,$f3
FFFC1186 00028863			beq		$t0,$x0,.0002
FFFC118A 10490953			fmul	$f18,$f18,$f4
FFFC118E FFAC8C93			sub		$s9,$s9,#6
FFFC1192 FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC1196 FFFC18B7			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC119A 47488893
FFFC119E 000888B3
FFFC11A2 0008A087
FFFC11A6 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC11AA A12092D3			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC11AE 02028A63			beq		$t0,$x0,.0004
FFFC11B2 FFFC18B7			flw		$f5,fltTen				; $f5 = 10.0
FFFC11B6 47888893
FFFC11BA 000888B3
FFFC11BE 0008A287
                        	.0006:
FFFC11C2 A12082D3			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC11C6 00028A63			beq		$t0,$x0,.0005
FFFC11CA 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC11CE 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC11D2 001C8C93			add		$s9,$s9,#1				; exp++;
FFFC11D6 FE0006E3			bra		.0006
                        	.0005:
FFFC11DA 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC11DE FFFC8C93			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC11E2 000CCE63			blt		$s9,$x0,.0007
FFFC11E6 00606A93			ldi		$s5,#6
FFFC11EA 015CDA63			bge		$s9,$s5,.0007
FFFC11EE FFFFE4B3			mov		$s1,#s0						; s1 = digits before decpt
FFFC11F2 00148493			add		$s1,$s1,#1
FFFC11F6 00006C93			ldi		$s9,#0						; exp = 0
FFFC11FA 00000C63			bra		.0008
                        	.0007:
FFFC11FE FF906A93			ldi		$s5,#-7
FFFC1202 015CC663			blt		$s9,$s5,.0009
FFFC1206 00106493			ldi		$s1,#1
FFFC120A 00000463			bra		.0008
                        	.0009:
FFFC120E FFF06493			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC1212 FFA06A93			ldi		$s5,#-6
FFFC1216 015CDE63			bge		$s9,$s5,.0010
FFFC121A 03006293			ldi		$t0,#'0'
FFFC121E 20538023			stb		$t0,STRTMP[$t2]
FFFC1222 00138393			add		$t2,$t2,#1
FFFC1226 02E06293			ldi		$t0,#'.'
FFFC122A 20538023			stb		$t0,STRTMP[$t2]
FFFC122E 00138393			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC1232 00006993			ldi		$s3,#0						; s3 = nn = 0
FFFC1236 01E06A93			ldi		$s5,#30
FFFC123A FFFC18B7			flw		$f7,fltTen				; f7 = 10.0
FFFC123E 47888893
FFFC1242 000888B3
FFFC1246 0008A387
                        	.0016:
FFFC124A 0159A2B3			slt		$t0,$s3,$s5
FFFC124E 06028863			beq		$t0,$x0,.0011
FFFC1252 00006A93			ldi		$s5,#0
FFFC1256 06CAD463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC125A 00006A13			ldi		$s4,#0						; s4 = digit = 0
FFFC125E 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC1262 A12082D3			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC1266 00028863			beq		$t0,$x0,.0012
FFFC126A 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC126E 001A0A13			add		$s4,$s4,#1						; digit++
FFFC1272 FE0008E3			bra		.0013
                        	.0012:
FFFC1276 030A0A93			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC127A 21538023			stb		$s5,STRTMP[$t2]
FFFC127E 00206A93			ldi		$s5,#2						; if (2 < digit)
FFFC1282 014AD863			bge		$s5,$s4,.0014
FFFC1286 D00A02D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC128A 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC128E 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC1292 00138393			add		$t2,$t2,#1				; ndx++
FFFC1296 FFF48493			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC129A 00049A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC129E 02E06293			ldi		$t0,#'.'
FFFC12A2 20538023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC12A6 00138393			add		$t2,$t2,#1				; ndx++
FFFC12AA 00000663			bra		.0017
                        	.0015:
FFFC12AE 0004D463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC12B2 FFF60613			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC12B6 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC12BA F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC12BE FFF38393			sub		$t2,$t2,#1				; ndx--
FFFC12C2 20038283			ldb		$t0,STRTMP[$t2]
FFFC12C6 0302C293			xor		$t0,$t0,#'0'
FFFC12CA FE028AE3			beq		$t0,$x0,.0018
FFFC12CE 00138393			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC12D2 20038283			ldb		$t0,STRTMP[$t2]
FFFC12D6 02E2C293			xor		$t0,$t0,#'.'
FFFC12DA 00029C63			bne		$t0,$x0,.0019
FFFC12DE 00138393			add		$t2,$t2,#1
FFFC12E2 03006293			ldi		$t0,#'0'
FFFC12E6 20538023			stb		$t0,STRTMP[$t2]
FFFC12EA 00138393			add		$t2,$t2,#1
FFFC12EE 20038023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC12F2 000C9663			bne		$s9,$x0,.0020
FFFC12F6 20038023			stb		$x0,STRTMP[$t2]
FFFC12FA 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC12FE 04506293			ldi		$t0,#'E'
FFFC1302 20538023			stb		$t0,STRTMP[$t2]
FFFC1306 00138393			add		$t2,$t2,#1
FFFC130A 000CDC63			bge		$s9,$x0,.0021
FFFC130E 02D06293			ldi		$t0,#'-'
FFFC1312 20538023			stb		$t0,STRTMP[$t2]
FFFC1316 00138393			add		$t2,$t2,#1
FFFC131A 41900CB3			sub		$s9,$x0,$s9			; exp = -exp
FFFC131E 00000863			bra		.0022
                        	.0021:
FFFC1322 02B06293			ldi		$t0,#'+'
FFFC1326 20538023			stb		$t0,STRTMP[$t2]
FFFC132A 00138393			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC132E 00006A13			ldi		$s4,#0
FFFC1332 3E806293			ldi		$t0,#1000
                        	.0025:
FFFC1336 005CD463			bge		$s9,$t0,.0023
FFFC133A 00000863			bra		.0024
                        	.0023:
FFFC133E 405C8CB3			sub		$s9,$s9,$t0
FFFC1342 001A0A13			add		$s4,$s4,#1
FFFC1346 FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC134A 000A6B33			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC134E 000A1863			bne		$s4,$x0,.0026
FFFC1352 030A0293			add		$t0,$s4,#'0'
FFFC1356 20538023			stb		$t0,STRTMP[$t2]
FFFC135A 00138393			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC135E 00006A13			ldi		$s4,#0
FFFC1362 06406293			ldi		$t0,#100
                        	.0027:
FFFC1366 005CD463			bge		$s9,$t0,.0028
FFFC136A 00000863			bra		.0029
                        	.0028:
FFFC136E 405C8CB3			sub		$s9,$s9,$t0
FFFC1372 001A0A13			add		$s4,$s4,#1
FFFC1376 FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC137A 000A6BB3			mov		$s7,$s4				; $s7 = d2
FFFC137E 000B1463			bne		$s6,$x0,.0030
FFFC1382 000A0863			beq		$s4,$x0,.0031
                        	.0030:
FFFC1386 030A0293			add		$t0,$s4,#'0'
FFFC138A 20538023			stb		$t0,STRTMP[$t2]
FFFC138E 00138393			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC1392 00006A13			ldi		$s4,#0
FFFC1396 00A06293			ldi		$t0,#10
                        	.0032:
FFFC139A 005CD463			bge		$s9,$t0,.0034
FFFC139E 00000863			bra		.0035
                        	.0034:
FFFC13A2 405C8CB3			sub		$s9,$s9,$t0
FFFC13A6 001A0A13			add		$s4,$s4,#1
FFFC13AA FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC13AE 000A6C33			mov		$s8,$s4
FFFC13B2 000A1663			bne		$s4,$x0,.0036
FFFC13B6 000B1463			bne		$s6,$x0,.0036
FFFC13BA 000B8863			beq		$s7,$x0,.0037
                        	.0036:
FFFC13BE 030A0293			add		$t0,$s4,#'0'
FFFC13C2 20538023			stb		$t0,STRTMP[$t2]
FFFC13C6 00138393			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC13CA 00006A13			ldi		$s4,#0
FFFC13CE 00106293			ldi		$t0,#1
                        	.0038:
FFFC13D2 005CD463			bge		$s9,$t0,.0040
FFFC13D6 00000863			bra		.0039
                        	.0040:
FFFC13DA 405C8CB3			sub		$s9,$s9,$t0
FFFC13DE 001A0A13			add		$s4,$s4,#1
FFFC13E2 FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC13E6 030A0293			add		$t0,$s4,#'0'
FFFC13EA 20538023			sb		$t0,STRTMP[$t2]
FFFC13EE 00138393			add		$t2,$t2,#1
FFFC13F2 20038023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC13F6 0405C663			blt		$a1,$x0,.0041
FFFC13FA 04058463			beq		$a1,$x0,.0041
FFFC13FE 00B3C463			blt		$t2,$a1,.0042
FFFC1402 04000063			bra		.0041
                        	.0042:
FFFC1406 02706993			ldi		$s3,#39					; s3 = nn
FFFC140A 407582B3			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC140E 0059D463			bge		$s3,$t0,.0043
FFFC1412 00000C63			bra		.0044
                        	.0043:
FFFC1416 40598B33			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC141A 20098303			ldb		$t1,STRTMP[$s3]
FFFC141E 206B0023			stb		$t1,STRTMP[$s6]
FFFC1422 FFF98993			sub		$s3,$s3,#1
FFFC1426 FE0004E3			bra		.0045
                        	.0044:
FFFC142A 02006293			ldi		$t0,#' '
                        	.0048:
FFFC142E 0009D463			bge		$s3,$x0,.0046
FFFC1432 00000863			bra		.0047
                        	.0046:
FFFC1436 20598023			stb		$t0,STRTMP[$s3]
FFFC143A FFF98993			sub		$s3,$s3,#1
FFFC143E FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC1442 0205D063			bge		$a1,$x0,.0050
FFFC1446 40B005B3			sub		$a1,$x0,$a1
FFFC144A 02006293			ldi		$t0,#' '
                        	.0052:
FFFC144E 00B3D863			bge		$t2,$a1,.0051
FFFC1452 20538023			stb		$t0,STRTMP[$t2]
FFFC1456 00138393			add		$t2,$t2,#1
FFFC145A FE000AE3			bra		.0052
                        	.0051:
FFFC145E 20038023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC1462 0003E533			mov		$a0,$t2
FFFC1466 00008067			ret
                        	
FFFC146A 6E490000			align	
                        	
                        	msgInf:
FFFC146C 00666E49			db	"Inf",0
                        	msgNan:
FFFC1470 006E614E			db	"Nan",0
                        	fltOne:
FFFC1474 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC1478 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC147C 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01Mem.r5a",1
                        	.file "cs01Mem.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "cs01Mem.r5a",25
                        			code	18 bits
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	MMUInit:
FFFC1480 1EC06293		ldi		$t0,#MEMSZ-OSPAGES-4  ; set number of available pages (20 pages already allocated)
FFFC1484 30502023		stt		$t0,NPAGES
                        	
                        		; satp register setting
FFFC1488 602002B7		ldi		$t0,#$60200100			; 32 maps of 256 entries, ASID = 0, custom MMU selected
FFFC148C 10028293
FFFC1490 18029073		csrrw	$x0,#CSR_SATP,$t0	  ; set ASID
                        	
                        		; Free all memory for all tasks
                        		; Sets all pages to map to page zero for all tasks, except for the system
                        		; tasks (task #28 to 31) which pre-allocates the first 16kB of memory.
FFFC1494 00006293		ldi		$t0,#$00
FFFC1498 01F06E93		ldi		$t4,#31					; app id
FFFC149C 01C06F13		ldi		$t5,#28
                        	.0004:
FFFC14A0 00006313		ldi		$t1,#$000				; regno
FFFC14A4 10006393		ldi		$t2,#256				; number of registers to update
FFFC14A8 01006E13		ldi		$t3,#16					; number of pages pre-allocated
                        	.0001:
FFFC14AC 010E9493		sll		$s1,$t4,#16			; put app id in place
FFFC14B0 0064E4B3		or		$s1,$s1,$t1			; or in page number
FFFC14B4 0292800D		mvmap	$x0,$t0,$s1
FFFC14B8 00128293		add		$t0,$t0,#$01
FFFC14BC 00130313		add		$t1,$t1,#$01		; increment page number
FFFC14C0 000E8463		beqz	$t4,.0008
FFFC14C4 01EEC463		blt   $t4,$t5,.0005
                        	.0008:
FFFC14C8 01C36463		bltu	$t1,$t3,.0003
                        	.0005:
FFFC14CC 000062B3		mov		$t0,$x0					; mark pages unallocated
                        	.0003:
FFFC14D0 FFF38393		sub		$t2,$t2,#1
FFFC14D4 FC039CE3		bnez	$t2,.0001
FFFC14D8 FFFE8E93		sub		$t4,$t4,#1      ; next app id
FFFC14DC FC0ED2E3		bge		$t4,$x0,.0004
                        	
                        		; allocate last 12 pages for system stacks
FFFC14E0 00C06393		ldi		$t2,#12
FFFC14E4 0FF06313		ldi		$t1,#$FF				
FFFC14E8 1FF06293		ldi		$t0,#$1FF
                        	.0006:
FFFC14EC 0262800D		mvmap	$x0,$t0,$t1
FFFC14F0 FFF30313		sub		$t1,$t1,#1
FFFC14F4 FFF28293		sub		$t0,$t0,#1
FFFC14F8 FFF38393		sub		$t2,$t2,#1
FFFC14FC FE0398E3		bnez	$t2,.0006
                        	
                        		; Now setup segment registers
FFFC1500 00006293		ldi		$t0,#$0
FFFC1504 00706313		ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC1508 0053000D		mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC150C 00128293		add		$t0,$t0,#1			; pick next segment register
FFFC1510 0802A393		slt		$t2,$t0,#128		; 128 base regs
FFFC1514 FE039AE3		bnez	$t2,.0002
FFFC1518 08006293		ldi		$t0,#128
FFFC151C FFF06313		ldi		$t1,#-1					; t1 = value to load, bounds max
                        	.0007:
FFFC1520 0053000D		mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC1524 00128293		add		$t0,$t0,#1			; pick next segment register
FFFC1528 1002A393		slt		$t2,$t0,#256		; 128 bound regs
FFFC152C FE039AE3		bnez	$t2,.0007
                        	
                        		; Now ensure all pages in PAM are marked as free or OS allocated
                        		; Cannot use stack until here, after segment regs and mem mapped.
FFFC1530 FFC10113		sub		$sp,$sp,#4
FFFC1534 00112023		stt		$ra,[$sp]
FFFC1538 598000EF		call  PAMInit
FFFC153C 00012083		ldt		$ra,[$sp]
FFFC1540 00410113		add		$sp,$sp,#4
FFFC1544 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		a0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
FFFC1548 00000000		align	1
FFFC154C 00000000
                        	
                        	FindRun:
FFFC1550 01F57E13		and			$t3,$a0,#$1F			; t3 = mid
FFFC1554 010E1E13		sll			$t3,$t3,#16				; shift into usable position
FFFC1558 00006313		ldi			$t1,#0						; t1 = count of consecutive empty buckets
FFFC155C 000E63B3		mov			$t2,$t3						; t2 = map entry number
FFFC1560 0103E393		or			$t2,$t2,#OSPAGES	; start looking at page 32 (others are for OS)
FFFC1564 1FF06F13		ldi			$t5,#511					; max number of pages - 1
FFFC1568 01CF6F33		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0001:
FFFC156C 0270050D		mvmap		$a0,$x0,$t2				; get map entry into v0
FFFC1570 00050A63		beq			$a0,$x0,.empty0		; is it empty?
FFFC1574 00138393		add			$t2,$t2,#1
FFFC1578 FFE3EAE3		bltu		$t2,$t5,.0001
                        	.0002:
FFFC157C FFF06513		ldi			$a0,#-1						; got here so no run was found
FFFC1580 00008067		ret
                        	.empty0:
FFFC1584 0003EE33		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC1588 FFE3FAE3		bgeu		$t2,$t5,.0002
FFFC158C 00130313		add			$t1,$t1,#1
FFFC1590 00B37C63		bgeu		$t1,$a1,.foundEnough
FFFC1594 00138393		add			$t2,$t2,#1				; next bucket
FFFC1598 0270050D		mvmap		$a0,$x0,$t2				; get map entry
FFFC159C FE0506E3		beq			$a0,$x0,.empty1
FFFC15A0 00006333		mov			$t1,$x0						; reset counter
FFFC15A4 FC0004E3		bra			.0001							; go back and find another run
                        	.foundEnough:
FFFC15A8 000E6533		mov			$a0,$t3						; v0 = start of run
FFFC15AC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = mid
                        	;		$a1 = amount of memory to allocate
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		$a1 = pointer to allocated memory in virtual address space.
                        	;		$a0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	Alloc:
FFFC15B0 FE810113		sub			$sp,$sp,#24
FFFC15B4 00112023		stt			$ra,[$sp]
FFFC15B8 00912223		stt			$s1,4[$sp]			; these regs must be saved
FFFC15BC 01212423		stt			$s2,8[$sp]
FFFC15C0 01312823		stt			$s3,16[$sp]
FFFC15C4 01412A23		stt     $s4,20[$sp]
FFFC15C8 0A058663		beqz    $a1,.allocZero
                        		; First check if there are enough pages available in the system.
FFFC15CC 3FF58A13		add			$s4,$a1,#PAGESZ-1	; v0 = round memory request
FFFC15D0 00AA5A13		srl			$s4,$s4,#LOG_PGSZ	; v0 = convert to pages required
FFFC15D4 30002283		ldt			$t0,NPAGES				; check number of pages available
FFFC15D8 0142F663		bleu		$s4,$t0,.enough
                        	.noRun2:
FFFC15DC 00006593		ldi			$a1,#0						; not enough, return null
FFFC15E0 06000A63		bra			.noRun
                        	.enough:
FFFC15E4 000564B3		mov			$s1,$a0
                        		; There are enough pages, but is there a run long enough in map space?
FFFC15E8 000A6933		mov			$s2,$s4				    ; save required # pages
FFFC15EC 000A65B3		mov			$a1,$s4
FFFC15F0 F61FF0EF		call		FindRun						; find a run of available slots
FFFC15F4 FE0544E3		bltz		$a0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC15F8 000564B3		mov			$s1,$a0						; s1 = start of run
FFFC15FC 30002983		ldt			$s3,NPAGES				; decrease number of pages available in system
FFFC1600 412989B3		sub			$s3,$s3,$s2
FFFC1604 31302023		stt			$s3,NPAGES
FFFC1608 000569B3		mov			$s3,$a0						; s3 = start of run
                        	.0001:
FFFC160C 3D4000EF	  call    PAMMarkPage       ; allocates a page
                        	;	palloc	$v0								; allocate a page (cheat and use hardware)
                        		;call		AllocPage
FFFC1610 04050263		beqz		$a0,.noRun        ; shouldn't get an error here
FFFC1614 0335000D		mvmap		$x0,$a0,$s3				; map the page
FFFC1618 00198993		add			$s3,$s3,#1				; next bucket
FFFC161C FFF90913		sub			$s2,$s2,#1
FFFC1620 FE0916E3		bnez		$s2,.0001
FFFC1624 000108B7		and     $a1,$s1,#$FFFF    ; strip out ASID
FFFC1628 FFF88893
FFFC162C 0098F5B3
FFFC1630 00A59593		sll			$a1,$a1,#LOG_PGSZ	; $a1 = virtual address of allocated mem.
FFFC1634 00C12483		ldt     $s1,12[$sp]
                        		; Clear the allocated memory
FFFC1638 0005EA33	  mov     $s4,$a1
                        	.zm:
FFFC163C 000A2023	  stt     $x0,[$s4]
FFFC1640 004A0A13	  add     $s4,$s4,#4
FFFC1644 FFC48493	  sub     $s1,$s1,#4
FFFC1648 FE04DAE3	  bge     $s1,$x0,.zm	
FFFC164C 00006513		ldi			$a0,#E_Ok
FFFC1650 00000463		bra			.xit
                        	.noRun:
FFFC1654 00906513		ldi			$a0,#E_NotAlloc
                        	.xit
FFFC1658 00012083		ldt			$ra,[$sp]
FFFC165C 00412483		ldt			$s1,4[$sp]			; restore regs
FFFC1660 00812903		ldt			$s2,8[$sp]
FFFC1664 01012983		ldt			$s3,16[$sp]
FFFC1668 01412A03		ldt     $s4,20[$sp]
FFFC166C 01810113		add			$sp,$sp,#24
FFFC1670 00008067		ret
                        	.allocZero:
FFFC1674 00006593	  ldi     $a1,#0
FFFC1678 00006513		ldi			$a0,#E_Ok
FFFC167C FC000EE3	  bra     .xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a task. The stack is located at the highest
                        	; virtual address ($7FC00).
                        	;
                        	; Parameters:
                        	;		$a0 = mid to allocate for
                        	;	Returns:
                        	;		$a0 = physical address, 0 if unsuccessful
                        	;		$a1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        		align 	16                        	
                        	AllocStack:
FFFC1680 FF410113	  sub   	$sp,$sp,#12
FFFC1684 00112023	  stt     $ra,[$sp]
FFFC1688 00912223	  stt     $s1,4[$sp]
FFFC168C 01212423	  stt     $s2,8[$sp]
FFFC1690 00056933	  mov     $s2,$a0
FFFC1694 01051493		sll			$s1,$a0,#16			; 
FFFC1698 1FF4E493		or			$s1,$s1,#511		; last page of memory is for stack
FFFC169C 0290050D		mvmap		$a0,$x0,$s1			; check if stack already allocated
FFFC16A0 02051063		bnez		$a0,.0001
FFFC16A4 FE912E23		stt     $s1,-4[$sp]
FFFC16A8 FFC10113	  sub     $sp,$sp,#4
FFFC16AC 334000EF		call    PAMMarkPage
FFFC16B0 00410113	  add     $sp,$sp,#4
FFFC16B4 FFC12483		ldt     $s1,-4[$sp]
                        	;	palloc	$v0							; allocate a page
FFFC16B8 02050063		beqz		$a0,.xit		    ; success?
FFFC16BC 0295000D		mvmap		$x0,$a0,$s1
                        	.0001:
FFFC16C0 1FF4F493		and			$s1,$s1,#511
FFFC16C4 00A51513		sll			$a0,$a0,#LOG_PGSZ			; convert pages to addresses
FFFC16C8 00A49493		sll			$s1,$s1,#LOG_PGSZ
                        	;	beqz    $s2,.xit
FFFC16CC A00008B7		or      $a1,$s1,#$A0000000    ; set stack segment
FFFC16D0 00088893
FFFC16D4 0098E5B3
                        	.xit:
FFFC16D8 00012083	  ldt     $ra,[$sp]
FFFC16DC 00412483	  ldt     $s1,4[$sp]
FFFC16E0 00812903	  ldt     $s2,8[$sp]
FFFC16E4 00C10113	  add     $sp,$sp,#12
FFFC16E8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a task including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		$a0 = mid to free memory for
                        	;	Modifies:
                        	;		a0,t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
FFFC16EC 00000000		align		1
                        	
                        	FreeAll:
FFFC16F0 FFC10113	  sub   	$sp,$sp,#4
FFFC16F4 00112023	  stt     $ra,[$sp]
FFFC16F8 00006E13		ldi			$t3,#0
FFFC16FC 01051E93		sll			$t4,$a0,#16
                        	.nxt:
FFFC1700 200E2313		slt			$t1,$t3,#512		; number of buckets to check
FFFC1704 02030C63		beqz		$t1,.0001
FFFC1708 001F08B7		and			$t4,$t4,#$1F0000
FFFC170C 00088893
FFFC1710 01D8FEB3
FFFC1714 01CEEEB3		or			$t4,$t4,$t3			; combine pid and bucket number
FFFC1718 00006513		ldi			$a0,#0					; new page number to set (indicates free)
FFFC171C 03D5050D		mvmap		$a0,$a0,$t4			; get page mapping and set to zero
FFFC1720 001E0E13		add			$t3,$t3,#1			; advance to next bucket
FFFC1724 FC050EE3		beqz		$a0,.nxt				; 0 = no map in this bucket
FFFC1728 308000EF		call    PAMUnmarkPage
                        	;	pfree		$t0							; free the page
FFFC172C 30002283		ldt			$t0,NPAGES			; update the number of available pages
FFFC1730 00128293		add			$t0,$t0,#1
FFFC1734 30502023		stt			$t0,NPAGES
FFFC1738 FC0004E3		bra			.nxt
                        	.0001:
FFFC173C 00012083	  ldt     $ra,[$sp]
FFFC1740 00410113	  add     $sp,$sp,#4
FFFC1744 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a linear one.
                        	;
                        	; Parameters:
                        	;		$a0 = virtual address to convert
                        	; Modifies:
                        	;		$a1,$t0
                        	; Returns:
                        	;		$a0 = linear address
                        	;------------------------------------------------------------------------------
FFFC1748 00000000		align	1
FFFC174C 00000000
                        	
                        	VirtToLinear:
FFFC1750 01C55593		srl   $a1,$a0,#28         ; get segment register of address
FFFC1754 00B0058D		mvseg $a1,$x0,$a1         ; get segment register value
FFFC1758 FF05F593		and   $a1,$a1,#$FFFFFFF0  ; mask off acr bits
FFFC175C 00659593		sll   $a1,$a1,#6          ; shift into position
FFFC1760 100008B7		and   $t0,$a0,#$0FFFFFFF  ; mask off segment
FFFC1764 FFF88893
FFFC1768 00A8F2B3
FFFC176C 00558533		add   $a0,$a1,$t0         ; v0 = linear address (segment base + address)
FFFC1770 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a linear one.
                        	;
                        	; Parameters:
                        	;   $a0 = tid
                        	;		$a1 = virtual address to convert
                        	; Modifies:
                        	;		$v1
                        	; Returns:
                        	;		$v0 = linear address
                        	;------------------------------------------------------------------------------
                        	
                        	;VirtToLinear2:
                        	;	srl   $v0,$a1,#28         ; get base register selector of address
                        	;	sll   $v0,$v0,#2          ; convert to index
                        	;	sll   $v1,$a0,#2
                        	;	ldt   $v1,TidTcbMap[$v1]  ; $v1 = pointer to TCB
                        	;	add   $v0,$v0,$v1
                        	;	ldt   $v1,TCBbases[$v0]   ; $v1 = base register value
                        	;	and   $v0,$v1,#$FFFFFFF0  ; mask off acr bits
                        	;	sll   $v0,$v0,#6          ; shift into position
                        	;	and   $v1,$a1,#$0FFFFFFF  ; mask off base selector
                        	;	add   $v0,$v1,$v0         ; v0 = linear address (base + address)
                        	;  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		$a0 = virtual address to convert
                        	; Modifies:
                        	;		$t0, $t1
                        	; Returns:
                        	;		$a0 = physical address
                        	;------------------------------------------------------------------------------
FFFC1774 00000000		align	1
FFFC1778 00000000
FFFC177C 00000000
                        	
                        	VirtToPhys:
FFFC1780 FF810113		sub 	$sp,$sp,#8
FFFC1784 00112023		stt   $ra,[$sp]
FFFC1788 00912223		stt   $s1,4[$sp]
FFFC178C 000564B3		mov   $s1,$a0
FFFC1790 FC1FF0EF		call  VirtToLinear
FFFC1794 02054263		bltz	$a0,.notMapped
FFFC1798 00A55293		srl		$t0,$a0,#LOG_PGSZ		; convert virt to page
                        		
FFFC179C 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC17A0 01051513	sll		$a0,$a0,#16
FFFC17A4 00556533		or		$a0,$a0,$t0					; and in tid
FFFC17A8 02A0050D		mvmap	$a0,$x0,$a0					; get the translation
FFFC17AC 00A51513		sll		$a0,$a0,#LOG_PGSZ		; convert page to address
FFFC17B0 3FF4F293		and		$t0,$s1,#$3FF				; insert LSB's
FFFC17B4 00556533		or		$a0,$a0,$t0
                        	.notMapped:
FFFC17B8 00012083		ldt   $ra,[$sp]
FFFC17BC 00412483		ldt   $s1,4[$sp]
FFFC17C0 00810113		add   $sp,$sp,#8
FFFC17C4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; VirtToPhys2:
                        	;   Used by the OS to convert virtual to physcial addresses.
                        	; Convert a virtual address to a physical one. Slightly tricky as linear
                        	; addresses are associated with the TID while paged addresses are associated
                        	; with the MID of the task.
                        	;
                        	; Parameters:
                        	;   $a0 = tid
                        	;		$a1 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		$v0 = physical address
                        	;------------------------------------------------------------------------------
FFFC17C8 00000000		align	1
FFFC17CC 00000000
                        	
                        	VirtToPhys2:
FFFC17D0 FFC10113		sub 	$sp,$sp,#4
FFFC17D4 00112023		stt   $ra,[$sp]
                        	;	call  VirtToLinear2
                        	;	bltz	$v0,.notMapped
                        	;	srl		$t0,$v0,#LOG_PGSZ		; convert virt to page
                        	;	sll   $v1,$a0,#2
                        	;	ldt   $v1,TidTcbMap[$v1]  ; $v1 = pointer to TCB
                        	;	ldbu  $v1,TCBmid[$v1]     ; $v1 = mid
                        	;	sll		$v0,$v1,#16         ; set map id field
                        	;	or		$v0,$v0,$t0					; and in tid
                        	;	mvmap	$v0,$x0,$v0					; get the translation
                        	;	sll		$v0,$v0,#LOG_PGSZ		; convert page to address
                        	;	and		$t0,$a0,#$3FF				; insert LSB's
                        	;	or		$v0,$v0,$t0
                        	.notMapped:
FFFC17D8 00012083		ldt   $ra,[$sp]
FFFC17DC 00410113		add   $sp,$sp,#4
FFFC17E0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC17E4 00000000		align	1
FFFC17E8 00000000
FFFC17EC 00000000
                        	
                        	FetchMemoryWord:
FFFC17F0 0005A583	  ldt   $a1,[$a1]
FFFC17F4 00006513	  ldi   $a0,#E_Ok
FFFC17F8 3B80106F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC17FC 00000000		align	1
                        	
                        	FMTK_Alloc:
FFFC1800 0005E533		mov		$a0,$a1
FFFC1804 000665B3		mov		$a1,$a2
FFFC1808 DA9FF0EF		call	Alloc
FFFC180C 3A40106F		jmp		OSExit
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01PAM.r5a",1
                        	.file "cs01PAM.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	; PAM
                        	; 0 = unallocated
                        	; 1 = reserved
                        	; 2 = end of run of pages
                        	; 3 = allocated
                        	;------------------------------------------------------------------------------
                        	
                        	;------------------------------------------------------------------------------
                        	; PAMFindRun
                        	;    Find a run of unallocated pages.
                        	;
                        	; Parameters:
                        	;   $a0 = number of consecutive pages required
                        	; Returns:
                        	;   $a0 = page starting run, -1 if not enough memory
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	PAMFindRun:
FFFC1810 FEC10113	  sub 	$sp,$sp,#20
FFFC1814 00112023	  stt   $ra,[$sp]
FFFC1818 00912223	  stt   $s1,4[$sp]
FFFC181C 01212423	  stt   $s2,8[$sp]
FFFC1820 01312623	  stt   $s3,12[$sp]
FFFC1824 01412823	  stt   $s4,16[$sp]
FFFC1828 000564B3	  mov   $s1,$a0             ; save argument value
FFFC182C 000048B7	  stt   $a0,$4010
FFFC1830 01088893
FFFC1834 000888B3
FFFC1838 00A8A023
FFFC183C 01006513	  ldi   $a0,#OSPAGES
                        	.nextPage:
FFFC1840 00056A33	  mov   $s4,$a0
FFFC1844 25C000EF	  call  PAMGetbitPair
FFFC1848 04051263	  bnez  $a0,.notAvailable
FFFC184C 000A69B3	  mov   $s3,$s4             ; remember start of run
FFFC1850 0004E933	  mov   $s2,$s1             ; $s2 = run length
                        	.runInc:
FFFC1854 FFF90913	  sub   $s2,$s2,#1
FFFC1858 04090463	  beqz  $s2,.foundRun
FFFC185C 001A0513	  add   $a0,$s4,#1          ; increment run start
FFFC1860 20052313	  slt   $t1,$a0,#MEMSZ
FFFC1864 02030A63	  beqz  $t1,.outOfMem
FFFC1868 00056A33	  mov   $s4,$a0             ; remember $a0
FFFC186C 000048B7	  stt   $s4,$4020
FFFC1870 02088893
FFFC1874 000888B3
FFFC1878 0148A023
FFFC187C 224000EF	  call  PAMGetbitPair
FFFC1880 FC050AE3	  beqz  $a0,.runInc
FFFC1884 00198513	  add   $a0,$s3,#1          ; increment run start pos
FFFC1888 FA000CE3	  bra   .nextPage
                        	.notAvailable:
                        	;	add		$a3,$a0,#'0'
                        	;	call	SerialPutChar
                        	;	stt		$s4,$4030
FFFC188C 001A0513	  add   $a0,$s4,#1
FFFC1890 20052313	  slt   $t1,$a0,#MEMSZ
FFFC1894 FA0316E3	  bnez  $t1,.nextPage
                        	.outOfMem:
FFFC1898 FFF06513	  ldi   $a0,#-1
FFFC189C 00000463	  bra   .xit
                        	.foundRun:
FFFC18A0 0009E533	  mov   $a0,$s3
                        	.xit
FFFC18A4 00012083	  ldt   $ra,[$sp]
FFFC18A8 00412483	  ldt   $s1,4[$sp]
FFFC18AC 00812903	  ldt   $s2,8[$sp]
FFFC18B0 00C12983	  ldt   $s3,12[$sp]
FFFC18B4 01012A03	  ldt   $s4,16[$sp]
FFFC18B8 01410113	  add   $sp,$sp,#20
FFFC18BC 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of pages and mark them all allocated.
                        	;
                        	; Parameters:
                        	;   $a0 = amount of memory to allocate
                        	; Returns:
                        	;   $a0 = pointer to memory, -1 if insufficient memory
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	PAMAlloc:
FFFC18C0 FF010113	  sub 	$sp,$sp,#16
FFFC18C4 00112023	  stt   $ra,[$sp]
FFFC18C8 00912223	  stt   $s1,4[$sp]
FFFC18CC 01412423	  stt   $s4,8[$sp]
FFFC18D0 01512623	  stt   $s5,12[$sp]
FFFC18D4 06050663	  beqz  $a0,.outOfMem       ; request sensible?
FFFC18D8 3FF50293	  add   $t0,$a0,#PAGESZ-1   ; round allocation up
FFFC18DC 00A2D513	  srl   $a0,$t0,#LOG_PGSZ   ; convert size to pages
FFFC18E0 00056A33	  mov   $s4,$a0             ; $s4 = length of run in pages
FFFC18E4 30002283	  ldt   $t0,NPAGES          ; check number of pages of memory available
FFFC18E8 40A282B3	  sub   $t0,$t0,$a0
FFFC18EC 0402CA63	  bltz  $t0,.outOfMem
FFFC18F0 30502023	  stt   $t0,NPAGES          ; update the number of available pages
FFFC18F4 F1DFF0EF	  call  PAMFindRun
FFFC18F8 04054863	  bltz  $a0,.xit2
FFFC18FC 000564B3	  mov   $s1,$a0
FFFC1900 000566B3	  mov   $a3,$a0
FFFC1904 00056AB3	  mov   $s5,$a0             ; $s5 = start of run
                        	.markNext:
FFFC1908 0006E533	  mov   $a0,$a3
FFFC190C 002A2593	  slt   $a1,$s4,#2          ; if $s4 <= 1
FFFC1910 0035C593	  xor   $a1,$a1,#3          ; $a1 = 3, 2 if end of run
FFFC1914 13C000EF	  call  PAMSetbitPair
FFFC1918 00168693	  add   $a3,$a3,#1          ; increment page number
FFFC191C FFFA0A13	  sub   $s4,$s4,#1          ; decrement length
FFFC1920 FF4044E3	  bgtz  $s4,.markNext
FFFC1924 00AA9513	  sll   $a0,$s5,#LOG_PGSZ   ; $a0 = physical address of page
                        	.xit:
FFFC1928 00012083	  ldt   $ra,[$sp]
FFFC192C 00412483	  ldt   $s1,4[$sp]
FFFC1930 00812A03	  ldt   $s4,8[$sp]
FFFC1934 00C12A83	  ldt   $s5,12[$sp]
FFFC1938 01010113	  add   $sp,$sp,#16
FFFC193C 00008067	  ret
                        	.outOfMem:
FFFC1940 FFF06513	  ldi   $a0,#-1
FFFC1944 FE0002E3	  bra   .xit
                        	  ; Failed to find a run so,
                        	  ; restore number of pages available
                        	.xit2:
FFFC1948 30002283		ldt		$t0,NPAGES
FFFC194C 014282B3		add		$t0,$t0,$s4
FFFC1950 30502023		stt		$t0,NPAGES
FFFC1954 FC000AE3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Free memory previously allocated with PAMAlloc.
                        	;
                        	; Parameters:
                        	;   $a0 = pointer to start of memory
                        	; Modifies:
                        	;   $a0,$t0,$t1,$t2,$t3,$t4
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
FFFC1958 00000000		align	1
FFFC195C 00000000
                        	
                        	PAMFree:
FFFC1960 FF410113	  sub   	$sp,$sp,#12
FFFC1964 00112023	  stt     $ra,[$sp]
FFFC1968 00912223	  stt     $s1,4[$sp]
FFFC196C 000564B3	  mov     $s1,$a0
FFFC1970 FFF808B7	  and     $a0,$a0,#$FFF803FF  ; check page 1kB aligned
FFFC1974 3FF88893
FFFC1978 00A8F533
FFFC197C 04051A63	  bnez    $a0,.xit
FFFC1980 00A4D513	  srl     $a0,$s1,#LOG_PGSZ   ; convert to page number
FFFC1984 00106E93	  ldi     $t4,#1
                        	.nextPage:
FFFC1988 000564B3	  mov     $s1,$a0
FFFC198C 114000EF	  call    PAMGetbitPair
FFFC1990 02050A63	  beqz    $a0,.endOfRun
FFFC1994 00352513	  slt     $a0,$a0,#3
FFFC1998 00051E63	  bnez    $a0,.lastPage
FFFC199C 0004E533	  mov     $a0,$s1
FFFC19A0 00006593	  ldi     $a1,#0
FFFC19A4 0AC000EF	  call    PAMSetbitPair
FFFC19A8 00150493	  add     $s1,$a0,#1
FFFC19AC 001E8E93	  add     $t4,$t4,#1
FFFC19B0 FC000CE3	  bra     .nextPage  
                        	.lastPage:
FFFC19B4 0004E533	  mov     $a0,$s1
FFFC19B8 00006593	  ldi     $a1,#0
FFFC19BC 094000EF	  call    PAMSetbitPair
FFFC19C0 001E8E93	  add     $t4,$t4,#1
                        	.endOfRun:
FFFC19C4 30002583	  ldt     $a1,NPAGES
FFFC19C8 01D585B3	  add     $a1,$a1,$t4
FFFC19CC 30B02023	  stt     $a1,NPAGES
                        	.xit:
FFFC19D0 00012083	  ldt     $ra,[$sp]
FFFC19D4 00412483	  ldt     $s1,4[$sp]
FFFC19D8 00C10113	  add     $sp,$sp,#12
FFFC19DC 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a single page of memory. Available memory is indicated by a bitmmap
                        	; called the PAM for page allocation map.
                        	;
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	; Returns:
                        	;		$a0 = page allocated
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	PAMMarkPage:
FFFC19E0 FF810113		sub		$sp,$sp,#8
FFFC19E4 00112023		stt		$ra,[$sp]
FFFC19E8 00912223		stt   $s1,4[$sp]
FFFC19EC 01006513		ldi   $a0,#OSPAGES
FFFC19F0 000564B3	  mov   $s1,$a0
                        	.0001:
FFFC19F4 0004E533	  mov   $a0,$s1
FFFC19F8 0A8000EF		call  PAMGetbitPair
FFFC19FC 00050C63		beqz  $a0,.gotFree
FFFC1A00 00148493		add   $s1,$s1,#1
FFFC1A04 2004A293		slt   $t0,$s1,#MEMSZ
FFFC1A08 FE0296E3		bnez  $t0,.0001
FFFC1A0C 00006513		ldi   $a0,#0
FFFC1A10 00000863		bra   .xit
                        	.gotFree:
FFFC1A14 0004E533	  mov   $a0,$s1
FFFC1A18 00206593	  ldi   $a1,#2          ; end of run bits
FFFC1A1C 034000EF	  call  PAMSetbitPair
                        	.xit:
FFFC1A20 00012083		ldt		$ra,[$sp]
FFFC1A24 00412483		ldt   $s1,4[$sp]
FFFC1A28 00810113		add		$sp,$sp,#8
FFFC1A2C 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = page number to free
                        	; Modifies:
                        	;		$a1,$t0,$t1,$t2,$t3
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	PAMUnmarkPage:
FFFC1A30 1FF06393		ldi		$t2,#MEMSZ-1  			; last page is permanently allocated to system stack
FFFC1A34 06757463		bgeu	$a0,$t2,PAMxit
FFFC1A38 01006393		ldi		$t2,#OSPAGES
FFFC1A3C 06756063		bltu	$a0,$t2,PAMxit			; first 64 pages (64kB) allocated permanently to system
FFFC1A40 00006593		ldi   $a1,#0
FFFC1A44 00000663		bra		PAMSetbitPair
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = bit number to set
                        	;   $a1 = value to set 0,1,2 or 3
                        	; Does not modify:
                        	;   $a0, $a1
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	;------------------------------------------------------------------------------
FFFC1A48 00000000		align 1
FFFC1A4C 00000000
                        	
                        	PAMSetbitPair:
FFFC1A50 00455393	  srl   $t2,$a0,#4          ; t2 = word
FFFC1A54 00239393	  sll   $t2,$t2,#2          ; t2 = word index
FFFC1A58 00F57E13	  and   $t3,$a0,#15         ; t3 = bit pair no
FFFC1A5C 001E1E13	  sll   $t3,$t3,#1          ; t3 = bit pair index
FFFC1A60 00306293	  ldi   $t0,#3              ; make a bit mask
FFFC1A64 01C292B3	  sll   $t0,$t0,$t3
FFFC1A68 FFF2C293	  xor   $t0,$t0,#-1         ; get inverted mask
FFFC1A6C 01C595B3	  sll   $a1,$a1,$t3
FFFC1A70 000018B7		ldt		$t1,PAM[$t2]        ; get word
FFFC1A74 00088893
FFFC1A78 007888B3
FFFC1A7C 0008A303
FFFC1A80 005372B3		and		$t0,$t1,$t0					; clear bit
FFFC1A84 00B2E2B3		or    $t0,$t0,$a1         ; set new bit status
FFFC1A88 000018B7		stt		$t0,PAM[$t2]        ; store word
FFFC1A8C 00088893
FFFC1A90 007888B3
FFFC1A94 0058A023
FFFC1A98 01C5D5B3		srl   $a1,$a1,$t3         ; restore $a1
                        	PAMxit:
FFFC1A9C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = bit pair number to get
                        	; Modifies:
                        	;		$t0,$t2,$t3
                        	; Returns:
                        	;   $a0 = value of bit pair (0, 1, 2 or 3)
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	PAMGetbitPair:
FFFC1AA0 00455393	  srl   $t2,$a0,#4          ; $t2 = word, bit pair num/16
FFFC1AA4 00239393	  sll   $t2,$t2,#2          ; $t2 = word index, 4 bytes per word
FFFC1AA8 00F57E13	  and   $t3,$a0,#15         ; $t3 = bit pair num in word = 0 to 15
FFFC1AAC 001E1E13	  sll   $t3,$t3,#1          ; $t3 = bit pair index
FFFC1AB0 000018B7		ldt		$t0,PAM[$t2]        ; get word
FFFC1AB4 00088893
FFFC1AB8 007888B3
FFFC1ABC 0008A283
FFFC1AC0 01C2D3B3		srl   $t2,$t0,$t3         ; extract bits
FFFC1AC4 0033F513		and   $a0,$t2,#3          ; return 0,1,2, or 3
FFFC1AC8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC1ACC 00000000		align	1
                        	
                        	PAMInit:
FFFC1AD0 FFC10113	  sub 	$sp,$sp,#4
FFFC1AD4 00112023	  stt   $ra,[$sp]
                        	  ; First zero out the entire PAM using word stores
FFFC1AD8 00006513	  ldi   $a0,#0
                        	.0002:
FFFC1ADC 000018B7	  stt   $x0,PAM[$a0]
FFFC1AE0 00088893
FFFC1AE4 00A888B3
FFFC1AE8 0008A023
FFFC1AEC 00450513	  add   $a0,$a0,#4
FFFC1AF0 08052293	  slt   $t0,$a0,#32*4   ; 1024 bits = 128 bytes
FFFC1AF4 FE0294E3	  bnez  $t0,.0002
                        	
                        	  ; Now set bits for preallocated memory pages
FFFC1AF8 00F06513	  ldi   $a0,#OSPAGES-1  ; OS pages
FFFC1AFC 00306593	  ldi   $a1,#3
                        	.0001:
FFFC1B00 F51FF0EF	  call  PAMSetbitPair
FFFC1B04 FFF50513	  sub   $a0,$a0,#1
FFFC1B08 FE055CE3	  bge   $a0,$x0,.0001
FFFC1B0C 00F06513	  ldi   $a0,#15         ; Last OS page
FFFC1B10 00206593	  ldi   $a1,#2          ; set mark end of run
FFFC1B14 F3DFF0EF	  call  PAMSetbitPair
FFFC1B18 1E806513	  ldi   $a0,#MEMSZ-24   ; OS stack page
FFFC1B1C 01806413	  ldi		$s0,#24					; 24 pages to mark
                        	.0003:
FFFC1B20 00306593	  ldi   $a1,#3          ; mid of run
FFFC1B24 F2DFF0EF	  call  PAMSetbitPair
FFFC1B28 00150513		add		$a0,$a0,#1
FFFC1B2C 00206593	  ldi   $a1,#2          ; end of run
FFFC1B30 F21FF0EF	  call  PAMSetbitPair
FFFC1B34 00150513		add		$a0,$a0,#1
FFFC1B38 FFE40413		sub		$s0,$s0,#2
FFFC1B3C FE0412E3		bnez	$s0,.0003  
FFFC1B40 00012083	  ldt   $ra,[$sp]
FFFC1B44 00410113	  add   $sp,$sp,#4
FFFC1B48 00008067	  ret
                        	
FFFC1B4C 00000000		align	1
                        	
                        	GetPamBit:
FFFC1B50 0005E533	  mov   $a0,$a1
FFFC1B54 F4DFF0EF	  call  PAMGetbitPair
FFFC1B58 000565B3	  mov   $a1,$a0
FFFC1B5C 00006513	  ldi   $a0,#E_Ok
FFFC1B60 0500106F	  jmp   OSExit
                        	
FFFC1B64 00000000		align	1
FFFC1B68 00000000
FFFC1B6C 00000000
                        	
                        	PAMDump:
FFFC1B70 FFC10113		sub		$sp,$sp,#4
FFFC1B74 00112023		stt		$ra,[$sp]
FFFC1B78 00006493		ldi		$s1,#0
                        	.0001:
FFFC1B7C 0004E533		mov		$a0,$s1
FFFC1B80 F21FF0EF		call	PAMGetbitPair
FFFC1B84 03050513		add		$a0,$a0,#'0'
FFFC1B88 859FE0EF		call	Putch
FFFC1B8C 00148493		add		$s1,$s1,#1
FFFC1B90 2004A313		slt		$t1,$s1,#MEMSZ
FFFC1B94 FE0314E3		bnez	$t1,.0001
FFFC1B98 00012083		ldt		$ra,[$sp]
FFFC1B9C 00410113		add		$sp,$sp,#4
FFFC1BA0 00008067		ret
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        	.file "../fmtk/serial.r5a",29
                        		code
FFFC1BA4 00000000		align	
                        	
                        	SerialFuncTbl:
FFFC1BA8 FFFC1D80		dw		SerialNOP			; no operation
FFFC1BAC FFFC1C90		dw		SerialSetup		; setup
FFFC1BB0 00000000		dw		0							; initialize
FFFC1BB4 00000000		dw		0							; status
FFFC1BB8 00000000		dw		0							; media check
FFFC1BBC 00000000		dw		0							; build BPB
FFFC1BC0 00000000		dw		0							; open
FFFC1BC4 00000000		dw		0							; close
FFFC1BC8 FFFC1E40		dw		SerialGetChar	; get char
FFFC1BCC FFFC1F20		dw		SerialPeekChar
FFFC1BD0 00000000		dw		0							; get char direct
FFFC1BD4 FFFC1F90		dw		SerialPeekCharDirect	; peek char direct
FFFC1BD8 00000000		dw		0							; input status
FFFC1BDC FFFC1FF0		dw		SerialPutChar
FFFC1BE0 00000000		dw		0							; reserved
FFFC1BE4 00000000		dw		0							; set position
FFFC1BE8 00000000		dw		0							; read block
FFFC1BEC 00000000		dw		0							; write block
FFFC1BF0 00000000		dw		0							; verify block
FFFC1BF4 00000000		dw		0							; output status
FFFC1BF8 00000000		dw		0							; flush input
FFFC1BFC 00000000		dw		0							; flush output
FFFC1C00 FFFC2130		dw		SerialIRQ			; IRQ routine
FFFC1C04 00000000		dw		0							; Is removable
FFFC1C08 00000000		dw		0							; ioctrl read
FFFC1C0C 00000000		dw		0							; ioctrl write
FFFC1C10 00000000		dw		0							; output until busy
FFFC1C14 FFFC2220		dw		SerialGetUI		; get ui flag
FFFC1C18 00000000		dw		0
FFFC1C1C 00000000		dw		0
FFFC1C20 00000000		dw		0
FFFC1C24 00000000		dw		0							; 31
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	  align 8                        	
                        	SerialDCB:
FFFC1C28 4D4F4304	  db    4,"COM1       "
FFFC1C2C 20202031
FFFC1C30 20202020
FFFC1C34 00000000	  dw    0     ; type
FFFC1C38 00000000	  dw    0     ; nBPB
FFFC1C3C 00000000	  dw    0
FFFC1C40 00000000	  dw    0     ; last error code
FFFC1C44 00000000	  dw    0
                        	; 32
FFFC1C48 00000000	  dw    0     ; starting block number
FFFC1C4C 00000000	  dw    0
FFFC1C50 00000000	  dw    0     ; number of blocks
FFFC1C54 00000000	  dw    0
FFFC1C58 00000000	  dw    0     ; command processing routine
FFFC1C5C 00000000	  dw		0
FFFC1C60 FFFC2130	  dw		SerialIRQ			; IRQ routine
FFFC1C64 00000000	  dw    0
                        	;64
FFFC1C68 00010000	  db    0     ; reentrancy count
FFFC1C69 00000100	  db    0     ; single user flag
FFFC1C6A 00000001	  db    1     ; user interface device flag
FFFC1C6B 00000000	  db    0
FFFC1C6C 00000000	  dw    0
FFFC1C70 00000000	  dw    0     ; hJob
FFFC1C74 00000000	  dw    0
FFFC1C78 00000000	  dw    0     ; Mailbox handle
FFFC1C7C 00000000	  dw    0
FFFC1C80 00000000	  dw    0     ; pointer to device semaphore
FFFC1C84 00000000	  dw    0
                        	; 96
                        	;  dw    0     ; reserved
                        	;  dw    0
                        	
FFFC1C88 00000000		align	1
FFFC1C8C 00000000
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	SerialSetup:
FFFC1C90 FFC10113		sub		$sp,$sp,#4
FFFC1C94 00112023		stt		$ra,[$sp]
FFFC1C98 00506513		ldi		$a0,#5							; serial device
FFFC1C9C FFFC25B7		ldi		$a1,#SerialFuncTbl
FFFC1CA0 BA858593
FFFC1CA4 59C020EF		call	CopyDevFuncTbl
FFFC1CA8 00506513		ldi		$a0,#5							; serial device
FFFC1CAC FFFC25B7		ldi   $a1,#SerialDCB
FFFC1CB0 C2858593
FFFC1CB4 5BC020EF		call  CopyDevDCB
FFFC1CB8 018000EF		call	SerialInit
FFFC1CBC 00012083		ldt		$ra,[$sp]
FFFC1CC0 00410113		add		$sp,$sp,#4
FFFC1CC4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
FFFC1CC8 00000000		align	1
FFFC1CCC 00000000
                        	
                        	SerialInit:
FFFC1CD0 FFC10113		sub		$sp,$sp,#4
FFFC1CD4 00112023		stt		$ra,[$sp]
FFFC1CD8 000028B7		stt		$x0,SerHeadRcv
FFFC1CDC C0088893
FFFC1CE0 000888B3
FFFC1CE4 0008A023
FFFC1CE8 000028B7		stt		$x0,SerTailRcv
FFFC1CEC C0488893
FFFC1CF0 000888B3
FFFC1CF4 0008A023
FFFC1CF8 000028B7		stt		$x0,SerHeadXmit
FFFC1CFC C0888893
FFFC1D00 000888B3
FFFC1D04 0008A023
FFFC1D08 000028B7		stt		$x0,SerTailXmit
FFFC1D0C C0C88893
FFFC1D10 000888B3
FFFC1D14 0008A023
FFFC1D18 000028B7		stb		$x0,SerRcvXon
FFFC1D1C C1088893
FFFC1D20 000888B3
FFFC1D24 00088023
FFFC1D28 000028B7		stb		$x0,SerRcvXoff
FFFC1D2C C1188893
FFFC1D30 000888B3
FFFC1D34 00088023
FFFC1D38 00906293		ldi		$t0,#$09						; dtr,rts active, rxint enabled, no parity
FFFC1D3C FFDC18B7		stt		$t0,UART+8
FFFC1D40 A0888893
FFFC1D44 000888B3
FFFC1D48 0058A023
FFFC1D4C 000602B7		ldi		$t0,#$0006001E			; reset the fifo's
FFFC1D50 01E28293
FFFC1D54 FFDC18B7		stt		$t0,UART+12
FFFC1D58 A0C88893
FFFC1D5C 000888B3
FFFC1D60 0058A023
FFFC1D64 01E06293		ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC1D68 FFDC18B7		stt		$t0,UART+12
FFFC1D6C A0C88893
FFFC1D70 000888B3
FFFC1D74 0058A023
FFFC1D78 00012083		ldt		$ra,[$sp]
FFFC1D7C 00410113		add		$sp,$sp,#4
                        	SerialNOP:
FFFC1D80 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialServiceInit:
FFFC1D84 00106513		ldi		$a0,#1			; start task
FFFC1D88 40006593		ldi		$a1,#1024		; memory required
FFFC1D8C FFFC2637		ldi		$a2,#SerialService
FFFC1D90 D9C60613
FFFC1D94 00000073		ecall
FFFC1D98 00008067		ret
                        	
                        	SerialService:
FFFC1D9C FD810113		sub		$sp,$sp,#40		; allocate stack for local vars
FFFC1DA0 00E06513		ldi		$a0,#14				; get current tid
FFFC1DA4 00000073		ecall
FFFC1DA8 00016633		mov		$a2,$sp				; where to put mailbox handle
FFFC1DAC 000565B3		mov		$a1,$a0				; a1 = tid
FFFC1DB0 00606513		ldi		$a0,#6				; alloc mailbox
FFFC1DB4 00000073		ecall
                        	
                        	SerialServiceLoop:
                        	.0001:
FFFC1DB8 00A06513		ldi		$a0,#10				; waitmsg
FFFC1DBC 00012583		lw		$a1,[$sp]			; mailbox handle
FFFC1DC0 00410613		add		$a2,$sp,#4		; where to put D1
FFFC1DC4 00810693		add		$a3,$sp,#8		; where to put D2
FFFC1DC8 00C10713		add		$a4,$sp,#12		; where to put D3
FFFC1DCC FFF06793		ldi		$a5,#-1				; timeout
FFFC1DD0 00000073		ecall
FFFC1DD4 FE0512E3		bnez	$a0,.0001			; E_Ok?
                        	
FFFC1DD8 00412283		lw		$t0,4[$sp]
FFFC1DDC 00812503		lw		$a0,8[$sp]
FFFC1DE0 00C12583		lw		$a1,12[$sp]
FFFC1DE4 01F2F293		and		$t0,$t0,#31		; command in bits 0 to 4 of D1
FFFC1DE8 00129293		sll		$t0,$t0,#1
FFFC1DEC FFFC28B7		lw		$t0,SerialFuncTbl[$t0]
FFFC1DF0 BA888893
FFFC1DF4 005888B3
FFFC1DF8 0008A283
FFFC1DFC FA028EE3		beqz	$t0,.0001
FFFC1E00 00028067		jmp		[$t0]
                        	
                        	SerialFinishCmd:
FFFC1E04 00412583		lw		$a1,4[$sp]		; reply mbx handle in bits 8 to 23 of D1
FFFC1E08 0085D593		srl		$a1,$a1,#8
FFFC1E0C 000108B7		and		$a1,$a1,#$FFFF
FFFC1E10 FFF88893
FFFC1E14 00B8F5B3
FFFC1E18 00158593		add		$a1,$a1,#1		; -1 = no reply requested
FFFC1E1C 00058E63		beqz	$a1,.0001
FFFC1E20 FFF58593		sub		$a1,$a1,#1		; $a1 = mailbox handle again
FFFC1E24 00906513		ldi		$a0,#9				; sendmsg
FFFC1E28 FFF06613		ldi		$a2,#-1
FFFC1E2C FFF06693		ldi		$a3,#-1
FFFC1E30 FFF06713		ldi		$a4,#-1
FFFC1E34 00000073		ecall
                        	.0001:
FFFC1E38 F81FF06F		jmp		SerialServiceLoop
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialGetChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. If the buffer is almost empty then send an
                        	; XON.
                        	;
                        	; Stack Space:
                        	;		4 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;		$a1 = character or -1
                        	;------------------------------------------------------------------------------
FFFC1E3C 00000000		align	1
                        	
                        	SerialGetChar:
FFFC1E40 FF010113		sub		$sp,$sp,#16
FFFC1E44 00112023		stt		$ra,[$sp]
FFFC1E48 00912423		stt		$s1,8[$sp]          ; XON status
FFFC1E4C 01212623		stt   $s2,12[$sp]         ; interrupt state
FFFC1E50 000028B7		ldb		$s1,SerRcvXon				; skip sending XON if already sent
FFFC1E54 C1088893
FFFC1E58 000888B3
FFFC1E5C 00088483
FFFC1E60 131000EF		call	LockOS
FFFC1E64 28C000EF		call	SerialRcvCount			; check number of chars in receive buffer
FFFC1E68 00852513		slt		$a0,$a0,#8					; less than 8?
FFFC1E6C 02050E63		beqz	$a0,.0002
FFFC1E70 02049C63		bnez	$s1,.0002           ; XON already sent?
FFFC1E74 01106513		ldi		$a0,#XON						; if <8 send an XON
FFFC1E78 000028B7		stb		$x0,SerRcvXoff			; clear XOFF status
FFFC1E7C C1188893
FFFC1E80 000888B3
FFFC1E84 00088023
FFFC1E88 000028B7		stb		$a0,SerRcvXon				; flag so we don't send it multiple times
FFFC1E8C C1088893
FFFC1E90 000888B3
FFFC1E94 00A88023
FFFC1E98 FFDC18B7		stb		$a0,UART+UART_TRB
FFFC1E9C A0088893
FFFC1EA0 000888B3
FFFC1EA4 00A88023
                        	.0002:
FFFC1EA8 000028B7		ldbu	$a1,SerHeadRcv			; check if anything is in buffer
FFFC1EAC C0088893
FFFC1EB0 000888B3
FFFC1EB4 0008C583
FFFC1EB8 000028B7		ldbu	$a0,SerTailRcv
FFFC1EBC C0488893
FFFC1EC0 000888B3
FFFC1EC4 0008C503
FFFC1EC8 02B50863		beq		$a0,$a1,.noChars		; no?
FFFC1ECC 000018B7		ldb		$a0,SerRcvBuf[$a1]	; get byte from buffer
FFFC1ED0 40088893
FFFC1ED4 00B888B3
FFFC1ED8 00088503
FFFC1EDC 00158593		add		$a1,$a1,#1					; update head index
FFFC1EE0 0FF5F593		and   $a1,$a1,#255        ; ring buffer wrapping
FFFC1EE4 000028B7		stb		$a1,SerHeadRcv
FFFC1EE8 C0088893
FFFC1EEC 000888B3
FFFC1EF0 00B88023
FFFC1EF4 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC1EF8 FFF06513		ldi		$a0,#-1
                        	.xit:
FFFC1EFC 000565B3	  mov   $a1,$a0
FFFC1F00 00006513	  ldi   $a0,#E_Ok
FFFC1F04 0CD000EF	  call	UnlockOS
                        	;	csrrc $x0,#$004,#1
FFFC1F08 00012083		ldt		$ra,[$sp]
FFFC1F0C 00812483		ldt		$s1,8[$sp]
FFFC1F10 00C12903		ldt   $s2,12[$sp]
FFFC1F14 01010113		add		$sp,$sp,#16
FFFC1F18 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. But don't update the buffer indexes. No need
                        	; to send an XON here.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;		$a1 = character or -1
                        	;------------------------------------------------------------------------------
FFFC1F1C 00000000		align	1
                        	
                        	SerialPeekChar:
FFFC1F20 FF810113		sub		$sp,$sp,#8
FFFC1F24 00112023		stt		$ra,[$sp]
FFFC1F28 00912223		stt		$s1,4[$sp]
FFFC1F2C 065000EF		call	LockOS
FFFC1F30 000028B7		ldbu	$a1,SerHeadRcv			; check if anything is in buffer
FFFC1F34 C0088893
FFFC1F38 000888B3
FFFC1F3C 0008C583
FFFC1F40 000028B7		ldbu	$a0,SerTailRcv
FFFC1F44 C0488893
FFFC1F48 000888B3
FFFC1F4C 0008C503
FFFC1F50 00B50C63		beq		$a0,$a1,.noChars		; no?
FFFC1F54 000018B7		ldb		$a0,SerRcvBuf[$a1]	; get byte from buffer
FFFC1F58 40088893
FFFC1F5C 00B888B3
FFFC1F60 00088503
FFFC1F64 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC1F68 FFF06513		ldi		$a0,#-1
                        	.xit
FFFC1F6C 065000EF	  call	UnlockOS
FFFC1F70 000565B3	  mov   $a1,$a0
FFFC1F74 00006513	  ldi   $a0,#E_Ok
FFFC1F78 00012083		ldt		$ra,[$sp]
FFFC1F7C 00412483		ldt		$s1,4[$sp]
FFFC1F80 00810113		add		$sp,$sp,#8
FFFC1F84 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;		Get a character directly from the I/O port. This bypasses the input
                        	; buffer.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   $v0 = E_Ok
                        	;		$v1 = character or -1
                        	;------------------------------------------------------------------------------
FFFC1F88 00000000		align	1
FFFC1F8C 00000000
                        	
                        	SerialPeekCharDirect:
FFFC1F90 FF810113		sub		$sp,$sp,#8
FFFC1F94 00112023		stt		$ra,[$sp]
FFFC1F98 00912223		stt		$s1,4[$sp]
FFFC1F9C 7C40F4F3		csrrc	$s1,#$7C4,#1				; disable interrupts
FFFC1FA0 FFDC18B7		ldb		$a0,UART+UART_STAT
FFFC1FA4 A0488893
FFFC1FA8 000888B3
FFFC1FAC 00088503
FFFC1FB0 00857513		and		$a0,$a0,#8					; look for Rx not empty
FFFC1FB4 00050C63		beqz	$a0,.0001
FFFC1FB8 FFDC18B7		ldb		$a1,UART+UART_TRB
FFFC1FBC A0088893
FFFC1FC0 000888B3
FFFC1FC4 00088583
FFFC1FC8 00000463		bra		.xit
                        	.0001:
FFFC1FCC FFF06593		ldi		$a1,#-1
                        	.xit:
FFFC1FD0 00006513	  ldi   $a0,#E_Ok
FFFC1FD4 7C449073		csrrw	$x0,#$7C4,$s1				; restore interrupts
FFFC1FD8 0040E073		csrrs $x0,#$004,#1
FFFC1FDC 00012083		ldt		$ra,[$sp]
FFFC1FE0 00412483		ldt		$s1,4[$sp]
FFFC1FE4 00810113		add		$sp,$sp,#8
FFFC1FE8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty. The routine will attempt to transmit the char up to 
                        	; 10 times. If it still can't transmit the char then sleep is called and the
                        	; task is put to sleep for a tick. When it wakes up the routine continues to
                        	; try and send a character up to 10 times. If sleep has been called 10 times
                        	; and the character still has not made it to the transmit fifo, then an
                        	; error is flagged.
                        	;
                        	; Stack Space
                        	;		5 words
                        	; Parameters:
                        	;		$a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$a0 = character put
                        	; Side Effects:
                        	;		LastErc in DCB set to E_NoDev (no device) if transmit times out
                        	;------------------------------------------------------------------------------
FFFC1FEC 00000000		align	1
                        	
                        	SerialPutChar:
FFFC1FF0 FEC10113		sub		$sp,$sp,#20
FFFC1FF4 00112223		stt		$ra,4[$sp]
FFFC1FF8 00B12423		stt		$a1,8[$sp]
FFFC1FFC 00912623		stt		$s1,12[$sp]
FFFC2000 00D12823		stt		$a3,16[$sp]
FFFC2004 00A06493		ldi		$s1,#10
                        	.0003:
FFFC2008 FFF48493		sub		$s1,$s1,#1
FFFC200C 06048A63		beqz	$s1,.noFunc
FFFC2010 00A06593		ldi		$a1,#10
FFFC2014 77C000EF		call	LockOS
                        	.0001:
FFFC2018 FFF58593		sub		$a1,$a1,#1
FFFC201C 04058663		beqz	$a1,.goSleep
                        	;	pfi												; poll for an interrupt here
FFFC2020 FFDC18B7		ldb		$a0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC2024 A0488893
FFFC2028 000888B3
FFFC202C 00088503
FFFC2030 01057513		and		$a0,$a0,#16					; bit #4 of the status reg
FFFC2034 FE0502E3		beqz	$a0,.0001				    ; branch if transmitter is not empty
FFFC2038 FFDC18B7		stb		$a3,UART+UART_TRB		; send the byte
FFFC203C A0088893
FFFC2040 000888B3
FFFC2044 00D88023
FFFC2048 788000EF		call	UnlockOS
                        	.xit:
FFFC204C 00412083		ldt		$ra,4[$sp]
FFFC2050 00812583		ldt		$a1,8[$sp]
FFFC2054 00C12483		ldt		$s1,12[$sp]
FFFC2058 01012683		ldt		$a3,16[$sp]
FFFC205C 0006E533		mov		$a0,$a3
FFFC2060 01410113		add		$sp,$sp,#20
FFFC2064 00008067		ret
                        	.goSleep:
FFFC2068 768000EF		call	UnlockOS
FFFC206C 00306513		ldi		$a0,#3							; ISleep function
FFFC2070 00106593		ldi		$a1,#1							; 1 tick
FFFC2074 21D000EF		call  OSOCall							; this may trash registers
FFFC2078 01012683		ldt		$a3,16[$sp]
FFFC207C F80006E3		bra		.0003
                        	.noFunc:
FFFC2080 FF810113		sub		$sp,$sp,#8
FFFC2084 00C12023		stt		$a2,[$sp]
FFFC2088 00E12223		stt		$a4,4[$sp]
FFFC208C 00406513		ldi		$a0,#4							; Set DCB field
FFFC2090 00506593		ldi		$a1,#5							; $a1 = I/O channel
FFFC2094 01806613		ldi		$a2,#$18						; LastErc
FFFC2098 00006693		ldi		$a3,#0							; 0 = set word
FFFC209C 02106713		ldi		$a4,#E_NoDev				; error code to set
FFFC20A0 1F1000EF		call	OSOCall
FFFC20A4 00012603		ldt		$a2,[$sp]
FFFC20A8 00412703		ldt		$a4,4[$sp]
FFFC20AC 00810113		add		$sp,$sp,#8
FFFC20B0 FFF06693		ldi		$a3,#-1							; flag EOF on error
FFFC20B4 F8000CE3		bra		.xit
                        	
FFFC20B8 00000000		align	1
FFFC20BC 00000000
                        	
                        	SerialPutCharEx:
                        	.0001:
                        	;	pfi												; poll for an interrupt here
FFFC20C0 FFDC18B7		ldb		$a0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC20C4 A0488893
FFFC20C8 000888B3
FFFC20CC 00088503
FFFC20D0 01057513		and		$a0,$a0,#16					; bit #4 of the status reg
FFFC20D4 FE0506E3		beqz	$a0,.0001				    ; branch if transmitter is not empty
FFFC20D8 FFDC18B7		stb		$a3,UART+UART_TRB		; send the byte
FFFC20DC A0088893
FFFC20E0 000888B3
FFFC20E4 00D88023
FFFC20E8 0006E533		mov		$a0,$a3
FFFC20EC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Calculate number of character in input buffer
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	SerialRcvCount:
FFFC20F0 000028B7		ldbu	$a0,SerTailRcv	; v0 = tail index
FFFC20F4 C0488893
FFFC20F8 000888B3
FFFC20FC 0008C503
FFFC2100 000028B7		ldbu	$a1,SerHeadRcv	; v1 = head index
FFFC2104 C0088893
FFFC2108 000888B3
FFFC210C 0008C583
FFFC2110 40B502B3		sub		$t0,$a0,$a1
FFFC2114 0002D863		bge		$t0,$x0,.xit
FFFC2118 10006293		ldi		$t0,#256
FFFC211C 40B282B3		sub		$t0,$t0,$a1
FFFC2120 00A282B3		add		$t0,$t0,$a0
                        	.xit:
FFFC2124 0002E533		mov		$a0,$t0
FFFC2128 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC212C 00000000		align	1
                        	
                        	SerialIRQ:
                        	.nxtByte:
FFFC2130 FFDC18B7		ldt		$a0,UART+UART_STAT	; check the status
FFFC2134 A0488893
FFFC2138 000888B3
FFFC213C 0008A503
FFFC2140 00857293		and		$t0,$a0,#$08				; bit 3 = rx full
FFFC2144 0C028863		beqz	$t0,.notRxInt
FFFC2148 FFDC18B7		ldt		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC214C A0088893
FFFC2150 000888B3
FFFC2154 0008A583
FFFC2158 0145C393		xor   $t2,$a1,#CTRLT
FFFC215C 00039863		bnez  $t2,.0001
FFFC2160 0005E4B3		mov   $s1,$a1
FFFC2164 0005E6B3		mov		$a3,$a1
                        	;	call	SerialPutcharEx
                        	;	call  DumpTraceQueue
FFFC2168 0004E5B3		mov   $a1,$s1
                        	.0001:
FFFC216C 000028B7		ldbu	$t2,SerHeadRcv			; get buffer indexes
FFFC2170 C0088893
FFFC2174 000888B3
FFFC2178 0008C383
FFFC217C 000028B7		ldbu	$t3,SerTailRcv
FFFC2180 C0488893
FFFC2184 000888B3
FFFC2188 0008CE03
FFFC218C 000E6EB3		mov   $t4,$t3
FFFC2190 001E0E13		add		$t3,$t3,#1					; see if buffer full
FFFC2194 0FFE7E13		and		$t3,$t3,#255
FFFC2198 07C38E63		beq		$t2,$t3,.rxFull
FFFC219C 000028B7		stb		$t3,SerTailRcv			; update tail pointer
FFFC21A0 C0488893
FFFC21A4 000888B3
FFFC21A8 01C88023
FFFC21AC 000018B7		stb		$a1,SerRcvBuf[$t4]	; store recieved byte in buffer
FFFC21B0 40088893
FFFC21B4 01D888B3
FFFC21B8 00B88023
FFFC21BC 000028B7		ldb		$a0,SerRcvXoff			; check if xoff already sent
FFFC21C0 C1188893
FFFC21C4 000888B3
FFFC21C8 00088503
FFFC21CC F60512E3		bnez	$a0,.nxtByte
FFFC21D0 F21FF0EF		call	SerialRcvCount			; if more than 240 chars in buffer
FFFC21D4 0F052513		slt		$a0,$a0,#240				; send an XOFF
FFFC21D8 F4051CE3		bnez	$a0,.nxtByte
FFFC21DC 01306513		ldi		$a0,#XOFF
FFFC21E0 000028B7		stb		$x0,SerRcvXon				; clear XON status
FFFC21E4 C1088893
FFFC21E8 000888B3
FFFC21EC 00088023
FFFC21F0 000028B7		stb		$a0,SerRcvXoff			; set XOFF status
FFFC21F4 C1188893
FFFC21F8 000888B3
FFFC21FC 00A88023
FFFC2200 FFDC18B7		stb		$a0,UART+UART_TRB
FFFC2204 A0088893
FFFC2208 000888B3
FFFC220C 00A88023
FFFC2210 F20000E3		bra		.nxtByte            ; check the status for another byte
                        	;	ldi		$a0,#$0B						; dtr,rts active, rxint disabled, no parity
                        	;	sw		$a0,UART+UART_CMD
                        	.rxFull:
                        	.notRxInt:
FFFC2214 30200073		mret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC2218 00000000		align	1
FFFC221C 00000000
                        	
                        	SerialGetUI:
FFFC2220 00006513	  ldi   $a0,#E_Ok           ; no errors
FFFC2224 00106593	  ldi   $a1,#1              ; yes this is a UI device
FFFC2228 00008067	  ret
                        	
                        	nmeSerial:
FFFC222C 69726553		db		"Serial",0
FFFC2230 00006C61
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC2233 00000000		align	
FFFC2237 FC235400
                        	
                        	ViaFuncTbl:
FFFC2238 FFFC2354		dw		ViaNOP				; no operation
FFFC223C FFFC2320		dw		ViaSetup			; setup
FFFC2240 00000000		dw		0							; initialize
FFFC2244 00000000		dw		0							; status
FFFC2248 00000000		dw		0							; media check
FFFC224C 00000000		dw		0							; build BPB
FFFC2250 00000000		dw		0							; open
FFFC2254 00000000		dw		0							; close
FFFC2258 00000000		dw		0							; get char
FFFC225C 00000000		dw		0							; Peek char
FFFC2260 00000000		dw		0							; get char direct
FFFC2264 00000000		dw		0							; peek char direct
FFFC2268 00000000		dw		0							; input status
FFFC226C 00000000		dw		0							; Put char
FFFC2270 00000000		dw		0							; reserved
FFFC2274 00000000		dw		0							; set position
FFFC2278 00000000		dw		0							; read block
FFFC227C 00000000		dw		0							; write block
FFFC2280 00000000		dw		0							; verify block
FFFC2284 00000000		dw		0							; output status
FFFC2288 00000000		dw		0							; flush input
FFFC228C 00000000		dw		0							; flush output
FFFC2290 FFFC23C0		dw		ViaIRQ				; IRQ routine
FFFC2294 00000000		dw		0							; Is removable
FFFC2298 00000000		dw		0							; ioctrl read
FFFC229C 00000000		dw		0							; ioctrl write
FFFC22A0 00000000		dw		0							; output until busy
FFFC22A4 00000000		dw		0							; 27
FFFC22A8 00000000		dw		0
FFFC22AC 00000000		dw		0
FFFC22B0 00000000		dw		0
FFFC22B4 00000000		dw		0							; 31
                        	
                        	  align 8                        	
                        	ViaDCB:
FFFC22B8 41495603	  db    3,"VIA        "
FFFC22BC 20202020
FFFC22C0 20202020
FFFC22C4 00000000	  dw    0     ; type
FFFC22C8 00000000	  dw    0     ; nBPB
FFFC22CC 00000000	  dw    0
FFFC22D0 00000000	  dw    0     ; last error code
FFFC22D4 00000000	  dw    0
FFFC22D8 00000000	  dw    0     ; starting block number
FFFC22DC 00000000	  dw    0
FFFC22E0 00000000	  dw    0     ; number of blocks
FFFC22E4 00000000	  dw    0
FFFC22E8 00000000	  dw    0     ; command processing routine
FFFC22EC 00000000	  dw    0
FFFC22F0 00000000	  db    0     ; reentrancy count
FFFC22F1 00000000	  db    0     ; single user flag
FFFC22F2 00000000	  db    0     ; user interface device flag
FFFC22F3 00000000	  db    0
FFFC22F4 00000000	  dw    0
FFFC22F8 00000000	  dw    0     ; hJob
FFFC22FC 00000000	  dw    0
FFFC2300 00000000	  dw    0     ; Mailbox handle
FFFC2304 00000000	  dw    0
FFFC2308 00000000	  dw    0     ; pointer to device semaphore
FFFC230C 00000000	  dw    0
FFFC2310 00000000	  dw    0     ; reserved
FFFC2314 00000000	  dw    0
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC2318 00000000		align	1
FFFC231C 00000000
                        	
                        	ViaSetup:
FFFC2320 FFC10113		sub		$sp,$sp,#4
FFFC2324 00112023		stt		$ra,[$sp]
FFFC2328 00F06513		ldi		$a0,#15							; VIA device
FFFC232C FFFC25B7		ldi		$a1,#ViaFuncTbl
FFFC2330 23858593
FFFC2334 70D010EF		call	CopyDevFuncTbl
FFFC2338 00F06513		ldi		$a0,#15							; VIA device
FFFC233C FFFC25B7		ldi		$a1,#ViaDCB
FFFC2340 2B858593
FFFC2344 72D010EF		call	CopyDevDCB
FFFC2348 018000EF		call  ViaInit
FFFC234C 00012083		ldt		$ra,[$sp]
FFFC2350 00410113		add		$sp,$sp,#4
                        	ViaNOP:
FFFC2354 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; ViaInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	; Initialize port A low order eight bits as output, the remaining bits as
                        	; input. Setup timer #3 as the system time slice (30ms).
                        	;------------------------------------------------------------------------------
                        	
FFFC2358 00000000		align	1
FFFC235C 00000000
                        	
                        	ViaInit:
FFFC2360 FFC10113		sub		$sp,$sp,#4
FFFC2364 00112023		stt		$ra,[$sp]
FFFC2368 FFDC0337		ldi		$t1,#VIA
FFFC236C 60030313
FFFC2370 0FF06293		ldi		$t0,#$000000FF      ; low eight bits output
FFFC2374 00532623		stt		$t0,VIA_DDRA[$t1]
FFFC2378 00106293		ldi		$t0,#1							; select timer 3 access
FFFC237C 025308A3		stb		$t0,VIA_PCR+1[$t1]
FFFC2380 000022B7		ldi		$t0,#$1F00
FFFC2384 F0028293
FFFC2388 02531623		stw		$t0,VIA_ACR[$t1]		; set timer 3 mode, timer 1/2 = 64 bit
FFFC238C 001252B7		ldi		$t0,#$00124F80			;	divider value for 33.333Hz (30 ms)
FFFC2390 F8028293
FFFC2394 00532823		stt		$t0,VIA_T1CL[$t1]
FFFC2398 00032A23		stt		$x0,VIA_T1CH[$t1]		; trigger transfer to count registers
FFFC239C 003D12B7		ldi   $t0,#$003D0900      ; divider value for 10 Hz (100 ms)
FFFC23A0 90028293
FFFC23A4 02532023		stt   $t0,VIA_T2CL[$t1]
FFFC23A8 02032223		stt   $x0,VIA_T2CH[$t1]
FFFC23AC 1C006293		ldi		$t0,#$1C0						; emable timer3/timer2 interrupts
FFFC23B0 02532C23		stt		$t0,VIA_IER[$t1]
FFFC23B4 00012083		ldt		$ra,[$sp]
FFFC23B8 00410113		add		$sp,$sp,#4
FFFC23BC 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        		align	16                        	
                        	ViaIRQ:
FFFC23C0 FFDC0337		ldi		$t1,#VIA
FFFC23C4 60030313
FFFC23C8 03431283		ldw		$t0,VIA_IFR[$t1]    ; get the flag register
FFFC23CC 0402F513		and   $a0,$t0,#$40        ; timer 2? (bit 6)
FFFC23D0 02051C63		bnez  $a0,.timer2irq
                        	.0001:
FFFC23D4 1002F513		and   $a0,$t0,#$100       ; timer 3? (bit 8)
FFFC23D8 00051463		bnez  $a0,.timer3irq
FFFC23DC 30200073		mret
                        	.timer3irq:
FFFC23E0 00106393		ldi		$t2,#1							; assume timer3, select timer 3 access
FFFC23E4 027308A3		stb		$t2,VIA_PCR+1[$t1]
FFFC23E8 01032383		ldt		$t2,VIA_T1CL[$t1]		; yes, clear interrupt
FFFC23EC 20802383		ldt		$t2,milliseconds
FFFC23F0 01E38393		add		$t2,$t2,#30
FFFC23F4 20702423		stt		$t2,milliseconds
FFFC23F8 20702023		stt		$t2,switchflag
FFFC23FC 00006513		ldi   $a0,#0							; invoke SchedulerIRQ()
FFFC2400 690000EF		call  OSOCall
FFFC2404 30200073		mret
                        		; reset countdown to clear interrupt
                        	.timer2irq:
FFFC2408 003D13B7		ldi   $t2,#$003D0900      ; divider value for 10 Hz (100 ms)
FFFC240C 90038393
FFFC2410 02732023		stt   $t2,VIA_T2CL[$t1]
FFFC2414 02032223		stt   $x0,VIA_T2CH[$t1]
FFFC2418 0440E073		csrrs $x0,#$044,#1        ; set GC interrupt pending bit
FFFC241C FA000CE3		bra   .0001               ; there might be a timer 3 irq too
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        		align	16                        	
                        	ViaTime:
FFFC2420 FFDC0337		ldi		$t1,#VIA
FFFC2424 60030313
FFFC2428 00106293		ldi		$t0,#1							; select timer 3 access
FFFC242C 025308A3		stb		$t0,VIA_PCR+1[$t1]
FFFC2430 01032283		ldt		$t0,VIA_T1CL[$t1]
FFFC2434 00125E37		ldi		$t3,#1200000				; timer counts down from here
FFFC2438 F80E0E13
FFFC243C 405E02B3		sub		$t0,$t3,$t0					; calc elapsed clocks
FFFC2440 0000AE37		ldi		$t3,#40000					; 40,000 clocks per millisecond
FFFC2444 C40E0E13
FFFC2448 03C2C2B3		div		$t0,$t0,$t3
FFFC244C 20802383		ldt		$t2,milliseconds
FFFC2450 00538533		add		$a0,$t2,$t0
FFFC2454 00008067		ret
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/task.r5a",25
                        		code
                        		align	4                        	
                        	OSCallTbl:
FFFC2458 C2E8C2D8	  dh    SchedulerIRQ >> 4
FFFC245A C347C2E8	  dh    IStartTask >> 4
FFFC245C C2CBC347	  dh    ISendMsg >> 4
FFFC245E C41EC2CB	  dh    ISleep >> 4
FFFC2460 C263C41E	  dh		ISetDCBField >> 4
                        	
                        	OSEcallTbl:
FFFC2462 C2E8C263		dh		FMTK_Initialize	>> 4				; 0
FFFC2464 C302C2E8		dh		FMTK_StartTask >> 4					; 1
FFFC2466 C303C302		dh		FMTK_ExitTask >> 4
FFFC2468 C270C303		dh		FMTK_KillTask >> 4
FFFC246A C2D7C270		dh		FMTK_SetTaskPriority >> 4
FFFC246C C311C2D7		dh		FMTK_Sleep >> 4							; 5
FFFC246E C324C311		dh		FMTK_AllocMbx >> 4
FFFC2470 002EC324		dh		FMTK_FreeMbx >> 4
FFFC2472 C355002E		dh		FMTK_PostMsg >> 4
FFFC2474 C363C355		dh		FMTK_SendMsg >> 4
FFFC2476 C362C363		dh		FMTK_WaitMsg >> 4					; 10
FFFC2478 C376C362		dh		FMTK_PeekMsg >> 4
FFFC247A C396C376		dh		FMTK_StartApp >> 4          ; 12
FFFC247C C265C396		dh		FMTK_ExitApp >> 4           ; 13
FFFC247E C43EC265		dh		FMTK_GetCurrentTid >> 4
FFFC2480 C397C43E		dh		FMTK_TCBFinalizerExit >> 4  ; 15
FFFC2482 C273C397		dh		FMTK_KillApp >> 4
FFFC2484 C26BC273		dh		FMTK_RunAsOS >> 4            ; 17
FFFC2486 C26FC26B		dh		FMTK_GetTaskAppId >> 4      ; 18
FFFC2488 C3EBC26F		dh		FMTK_SetTaskId >> 4         ; 19
FFFC248A C3F3C3EB		dh		FMTK_HasIOFocus	>> 4				; 20
FFFC248C C3FDC3F3		dh		FMTK_SwitchIOFocus >> 4			; 21
FFFC248E C3FEC3FD		dh		FMTK_ReleaseIOFocus	>> 4		; 22
FFFC2490 C3F4C3FE		dh		FMTK_ForceReleaseIOFocus >> 4	; 23
FFFC2492 C274C3F4		dh		FMTK_RequestIOFocus	>> 4		; 24
FFFC2494 C412C274		dh		FMTK_MapOSVars >> 4         ; 25
FFFC2496 C419C412		dh		FMTK_IO	>> 4								; 26
FFFC2498 C423C419		dh    FMTK_GetDCBField >> 4       ; 27
FFFC249A C26EC423		dh    FMTK_SetDCBField >> 4       ; 28
FFFC249C C26CC26E		dh    FMTK_GetAppTaskId >> 4      ; 29
FFFC249E 0000C26C		dh    FMTK_SetTaskAppId >> 4      ; 30
FFFC24A0 C1B50000		dh    0
FFFC24A2 C17FC1B5		dh    GetPamBit >> 4              ; 32
FFFC24A4 C051C17F		dh    FetchMemoryWord >> 4        ; 33
FFFC24A6 C266C051		dh    Monitor >> 4                ; 34
FFFC24A8 C268C266		dh    GetIRQFlag >> 4             ; 35
FFFC24AA C180C268		dh    SetIRQFlag >> 4             ; 36
FFFC24AC C26AC180		dh    FMTK_Alloc >> 4							; 37
FFFC24AE 0000C26A		dh    FMTK_GetCurrentAppId >> 4		; 38
FFFC24B0 00000000		dh    0
FFFC24B2 00000000		dh    0                       ; 40
FFFC24B4 00000000		dh    0                       ; 41
FFFC24B6 00000000		dh    0                       ; 42
FFFC24B8 00000000		dh    0                       ; 43
FFFC24BA 00000000		dh    0                       ; 44
FFFC24BC 00000000		dh    0                       ; 45
FFFC24BE 00000000		dh    0                       ; 46
FFFC24C0 00000000		dh    0                       ; 47
                        	
                        	qToChk:
FFFC24C2 01000000		db	0,0,0,1,0,0,2,1
FFFC24C6 01020000
FFFC24CA 01030000		db	0,0,3,1,0,0,2,1
FFFC24CE 01020000
FFFC24D2 01040000		db	0,0,4,1,0,0,2,1
FFFC24D6 01020000
FFFC24DA 01030000		db	0,0,3,1,0,0,2,1
FFFC24DE 01020000
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC24E2 00000000		align	1
FFFC24E6 00000000
FFFC24EA 00000000
FFFC24EE 22230000
                        	
                        	FMTKInit:
FFFC24F0 30002223		stt		$x0,QNDX
FFFC24F4 2E002823		stt   $x0,APPID_POOL
FFFC24F8 36002C23		stt   $x0,CHAINA0
FFFC24FC 32002023		stt		$x0,missed_ticks
FFFC2500 00006293		ldi   $t0,#0
FFFC2504 7C229073		csrrw $x0,#CSR_TASKID,$t0   ; task id = 0
FFFC2508 22002023		stt   $x0,TaskNum
FFFC250C 32002423		stt		$x0,TimeoutList
FFFC2510 40002023		stt		$x0,HEADRDY0
FFFC2514 40002223		stt		$x0,HEADRDY1
FFFC2518 40002423		stt		$x0,HEADRDY2
FFFC251C 40002623		stt		$x0,HEADRDY3
FFFC2520 40002823		stt		$x0,HEADRDY4
FFFC2524 42002023		stt		$x0,TAILRDY0
FFFC2528 42002223		stt		$x0,TAILRDY1
FFFC252C 42002423		stt		$x0,TAILRDY2
FFFC2530 42002623		stt		$x0,TAILRDY3
FFFC2534 42002823		stt		$x0,TAILRDY4
                        	
FFFC2538 000018B7		stt		$x0,IOFocusNdx
FFFC253C 08088893
FFFC2540 000888B3
FFFC2544 0008A023
                        	
                        	  ; one out the register set last tid
FFFC2548 000002B7	  ldi   $t0,#$FFFFFFFF
FFFC254C FFF28293
FFFC2550 000018B7	  stt   $t0,RegsetTid
FFFC2554 0F088893
FFFC2558 000888B3
FFFC255C 0058A023
FFFC2560 000018B7	  stt   $t0,RegsetTid+4
FFFC2564 0F488893
FFFC2568 000888B3
FFFC256C 0058A023
FFFC2570 000018B7	  stt   $t0,RegsetTid+8
FFFC2574 0F888893
FFFC2578 000888B3
FFFC257C 0058A023
FFFC2580 000018B7	  stt   $t0,RegsetTid+12
FFFC2584 0FC88893
FFFC2588 000888B3
FFFC258C 0058A023
                        	
                        		; zero out device function table
FFFC2590 000022B7		ldi		$t0,#DVF_Base
FFFC2594 00028293
FFFC2598 40006313		ldi		$t1,#32*32
                        	.0003:
FFFC259C 0002A023		stt		$x0,[$t0]
FFFC25A0 00428293		add		$t0,$t0,#4
FFFC25A4 FFF30313		sub		$t1,$t1,#1
FFFC25A8 FE604AE3		bgtz	$t1,.0003
                        	
                        		; Initialize free message list
FFFC25AC 000018B7		stt		$x0,FreeMsg
FFFC25B0 C0088893
FFFC25B4 000888B3
FFFC25B8 0008A023
                        	
                        		; Initialize mailboxes
FFFC25BC 000018B7		stt   $x0,FreeMbx
FFFC25C0 C0888893
FFFC25C4 000888B3
FFFC25C8 0008A023
FFFC25CC 000018B7		stw   $x0,IdleTaskMbx
FFFC25D0 C1088893
FFFC25D4 000888B3
FFFC25D8 00089023
FFFC25DC 000018B7		stw   $x0,IdleTaskId
FFFC25E0 C2A88893
FFFC25E4 000888B3
FFFC25E8 00089023
FFFC25EC 000018B7		stb   $x0,MbxBlockCounter
FFFC25F0 0E088893
FFFC25F4 000888B3
FFFC25F8 00088023
FFFC25FC 00806293		ldi   $t0,#MBX_BLOCKPTR_BUFSZ
FFFC2600 00001337		ldi   $t1,#MbxBlockPtr
FFFC2604 0A030313
                        	.0001:
FFFC2608 00032023		stt   $x0,[$t1]
FFFC260C 00430313		add   $t1,$t1,#4
FFFC2610 FFF28293		sub   $t0,$t0,#1
FFFC2614 FE029AE3		bnez  $t0,.0001
                        	
                        		; unlock the system semaphore	
                        		
FFFC2618 FFF06513			ldi				a0,#-1
FFFC261C 34A02023			stt				a0,SysSema
                        	
FFFC2620 00008067		ret
                        	
FFFC2624 00000000		align	1
FFFC2628 00000000
FFFC262C 00000000
                        	
                        	FMTK_Initialize:
                        	  
FFFC2630 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2634 EBDFF06F	jmp  FMTKInit
                        	 
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
FFFC2638 00000000		align	1
FFFC263C 00000000
                        	
                        	GetCurrentTid:
                        		
FFFC2640 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2644 00008067	ret
                        	
FFFC2648 00000000		align	1
FFFC264C 00000000
                        	
                        	FMTK_GetCurrentTid:
                        		
FFFC2650 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2654 000565B3	mov		$a1,$a0
FFFC2658 00006513		ldi		$a0,#E_Ok
FFFC265C 00008067		ret
                        	
                        		align	16                        	
                        	GetIRQFlag:
FFFC2660 000018B7	  ldt   $a1,IRQFlag
FFFC2664 09088893
FFFC2668 000888B3
FFFC266C 0008A583
FFFC2670 00006513	  ldi   $a0,#E_Ok
FFFC2674 00008067	  ret
                        	
FFFC2678 00000000		align	1
FFFC267C 00000000
                        	
                        	SetIRQFlag:
FFFC2680 000018B7	  stt   $a1,IRQFlag
FFFC2684 09088893
FFFC2688 000888B3
FFFC268C 00B8A023
FFFC2690 00006513	  ldi   $a0,#E_Ok
FFFC2694 00008067	  ret
                        	
                        	; Accessors
                        	
FFFC2698 00000000		align	1
FFFC269C 00000000
                        	
                        	FMTK_GetCurrentAppId:
                        		
FFFC26A0 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC26A4 000565B3	mov		$a1,$a0
FFFC26A8 0080006F		jmp		FMTK_GetTaskAppId
                        	
FFFC26AC 00000000		align	1
                        	
                        	FMTK_GetTaskAppId:
FFFC26B0 00A59593	  sll   $a1,$a1,#LOG_PGSZ
FFFC26B4 3425D583	  ldwu  $a1,TCBappid[$a1]
FFFC26B8 00006513	  ldi   $a0,#E_Ok
FFFC26BC 00008067	  ret
                        	
                        		align	16                        	
                        	FMTK_SetTaskAppId:
FFFC26C0 00A59593	  sll   $a1,$a1,#LOG_PGSZ
FFFC26C4 34C59123	  stw   $a2,TCBappid[$a1]
FFFC26C8 00A5D593	  srl   $a1,$a1,#LOG_PGSZ ; be nice, return what was passed
FFFC26CC 00006513	  ldi   $a0,#E_Ok
FFFC26D0 00008067	  ret
                        	
FFFC26D4 00000000		align	1
FFFC26D8 00000000
FFFC26DC 00000000
                        	
                        	FMTK_GetAppTaskId:
FFFC26E0 00A59593	  sll   $a1,$a1,#LOG_PGSZ
FFFC26E4 3C05D583	  ldwu  $a1,ACBTask[$a1]
FFFC26E8 00006513	  ldi   $a0,#E_Ok
FFFC26EC 00008067	  ret
                        	
                        	; The following only really needed by startup code, otherwise the task id
                        	; is completely managed by the OS.
                        		align	16                        	
                        	FMTK_SetTaskId:
                        	  ; Should get the id and see if it's currently zero (unset).
                        	  ; but this would be more code bloat.
FFFC26F0 7C259073	  csrrw $x0,#CSR_TASKID,$a1
FFFC26F4 00006513	  ldi   $a0,#E_Ok
FFFC26F8 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Setting the task priority will take effect the next time the task is
                        	; scheduled.
                        	;
                        	; Parameters:
                        	;   $a1 = new priority to set
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;------------------------------------------------------------------------------
FFFC26FC 00000000		align	1
                        	
                        	FMTK_SetTaskPriority:
                        	  
FFFC2700 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2704 00A51293	sll   $t0,$a0,#LOG_TCBSZ
FFFC2708 2CB284A3	  stb   $a1,TCBPriority[$t0]
FFFC270C 00006513	  ldi   $a0,#E_Ok
FFFC2710 00008067	  ret
                        	.badTid:
FFFC2714 02806513	  ldi   $a0,#E_BadTid
FFFC2718 00008067	  ret
                        	.badPtr:
FFFC271C 000008B7	  call  FreeTID
FFFC2720 30C880E7
FFFC2724 02706513	  ldi   $a0,#E_BadTcbPointer
FFFC2728 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; RunAsOS
                        	;   Runs a piece of code as part of the OS.
                        	; Only certain tasks are allowed to run code this way.
                        	;
                        	; Parameters:
                        	;   $a1 = pointer to code to run
                        	;------------------------------------------------------------------------------
FFFC272C 00000000		align	1
                        	
                        	FMTK_RunAsOS:
FFFC2730 0005E2B3	  mov   $t0,$a1
FFFC2734 00028067	  jmp   [$t0]
                        	.badFunc:
FFFC2738 00206513	  ldi   $a0,#E_Func
FFFC273C 00008067	  ret
                        	 
                        	;------------------------------------------------------------------------------
                        	; Map operating system variables into the app's address space.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;   $a0 = E_Ok if successful
                        	;   $a1 = virtual address space location of vars., -1 if unsuccessful
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	FMTK_MapOSVars:
FFFC2740 00006513	  ldi   $a0,#0          ; OS app
FFFC2744 01006593	  ldi   $a1,#OSPAGES
FFFC2748 E09FE0EF	  call  FindRun
FFFC274C 02054863	  bltz  $a0,.noMem
FFFC2750 00006293	  ldi   $t0,#0
FFFC2754 000565B3	  mov   $a1,$a0
                        	.mapMore:
FFFC2758 02A2800D	  mvmap $x0,$t0,$a0
FFFC275C 00128293	  add   $t0,$t0,#1
FFFC2760 00150513	  add   $a0,$a0,#1
FFFC2764 0102A313	  slt   $t1,$t0,#16
FFFC2768 FE0318E3	  bnez  $t1,.mapMore
FFFC276C 1FF5F593	  and   $a1,$a1,#$1FF
FFFC2770 00A59593	  sll   $a1,$a1,#LOG_PGSZ
FFFC2774 00006513	  ldi   $a0,#E_Ok
FFFC2778 00008067	  ret
                        	.noMem:
FFFC277C FFF06593	  ldi   $a1,#-1
FFFC2780 04706513	  ldi   $a0,#E_NoMem
FFFC2784 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
FFFC2788 00000000		align	1
FFFC278C 00000000
                        	
                        	LockOSSemaphore:
                        	LockOS:
FFFC2790 7C401DF3		csrrw	$s11,#CSR_PMSTACK,$x0		; Get current interrupt enable setting
                        	.spin:
                        		
FFFC2794 010002B7			ldi				$t0,#$000180|(1<<24)				; enable timer3 interrupts after tm cycles
		stt				$t0,VIA_IER+VIA
FFFC2798 18028293
FFFC279C FFDC08B7
FFFC27A0 63888893
FFFC27A4 000888B3
FFFC27A8 0058A023
                        	
FFFC27AC 7C40E073		csrrs	$x0,#CSR_PMSTACK,#1			; ensure interrupts are enabled
FFFC27B0 FFDB08B7		ldt		$t0,OS_SEMA+4						; try and lock semaphore
FFFC27B4 00488893
FFFC27B8 000888B3
FFFC27BC 0008A283
FFFC27C0 FC028AE3		beqz	$t0,.spin
FFFC27C4 7C40F073	  csrrc	$x0,#CSR_PMSTACK,#1			; disable interrupts
FFFC27C8 00008067		ret
                        	
FFFC27CC 00000000		align	1
                        	
                        	UnlockOSSemaphore:
                        	UnlockOS:
FFFC27D0 7C4D9073		csrrw	$x0,#CSR_PMSTACK,$s11		; restore interrupts
FFFC27D4 00106D93		ldi		$s11,#1
FFFC27D8 FFDB48B7		stt		$s11,OS_SEMA+$4000			; unlock semaphore
FFFC27DC 00088893
FFFC27E0 000888B3
FFFC27E4 01B8A023
FFFC27E8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready lists are searched in a circular
                        	; fashion beginning with the list identified indirectly by QNDX. There are
                        	; five ready lists to hold tasks of five different priorities.
                        	; Cannot wait for an interrupt in this routine because it is called by
                        	; the SchedulerIRQ() routine. 
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		$a1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		$a0 = task id of task to run. 0 if no task is ready to run.
                        	;------------------------------------------------------------------------------
FFFC27EC 00000000	  align 1
                        	
                        	SelectTaskToRun:
FFFC27F0 FFC10113	  sub   $sp,$sp,#4
FFFC27F4 00112023	  stt   $ra,[$sp]
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
                        	
                        		; Every UnlockOS must have a correpsonding LockOS preceding it. $s11 is
                        		; used to store the interrupt enable status. Here an unlock is desired
                        		; without a preceding lock.
                        	;  csrrs	$x0,#CSR_PMSTACK,#1			; enable interrupts
                        	;	ldi		$s11,#1
                        	;	stt		$s11,OS_SEMA+$4000			; unlock semaphore
                        	.checkAgain:
FFFC27F8 F99FF0EF		call	LockOS
FFFC27FC 30404583		ldbu	$a1,QNDX						; get index into que check table
FFFC2800 00158593		add		$a1,$a1,#1					; increment it, and limit
FFFC2804 01F5F593		and		$a1,$a1,#31
FFFC2808 30B00223		stb		$a1,QNDX						; store back
FFFC280C FFFC28B7		ldbu	$a1,qToChk[$a1]			; assume this will be valid
FFFC2810 4C288893
FFFC2814 00B888B3
FFFC2818 0008C583
FFFC281C 00259593		sll		$a1,$a1,#2					; turn $a1 into index
FFFC2820 00506393		ldi		$t2,#5							; 5 queues to check
                        	.nxtQ:
FFFC2824 4005A503	  ldt		$a0,HEADRDY[$a1]
FFFC2828 02051463	  bnez  $a0,.dq      				;
FFFC282C 00458593		add		$a1,$a1,#4					; no, advance to next queue
FFFC2830 0145A513		slt   $a0,$a1,#20
FFFC2834 00051463		bnez  $a0,.mod
FFFC2838 00006593		ldi   $a1,#0
                        	.mod:
FFFC283C FFF38393		sub		$t2,$t2,#1					;
FFFC2840 FE7042E3		bgtz	$t2,.nxtQ				    ; go back to check next queue
                        		; Here, nothing else is actually ready to run?
                        		; This should not be possible as the IdleTask should always
                        		; be present. Return NULL.
FFFC2844 00006513		ldi		$a0,#0
FFFC2848 F89FF0EF		call	UnlockOS
FFFC284C 02000063		bra		.xit
                        	.dq:
                        	  ; If we got a task but it isn't actually ready anymore go back
                        	  ; and get another task.
FFFC2850 2C850283	  ldb   $t0,TCBStatus[$a0]
FFFC2854 0012F293	  and   $t0,$t0,#TS_READY
                        	  ; Rotate ready list
                        	;  call	LockOS
FFFC2858 31052303	  ldt   $t1,TCBNext[$a0]
FFFC285C 4065A023	  stt		$t1,HEADRDY[$a1]
FFFC2860 42A5A023	  stt		$a0,TAILRDY[$a1]
FFFC2864 F6DFF0EF		call	UnlockOS
FFFC2868 F80288E3	  beqz  $t0,.checkAgain
                        	  ; Return $a0 equal selected task
                        	.xit:
FFFC286C 00012083	  ldt   $ra,[$sp]
FFFC2870 00410113	  add   $sp,$sp,#4
FFFC2874 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	;
                        	; Parameters:
                        	;		$s1 = pointer to TCB of outgoing context
                        	;		$s2 = pointer to TCB of incoming context
                        	; Must not modify:
                        	;   $t2
                        	; Modifies:
                        	;   $t0,$t1,$t3,$t4,$t5
                        	;------------------------------------------------------------------------------
FFFC2878 00000000	  align 1
FFFC287C 00000000
                        	
                        	SwapContext:
FFFC2880 FF810113		sub		$sp,$sp,#8
FFFC2884 00112023		stt		$ra,[$sp]
FFFC2888 00712223		stt		$t2,4[$sp]
                        	/*
	ldbu	$a0,TCBRegset[$s1]
	mov		$a0,$s1
	call	PutHexByte
	ldi		$a0,#' '
	call 	Putch
	ldbu	$a0,TCBRegset[$s2]
	call	PutHexByte
	ldi		$a0,#CR
	call	Putch
*/
                        		; Save outgoing register set in TCB
FFFC288C F05FF0EF		call	LockOS
FFFC2890 7C026073		csrrs	$x0,#CSR_REGSET,#4	  ; select prior register set for Rs2, epc
FFFC2894 0414A423		stt		$x1,TCBxRA[$s1]
FFFC2898 0424A823		stt		$x2,TCBxSP[$s1]
FFFC289C 0434AC23		stt		$x3,TCBxGP[$s1]
FFFC28A0 0644A023		stt		$x4,TCBxTP[$s1]
FFFC28A4 0654A423		stt		$x5,TCBxT0[$s1]
FFFC28A8 0664A823		stt		$x6,TCBxT1[$s1]
FFFC28AC 0674AC23		stt		$x7,TCBxT2[$s1]
FFFC28B0 0884A023		stt		$x8,TCBxFP[$s1]
FFFC28B4 0894A423		stt		$x9,TCBxS1[$s1]
FFFC28B8 08A4A823		stt		$x10,TCBxA0[$s1]
FFFC28BC 08B4AC23		stt		$x11,TCBxA1[$s1]
FFFC28C0 0AC4A023		stt		$x12,TCBxA2[$s1]
FFFC28C4 0AD4A423		stt		$x13,TCBxA3[$s1]
FFFC28C8 0AE4A823		stt		$x14,TCBxA4[$s1]
FFFC28CC 0AF4AC23		stt		$x15,TCBxA5[$s1]
FFFC28D0 0D04A023		stt		$x16,TCBxA6[$s1]
FFFC28D4 7C0FF073		csrrc	$x0,#CSR_REGSET,#31   ; restore register set selections
FFFC28D8 EF9FF0EF		call	UnlockOS
FFFC28DC EB5FF0EF		call	LockOS
FFFC28E0 7C026073		csrrs	$x0,#CSR_REGSET,#4	  ; select prior register set for Rs2, epc
FFFC28E4 0D14A423		stt		$x17,TCBxA7[$s1]
FFFC28E8 0D24A823		stt		$x18,TCBxS2[$s1]
FFFC28EC 0D34AC23		stt		$x19,TCBxS3[$s1]
FFFC28F0 0F44A023		stt		$x20,TCBxS4[$s1]
FFFC28F4 0F54A423		stt		$x21,TCBxS5[$s1]
FFFC28F8 0F64A823		stt		$x22,TCBxS6[$s1]
FFFC28FC 0F74AC23		stt		$x23,TCBxS7[$s1]
FFFC2900 1184A023		stt		$x24,TCBxS8[$s1]
FFFC2904 1194A423		stt		$x25,TCBxS9[$s1]
FFFC2908 11A4A823		stt		$x26,TCBxS10[$s1]
FFFC290C 11B4AC23		stt		$x27,TCBxS11[$s1]
FFFC2910 13C4A023		stt		$x28,TCBxT3[$s1]
FFFC2914 13D4A423		stt		$x29,TCBxT4[$s1]
FFFC2918 13E4A823		stt		$x30,TCBxT5[$s1]
FFFC291C 13F4AC23		stt		$x31,TCBxT6[$s1]
FFFC2920 7C0FF073		csrrc	$x0,#CSR_REGSET,#31   ; restore register set selections
FFFC2924 EADFF0EF		call	UnlockOS
                        	
                        		; Save MEPC
FFFC2928 34101E73		csrrw $t3,#CSR_MEPC,$x0
FFFC292C 2DC4A023		stt   $t3,TCBepc[$s1]
                        	
                        		; Save the operating mode
FFFC2930 7C401E73		csrrw $t3,#CSR_PMSTACK,$x0
FFFC2934 038E7E13		and   $t3,$t3,#$38
FFFC2938 35C48223		stb   $t3,TCBOpMode[$s1]
                        	
                        		; Save interrupt mask
FFFC293C 7C501E73		csrrw	$t3,#CSR_IMSTACK,$x0
FFFC2940 00FE7E13		and		$t3,$t3,#15
FFFC2944 35C482A3		stb		$t3,TCBImMask[$s1]
                        	
                        		; set task id
FFFC2948 E49FF0EF		call	LockOS
FFFC294C 00A95513	  srl   $a0,$s2,#LOG_PGSZ
FFFC2950 7C251073		csrrw $x0,#CSR_TASKID,$a0			
                        	
                        		; Switch to destination memory map
FFFC2954 2CC94503	  ldbu  $a0,TCBRegset[$s2]
                        	;  ldbu  $a0,TCBmid[$s2]
FFFC2958 01651513	  sll		$a0,$a0,#22							; shift into position
FFFC295C 18001373	  csrrw	$t1,#CSR_SATP,$x0				; get satp
FFFC2960 F84008B7	  and		$t1,$t1,#$f83fffff			; mask off asid
FFFC2964 FFF88893
FFFC2968 0068F333
FFFC296C 00A36333	  or		$t1,$t1,$a0							; set new asid
FFFC2970 18031073		csrrw	$x0,#CSR_SATP,$t1				; set satp
                        		; User map has now been switched
                        	
                        		; Select register set to return to
FFFC2974 2CC94503	  ldbu  $a0,TCBRegset[$s2]
FFFC2978 7C301373		csrrw $t1,#CSR_RSSTACK,$x0
FFFC297C C1F37313		and   $t1,$t1,#$FFFFFC1F
FFFC2980 00551293		sll   $t0,$a0,#5
FFFC2984 00536333		or    $t1,$t1,$t0
FFFC2988 7C331073		csrrw $x0,#CSR_RSSTACK,$t1
FFFC298C E45FF0EF		call	UnlockOS
                        	
FFFC2990 E01FF0EF		call	LockOS
FFFC2994 7C00E073		csrrs $x0,#CSR_REGSET,#1      ; select task's register set
                        		; These two registers always need to be loaded so that the OS return values
                        		; can be transferred.
FFFC2998 05092103		ldt		$x2,TCBxSP[$s2]         ; manipulated by StartTask
FFFC299C 05892183		ldt		$x3,TCBxGP[$s2]         ; manipulated by StartApp
FFFC29A0 09092503		ldt		$x10,TCBxA0[$s2]
FFFC29A4 09892583		ldt		$x11,TCBxA1[$s2]
                        	;	beqz  $t1,.skipCtxLoad
FFFC29A8 04892083		ldt		$x1,TCBxRA[$s2]
FFFC29AC 06092203		ldt		$x4,TCBxTP[$s2]
FFFC29B0 06892283		ldt		$x5,TCBxT0[$s2]
FFFC29B4 07092303		ldt		$x6,TCBxT1[$s2]
FFFC29B8 07892383		ldt		$x7,TCBxT2[$s2]
FFFC29BC 08092403		ldt		$x8,TCBxFP[$s2]
FFFC29C0 08892483		ldt		$x9,TCBxS1[$s2]
FFFC29C4 0A092603		ldt		$x12,TCBxA2[$s2]
FFFC29C8 0A892683		ldt		$x13,TCBxA3[$s2]
FFFC29CC 0B092703		ldt		$x14,TCBxA4[$s2]
FFFC29D0 0B892783		ldt		$x15,TCBxA5[$s2]
FFFC29D4 0C092803		ldt		$x16,TCBxA6[$s2]
FFFC29D8 7C0FF073		csrrc	$x0,#CSR_REGSET,#31   ; restore register set selections
FFFC29DC DF5FF0EF		call	UnlockOS
FFFC29E0 DB1FF0EF		call	LockOS
FFFC29E4 7C00E073		csrrs $x0,#CSR_REGSET,#1      ; select task's register set
FFFC29E8 0C892883		ldt		$x17,TCBxA7[$s2]
FFFC29EC 0D092903		ldt		$x18,TCBxS2[$s2]
FFFC29F0 0D892983		ldt		$x19,TCBxS3[$s2]
FFFC29F4 0E092A03		ldt		$x20,TCBxS4[$s2]
FFFC29F8 0E892A83		ldt		$x21,TCBxS5[$s2]
FFFC29FC 0F092B03		ldt		$x22,TCBxS6[$s2]
FFFC2A00 0F892B83		ldt		$x23,TCBxS7[$s2]
FFFC2A04 10092C03		ldt		$x24,TCBxS8[$s2]
FFFC2A08 10892C83		ldt		$x25,TCBxS9[$s2]
FFFC2A0C 11092D03		ldt		$x26,TCBxS10[$s2]
FFFC2A10 11892D83		ldt		$x27,TCBxS11[$s2]
FFFC2A14 12092E03		ldt		$x28,TCBxT3[$s2]
FFFC2A18 12892E83		ldt		$x29,TCBxT4[$s2]
FFFC2A1C 13092F03		ldt		$x30,TCBxT5[$s2]
FFFC2A20 13892F83		ldt		$x31,TCBxT6[$s2]
FFFC2A24 7C0FF073		csrrc	$x0,#CSR_REGSET,#31   ; restore register set selections
FFFC2A28 DA9FF0EF		call	UnlockOS
                        	
FFFC2A2C D65FF0EF		call	LockOS
                        	  ; Setup return privilege mode
FFFC2A30 34494E03	  ldbu  $t3,TCBOpMode[$s2]
FFFC2A34 7C4012F3	  csrrw $t0,#CSR_PMSTACK,$x0
FFFC2A38 FC72F293	  and   $t0,$t0,#$FFFFFFC7
FFFC2A3C 038E7E13	  and   $t3,$t3,#$38          ; four operating modes max
FFFC2A40 01C2E2B3	  or    $t0,$t0,$t3
FFFC2A44 7C429073	  csrrw $x0,#CSR_PMSTACK,$t0
                        	
                        		; Setup interrupt mask
FFFC2A48 34594E03		ldbu	$t3,TCBImMask[$s2]
FFFC2A4C 7C5012F3		csrrw	$t0,#CSR_IMSTACK,$x0
FFFC2A50 FF02F293		and		$t0,$t0,#$FFFFFFF0
FFFC2A54 00FE7E13		and		$t3,$t3,#15
FFFC2A58 01C2E2B3		or		$t0,$t0,$t3
FFFC2A5C 7C529073		csrrw	$x0,#CSR_IMSTACK,$t0
                        	
                        		; Setup EPC to return to task
FFFC2A60 2C092E03	  ldt   $t3,TCBepc[$s2]
FFFC2A64 341E1073	  csrrw $x0,#CSR_MEPC,$t3
FFFC2A68 D69FF0EF		call	UnlockOS
                        	
FFFC2A6C 00012083	  ldt		$ra,[$sp]
FFFC2A70 00412383	  ldt		$t2,4[$sp]
FFFC2A74 00810113	  add		$sp,$sp,#8
                        	
FFFC2A78 00008067		ret
                        	/*
	; Now save off segment registers
	ldi		$t1,#0
.svseg:
	mvseg	$t0,$x0,$t1
	sll		$t3,$t1,#2
	add		$t3,$t3,$s1
	stt		$t0,TCBbases[$t3]
	add		$t1,$t1,#1
	and		$t1,$t1,#15
	bnez	$t1,.svseg

	; Switch memory maps
;	srl		$v0,$a1,#10					; convert pointer to tid
;	and		$v0,$v0,#$F					; mask to 16 task
  ldbu  $a0,TCBmid[$s2]
  sll		$a0,$a0,#22					; shift into position
  csrrw	$t1,#$180,$x0				; get satp
  and		$t1,$t1,#$f83fffff	; mask off asid
  or		$t1,$t1,$a0					; set new asid
	csrrw	$x0,#$180,$t1				; set satp
  srl   $a0,$s2,#LOG_PGSZ
	csrrw $x0,#CSR_TASKID,$a0
	; User map has now been switched

	; Restore segment register set
	ldi		$t1,#0
.rsseg:
	sll		$t3,$t1,#2
	add		$t3,$t3,$s2
	ldt		$t0,TCBbases[$t3]
	mvseg	$x0,$t0,$t1
	add		$t1,$t1,#1
	and		$t1,$t1,#15
	bnez	$t1,.rsseg

.0005:
	; We can skip over a bunch of load operations if the last task to use the
	; register set is the same task that wants it. In that event there are no
	; registers to reload other than the return value ones.
	srl   $t0,$t0,#4              ; position $t0 as index
	ldbu  $t1,RegsetTid[$t0]
	beq   $t1,$t0,.0001:
	stb   $t0,RegsetTid[$t0]      ; flag as the last user
	ldi   $t1,#1
	jmp   .0002
.0001:
  ldi   $t1,#0
.0002:
*/
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system ordinary call dispatcher.
                        	;------------------------------------------------------------------------------
FFFC2A7C 00000000	  align 
                        	
FFFC2A80 434F534F	  db  "OSOCall",0
FFFC2A84 006C6C61
FFFC2A88 00000000	  align 1
FFFC2A8C 00000000
                        	
                        	OSOCall:
FFFC2A90 00852293	  slt   $t0,$a0,#8
FFFC2A94 08028063		beqz  $t0,.badFunc
FFFC2A98 7C10E073	  csrrs $x0,#$7C1,#1    		; set OS running semaphore
FFFC2A9C FFC10113	  sub		$sp,$sp,#4
FFFC2AA0 00112023	  stt		$ra,[$sp]
                        		
FFFC2AA4 10006293		ldi		$t0,#$100						; disable timer3 (time slice) interrupts
FFFC2AA8 FFDC08B7		stt		$t0,VIA_IER+VIA
FFFC2AAC 63888893
FFFC2AB0 000888B3
FFFC2AB4 0058A023
FFFC2AB8 00000013		nop                   ; make sure disable has time for effect
FFFC2ABC 00000013		nop
                        	; The function address table is compressed by assuming all the code is
                        		; located within the same 64kB block of memory. We're really saving bytes
                        		; here.
FFFC2AC0 00A50533		add		$a0,$a0,$a0         ; shift left one bit, assume add might be faster
FFFC2AC4 FFFC28B7		ldwu  $t0,OSCallTbl[$a0]  ; get the low order 16 bits of the address
FFFC2AC8 45888893
FFFC2ACC 00A888B3
FFFC2AD0 0008D283
FFFC2AD4 04028063		beqz  $t0,.badFunc
FFFC2AD8 00429293		sll		$t0,$t0,#4
FFFC2ADC FFFC08B7		or    $t0,$t0,#$FFFC0000  ; add in the high order address bits
FFFC2AE0 00088893
FFFC2AE4 0058E2B3
FFFC2AE8 000280E7		call	[$t0]
FFFC2AEC 00012083		ldt		$ra,[$sp]
FFFC2AF0 00410113		add		$sp,$sp,#4
                        		
FFFC2AF4 0A0002B7			ldi				$t0,#$000180|(10<<24)				; enable timer3 interrupts after tm cycles
		stt				$t0,VIA_IER+VIA
FFFC2AF8 18028293
FFFC2AFC FFDC08B7
FFFC2B00 63888893
FFFC2B04 000888B3
FFFC2B08 0058A023
                        	
FFFC2B0C 7C10F073		csrrc $x0,#$7C1,#1        ; clear OS running semaphore
FFFC2B10 00008067		ret
                        	.badFunc:
FFFC2B14 00206513	  ldi   $a0,#E_Func
FFFC2B18 00008067	  ret
                        	  
                        	;------------------------------------------------------------------------------
                        	; Operating system ecall dispatcher.
                        	; On entry machine registers are selected.
                        	;------------------------------------------------------------------------------
FFFC2B1C 00000000	  align 1
                        	
                        	OSECALL:
FFFC2B20 7C10E073	  csrrs $x0,#$7C1,#1    ; set OS running semaphore
FFFC2B24 C6DFF0EF	  call	LockOS
                        	  
FFFC2B28 10006293		ldi		$t0,#$100						; disable timer3 (time slice) interrupts
FFFC2B2C FFDC08B7		stt		$t0,VIA_IER+VIA
FFFC2B30 63888893
FFFC2B34 000888B3
FFFC2B38 0058A023
FFFC2B3C 00000013		nop                   ; make sure disable has time for effect
FFFC2B40 00000013		nop
FFFC2B44 7C016073	csrrs	$x0,#CSR_REGSET,#2  ; get register sets
FFFC2B48 00000013		nop
FFFC2B4C 00056533		mov		$a0,$a0					; move user to machine
FFFC2B50 0005E5B3		mov		$a1,$a1
FFFC2B54 00066633		mov		$a2,$a2
FFFC2B58 0006E6B3		mov		$a3,$a3
FFFC2B5C 00076733		mov		$a4,$a4
FFFC2B60 0007E7B3		mov		$a5,$a5
FFFC2B64 7C07F073		csrrc	$x0,#CSR_REGSET,#15 ; get back current registers for all
FFFC2B68 00000013		nop
                        	  ; Enable other kinds of interrupts. While accessing the previous register set
                        	  ; we cannot be interrupted because the regset would be in flux.
FFFC2B6C C65FF0EF	  call	UnlockOS
FFFC2B70 02F52293	  slt   $t0,$a0,#47     
FFFC2B74 02028A63		beqz  $t0,.badFunc
                        		; The function address table is compressed by assuming all the code is
                        		; located within the same 64kB block of memory. We're really saving bytes
                        		; here.
FFFC2B78 00A50533		add		$a0,$a0,$a0     ; shift left one bit, assume add might be faster
FFFC2B7C FFFC28B7		ldwu  $t0,OSEcallTbl[$a0] ; get the low order 16 bits of the address
FFFC2B80 46288893
FFFC2B84 00A888B3
FFFC2B88 0008D283
FFFC2B8C 00028E63		beqz  $t0,.badFunc
FFFC2B90 00429293		sll		$t0,$t0,#4
FFFC2B94 FFFC08B7		or    $t0,$t0,#$FFFC0000  ; add in the high order address bits
FFFC2B98 00088893
FFFC2B9C 0058E2B3
FFFC2BA0 000280E7		call	[$t0]
FFFC2BA4 00C0006F		jmp		OSExit
                        	.badFunc:
FFFC2BA8 00206513	  ldi   $a0,#E_Func
FFFC2BAC 0040006F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit from the operating system. All operating system routines use this
                        	; fragment of code to return. Return values are transferred to the previously
                        	; active register set.
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	OSExit:
FFFC2BB0 BE1FF0EF	  call	LockOS
FFFC2BB4 00000013	  nop                       ; landing zone for interrupts
FFFC2BB8 00000013	  nop
FFFC2BBC 7C00E073		csrrs	$x0,#CSR_REGSET,#1		; get register sets
FFFC2BC0 00000013		nop
FFFC2BC4 0005E5B3		mov		$a1,$a1							; move return values to user registers
FFFC2BC8 00056533		mov		$a0,$a0
FFFC2BCC 7C07F073		csrrc $x0,#CSR_REGSET,#15 ; restore register set selection
FFFC2BD0 00000013		nop
FFFC2BD4 BFDFF0EF		call	UnlockOS
FFFC2BD8 7C10F073		csrrc $x0,#$7C1,#1        ; clear OS running semaphore
                        		
FFFC2BDC 1A0002B7		ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
FFFC2BE0 18028293
FFFC2BE4 FFDC08B7		stt		$t0,VIA_IER+VIA
FFFC2BE8 63888893
FFFC2BEC 000888B3
FFFC2BF0 0058A023
FFFC2BF4 30200073	mret
                        	
                        	;------------------------------------------------------------------------------
                        	; Time accounting.
                        	; Update the length of time the task has been running.
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB
                        	; Modifies:
                        	;		t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	AccountTime:
                        	;	csrrw	$t3,#$741,$x0					; get high time
                        	;	csrrw	$t2,#$701,$x0					; get low time
                        	;	csrrw	$t4,#$741,$x0
                        	;	bne		$t3,$t4,.again
FFFC2BF8 FFC10113		sub		$sp,$sp,#4
FFFC2BFC 00112023		stt		$ra,[$sp]
FFFC2C00 821FF0EF		call	ViaTime
FFFC2C04 2CA4AC23		stt		$a0,TCBEndTick[$s1]
FFFC2C08 2D04AE03		ldt		$t3,TCBStartTick[$s1]
FFFC2C0C 41C38EB3		sub		$t4,$t2,$t3						; end - start
FFFC2C10 3004AF03		ldt		$t5,TCBTicks[$s1]
FFFC2C14 01DF0F33		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC2C18 31E4A023		stt		$t5,TCBTicks[$s1]
FFFC2C1C 00012083		ldt		$ra,[$sp]
FFFC2C20 00410113		add		$sp,$sp,#4
FFFC2C24 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; UpdateMsgFields
                        	;    Place message data in target address by calling PeekMsg().
                        	;
                        	; Parameters:
                        	;   $a0 = target tid
                        	;   $t2 = TCB status (updated)
                        	;   $s2 = target TCB to update
                        	; Modifies:
                        	;   $a1,$a2,$a3,$a4,$a5,$t3,$t4
                        	;------------------------------------------------------------------------------
FFFC2C28 00000000	  align 1
FFFC2C2C 00000000
                        	
                        	UpdateMsgFields:
FFFC2C30 FF810113	  sub 	$sp,$sp,#8
FFFC2C34 00112023	  stt   $ra,[$sp]
FFFC2C38 00912223	  stt		$s1,4[$sp]
FFFC2C3C 2C894383	  ldbu	$t2,TCBStatus[$s2]
FFFC2C40 0083FE13	  and   $t3,$t2,#TS_WAITMSG
FFFC2C44 040E0863	  beqz  $t3,.notWaiting
                        	;  call	DumpReadyQueue
                        	;  call	DumpTimeoutList
                        	;.0001:
                        	;	bra		.0001
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC2C48 00B06E13		ldi		$t3,#E_NoMsg						; setup to return E_NoMsg
FFFC2C4C 09C92823		stt		$t3,TCBxA0[$s2]					; in a0
FFFC2C50 0043FE13		and		$t3,$t2,#TS_MSGRDY
FFFC2C54 020E0663		beqz	$t3,.noMsg
FFFC2C58 0005EEB3		mov   $t4,$a1                 ; save $a1
FFFC2C5C 09892583		ldt		$a1,TCBxA1[$s2]					; user a1 (x20)
FFFC2C60 0A092603		ldt		$a2,TCBxA2[$s2]					; user a2 (x20)
FFFC2C64 0A892683		ldt		$a3,TCBxA3[$s2]					; user a3 (x20)
FFFC2C68 0B092703		ldt		$a4,TCBxA4[$s2]					; user a4 (x20)
FFFC2C6C 0B892783		ldt		$a5,TCBxA5[$s2]					; user a5 (x20)
FFFC2C70 0F1000EF		call  PeekMsg
FFFC2C74 000EE5B3		mov   $a1,$t4                 ; restore $a1
FFFC2C78 00006E13		ldi		$t3,#E_Ok						    ; setup to return E_Ok
FFFC2C7C 09C92823		stt		$t3,TCBxA0[$s2]					; in a0
                        	.noMsg:
FFFC2C80 B11FF0EF		call	LockOS
FFFC2C84 2C894383	  ldbu	$t2,TCBStatus[$s2]
FFFC2C88 FF33F393		and		$t2,$t2,#~(TS_WAITMSG|TS_MSGRDY)  ; mask out message ready status
	stb		$t2,TCBStatus[$s2]
FFFC2C8C 2C790423
FFFC2C90 B41FF0EF		call	UnlockOS
                        	.notWaiting:
FFFC2C94 00012083	  ldt   $ra,[$sp]
FFFC2C98 00412483	  ldt		$s1,4[$sp]
FFFC2C9C 00810113	  add   $sp,$sp,#8
FFFC2CA0 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
                        	; Passing a time of zero or less causes the function to return right away.
                        	;
                        	; Parameters:
                        	;		$a1 = length of time to sleep (must be >= 0)
                        	; Returns:
                        	;		$v0 = E_Ok
                        	;   $v1 = 1 = context switched, 0 = same context
                        	;------------------------------------------------------------------------------
FFFC2CA4 00000000	  align 1
FFFC2CA8 00000000
FFFC2CAC 00000000
                        	
                        	ISleep:
FFFC2CB0 FF010113	  sub 	$sp,$sp,#16
FFFC2CB4 00112023	  stt   $ra,[$sp]
FFFC2CB8 00912223	  stt   $s1,4[$sp]
FFFC2CBC 01212423	  stt   $s2,8[$sp]
FFFC2CC0 01312623	  stt		$s3,12[$sp]
FFFC2CC4 0805C263		bltz	$a1,.xit
                        		
FFFC2CC8 7C201573	  csrrw $a0,#CSR_TASKID,$x0
                        	;	beqz  $a0,.xit
FFFC2CCC 00A51493		sll   $s1,$a0,#LOG_PGSZ
FFFC2CD0 0004E933		mov   $s2,$s1               ; for bad pointer processing
FFFC2CD4 00058863		beqz	$a1,.0001             ; zero timeout?
FFFC2CD8 0004E533		mov		$a0,$s1
FFFC2CDC 535000EF		call	RemoveFromReadyQueue
FFFC2CE0 5D1000EF		call	InsertIntoTimeoutList	; a1 = timeout
                        	.0001:
FFFC2CE4 AADFF0EF		call	LockOS
FFFC2CE8 2C84C503		ldbu	$a0,TCBStatus[$s1]		; flag task as no longer running
FFFC2CEC F7F57513		and		$a0,$a0,#~TS_RUNNING
FFFC2CF0 2CA48423		stb		$a0,TCBStatus[$s1]
FFFC2CF4 ADDFF0EF		call	UnlockOS
                        	
FFFC2CF8 F01FF0EF		call	AccountTime						; uses s1
FFFC2CFC AF5FF0EF		call	SelectTaskToRun
FFFC2D00 00056933	  mov   $s2,$a0    						; $s2 = $a0 = TCB pointer
FFFC2D04 A8DFF0EF	  call	LockOS
FFFC2D08 2C894383		ldbu	$t2,TCBStatus[$s2]		; x2 = incoming status
FFFC2D0C 0803E393		or		$t2,$t2,#TS_RUNNING	  ; set status = running
FFFC2D10 2C790423		stb   $t2,TCBStatus[$s2]
FFFC2D14 ABDFF0EF		call	UnlockOS
FFFC2D18 30892E03		ldt		$t3,TCBException[$s2]	;
FFFC2D1C 000E0A63		beqz	$t3,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC2D20 09C92823		stt		$t3,TCBxA0[$s2]						; r1 = exception
FFFC2D24 30092423		stt		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC2D28 02D06E13		ldi		$t3,#45
FFFC2D2C 09C92C23		stt		$t3,TCBxA1[$s2]						; r2 = 45
                        	.noException:
FFFC2D30 00006593		ldi   $a1,#0
FFFC2D34 01248663		beq		$s1,$s2,.noCtxSwitch	; incoming and outgoing contexts the same?
FFFC2D38 B49FF0EF		call	SwapContext
FFFC2D3C 00106593		ldi   $a1,#1
                        	.noCtxSwitch:
                        	;	call  UpdateMsgFields       ; must be after context is set
FFFC2D40 EE0FF0EF		call	ViaTime
FFFC2D44 2CA4A823		stt		$a0,TCBStartTick[$s1]
                        	.xit:
FFFC2D48 00006513		ldi   $a0,#E_Ok
FFFC2D4C 00012083	  ldt   $ra,[$sp]
FFFC2D50 00412483	  ldt   $s1,4[$sp]
FFFC2D54 00812903	  ldt   $s2,8[$sp]
FFFC2D58 00C12983	  ldt		$s3,12[$sp]
FFFC2D5C 01010113	  add   $sp,$sp,#16
FFFC2D60 00008067		ret
                        	
FFFC2D64 00000000		align	1
FFFC2D68 00000000
FFFC2D6C 00000000
                        	
                        	FMTK_Sleep:
FFFC2D70 F41FF06F	  jmp  	ISleep
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR. This routine will not
                        	; be invoked if the operating system is active.
                        	; Does not return anything.
                        	; The user mode task may be switched to the highest priority task.
                        	;------------------------------------------------------------------------------
FFFC2D74 00000000	  align 1
FFFC2D78 00000000
FFFC2D7C 00000000
                        	
                        	SchedulerIRQ:
                        		; See if the OS was interrupted.
FFFC2D80 7C101573		csrrw $a0,#$7C1,$x0   ; Is the OS running?
FFFC2D84 00157513		and   $a0,$a0,#1
FFFC2D88 00050463		beqz  $a0,.noOS
FFFC2D8C 00008067		ret                   ; refuse to continue this function
                        	.noOS:
FFFC2D90 FF010113		sub		$sp,$sp,#16
FFFC2D94 00112023		stt		$ra,[$sp]
FFFC2D98 00912223		stt   $s1,4[$sp]
FFFC2D9C 01212423		stt   $s2,8[$sp]
FFFC2DA0 01312623		stt		$s3,12[$sp]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
FFFC2DA4 9EDFF0EF		call	LockOS
                        	.0001:
FFFC2DA8 32802503		ldt		$a0,TimeoutList
FFFC2DAC 04050E63		beqz	$a0,.toDone
FFFC2DB0 00080337		ldi		$t1,#512<<LOG_PGSZ			; valid tid?
FFFC2DB4 00030313
FFFC2DB8 04657863		bgeu	$a0,$t1,.toDone
FFFC2DBC 32052303		ldt		$t1,TCBTimeout[$a0]
FFFC2DC0 00030863		beqz	$t1,.rmvFromTol
FFFC2DC4 FFF30313		sub		$t1,$t1,#1			; decrement timeouts for tasks on timeout list
FFFC2DC8 32652023		stt		$t1,TCBTimeout[$a0]
FFFC2DCC 02000E63		bra		.toDone
                        	.rmvFromTol:
FFFC2DD0 2C854383		ldbu	$t2,TCBStatus[$a0]
FFFC2DD4 FE73F393		and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG) ; no longer timing out or waiting
	stb		$t2,TCBStatus[$a0]
FFFC2DD8 2C750423
                        		; Remove task from task queue of mailbox
FFFC2DDC 9F5FF0EF		call	UnlockOS
FFFC2DE0 290000EF		call  MbxRemoveTask
FFFC2DE4 9ADFF0EF		call	LockOS
                        		; Remove task from timeout list
FFFC2DE8 31052983		ldt		$s3,TCBNext[$a0]
FFFC2DEC 33302423		stt		$s3,TimeoutList
FFFC2DF0 30052823		stt		$x0,TCBNext[$a0]
FFFC2DF4 9DDFF0EF		call	UnlockOS
FFFC2DF8 399000EF		call	InsertIntoReadyQueue
FFFC2DFC 995FF0EF		call	LockOS
FFFC2E00 00098463		beqz	$s3,.toDone						; list empty?
FFFC2E04 FA0002E3		bra		.0001
                        	.toDone:
FFFC2E08 9C9FF0EF		call	UnlockOS
                        		
FFFC2E0C 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2E10 00A51493	sll   $s1,$a0,#LOG_PGSZ
                        	; Might need the following if the external timer isn't used.
                        	;	csrrw	$v0,#$701,$x0					; get the time
                        	;	add		$v0,$v0,#600000				; wait 600,000 cycles @20MHz (30ms)
                        	;	csrrw	$x0,#$321,$v0					; set next interrupt time
FFFC2E14 DE5FF0EF		call	AccountTime
FFFC2E18 979FF0EF		call	LockOS
FFFC2E1C 2C84CF03		ldbu	$t5,TCBStatus[$s1]
FFFC2E20 020F6F13		or		$t5,$t5,#TS_PREEMPT
FFFC2E24 F7FF7F13		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC2E28 2DE48423		stb		$t5,TCBStatus[$s1]
FFFC2E2C 9A5FF0EF		call	UnlockOS
                        		; The ready queue was just updated, there could be new tasks
                        		; ready to run.
FFFC2E30 9C1FF0EF		call	SelectTaskToRun
FFFC2E34 02050663		beqz	$a0,.noCtxSwitch
FFFC2E38 00056933	  mov   $s2,$a0
FFFC2E3C 955FF0EF		call	LockOS
FFFC2E40 2C894E03		lbu		$t3,TCBStatus[$s2]	; t3 = incoming status
FFFC2E44 081E6393		or		$t2,$t3,#TS_RUNNING|TS_READY	; status = running
FFFC2E48 FDF3F393		and   $t2,$t2,#~TS_PREEMPT
FFFC2E4C 985FF0EF		call	UnlockOS
FFFC2E50 30892E03		ldt		$t3,TCBException[$s2]	;
FFFC2E54 000E0263		beqz	$t3,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
FFFC2E58 01248463		beq		$s1,$s2,.noCtxSwitch
FFFC2E5C A25FF0EF		call	SwapContext
                        	.noCtxSwitch:
                        	;	call  UpdateMsgFields       ; must be after context set
FFFC2E60 DC0FF0EF		call	ViaTime
FFFC2E64 2CA4A823		stt		$a0,TCBStartTick[$s1]
FFFC2E68 00012083		ldt		$ra,[$sp]
FFFC2E6C 00412483		ldt   $s1,4[$sp]
FFFC2E70 00812903		ldt   $s2,8[$sp]
FFFC2E74 00C12983		ldt		$s3,12[$sp]
FFFC2E78 01010113		add		$sp,$sp,#16
FFFC2E7C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready queue. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;   $a1 = app id
                        	;		$a2 = memory required (task's local memory)
                        	;		$a3 = start pc (usually $400)
                        	;   $a4 = register set, operating mode
                        	;	Modifies:
                        	;	Returns:
                        	;		$a0 = E_Ok if successful
                        	;		$a1 = tid of started task if successful
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	FMTK_StartTask:
                        	IStartTask:
FFFC2E80 FE810113	  sub 	$sp,$sp,#24
FFFC2E84 00112023	  stt   $ra,[$sp]
FFFC2E88 00912223	  stt   $s1,4[$sp]
FFFC2E8C 01212423	  stt   $s2,8[$sp]
FFFC2E90 01312623	  stt   $s3,12[$sp]
FFFC2E94 01412823	  stt   $s4,16[$sp]
FFFC2E98 01512A23	  stt   $s5,20[$sp]
FFFC2E9C 0005E9B3	  mov   $s3,$a1       ; $s3 = app id
FFFC2EA0 00066933	  mov   $s2,$a2       ; $s2 = memory required
FFFC2EA4 0006EAB3	  mov   $s5,$a3       ; $s5 = start address
FFFC2EA8 40006513	  ldi   $a0,#1024     ; TCB is 1kB
FFFC2EAC A15FE0EF	  call  PAMAlloc      ; allocate storage for the TCB
FFFC2EB0 14054E63		bltz	$a0,.err
FFFC2EB4 00056A33		mov   $s4,$a0
FFFC2EB8 00A55593		srl   $a1,$a0,#LOG_PGSZ
FFFC2EBC 32BA1C23	  stw   $a1,TCBtid[$s4]
FFFC2EC0 000564B3	  mov   $s1,$a0         ; $s1 = pointer to TCB
                        	;	call	FreeAll
                        	;	call	MapOSPages			; Map OS pages into address space
FFFC2EC4 0009E533	  mov   $a0,$s3         ; $a0 = app id
FFFC2EC8 34AA1123	  stw   $a0,TCBappid[$s4]
FFFC2ECC 00050663	  beqz  $a0,.appidZero
                        	  
FFFC2ED0 00A51513	  sll   $a0,$a0,#LOG_PGSZ
FFFC2ED4 3C450503	  ldb   $a0,ACBmid[$a0]
                        	.appidZero:
FFFC2ED8 34AA1023	  stw   $a0,TCBmid[$s4] ; record the mid
FFFC2EDC FA4FE0EF		call	AllocStack
FFFC2EE0 12050663		beqz  $a0,.err
FFFC2EE4 200008B7		or		$t0,$a0,#$200003FC	; set stack pointer
FFFC2EE8 3FC88893
FFFC2EEC 00A8E2B3
FFFC2EF0 0454A823		stt		$t0,TCBxSP[$s1]
FFFC2EF4 2D54A023		stt		$s5,TCBepc[$s1]	; address task will begin at
FFFC2EF8 00106293		ldi		$t0,#TS_READY
FFFC2EFC 2C548423		stb		$t0,TCBStatus[$s1]
FFFC2F00 00206293		ldi		$t0,#2					; normal execution priority
FFFC2F04 2C5484A3		stb		$t0,TCBPriority[$s1]
FFFC2F08 3204A023		stt   $x0,TCBTimeout[$s1]
                        	
                        		; leave segment base at $0, flat memory model
FFFC2F0C 00606293		ldi		$t0,#6							; read,write
FFFC2F10 00299513		sll		$a0,$s3,#2					; $a0 = appid shifted into place
FFFC2F14 0055000D		mvseg	$x0,$a0,$t0
FFFC2F18 00150513		add		$a0,$a0,#1
FFFC2F1C 0055000D		mvseg	$x0,$a0,$t0
FFFC2F20 00150513		add		$a0,$a0,#1
FFFC2F24 0055000D		mvseg	$x0,$a0,$t0
FFFC2F28 00150513		add		$a0,$a0,#1
FFFC2F2C 0055000D		mvseg	$x0,$a0,$t0
                        		; Set bounds registers
FFFC2F30 FFF06293		ldi		$t0,#-1
FFFC2F34 08056513		or		$a0,$a0,#128
FFFC2F38 0FC57513		and		$a0,$a0,#$FC
FFFC2F3C 0055000D		mvseg	$x0,$a0,$t0
FFFC2F40 00150513		add		$a0,$a0,#1
FFFC2F44 0055000D		mvseg	$x0,$a0,$t0
FFFC2F48 00150513		add		$a0,$a0,#1
FFFC2F4C 0055000D		mvseg	$x0,$a0,$t0
FFFC2F50 00150513		add		$a0,$a0,#1
FFFC2F54 0055000D		mvseg	$x0,$a0,$t0
                        	
                        		; Clear time accounting fields
FFFC2F58 3004A023		stt		$x0,TCBTicks[$s1]
FFFC2F5C 2C04A823		stt		$x0,TCBStartTick[$s1]
FFFC2F60 2C04AC23		stt		$x0,TCBEndTick[$s1]
                        	
                        	;	srl		$a0,$s1,#LOG_TCBSZ	; need the tid again
FFFC2F64 3404A423	  stt   $x0,TCBMbxNext[$s1]
FFFC2F68 3404A823	  stt   $x0,TCBMbxPrev[$s1]
FFFC2F6C 0004E533	  mov   $a0,$s1							; a0 = tid
FFFC2F70 01F77293	  and   $t0,$a4,#31
FFFC2F74 2C548623	  stb   $t0,TCBRegset[$s1]
FFFC2F78 30077293	  and   $t0,$a4,#$300
FFFC2F7C 0042D293	  srl		$t0,$t0,#4
FFFC2F80 0082E293	  or    $t0,$t0,#$08        ; enable interrupts at startup
FFFC2F84 34548223	  stb   $t0,TCBOpMode[$s1]
FFFC2F88 340482A3	  stb		$x0,TCBImMask[$s1]
FFFC2F8C 2C0486A3	  stb   $x0,TCBHasFocus[$s1]
FFFC2F90 000008B7	  stt   $x0,IOF_NEXT[$s1]
FFFC2F94 33088893
FFFC2F98 009888B3
FFFC2F9C 0008A023
FFFC2FA0 000008B7	  stt   $x0,IOF_PREV[$s1]
FFFC2FA4 33188893
FFFC2FA8 009888B3
FFFC2FAC 0008A023
FFFC2FB0 22002283	  ldt   $t0,TaskNum
FFFC2FB4 3454AC23	  stt   $t0,TCBTaskNum[$s1]
FFFC2FB8 00128293	  add   $t0,$t0,#1
FFFC2FBC 22502023	  stt   $t0,TaskNum
FFFC2FC0 FFF28293	  sub   $t0,$t0,#1
FFFC2FC4 00029E63	  bnez  $t0,.notIdleTask
FFFC2FC8 00A55513	  srl		$a0,$a0,#LOG_PGSZ
FFFC2FCC 000018B7	  stw   $a0,IdleTaskId
FFFC2FD0 C2A88893
FFFC2FD4 000888B3
FFFC2FD8 00A89023
FFFC2FDC 00A51513	  sll		$a0,$a0,#LOG_PGSZ
                        	.notIdleTask:
FFFC2FE0 1B1000EF		call	InsertIntoReadyQueue
FFFC2FE4 00A55593	  srl   $a1,$a0,#LOG_PGSZ
FFFC2FE8 00006513		ldi   $a0,#E_Ok
                        	.xit:
FFFC2FEC 00012083		ldt   $ra,[$sp]
FFFC2FF0 00412483	  ldt   $s1,4[$sp]
FFFC2FF4 00812903	  ldt   $s2,8[$sp]
FFFC2FF8 00C12983	  ldt   $s3,12[$sp]
FFFC2FFC 01012A03	  ldt   $s4,16[$sp]
FFFC3000 01412A83	  ldt   $s5,20[$sp]
FFFC3004 01810113		add   $sp,$sp,#24
FFFC3008 00008067	  ret
                        	.err:
FFFC300C 04706513	  ldi   $a0,#E_NoMem
FFFC3010 FC000EE3	  bra   .xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
FFFC3014 00000000		align	1
FFFC3018 00000000
FFFC301C 00000000
                        	
                        	FMTK_ExitTask:
                        		
FFFC3020 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC3024 00A51593	sll		$a1,$a0,#LOG_PGSZ
                        		; fall through to KillTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
FFFC3028 00000000	  align 1
FFFC302C 00000000
                        	
                        	FMTK_KillTask:
FFFC3030 3585A283		ldt   $t0,TCBTaskNum[$a1]
FFFC3034 02028863		beqz	$t0,.immortal		    ; tid #0 is immortal (the system)
FFFC3038 04006293		ldi		$t0,#TS_UNDEAD			; flag task as undead
FFFC303C 2C558423		stb		$t0,TCBStatus[$a1]
                        		; Move the task to the undead queue, it will no longer be selected by the
                        		; scheduler.
FFFC3040 0005E533		mov		$a0,$a1
FFFC3044 FFC10113		sub		$sp,$sp,#4
FFFC3048 00112023		stt		$ra,[$sp]
FFFC304C 1C5000EF		call	RemoveFromReadyQueue
FFFC3050 00706293		ldi   $t0,#UNDEADQ
FFFC3054 2C5584A3		stb   $t0,TCBPriority[$a1]
FFFC3058 139000EF		call	InsertIntoReadyQueue
FFFC305C 00012083		ldt		$ra,[$sp]
FFFC3060 00410113		add		$sp,$sp,#4
                        	;	ldbu  $a0,TCBmid[$a1]
                        	;	call	FreeAll							; free all the memory associated with the task
                        	.immortal:
FFFC3064 00006513		ldi		$a0,#E_Ok
FFFC3068 00008067		ret
                        	
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.r5a",34
                        		code  18 bits
                        	;------------------------------------------------------------------------------
                        	; Remove the task from the list of tasks waiting at the mailbox.
                        	;
                        	; Parameters:
                        	;		$a0 = task id
                        	;------------------------------------------------------------------------------
FFFC306C 00000000	  align  1
                        	
                        	MbxRemoveTask:
FFFC3070 FE810113		sub		$sp,$sp,#24
FFFC3074 00912023		stt		$s1,[$sp]
FFFC3078 00512223		stt		$t0,4[$sp]
FFFC307C 00612423		stt		$t1,8[$sp]
FFFC3080 00712623		stt		$t2,12[$sp]
FFFC3084 00A12823		stt   $a0,16[$sp]
FFFC3088 00112A23		stt		$ra,20[$sp]
FFFC308C F04FF0EF		call	LockOS
FFFC3090 35052283		ldt   $t0,TCBMbxPrev[$a0]
FFFC3094 34852303		ldt   $t1,TCBMbxNext[$a0]
FFFC3098 00028863		beqz  $t0,.atHead
FFFC309C 3462A423		stt   $t1,TCBMbxNext[$t0]
FFFC30A0 34532823	  stt   $t0,TCBMbxPrev[$t1]
FFFC30A4 04000863	  bra   .xit
                        	.atHead:
FFFC30A8 2CA51283		ldw		$t0,TCBWaitMbx[$a0]		; get mailbox handle
FFFC30AC 04505463		ble	  $t0,$x0,.xit  		    ; handle good?
                        		
FFFC30B0 0082D393	    srl   $t2,$t0,#8        ; extract collection index
FFFC30B4 00239393	    sll   $t2,$t2,#2
FFFC30B8 000018B7	    ldt   $t2,MbxBlockPtr[$t2]
FFFC30BC 0A088893
FFFC30C0 007888B3
FFFC30C4 0008A383
FFFC30C8 0FF2F293	    and   $t0,$t0,#$FF
FFFC30CC 00229293	    sll   $t0,$t0,#2
FFFC30D0 0072E2B3	    or    $t0,$t0,$t2
                        	
FFFC30D4 0042A303		ldt		$t1,MBX_TQHEAD[$t0]		; get waiting task list
FFFC30D8 00030A63		beqz  $t1,.tqEmpty
FFFC30DC 00A31863		bne		$t1,$a0,.tqEmpty
FFFC30E0 34852303		ldt		$t1,TCBMbxNext[$a0]
FFFC30E4 0062A223		stt		$t1,MBX_TQHEAD[$t0]
FFFC30E8 34032823		stt		$x0,TCBMbxPrev[$t1]
                        	.tqEmpty:
FFFC30EC 34052823		stt   $x0,TCBMbxPrev[$a0]
FFFC30F0 34052423		stt   $x0,TCBMbxNext[$a0]
                        	.xit:
FFFC30F4 EDCFF0EF	  call	UnlockOS
FFFC30F8 00012483		ldt		$s1,[$sp]
FFFC30FC 00412283		ldt		$t0,4[$sp]
FFFC3100 00812303		ldt		$t1,8[$sp]
FFFC3104 00C12383		ldt		$t2,12[$sp]
FFFC3108 01012503		ldt   $a0,16[$sp]
FFFC310C 01412083		ldt		$ra,20[$sp]
FFFC3110 01810113		add		$sp,$sp,#24
FFFC3114 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = app id of owner
                        	;		a2 = pointer where to store handle
                        	; Returns:
                        	;		a0 = E_Ok
                        	;------------------------------------------------------------------------------
                        	/*
  align 16
FMTK_AllocMbx_Old:
  csrrs $x0,#$300,#1        ; enable interrupts
	beq		$a2,$x0,.badArg
	ldi		$t0,#mbxs
  mDI
.nxt:
	lbu		$t1,MBX_OWNER[$t0]
	beq		$t1,$x0,.noOwner
	add		$t0,$t0,#MBX_SIZE
	slt		$t1,$t0,#mbxs_end
	bne		$t1,$x0,.nxt
	ldi		$a0,#E_NoMoreMbx
	ret
.noOwner:
	stb		$a1,MBX_OWNER[$t0]
	stt   $x0,MBX_TQHEAD[$t0]
	stt   $x0,MBX_TQTAIL[$t0]
	stt   $x0,MBX_MQHEAD[$t0]
	stt   $x0,MBX_MQTAIL[$t0]
	sub		$t5,$t0,#mbxs				; convert pointer to handle
	srl		$t5,$t5,#5
	mov   $a0,$a1             ; $a0 = mid
	mov		$a1,$a2
	call	VirtToPhys2
	stw		$t5,[$a0]
  mEI
	ldi		$a0,#E_Ok
	ret
.badArg:
	ldi		$a0,#E_Arg
	ret
*/
                        	;------------------------------------------------------------------------------
                        	; FMTK_AllocMbx
                        	;   Allocate a mailbox. Get the mailbox off the free list. If there are no
                        	; free mailboxes then allocate a block of new mailboxes.
                        	;
                        	; Parameters:
                        	;		$a1 = app id of owner
                        	; Returns:
                        	;		$a0 = E_Ok
                        	;   $a1 = mailbox handle
                        	;------------------------------------------------------------------------------
                        	FMTK_AllocMbx:
FFFC3118 000018B7	  ldt   $a0,FreeMbx
FFFC311C C0888893
FFFC3120 000888B3
FFFC3124 0008A503
FFFC3128 0A051A63	  bnez  $a0,.gotMbx
                        	  ; no free mailboxes?
FFFC312C 40006513	  ldi   $a0,#1024         ; 1 page
FFFC3130 F90FE0EF	  call  PAMAlloc
FFFC3134 0E054C63	  bltz  $a0,.outOfMem
FFFC3138 000018B7	  ldbu  $t0,MbxBlockCounter
FFFC313C 0E088893
FFFC3140 000888B3
FFFC3144 0008C283
FFFC3148 00550E23	  stb   $t0,OBJCollectionIndex[$a0] ; store which index of the collection we are
FFFC314C 00229293	  sll   $t0,$t0,#2
FFFC3150 000018B7	  stt   $a0,MbxBlockPtr[$t0]
FFFC3154 0A088893
FFFC3158 005888B3
FFFC315C 00A8A023
FFFC3160 0022D293	  srl   $t0,$t0,#2
FFFC3164 00128293	  add   $t0,$t0,#1
FFFC3168 000018B7	  stb   $t0,MbxBlockCounter
FFFC316C 0E088893
FFFC3170 000888B3
FFFC3174 00588023
FFFC3178 02F06293	  ldi   $t0,#47           ; 48 mailboxes in block
                        	  ; Initialize object fields
FFFC317C 204D4337	  ldi   $t1,#MBX_MAGIC
FFFC3180 25830313
FFFC3184 00652023	  stt   $t1,OBJMagic[$a0]
FFFC3188 3C006313	  ldi   $t1,#960
FFFC318C 00652423	  stt   $t1,OBJSize[$a0]
FFFC3190 00050C23	  stb   $x0,OBJState[$a0]
FFFC3194 00050CA3	  stb   $x0,OBJScavcnt[$a0]
FFFC3198 00050D23	  stb   $x0,OBJOwningMap[$a0]
FFFC319C 00000337	  ldi   $t1,#MbxFinalizer
FFFC31A0 33A30313
FFFC31A4 02652823	  stt   $t1,OBJFinalizer[$a0]
                        	  
FFFC31A8 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC31AC 04050313	add   $t1,$a0,#64       ; point to first mailbox
FFFC31B0 000018B7	  stt   $t1,FreeMbx
FFFC31B4 C0888893
FFFC31B8 000888B3
FFFC31BC 0068A023
FFFC31C0 00036533	  mov   $a0,$t1
                        	.0001:
FFFC31C4 01430393	  add   $t2,$t1,#MBX_SIZE
FFFC31C8 00732223	  stt   $t2,MBX_LINK[$t1]
FFFC31CC 0003E333	  mov   $t1,$t2
FFFC31D0 FFF28293	  sub   $t0,$t0,#1
FFFC31D4 FE5048E3	  bgtz  $t0,.0001
FFFC31D8 00032223	  stt   $x0,MBX_LINK[$t1]
                        	.gotMbx:
FFFC31DC 00452283	  ldt   $t0,MBX_LINK[$a0]
FFFC31E0 000018B7	  stt   $t0,FreeMbx
FFFC31E4 C0888893
FFFC31E8 000888B3
FFFC31EC 0058A023
FFFC31F0 00052223	  stt   $x0,MBX_LINK[$a0]
FFFC31F4 00B50023		stb		$a1,MBX_OWNER[$a0]
FFFC31F8 00052223		stt   $x0,MBX_TQHEAD[$a0]
FFFC31FC 00052423		stt   $x0,MBX_TQTAIL[$a0]
FFFC3200 00052623		stt   $x0,MBX_MQHEAD[$a0]
FFFC3204 00052823		stt   $x0,MBX_MQTAIL[$a0]
                        		; Create an id that is a hash code representing the location of the mailbox.
                        		; Given the hash code the mailbox pointer can be recreated easily.
FFFC3208 C0057293		and   $t0,$a0,#$FFFFFC00    ; get pointer to block object
FFFC320C 01C2C303		ldbu  $t1,OBJCollectionIndex[$t0]
                        		
FFFC3210 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC3214 3FF57393	and   $t2,$a0,#$3FF         ; get offset of mailbox in block
FFFC3218 00A31313		sll   $t1,$t1,#10           ; make an id hash
FFFC321C 007365B3		or    $a1,$t1,$t2
FFFC3220 0025D593		srl   $a1,$a1,#2            ; 2 LSB's will be zero
FFFC3224 00006513	  ldi   $a0,#E_Ok
FFFC3228 00008067	  ret
                        	.outOfMem:
FFFC322C 04706513	  ldi   $a0,#E_NoMem
FFFC3230 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Dequeue any waiting tasks returning to them a E_NoMsg status and removing
                        	; them from the timeout list as well. Then move any messages that are queued
                        	; back to the free message list.
                        	;------------------------------------------------------------------------------
                        	/*
  align 16
FMTK_FreeMbx_Old:
  csrrs $x0,#$300,#1        ; enable interrupts
	slt		$s1,$a1,#32
	beq		$s1,$x0,.badMbx
	sll		$s1,$a1,#4					; convert handle to pointer
	add		$s1,$s1,#mbxs
	bra   FreeMbx1
*/
FFFC3234 00000000	  align 1
FFFC3238 00000000
FFFC323C 00000000
                        	
                        	FMTK_FreeMbx:
FFFC3240 FF010113		sub		$sp,$sp,#16
FFFC3244 00112023		stt		$ra,[$sp]
FFFC3248 00912223		stt		$s1,4[$sp]
FFFC324C 01512423		stt		$s5,8[$sp]
FFFC3250 01612623		stt		$s6,12[$sp]
FFFC3254 0005E533	  mov   $a0,$a1
                        	  
FFFC3258 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC325C 00229293	  sll   $t0,$t0,#2
FFFC3260 000018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC3264 0A088893
FFFC3268 005888B3
FFFC326C 0008A283
FFFC3270 0FF57513	  and   $a0,$a0,#$FF
FFFC3274 00251513	  sll   $a0,$a0,#2
FFFC3278 00556533	  or    $a0,$a0,$t0
FFFC327C D14FF0EF	call	LockOS
FFFC3280 000018B7	  ldt   $t0,FreeMbx
FFFC3284 C0888893
FFFC3288 000888B3
FFFC328C 0008A283
FFFC3290 00552223	  stt   $t0,MBX_LINK[$a0]
FFFC3294 000018B7	  stt   $a0,FreeMbx
FFFC3298 C0888893
FFFC329C 000888B3
FFFC32A0 00A8A023
                        	
FFFC32A4 000564B3	  mov   $s1,$a0
                        	FreeMbx1:
FFFC32A8 0044AB03		ldt		$s6,MBX_TQHEAD[$s1]
                        	.0002:
FFFC32AC 040B0A63		beqz	$s6,.0001
FFFC32B0 2C8B4383		ldbu	$t2,TCBStatus[$s6]
FFFC32B4 FF73F393		and		$t2,$t2,#~TS_WAITMSG	; no longer waiting
FFFC32B8 2C7B0423		stb		$t2,TCBStatus[$s6]
FFFC32BC 0103F393		and		$t2,$t2,#TS_TIMEOUT   ; Is the task timing out?
FFFC32C0 00038A63		beqz	$t2,.0003
FFFC32C4 000B6533		mov		$a0,$s6
FFFC32C8 D08FF0EF		call	UnlockOS
FFFC32CC 085000EF		call	RemoveFromTimeoutList
FFFC32D0 CC0FF0EF		call	LockOS
                        	.0003:
FFFC32D4 000B6533	  mov		$a0,$s6
FFFC32D8 CF8FF0EF	  call	UnlockOS
FFFC32DC 6B4000EF		call	InsertIntoReadyQueue
FFFC32E0 CB0FF0EF		call	LockOS
FFFC32E4 00B06393		ldi		$t2,#E_NoMsg					; but no message
FFFC32E8 087B2823		stt		$t2,TCBxA0[$s6]	; a0 = E_NoMsg
FFFC32EC 348B2A83		ldt   $s5,TCBMbxNext[$s6]
FFFC32F0 340B2423		stt   $x0,TCBMbxNext[$s6]
FFFC32F4 340B2823		stt   $x0,TCBMbxPrev[$s6]
FFFC32F8 000AEB33		mov   $s6,$s5
FFFC32FC FA0008E3		bra   .0002
                        	.0001:
FFFC3300 0004A223	  stt   $x0,MBX_TQHEAD[$s1]
FFFC3304 0004A423	  stt   $x0,MBX_TQTAIL[$s1]
                        	  ; Now free any messages queued at the mailbox. We are crafty here and
                        	  ; don't follow any links. Instead the entire chain of messages queued
                        	  ; is transferred to the free message list.
FFFC3308 0104AB03	  ldt   $s6,MBX_MQTAIL[$s1] ; get pointer to last message
FFFC330C 000018B7	  ldt   $s5,FreeMsg
FFFC3310 C0088893
FFFC3314 000888B3
FFFC3318 0008AA83
FFFC331C 015B2023	  stt   $s5,MSG_LINK[$s6]   ; link current free list onto it
FFFC3320 00C4AB03	  ldt   $s6,MBX_MQHEAD[$s1]
FFFC3324 000018B7	  stt   $s6,FreeMsg         ; set new head of free list
FFFC3328 C0088893
FFFC332C 000888B3
FFFC3330 0168A023
FFFC3334 C9CFF0EF	  call	UnlockOS
FFFC3338 00012083	  ldt		$ra,[$sp]
FFFC333C 00412483	  ldt		$s1,4[$sp]
FFFC3340 00812A83	  ldt		$s5,8[$sp]
FFFC3344 00C12B03	  ldt		$s6,12[$sp]
FFFC3348 01010113	  add		$sp,$sp,#16
FFFC334C 00006513		ldi		$a0,#E_Ok
FFFC3350 00008067		ret
                        	.badMbx:
FFFC3354 00012083	  ldt		$ra,[$sp]
FFFC3358 00412483	  ldt		$s1,4[$sp]
FFFC335C 00812A83	  ldt		$s5,8[$sp]
FFFC3360 00C12B03	  ldt		$s6,12[$sp]
FFFC3364 01010113	  add		$sp,$sp,#16
FFFC3368 00406513		ldi		$a0,#E_BadMbx				; return null pointer if bad mailbox
FFFC336C 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; AllocMsg
                        	;
                        	; This internally used routine to provide message space to store data in.
                        	; First the free list is checked to see if any messages are available.
                        	; If there are no message available then a block of 48 messages is allocated
                        	; and added to the free list. 48 messages fit nicely into a 1kB memory page.
                        	;
                        	; Parameters:
                        	;   none
                        	; Returns:
                        	;   $a0 = status (E_Ok)
                        	;   $a1 = pointer to message
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	AllocMsg:
                        	  
FFFC3370 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC3374 000018B7	ldt   $a0,FreeMsg
FFFC3378 C0088893
FFFC337C 000888B3
FFFC3380 0008A503
FFFC3384 06051863	  bnez  $a0,.gotMsg
                        	  ; no free messages?
FFFC3388 40006513	  ldi   $a0,#1024         ; 1 page
FFFC338C D34FE0EF	  call  PAMAlloc
FFFC3390 08054663	  bltz  $a0,.outOfMem
FFFC3394 02F06293	  ldi   $t0,#47           ; 48 messages in block
                        	  ; Initialize object fields
FFFC3398 204D5337	  ldi   $t1,#MSG_MAGIC
FFFC339C 34730313
FFFC33A0 00652023	  stt   $t1,OBJMagic[$a0]
FFFC33A4 3C006313	  ldi   $t1,#960
FFFC33A8 00652423	  stt   $t1,OBJSize[$a0]
FFFC33AC 00050C23	  stb   $x0,OBJState[$a0]
FFFC33B0 00050CA3	  stb   $x0,OBJScavcnt[$a0]
FFFC33B4 00050D23	  stb   $x0,OBJOwningMap[$a0]
FFFC33B8 FFFC3337	  ldi   $t1,#MsgFinalizer
FFFC33BC 71030313
FFFC33C0 02652823	  stt   $t1,OBJFinalizer[$a0]
                        	 
FFFC33C4 04050313	  add   $t1,$a0,#64       ; point to first message
FFFC33C8 000018B7	  stt   $t1,FreeMsg
FFFC33CC C0088893
FFFC33D0 000888B3
FFFC33D4 0068A023
FFFC33D8 00036533	  mov   $a0,$t1
                        	.0001:
FFFC33DC 01430393	  add   $t2,$t1,#MSG_SIZE
FFFC33E0 00732023	  stt   $t2,MSG_LINK[$t1]
FFFC33E4 0003E333	  mov   $t1,$t2
FFFC33E8 FFF28293	  sub   $t0,$t0,#1
FFFC33EC FE5048E3	  bgtz  $t0,.0001
FFFC33F0 00032023	  stt   $x0,MSG_LINK[$t1]
                        	.gotMsg:
FFFC33F4 00052283	  ldt   $t0,MSG_LINK[$a0]
FFFC33F8 000018B7	  stt   $t0,FreeMsg
FFFC33FC C0088893
FFFC3400 000888B3
FFFC3404 0058A023
FFFC3408 00052023	  stt   $x0,MSG_LINK[$a0]
                        	  
FFFC340C 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC3410 000565B3	mov   $a1,$a0
FFFC3414 00006513	  ldi   $a0,#E_Ok
FFFC3418 00008067	  ret
                        	.outOfMem:
                        	  
FFFC341C 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC3420 04706513	ldi   $a0,#E_NoMem
FFFC3424 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; FreeMsg
                        	;
                        	; This internally used routine frees a message previously allocated with
                        	; AllocMsg. The message is added to the free list.
                        	;
                        	; Parameters:
                        	;   $a0 = pointer to message.
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;------------------------------------------------------------------------------
FFFC3428 00000000	  align 1
FFFC342C 00000000
                        	
                        	FreeMsgRout:
                        	  
FFFC3430 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC3434 000018B7	ldt   $t0,FreeMsg
FFFC3438 C0088893
FFFC343C 000888B3
FFFC3440 0008A283
FFFC3444 00552023	  stt   $t0,MSG_LINK[$a0]
FFFC3448 000018B7	  stt   $a0,FreeMsg
FFFC344C C0088893
FFFC3450 000888B3
FFFC3454 00A8A023
                        	  
FFFC3458 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC345C 00006513	ldi   $a0,#E_Ok
FFFC3460 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		$t0 = mailbox pointer
                        	;		$t1 = message pointer
                        	;		$s1 = task id of waiting task
                        	; Modifies:
                        	;		$a0
                        	; Parameters:
                        	;		$a1 = mailbox handle
                        	;		$a2 = message d1
                        	;		$a3 = message d2
                        	;		$a4 = message d3
                        	;------------------------------------------------------------------------------
FFFC3464 00000000	  align 1
FFFC3468 00000000
FFFC346C 00000000
                        	
                        	ISendMsg:
FFFC3470 FFC10113	  sub   $sp,$sp,#4
FFFC3474 00112023	  stt   $ra,[$sp]
                        	;  mEI
                        	;	slt		$t0,$a1,#32
                        	;	beq		$t0,$x0,.badMbx
                        	;	sll		$t0,$a1,#4					; convert handle to pointer
                        	;	add		$t0,$t0,#mbxs
FFFC3478 0005E533	  mov   $a0,$a1
                        	  
FFFC347C 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC3480 00229293	  sll   $t0,$t0,#2
FFFC3484 000018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC3488 0A088893
FFFC348C 005888B3
FFFC3490 0008A283
FFFC3494 0FF57513	  and   $a0,$a0,#$FF
FFFC3498 00251513	  sll   $a0,$a0,#2
FFFC349C 00556533	  or    $a0,$a0,$t0
FFFC34A0 000562B3	mov   $t0,$a0
FFFC34A4 0042A983		ldt		$s3,MBX_TQHEAD[$t0]
FFFC34A8 04098663		beq		$s3,$x0,.noWaiters
FFFC34AC 2CC9AC23		stt		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC34B0 2ED9A023		stt		$a3,TCBMsgD2[$s3]
FFFC34B4 2EE9A423		stt		$a4,TCBMsgD3[$s3]
FFFC34B8 2C89C383		ldbu	$t2,TCBStatus[$s3]
FFFC34BC 0043E393		or		$t2,$t2,#TS_MSGRDY
FFFC34C0 2C798423		stb		$t2,TCBStatus[$s3]
FFFC34C4 3389D503		ldwu  $a0,TCBtid[$s3]
FFFC34C8 FFC10113		sub		$sp,$sp,#4
FFFC34CC 00512023		stt		$t0,[$sp]						; push t0
FFFC34D0 4C0000EF		call	InsertIntoReadyQueue
FFFC34D4 00012283		ldt		$t0,[$sp]						; pop t0
FFFC34D8 00410113		add		$sp,$sp,#4
FFFC34DC 3489AA83		ldt   $s5,TCBMbxNext[$s3]
FFFC34E0 3409A423		stt   $x0,TCBMbxNext[$s3]
FFFC34E4 3409A823		stt   $x0,TCBMbxPrev[$s3]
FFFC34E8 0152A223		stt   $s5,MBX_TQHEAD[$t0]
FFFC34EC 00006513		ldi		$a0,#E_Ok
FFFC34F0 04000663		bra   .xit
                        	.noWaiters:
FFFC34F4 E7DFF0EF	  call  AllocMsg
FFFC34F8 02051C63		bnez	$a0,.noMsg			    ; message available?
FFFC34FC 00C5A423		stt		$a2,MSG_D1[$a1]
FFFC3500 00D5A623		stt		$a3,MSG_D2[$a1]
FFFC3504 00E5A823		stt		$a4,MSG_D3[$a1]
FFFC3508 0102AE03		ldt		$t3,MBX_MQTAIL[$t0]
FFFC350C 000E0A63		beqz	$t3,.mbxEmpty
FFFC3510 00BE2023		stt		$a1,MSG_LINK[$t3]
FFFC3514 00B2A823		stt		$a1,MBX_MQTAIL[$t0]
FFFC3518 00006513		ldi		$a0,#E_Ok
FFFC351C 02000063		bra   .xit
                        	.mbxEmpty:
FFFC3520 00B2A623		stt		$a1,MBX_MQHEAD[$t0]
FFFC3524 00B2A823		stt		$a1,MBX_MQTAIL[$t0]
FFFC3528 00006513		ldi		$a0,#E_Ok
FFFC352C 00000863		bra   .xit
                        	.noMsg:
FFFC3530 00B06513		ldi		$a0,#E_NoMsg
FFFC3534 00000463		bra   .xit
                        	.badMbx:
FFFC3538 00406513		ldi		$a0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit
FFFC353C 00012083		ldt   $ra,[$sp]
FFFC3540 00410113		add   $sp,$sp,#4
FFFC3544 00008067		ret
                        	
FFFC3548 00000000	  align 1
FFFC354C 00000000
                        	
                        	FMTK_SendMsg:
FFFC3550 F21FF06F	  jmp  ISendMsg
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a1 = mailbox handle
                        	;		$a2 = pointer where to put message D1
                        	;		$a3 = pointer where to put message D2
                        	;		$a4 = pointer where to put message D3
                        	;		$a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
FFFC3554 00000000	  align 1
FFFC3558 00000000
FFFC355C 00000000
                        	
                        	PeekMsg:
FFFC3560 FFC10113		sub		$sp,$sp,#4
FFFC3564 00112023		stt		$ra,[$sp]
                        	;	slt		$t0,$a1,#32
                        	;	beq		$t0,$x0,.badMbx
                        	;	sll		$t2,$a1,#4					; convert handle to pointer
                        	;	add		$t2,$t2,#mbxs
FFFC3568 0005E533		mov   $a0,$a1
                        		
FFFC356C 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC3570 00229293	  sll   $t0,$t0,#2
FFFC3574 000018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC3578 0A088893
FFFC357C 005888B3
FFFC3580 0008A283
FFFC3584 0FF57513	  and   $a0,$a0,#$FF
FFFC3588 00251513	  sll   $a0,$a0,#2
FFFC358C 00556533	  or    $a0,$a0,$t0
FFFC3590 000563B3	mov   $t2,$a0
FFFC3594 9FCFF0EF		call	LockOS
FFFC3598 00C3A303		ldt		$t1,MBX_MQHEAD[$t2]
FFFC359C 06030463		beqz	$t1,.noMsg
FFFC35A0 00078A63		beqz	$a5,.nodq
FFFC35A4 00032E03		ldt		$t3,MSG_LINK[$t1]
FFFC35A8 01C3A623		stt		$t3,MBX_MQHEAD[$t2]
                        		; This is done here only because interrupts are disabled
FFFC35AC 000E6533		mov   $a0,$t3
FFFC35B0 E81FF0EF		call  FreeMsgRout
                        	.nodq:
                        	  ; Makes use of the MPRV feature. PeekMsg() or WaitMsg() will be running in
                        	  ; the task context expecting to receive a message. That means the base
                        	  ; registers and ASID should be set appropriately.
FFFC35B4 000205B7		ldi   $a1,#$20000       ; bit 17 = mprv
FFFC35B8 00058593
FFFC35BC 34030503	  ldb   $a0,TCBmid[$t1]   ; $a0 = mid
FFFC35C0 00060A63		beqz  $a2,.nod1
FFFC35C4 00832E03		ldt		$t3,MSG_D1[$t1]
FFFC35C8 3005A073		csrrs $x0,#CSR_MSTATUS,$a1
FFFC35CC 01C62023		stt		$t3,[$a2]
FFFC35D0 3005B073		csrrc $x0,#CSR_MSTATUS,$a1
                        	.nod1:
FFFC35D4 00068A63		beqz	$a3,.nod2
FFFC35D8 00C32E03		ldt		$t3,MSG_D2[$t1]
FFFC35DC 3005A073		csrrs $x0,#CSR_MSTATUS,$a1
FFFC35E0 01C6A023		stt		$t3,[$a3]
FFFC35E4 3005B073		csrrc $x0,#CSR_MSTATUS,$a1
                        	.nod2:
FFFC35E8 00070A63		beqz	$a4,.nod3
FFFC35EC 01032E03		ldt		$t3,MSG_D3[$t1]
FFFC35F0 3005A073		csrrs $x0,#CSR_MSTATUS,$a1
FFFC35F4 01C72023		stt		$t3,[$a4]
FFFC35F8 3005B073		csrrc $x0,#CSR_MSTATUS,$a1
                        	.nod3:
FFFC35FC 00006513		ldi		$a0,#E_Ok
FFFC3600 00000863		bra		.ret
                        	.noMsg:
FFFC3604 00B06513		ldi		$a0,#E_NoMsg
FFFC3608 00000463		bra		.ret
                        	.badMbx:
FFFC360C 00406513		ldi		$a0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
FFFC3610 9C0FF0EF	  call	UnlockOS
FFFC3614 00012083		ldt		$ra,[$sp]
FFFC3618 00410113		add		$sp,$sp,#4
FFFC361C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC3620 F41FF06F		jmp		PeekMsg
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
FFFC3624 00000000	  align 1
FFFC3628 00000000
FFFC362C 00000000
                        	
                        	FMTK_WaitMsg:
FFFC3630 FF810113		sub		$sp,$sp,#8
FFFC3634 00112023		stt		$ra,[$sp]
FFFC3638 01512223		stt		$s5,4[$sp]
FFFC363C 0007EAB3		mov		$s5,$a5
FFFC3640 00106793		ldi		$a5,#1              ; dequeue messages
FFFC3644 F1DFF0EF		call	PeekMsg							; check for a message, return if available
FFFC3648 00B06313		ldi		$t1,#E_NoMsg
FFFC364C 00650A63		beq		$a0,$t1,.qt					; no message? Then go queue task
FFFC3650 00012083		ldt		$ra,[$sp]
FFFC3654 00412A83		ldt		$s5,4[$sp]
FFFC3658 00810113		add		$sp,$sp,#8
FFFC365C 00008067		ret
                        	.qt:
FFFC3660 000AE7B3		mov		$a5,$s5
FFFC3664 0005E533	  mov   $a0,$a1
                        	  
FFFC3668 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC366C 00229293	  sll   $t0,$t0,#2
FFFC3670 000018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC3674 0A088893
FFFC3678 005888B3
FFFC367C 0008A283
FFFC3680 0FF57513	  and   $a0,$a0,#$FF
FFFC3684 00251513	  sll   $a0,$a0,#2
FFFC3688 00556533	  or    $a0,$a0,$t0
FFFC368C 00056E33	mov   $t3,$a0
                        		
FFFC3690 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC3694 00A51313	sll		$t1,$a0,#LOG_TCBSZ  ; $t1 = tcb pointer
FFFC3698 8F8FF0EF	  call	LockOS
FFFC369C 008E2E83		ldt		$t4,MBX_TQTAIL[$t3]	; get waiting task list tail
FFFC36A0 000E8A63		beqz  $t4,.qempty
FFFC36A4 35D32823	  stt   $t4,TCBMbxPrev[$t1] ; add task onto tail of waiting list
FFFC36A8 346EA423	  stt   $t1,TCBMbxNext[$t4] ; tail->next = tid tcb pointer
FFFC36AC 006E2423	  stt   $t1,MBX_TQTAIL[$t3]
FFFC36B0 00000663	  bra   .setA
                        	.qempty:
FFFC36B4 006E2223	  stt   $t1,MBX_TQHEAD[$t3]
FFFC36B8 006E2423	  stt   $t1,MBX_TQTAIL[$t3]
                        	.setA:
FFFC36BC 08B32C23		stt		$a1,TCBxA1[$t1]
FFFC36C0 0AC32023	  stt   $a2,TCBxA2[$t1]   ; save pointers for data in task regs
FFFC36C4 0AD32423	  stt   $a3,TCBxA3[$t1]
FFFC36C8 0AE32823	  stt   $a4,TCBxA4[$t1]
FFFC36CC 0AF32C23	  stt   $a5,TCBxA5[$t1]
FFFC36D0 2C834E03		ldbu	$t3,TCBStatus[$t1]
FFFC36D4 008E6E13		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC36D8 FFEE7E13		and		$t3,$t3,#~TS_READY	; not ready
FFFC36DC 2DC30423		stb		$t3,TCBStatus[$t1]
FFFC36E0 2CB31523		stw		$a1,TCBWaitMbx[$t1]	; set mailbox task is waiting for
FFFC36E4 8ECFF0EF		call	UnlockOS
FFFC36E8 00036533		mov		$a0,$t1
FFFC36EC 0007E5B3		mov		$a1,$a5
FFFC36F0 3C0000EF		call	InsertIntoTimeoutList
FFFC36F4 00012083		ldt		$ra,[$sp]
FFFC36F8 00412A83		ldt		$s5,4[$sp]
FFFC36FC 00810113		add		$sp,$sp,#8
FFFC3700 E70FF06F		jmp		FMTK_Sleep          ; Continue by switching tasks
                        	
FFFC3704 00000000		align	1
FFFC3708 00000000
FFFC370C 00000000
                        	
                        	MsgFinalizer:
FFFC3710 00008067	  ret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/app.r5a",1
                        	.file "../fmtk/app.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/app.r5a",25
                        		code
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   none
                        	; Returns:
                        	;   $a0 = app id (0 to 31), -1 if none available
                        	;------------------------------------------------------------------------------
FFFC3714 00000000	  align 1
FFFC3718 00000000
FFFC371C 00000000
                        	
                        	AllocAppId:
FFFC3720 2F002583	  ldt   $a1,APPID_POOL
FFFC3724 01F06513	  ldi   $a0,#31
                        	.0002:
FFFC3728 0005CC63	  bltz  $a1,.0001
FFFC372C 00106293	  ldi   $t0,#1
FFFC3730 00A292B3	  sll   $t0,$t0,$a0
FFFC3734 0055E5B3	  or    $a1,$a1,$t0
FFFC3738 2EB02823	  stt   $a1,APPID_POOL
FFFC373C 00008067	  ret
                        	.0001:
FFFC3740 00159593	  sll   $a1,$a1,#1
FFFC3744 FFF50513	  sub   $a0,$a0,#1
FFFC3748 FE0550E3	  bge   $a0,$x0,.0002
FFFC374C FFF06513	  ldi   $a0,#-1
FFFC3750 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a1 = pointer to application start record
                        	;------------------------------------------------------------------------------
FFFC3754 00000000	  align 1
FFFC3758 00000000
FFFC375C 00000000
                        	
                        	FMTK_StartApp:
FFFC3760 0005E4B3	  mov   $s1,$a1
FFFC3764 000108B7	  stt		$s1,$10008
FFFC3768 00888893
FFFC376C 000888B3
FFFC3770 0098A023
FFFC3774 00006533	  mov   $a0,$x0           ; OS owns the ACB
FFFC3778 000015B7	  ldi   $a1,#4096         ; size of application control block
FFFC377C 00058593
FFFC3780 940FE0EF	  call  PAMAlloc          ; allocate ACB
FFFC3784 0005E9B3	  mov   $s3,$a1           ; $s3 = pointer to ACB
FFFC3788 204142B7	  ldi   $t0,#ACB_MAGIC
FFFC378C 34228293
FFFC3790 0059A023	  stt   $t0,OBJMagic[$s3]
FFFC3794 0809AC23	  stt   $x0,ACBGarbageList[$s3]
FFFC3798 3209AC23	  stt   $x0,ACBiofNext[$s3]
FFFC379C 3409A023	  stt   $x0,ACBiofPrev[$s3]
                        	;  ldb   $t0,ASRmid[$s1]
FFFC37A0 0024C283	  ldbu	$t0,ASRRegset[$s1]
FFFC37A4 3C598223	  stb   $t0,ACBmid[$s3]
                        	  ; Allocate a virtual screen and set pointers to it.
FFFC37A8 00A9D513	  srl   $a0,$s3,#LOG_PGSZ ; App owns the screen
FFFC37AC 000025B7	  ldi   $a1,#8192         ; size of virtual screen
FFFC37B0 00058593
FFFC37B4 90CFE0EF	  call  PAMAlloc
FFFC37B8 18054C63	  bltz  $a0,.noMem
FFFC37BC 34B9A823	  stt   $a1,ACBpVidMem[$s3]
FFFC37C0 34B9AC23	  stt   $a1,ACBpVirtVidMem[$s3]
                        	  ; Setup screen attributes
FFFC37C4 03806293	  ldi   $t0,#56
FFFC37C8 365980A3	  stb   $t0,ACBVideoCols[$s3]
FFFC37CC 01F06293	  ldi   $t0,#31
FFFC37D0 36598023	  stb   $t0,ACBVideoRows[$s3]
FFFC37D4 36098123	  stb   $x0,ACBCursorRow[$s3]
FFFC37D8 360981A3	  stb   $x0,ACBCursorCol[$s3]
FFFC37DC 008802B7	  ldi   $t0,#$0087FC00
FFFC37E0 C0028293
FFFC37E4 3659A223	  stt   $t0,ACBNormAttr[$s3]
                        	
                        	  ; Allocate memory for application code and copy code into position
FFFC37E8 0024C503	  ldbu	$a0,ASRRegset[$s1]
FFFC37EC 0084A583	  ldt   $a1,ASRCodeSize[$s1]
FFFC37F0 000108B7	  stt		$a1,$10000
FFFC37F4 00088893
FFFC37F8 000888B3
FFFC37FC 00B8A023
FFFC3800 000108B7	  stt		$s1,$10004
FFFC3804 00488893
FFFC3808 000888B3
FFFC380C 0098A023
FFFC3810 02058C63	  beqz  $a1,.0004         ; 0 size code = in ROM
FFFC3814 D9DFD0EF	  call  Alloc
FFFC3818 12054C63	  bltz  $a0,.noMem
FFFC381C 08B9A323	  stt   $a1,ACBpCode[$s3] ; save pointer to code area in ACB
FFFC3820 0005EA33	  mov   $s4,$a1           ; $s4 = pointer to application code
FFFC3824 0084A283	  ldt   $t0,ASRCodeSize[$s1]  ; $t0 = code size
FFFC3828 0304AA83	  ldt   $s5,ASRpCode[$s1] ; $s5 = pointer to application code
                        	.0001:
FFFC382C 000AA303	  ldt   $t1,[$s5]
FFFC3830 006A2023	  stt   $t1,[$s4]
FFFC3834 004A8A93	  add   $s5,$s5,#4
FFFC3838 004A0A13	  add   $s4,$s4,#4
FFFC383C FFC28293	  sub   $t0,$t0,#4
FFFC3840 FE5046E3	  bgtz  $t0,.0001
FFFC3844 00000663	  bra   .0003
                        	.0004:
FFFC3848 0304AA83	  ldt   $s5,ASRpCode[$s1] ; $s5 = pointer to application code
FFFC384C 0959A323	  stt   $s5,ACBpCode[$s3] ; save pointer to code area in ACB
                        	
                        	.0003:
                        	  ; Allocate memory for application data and copy data into position
                        	  ; The memory requirements for both initialized and uninitialized data are
                        	  ; summed and a single block of memory allocated for both.
                        	  ; Vars will then be accessed via a global pointer offset from the start
                        	  ; of the data area.
FFFC3850 0409A023	  stt   $x0,ACBpData[$s3]
FFFC3854 0409A823	  stt   $x0,ACBpUIData[$s3]
FFFC3858 0024C503	  ldbu	$a0,ASRRegset[$s1]
FFFC385C 0104A583	  ldt   $a1,ASRDataSize[$s1]
FFFC3860 000008B7	  ldt   $a2,ASRIUDataSize[$s1]
FFFC3864 35E88893
FFFC3868 009888B3
FFFC386C 0008A603
FFFC3870 00C585B3	  add   $a1,$a1,$a2
FFFC3874 02058E63	  beqz  $a1,.0005         ; no data?
FFFC3878 D39FD0EF	  call  Alloc
FFFC387C 0C054A63	  bltz  $a0,.noMem
FFFC3880 04B9A023	  stt   $a1,ACBpData[$s3]
                        	
                        	  ; Copy pre-initialized data to data area.
FFFC3884 0005EA33	  mov   $s4,$a1           ; $s4 = pointer to application data
FFFC3888 0104A283	  ldt   $t0,ASRDataSize[$s1]  ; $t0 = data size
FFFC388C 00328293	  add   $t0,$t0,#3        ; round to whole words
FFFC3890 FFC2F293	  and   $t0,$t0,#$FFFFFFFC
FFFC3894 0384AA83	  ldt   $s5,ASRpData[$s1] ; $s5 = pointer to application data
                        	.0002:
FFFC3898 000AA303	  ldt   $t1,[$s5]
FFFC389C 006A2023	  stt   $t1,[$s4]
FFFC38A0 004A8A93	  add   $s5,$s5,#4
FFFC38A4 004A0A13	  add   $s4,$s4,#4
FFFC38A8 FFC28293	  sub   $t0,$t0,#4
FFFC38AC FE5046E3	  bgtz  $t0,.0002
                        	
                        	.0005:
                        	  ; Record pointer to uninitialized data
FFFC38B0 0104A503	  ldt   $a0,ASRDataSize[$s1]
FFFC38B4 0404A583	  ldt   $a1,ACBpData[$s1]
FFFC38B8 00B505B3	  add   $a1,$a0,$a1
FFFC38BC 00358593	  add   $a1,$a1,#3
FFFC38C0 FFC5F593	  and   $a1,$a1,#$FFFFFFFC
FFFC38C4 04B9A823	  stt   $a1,ACBpUIData[$s3]
                        	
                        	.0006:
                        	  ; Allocate memory for heap
FFFC38C8 0024C503	  ldbu	$a0,ASRRegset[$s1]
FFFC38CC 0204A583	  ldt   $a1,ASRHeapSize[$s1]
FFFC38D0 00058863	  beqz  $a1,.0007         ; no heap?
FFFC38D4 CDDFD0EF	  call  Alloc
FFFC38D8 06054C63	  bltz  $a0,.noMem
FFFC38DC 0AB9A023	  stt   $a1,ACBHeap[$s3]
                        	
                        	.0007:
FFFC38E0 00106513	  ldi   $a0,#1            ; IStartTask
FFFC38E4 00A9D593	  srl   $a1,$s3,#LOG_PGSZ ; $a1 = app id
FFFC38E8 40006613	  ldi   $a2,#1024         ; task local memory
FFFC38EC 0304A683	  ldt   $a3,ASRpCode[$s1] ; get pointer to code area
FFFC38F0 0024C703	  ldbu	$a4,ASRRegset[$s1]
FFFC38F4 01C06293	  ldi		$t0,#28						; register set 28 and above are Machine
FFFC38F8 00574463	  blt		$a4,$t0,.norm
FFFC38FC 30076713	  or		$a4,$a4,#$300			; set Machine Mode
                        	.norm:
FFFC3900 990FF0EF	  call  OSOCall           ; start the initial app task
FFFC3904 02051E63	  bnez  $a0,.tskErr       ; error?
FFFC3908 00A5D593	  srl		$a1,$a1,#LOG_PGSZ
FFFC390C 3CB99023	  stw   $a1,ACBTask[$s3]
FFFC3910 000048B7	  stw   $a1,$3F48
FFFC3914 F4888893
FFFC3918 000888B3
FFFC391C 00B89023
FFFC3920 00A59293	  sll   $t0,$a1,#LOG_PGSZ
FFFC3924 0409A303	  ldt   $t1,ACBpData[$s3]
FFFC3928 0462AC23	  stt   $t1,TCBxGP[$t0]   ; set global pointer to data area
FFFC392C 00106313	  ldi   $t1,#AS_LIVE
FFFC3930 3C698323	  stb   $t1,ACBStatus[$s3]
FFFC3934 00A9D593	  srl   $a1,$s3,#LOG_PGSZ ; return app id
FFFC3938 00006513	  ldi   $a0,#E_Ok
FFFC393C 00008067	  ret
                        	.tskErr:
FFFC3940 00406313	  ldi   $t1,#AS_UNDEAD
FFFC3944 3C698323	  stb   $t1,ACBStatus[$s3]
FFFC3948 00008067	  ret
                        	
                        	.noMoreApps:
FFFC394C 04606513	  ldi   $a0,#E_NoMoreAppIds
                        	.noMem
FFFC3950 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
FFFC3954 00000000		align	1
FFFC3958 00000000
FFFC395C 00000000
                        	
                        	FMTK_ExitApp:
                        		
FFFC3960 7C201573	  csrrw $a0,#CSR_TASKID,$x0
                        	;	sll		$a1,$a0,#LOG_TCBSZ  ; convert TID to TCB address
FFFC3964 34058583		ldb   $a1,TCBmid[$a1]     ; get the mid
FFFC3968 00000463		bra		FMTK_KillApp
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = mid of task to kill
                        	;------------------------------------------------------------------------------
FFFC396C 00000000	  align 1
                        	
                        	FMTK_KillApp:
FFFC3970 00058C63		beqz	$a1,.immortal		    ; app #0 is immortal (the system)
FFFC3974 00206293		ldi		$t0,#TS_DEAD				; flag app as dead (prevents it from being re-queued)
FFFC3978 00259593		sll		$a1,$a1,#2	        
                        	;	ldt   $a1,TidTcbMap[$a1]  ; convert TID to TCB address
FFFC397C 3C05A583		ldt		$a1,ACBTask[$a1]
FFFC3980 2C558423		stb		$t0,TCBStatus[$a1]
                        	;	ldbu  $a0,TCBmid[$a1]
                        	;	call	FreeAll							; free all the memory associated with the task
                        		; Now make task ID available for reuse
FFFC3984 3385C503		ldbu  $a0,TCBtid[$a1]
                        	.immortal:
FFFC3988 00006513		ldi		$a0,#E_Ok
FFFC398C 00008067		ret
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/tcb.r5a",25
                        		code
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready queue.
                        	; Inserting into the ready queue is done by both OS ecall functions and
                        	; interrupt driven scheduling. It's important to have interrupts disabled
                        	; so that there is no contention for the ready queue.
                        	;
                        	; Parameters:
                        	;		$a0 = tid to insert (TCB pointer)
                        	; Modifies:
                        	;	  $t0,$t1
                        	; Stack Space:
                        	;		1 word
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	InsertIntoReadyQueue:
FFFC3990 04050A63		beqz	$a0,.retx
FFFC3994 FFC10113		sub		$sp,$sp,#4
FFFC3998 00112023		stt		$ra,[$sp]
FFFC399C DF5FE0EF		call	LockOS
FFFC39A0 2C854283		ldbu	$t0,TCBStatus[$a0]		; set status to ready
FFFC39A4 0012E293		or		$t0,$t0,#TS_READY
FFFC39A8 2C550423		stb		$t0,TCBStatus[$a0]
FFFC39AC 2C950283		ldb		$t0,TCBPriority[$a0]	; $t0 = priority
FFFC39B0 0072F293		and		$t0,$t0,#7
FFFC39B4 00229293		sll		$t0,$t0,#2						; $t0 = index to priority list
FFFC39B8 4202A303		ldt		$t1,TAILRDY[$t0]			; $t1 = tail
FFFC39BC 02030663		beqz	$t1,.qempty
FFFC39C0 30A32823		stt		$a0,TCBNext[$t1]			; tail->next = new
FFFC39C4 42A2A023		stt		$a0,TAILRDY[$t0]			; tail = new
FFFC39C8 30652C23		stt		$t1,TCBPrev[$a0]			; new->prev = $t1
FFFC39CC 4002A303		ldt		$t1,HEADRDY[$t0]
FFFC39D0 30652823		stt		$t1,TCBNext[$a0]			; new->next = head
FFFC39D4 30A32C23		stt		$a0,TCBPrev[$t1]			; head->prev = new
FFFC39D8 DF9FE0EF		call	UnlockOS
FFFC39DC 00012083		ldt		$ra,[$sp]
FFFC39E0 00410113		add		$sp,$sp,#4
                        	.retx:
FFFC39E4 00008067		ret
                        	.qempty:
FFFC39E8 40A2A023		stt		$a0,HEADRDY[$t0]
FFFC39EC 42A2A023		stt		$a0,TAILRDY[$t0]
FFFC39F0 30A52823		stt		$a0,TCBNext[$a0]
FFFC39F4 30A52C23		stt		$a0,TCBPrev[$a0]
FFFC39F8 DD9FE0EF		call	UnlockOS
FFFC39FC 00012083		ldt		$ra,[$sp]
FFFC3A00 00410113		add		$sp,$sp,#4
FFFC3A04 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove from ready queue.
                        	;
                        	; Parameters:
                        	;		$a0 = tid to remove (TCB pointer)
                        	; Modifies:
                        	;		$t0,$t1
                        	; Stack Space:
                        	;		1 word
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
FFFC3A08 00000000		align	1
FFFC3A0C 00000000
                        	
                        	RemoveFromReadyQueue:
FFFC3A10 02050E63		beqz	$a0,.retx
FFFC3A14 FFC10113		sub		$sp,$sp,#4
FFFC3A18 00112023		stt		$ra,[$sp]
FFFC3A1C D75FE0EF		call	LockOS
FFFC3A20 2C850283		ldb		$t0,TCBStatus[$a0]		; set status no longer ready or running
FFFC3A24 F7E2F293		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$a0]
FFFC3A28 2C550423
FFFC3A2C 31052283		ldt		$t0,TCBNext[$a0]
FFFC3A30 02A28063		beq		$t0,$a0,.emptyList
FFFC3A34 31852303		ldt		$t1,TCBPrev[$a0]
FFFC3A38 3062AC23		stt		$t1,TCBPrev[$t0]
FFFC3A3C 30532823		stt		$t0,TCBNext[$t1]
                        	.xit:
FFFC3A40 D91FE0EF		call	UnlockOS
FFFC3A44 00012083		ldt		$ra,[$sp]
FFFC3A48 00410113		add		$sp,$sp,#4
                        	.retx:
FFFC3A4C 00008067		ret
                        	
                        	; Removing the last task from a ready list.
                        	; Find the task in the ready lists
                        	.emptyList:
FFFC3A50 40002283		ldt		$t0,HEADRDY0
FFFC3A54 00A29663		bne		$t0,$a0,.hr1
FFFC3A58 40002023		stt		$x0,HEADRDY0
FFFC3A5C 42002023		stt		$x0,TAILRDY0
                        	.hr1:
FFFC3A60 40402283		ldt		$t0,HEADRDY1
FFFC3A64 00A29663		bne		$t0,$a0,.hr2
FFFC3A68 40002223		stt		$x0,HEADRDY1
FFFC3A6C 42002223		stt		$x0,TAILRDY1
                        	.hr2:
FFFC3A70 40802283		ldt		$t0,HEADRDY2
FFFC3A74 00A29663		bne		$t0,$a0,.hr3
FFFC3A78 40002423		stt		$x0,HEADRDY2
FFFC3A7C 42002423		stt		$x0,TAILRDY2
                        	.hr3:
FFFC3A80 40C02283		ldt		$t0,HEADRDY3
FFFC3A84 00A29663		bne		$t0,$a0,.hr4
FFFC3A88 40002623		stt		$x0,HEADRDY3
FFFC3A8C 42002623		stt		$x0,TAILRDY3
                        	.hr4:
FFFC3A90 41002283		ldt		$t0,HEADRDY4
FFFC3A94 FAA296E3		bne		$t0,$a0,.xit
FFFC3A98 40002823		stt		$x0,HEADRDY4
FFFC3A9C 42002823		stt		$x0,TAILRDY4
FFFC3AA0 FA0000E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = task id to insert
                        	;		$a1 = timeout value
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4
                        	;------------------------------------------------------------------------------
                        	
FFFC3AA4 00000000		align	1
FFFC3AA8 00000000
FFFC3AAC 00000000
                        	
                        	InsertIntoTimeoutList:
FFFC3AB0 08050C63		beqz	$a0,.retx
FFFC3AB4 FFC10113		sub		$sp,$sp,#4
FFFC3AB8 00112023		stt		$ra,[$sp]
FFFC3ABC CD5FE0EF		call	LockOS
FFFC3AC0 2C854383		ldbu	$t2,TCBStatus[$a0]		; set status to timing out
FFFC3AC4 0103E393		or		$t2,$t2,#TS_TIMEOUT
FFFC3AC8 2C750423		stb		$t2,TCBStatus[$a0]
FFFC3ACC 32802283		ldt		$t0,TimeoutList
FFFC3AD0 00006E13		ldi		$t3,#0
FFFC3AD4 02028A63		beqz	$t0,.listEmpty
                        	.loop:
FFFC3AD8 06A28063		beq		$t0,$a0,.xit				; task already on TimeoutList
FFFC3ADC 3202A303		ldt		$t1,TCBTimeout[$t0]
FFFC3AE0 0065B3B3		sltu	$t2,$a1,$t1
FFFC3AE4 02039A63		bnez	$t2,.lessThan
                        		; Here timeout was >
FFFC3AE8 406585B3		sub		$a1,$a1,$t1
FFFC3AEC 0002EE33		mov		$t3,$t0
FFFC3AF0 3102A283		ldt		$t0,TCBNext[$t0]
FFFC3AF4 FE0292E3		bnez	$t0,.loop
                        		; Add at end
FFFC3AF8 30A2A823		stt		$a0,TCBNext[$t0]
FFFC3AFC 30052823		stt		$x0,TCBNext[$a0]
FFFC3B00 32B52023		stt		$a1,TCBTimeout[$a0]
FFFC3B04 02000A63		bra		.xit
                        	.listEmpty:
FFFC3B08 32B52023		stt		$a1,TCBTimeout[$a0]
FFFC3B0C 32A02423		stt		$a0,TimeoutList
FFFC3B10 30052823		stt		$x0,TCBNext[$a0]
FFFC3B14 02000263		bra		.xit
                        	.lessThan:
FFFC3B18 02A28063		beq		$t0,$a0,.xit
FFFC3B1C 40B30333		sub		$t1,$t1,$a1
FFFC3B20 3262A023		stt		$t1,TCBTimeout[$t0]
FFFC3B24 30552823		stt		$t0,TCBNext[$a0]
FFFC3B28 000E0663		beqz	$t3,.atHead
FFFC3B2C 30AE2823		stt		$a0,TCBNext[$t3]
FFFC3B30 00000463		bra		.xit
                        	.atHead:
FFFC3B34 32A02423		stt		$a0,TimeoutList
                        	.xit:
FFFC3B38 C99FE0EF		call	UnlockOS
FFFC3B3C 00006513		ldi		$a0,#E_Ok
FFFC3B40 00012083		ldt		$ra,[$sp]
FFFC3B44 00410113		add		$sp,$sp,#4
                        	.retx:
FFFC3B48 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove a task from the timeout list.
                        	; Called when a mailbox is freed and a task is waiting at the
                        	; mailbox.
                        	;
                        	; Parameters:
                        	;		$a0 = task id to remove
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3,$t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
FFFC3B4C 00000000		align	1
                        	
                        	RemoveFromTimeoutList:
FFFC3B50 08050A63		beqz	$a0,.retx
FFFC3B54 FFC10113		sub		$sp,$sp,#4
FFFC3B58 00112023		stt		$ra,[$sp]
FFFC3B5C C35FE0EF		call	LockOS
FFFC3B60 32802283		ldt		$t0,TimeoutList
FFFC3B64 04A28263		beq		$t0,$a0,.atHead				; quick test for head of list
FFFC3B68 00006E13		ldi		$t3,#0
                        	.0001:
FFFC3B6C 00A28A63		beq		$t0,$a0,.found
FFFC3B70 0002EE33		mov		$t3,$t0
FFFC3B74 3102A283		ldt		$t0,TCBNext[$t0]
FFFC3B78 FE029AE3		bnez	$t0,.0001
FFFC3B7C 04000E63		bra		.xit
                        	.found:
FFFC3B80 31052283		ldt		$t0,TCBNext[$a0]
FFFC3B84 04028463		beqz	$t0,.atTail2
FFFC3B88 3202A303		ldt		$t1,TCBTimeout[$t0]
FFFC3B8C 32052383		ldt		$t2,TCBTimeout[$a0]
FFFC3B90 40730333		sub		$t1,$t1,$t2
FFFC3B94 3262A023		stt		$t1,TCBTimeout[$t0]
FFFC3B98 305E2823		stt		$t0,TCBNext[$t3]			; this->prev->next = this->next
FFFC3B9C 30052823		stt		$x0,TCBNext[$a0]
FFFC3BA0 32052023		stt		$x0,TCBTimeout[$a0]
FFFC3BA4 02000A63		bra		.xit
                        	.atHead:
FFFC3BA8 31052283		ldt		$t0,TCBNext[$a0]
FFFC3BAC 3202A303		ldt		$t1,TCBTimeout[$t0]
FFFC3BB0 32052383		ldt		$t2,TCBTimeout[$a0]
FFFC3BB4 40730333		sub		$t1,$t1,$t2
FFFC3BB8 3262A023		stt		$t1,TCBTimeout[$t0]
FFFC3BBC 32502423		stt		$t0,TimeoutList
FFFC3BC0 30052823		stt		$x0,TCBNext[$a0]
FFFC3BC4 32052023		stt		$x0,TCBTimeout[$a0]
FFFC3BC8 00000863		bra		.xit
                        	.atTail2:
FFFC3BCC 300E2823		stt		$x0,TCBNext[$t3]
FFFC3BD0 30052823		stt		$x0,TCBNext[$a0]
FFFC3BD4 32052023		stt		$x0,TCBTimeout[$a0]
                        	.xit:
FFFC3BD8 BF9FE0EF		call	UnlockOS
FFFC3BDC 00012083		ldt		$ra,[$sp]
FFFC3BE0 00410113		add		$sp,$sp,#4
                        	.retx:
FFFC3BE4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
FFFC3BE8 00000000		align	1
FFFC3BEC 00000000
                        	
                        	DumpReadyQueue:
FFFC3BF0 FE010113		sub		$sp,$sp,#32
FFFC3BF4 00112023		stt		$ra,[$sp]
FFFC3BF8 00A12223		stt		$a0,4[$sp]
FFFC3BFC 00C12423		stt		$a2,8[$sp]
FFFC3C00 00D12623		stt		$a3,12[$sp]
FFFC3C04 00612823		stt		$t1,16[$sp]
FFFC3C08 00712A23		stt		$t2,20[$sp]
FFFC3C0C 01C12C23		stt		$t3,24[$sp]
FFFC3C10 00912E23		stt		$s1,28[$sp]
FFFC3C14 00D06513	  ldi   $a0,#CR
FFFC3C18 FC8FC0EF	  call  Putch
FFFC3C1C 00006513	  ldi   $a0,#LF
  call  Putch
FFFC3C20 FC0FC0EF
                        	  ; Display PAM
FFFC3C24 00006313	  ldi   $t1,#0        ; $a1 = bit number
                        	.0006:
FFFC3C28 02006513	  ldi   $a0,#32       ; Get PAM bit pair
FFFC3C2C 000365B3	  mov   $a1,$t1
                        	;  csrrw	$t0,#CSR_RSSTACK,$x0
                        	;  stt		$t0,$10000
FFFC3C30 00000073	  ecall
                        	;  csrrw	$t0,#CSR_RSSTACK,$x0
                        	;  stt		$t0,$10004
FFFC3C34 03058513	  add   $a0,$a1,#'0'
FFFC3C38 FA8FC0EF	  call  Putch
FFFC3C3C 00130313	  add   $t1,$t1,#1
FFFC3C40 20032513	  slt   $a0,$t1,#MEMSZ
FFFC3C44 FE0512E3	  bnez  $a0,.0006
                        	
FFFC3C48 FFFC4537		ldi		$a0,#msgReadyQueue
FFFC3C4C E1C50513
FFFC3C50 F91FC0EF		call	PutString
FFFC3C54 00006913		ldi		$s2,#0
                        	;	csrrc	$s1,#CSR_PMSTACK,#1
                        	.0002:
                        	;	call	SerialPeekCharDirect
                        	;	xor		$v0,$v0,#CTRLC
                        	;	beqz	$v0,.brk
FFFC3C58 00D06513		ldi		$a0,#CR
FFFC3C5C F84FC0EF		call	Putch
FFFC3C60 05106513		ldi		$a0,#'Q'
FFFC3C64 F7CFC0EF		call	Putch
                        		;srl		$a0,$t1,#1
FFFC3C68 00096533		mov   $a0,$s2
FFFC3C6C F25FC0EF		call	PutHexNybble
FFFC3C70 03A06513		ldi		$a0,#':'
FFFC3C74 F6CFC0EF		call	Putch
FFFC3C78 00291313		sll		$t1,$s2,#2
FFFC3C7C 40032983		ldt		$s3,HEADRDY[$t1]
FFFC3C80 0009EA33		mov		$s4,$s3							; record head of list
                        	.0007:
FFFC3C84 02098063		beqz	$s3,.0008
FFFC3C88 00A9D513		srl		$a0,$s3,#LOG_PGSZ
FFFC3C8C EA5FC0EF		call	PutHexHalf
FFFC3C90 00D06513		ldi		$a0,#CR
FFFC3C94 F4CFC0EF		call	Putch
FFFC3C98 3109A983		ldt		$s3,TCBNext[$s3]
FFFC3C9C 00098463		beqz	$s3,.0008
FFFC3CA0 FF4992E3		bne		$s3,$s4,.0007
                        	.0008:
FFFC3CA4 00190913		add		$s2,$s2,#1
FFFC3CA8 00506313		ldi		$t1,#5
FFFC3CAC FA6946E3		blt		$s2,$t1,.0002
                        	.0005:
                        	;	bra   .0001
                        	;	sll		$a3,$a3,#LOG_TCBSZ
                        	;	ldw		$a0,TCBNext[$a3]
                        	;	call	PutHexHalf
                        	;	ldi		$a0,#' '
                        	;	call	Putch
                        	;	ldw		$a0,TCBPrev[$a3]
                        	;	call	PutHexHalf
                        	.brk:
FFFC3CB0 FFFC4537		ldi		$a0,#msgTaskInfo
FFFC3CB4 E4650513
FFFC3CB8 F29FC0EF		call	PutString
FFFC3CBC 00001437	  ldi   $s0,#$1000
FFFC3CC0 00040413
                        	.0004:
FFFC3CC4 00042503	  ldt   $a0,[$s0]
FFFC3CC8 205448B7	  xor   $a0,$a0,#TCB_MAGIC
FFFC3CCC 34288893
FFFC3CD0 00A8C533
FFFC3CD4 06051463	  bnez  $a0,.nxtT
                        	;  ldi   $t2,#1
                        	;  sll   $t2,$t2,$t0
                        	;  ldt   $a0,TID_POOL
                        	;  and   $t2,$t2,$a0
                        	;  beqz  $t2,.nxtT
FFFC3CD8 000463B3	  mov   $t2,$s0
FFFC3CDC 00046533	  mov		$a0,$s0
FFFC3CE0 E21FC0EF	  call  PutHexWord
FFFC3CE4 02006513	  ldi   $a0,' '
FFFC3CE8 EF8FC0EF	  call  Putch
FFFC3CEC 3383D503	  ldwu  $a0,TCBtid[$t2]
FFFC3CF0 E41FC0EF	  call  PutHexHalf
FFFC3CF4 02006513	  ldi   $a0,' '
FFFC3CF8 EE8FC0EF	  call  Putch
FFFC3CFC 2C93C503	  ldbu  $a0,TCBPriority[$t2]
FFFC3D00 E61FC0EF	  call  PutHexByte
FFFC3D04 02006513	  ldi   $a0,' '
FFFC3D08 ED8FC0EF	  call  Putch
FFFC3D0C 2C83C503	  ldbu  $a0,TCBStatus[$t2]
FFFC3D10 E51FC0EF	  call  PutHexByte
FFFC3D14 02006513	  ldi   $a0,' '
FFFC3D18 EC8FC0EF	  call  Putch
FFFC3D1C 3203A503	  ldt   $a0,TCBTimeout[$t2]
FFFC3D20 DE1FC0EF	  call  PutHexWord
FFFC3D24 02006513	  ldi   $a0,' '
FFFC3D28 EB8FC0EF	  call  Putch
FFFC3D2C 0503A503	  ldt   $a0,TCBxSP[$t2]
FFFC3D30 DD1FC0EF	  call  PutHexWord
FFFC3D34 00D06513		ldi		$a0,#CR
FFFC3D38 EA8FC0EF		call	Putch
                        	.nxtT:
FFFC3D3C 40040413	  add   $s0,$s0,#$400
FFFC3D40 0007D8B7	  slt   $t1,$s0,#$7D000
FFFC3D44 00088893
FFFC3D48 0088A333
FFFC3D4C F6031CE3	  bnez  $t1,.0004
                        	;	csrrw	$x0,#CSR_PMSTACK,$s1
FFFC3D50 00012083		ldt		$ra,[$sp]
FFFC3D54 00412503		ldt		$a0,4[$sp]
FFFC3D58 00812603		ldt		$a2,8[$sp]
FFFC3D5C 00C12683		ldt		$a3,12[$sp]
FFFC3D60 01012303		ldt		$t1,16[$sp]
FFFC3D64 01412383		ldt		$t2,20[$sp]
FFFC3D68 01812E03		ldt		$t3,24[$sp]
FFFC3D6C 01C12483		ldt		$s1,28[$sp]
FFFC3D70 02010113		add		$sp,$sp,#32
FFFC3D74 00008067		ret
                        	
FFFC3D78 00000000		align	1
FFFC3D7C 00000000
                        	
                        	DumpTimeoutList:
FFFC3D80 FE010113		sub		$sp,$sp,#32
FFFC3D84 00112023		stt		$ra,[$sp]
FFFC3D88 00A12223		stt		$a0,4[$sp]
FFFC3D8C 00C12423		stt		$a2,8[$sp]
FFFC3D90 00D12623		stt		$a3,12[$sp]
FFFC3D94 00612823		stt		$t1,16[$sp]
FFFC3D98 00712A23		stt		$t2,20[$sp]
FFFC3D9C 01C12C23		stt		$t3,24[$sp]
FFFC3DA0 00912E23		stt		$s1,28[$sp]
FFFC3DA4 FFFC4537		ldi		$a0,#msgTimeoutList
FFFC3DA8 E7550513
FFFC3DAC E35FC0EF		call	PutString
FFFC3DB0 32802603		ldt		$a2,TimeoutList
                        	.0002:
FFFC3DB4 9DCFE0EF		call	SerialPeekCharDirect
FFFC3DB8 00354513		xor		$a0,$a0,#CTRLC
FFFC3DBC 02050C63		beqz	$a0,.brk
FFFC3DC0 00D06513		ldi		$a0,#CR
FFFC3DC4 E1CFC0EF		call	Putch
FFFC3DC8 02060663		beqz	$a2,.brk
FFFC3DCC 00A65513		srl		$a0,$a2,#LOG_PGSZ
FFFC3DD0 D61FC0EF		call	PutHexHalf
FFFC3DD4 02D06513		ldi		$a0,#'-'
FFFC3DD8 E08FC0EF		call	Putch
FFFC3DDC 32062503		ldt		$a0,TCBTimeout[$a2]
FFFC3DE0 D21FC0EF		call	PutHexWord
FFFC3DE4 00D06513		ldi		$a0,#CR
FFFC3DE8 DF8FC0EF		call	Putch
FFFC3DEC 31062603		ldt		$a2,TCBNext[$a2]
FFFC3DF0 FC0612E3		bnez	$a2,.0002
                        	.brk:
FFFC3DF4 00012083		ldt		$ra,[$sp]
FFFC3DF8 00412503		ldt		$a0,4[$sp]
FFFC3DFC 00812603		ldt		$a2,8[$sp]
FFFC3E00 00C12683		ldt		$a3,12[$sp]
FFFC3E04 01012303		ldt		$t1,16[$sp]
FFFC3E08 01412383		ldt		$t2,20[$sp]
FFFC3E0C 01812E03		ldt		$t3,24[$sp]
FFFC3E10 01C12483		ldt		$s1,28[$sp]
FFFC3E14 02010113		add		$sp,$sp,#32
FFFC3E18 00008067		ret
                        	
                        	msgReadyQueue:
FFFC3E1C 6165520D		db	CR,"Ready Queue",CR
FFFC3E20 51207964
FFFC3E24 65756575
FFFC3E28 6575510D
FFFC3E29 3A657551		db	"Que: Tid List",CR
FFFC3E2D 64695420
FFFC3E31 73694C20
FFFC3E35 2D2D0D74
FFFC3E37 2D2D2D2D		db	"-------------",CR,0
FFFC3E3B 2D2D2D2D
FFFC3E3F 2D2D2D2D
FFFC3E43 0D000D2D
                        	msgTaskInfo:
FFFC3E46 7361540D	  db  CR,"Task Info",CR
FFFC3E4A 6E49206B
FFFC3E4E 540D6F66
FFFC3E51 20424354	  db  "TCB Ptr   Tid  Pr St Timeout    SP",CR
FFFC3E55 20727450
FFFC3E59 69542020
FFFC3E5D 50202064
FFFC3E61 74532072
FFFC3E65 6D695420
FFFC3E69 74756F65
FFFC3E6D 20202020
FFFC3E71 000D5053
FFFC3E74 69540D00	  db  0
                        	msgTimeoutList:
FFFC3E75 6D69540D		db	CR,"Timeout List",CR
FFFC3E79 74756F65
FFFC3E7D 73694C20
FFFC3E81 54200D74
FFFC3E83 64695420		db	" Tid - Timeout",CR
FFFC3E87 54202D20
FFFC3E8B 6F656D69
FFFC3E8F 2D0D7475
FFFC3E92 2D2D2D2D		db	"--------------",CR,0
FFFC3E96 2D2D2D2D
FFFC3E9A 2D2D2D2D
FFFC3E9E 000D2D2D
                        	
FFFC3EA2 00000000		align 
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;-----------------------------------------------------------------------------
                        	;-----------------------------------------------------------------------------
                        	
                        	.file "../fmtk/iofocus.r5a",28
                        		code
                        	
                        	;-----------------------------------------------------------------------------
                        	; Determine if the currently running app has the I/O focus.
                        	;
                        	; Stack Space:
                        	;		none
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$a0 = E_Ok
                        	;		$a1 = 1 if task has IO focus, 0 otherwise
                        	;-----------------------------------------------------------------------------
FFFC3EA4 00000000		align	1
FFFC3EA8 00000000
FFFC3EAC 00000000
                        	
                        	FMTK_HasIOFocus:
                        		
FFFC3EB0 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC3EB4 00A51513	sll   $a0,$a0,#LOG_PGSZ
FFFC3EB8 34255503		ldwu  $a0,TCBappid[$a0]
FFFC3EBC 00050E63		beqz  $a0,.hasFocus       ; startup appid = zero
FFFC3EC0 00A51513		sll   $a0,$a0,#LOG_PGSZ   ; $a0 = ACB pointer
FFFC3EC4 000018B7		ldt   $a1,IOFocusNdx
FFFC3EC8 08088893
FFFC3ECC 000888B3
FFFC3ED0 0008A583
FFFC3ED4 00A59863		bne   $a1,$a0,.notEqual
                        	.hasFocus:
FFFC3ED8 00106593		ldi   $a1,#1
FFFC3EDC 00006513		ldi		$a0,#E_Ok
FFFC3EE0 00008067		ret
                        	.notEqual:
FFFC3EE4 00006593	  ldi   $a1,#0
FFFC3EE8 00006513		ldi		$a0,#E_Ok
FFFC3EEC 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; First check if it's even possible to switch the focus to another
                        	; app. The I/O focus list could be empty or there may be only a
                        	; single task in the list. In either case it's not possible to
                        	; switch.
                        	;
                        	;	Parameters:
                        	;		none
                        	;	Modifies:
                        	;		none
                        	;	Returns:
                        	;		a0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        		align	16                        	
                        	SwitchIOFocusHelper:
FFFC3EF0 000018B7	  ldt   $t0,IOFocusNdx
FFFC3EF4 08088893
FFFC3EF8 000888B3
FFFC3EFC 0008A283
FFFC3F00 3382A303	  ldt   $t1,ACBiofNext[$t0]
FFFC3F04 00030C63	  beqz  $t1,.zeroAppid
FFFC3F08 000018B7	  stt   $t1,IOFocusNdx
FFFC3F0C 08088893
FFFC3F10 000888B3
FFFC3F14 0068A023
FFFC3F18 00629663	  bne   $t0,$t1,.notSame
                        	.zeroAppid:
FFFC3F1C 00006513		ldi		$a0,E_Ok
FFFC3F20 00008067		ret
                        	.notSame:
                        		; swap virtual screens
                        		; set vidmem pointer
FFFC3F24 00006513		ldi		$a0,E_Ok
FFFC3F28 00008067		ret
                        	    
FFFC3F2C 00000000		align	1
                        	
                        	FMTK_SwitchIOFocus:
FFFC3F30 FC1FF06F		jmp		SwitchIOFocusHelper
                        	
                        	;-----------------------------------------------------------------------------
                        	; RequestIOFocus requests that the task receive the I/O focus. It does not
                        	; mean the task will receive the focus immediately. Instead it is placed
                        	; on a list of requesters. Which task has the I/O focus is determined from
                        	; user input.
                        	; The I/O focus list is an array indicating which apps are requesting the
                        	; I/O focus. The I/O focus is user controlled by pressing CNTRL-T on the
                        	; keyboard.
                        	;
                        	; Parameters:
                        	;		$a1 = app id requesting focus for
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;   $a1 (unmodified)
                        	;-----------------------------------------------------------------------------
                        	
FFFC3F34 00000000		align	1
FFFC3F38 00000000
FFFC3F3C 00000000
                        	
                        	FMTK_RequestIOFocus:
FFFC3F40 20006613		ldi		$a2,#512
FFFC3F44 06C5FE63		bgeu	$a1,$a2,.badAppId
FFFC3F48 FFC10113		sub		$sp,$sp,#4
FFFC3F4C 00112023		stt		$ra,[$sp]
FFFC3F50 841FE0EF		call	LockOS
FFFC3F54 00106613		ldi   $a2,#1
FFFC3F58 00A59393	  sll   $t2,$a1,#LOG_PGSZ
FFFC3F5C 3C238303		ldb		$t1,ACBHasFocus[$t2]  ; Is the task already included in the IO focus?
FFFC3F60 04031463		bnez	$t1,.ret				      ; If so, don't add again
FFFC3F64 000018B7		ldt	  $t0,IOFocusNdx			  ; get current index
FFFC3F68 08088893
FFFC3F6C 000888B3
FFFC3F70 0008A283
FFFC3F74 02029063		bnez	$t0,.notEmpty		      ; is there one? (!= 0)
FFFC3F78 000018B7		stt   $t2,IOFocusNdx
FFFC3F7C 08088893
FFFC3F80 000888B3
FFFC3F84 0078A023
FFFC3F88 3273AC23		stt   $t2,ACBiofNext[$t2]
FFFC3F8C 3473A023		stt   $t2,ACBiofPrev[$t2]
FFFC3F90 0180006F		jmp   .ret
                        	.notEmpty:
                        	  ; Insert just before head which is end of queue
FFFC3F94 3402A303	  ldt   $t1,ACBiofPrev[$t0]
FFFC3F98 3472A023	  stt   $t2,ACBiofPrev[$t0]     ; head->prev = new
FFFC3F9C 32732C23	  stt   $t2,ACBiofNext[$t1]     ; head->prev->next = new
FFFC3FA0 3253AC23	  stt   $t0,ACBiofNext[$t2]     ; new->next = head
FFFC3FA4 3463A023	  stt   $t1,ACBiofPrev[$t2]     ; new->prev = head->prev
                        	.ret:
FFFC3FA8 3CC38123		stb   $a2,ACBHasFocus[$t2]  ; set has focus flag
FFFC3FAC 825FE0EF		call	UnlockOS
FFFC3FB0 00012083		ldt		$ra,[$sp]
FFFC3FB4 00410113		add		$sp,$sp,#4
FFFC3FB8 00006513		ldi		$a0,#E_Ok
FFFC3FBC 00008067		ret
                        	.badAppId:
FFFC3FC0 01C06513		ldi		$a0,#E_BadAppId
FFFC3FC4 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; ReleaseIOFocus called when the app no longer desires to be on the I/O
                        	; focus list.
                        	;-----------------------------------------------------------------------------
                        	
FFFC3FC8 00000000		align	1
FFFC3FCC 00000000
                        	
                        	FMTK_ReleaseIOFocus:
                        		
FFFC3FD0 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC3FD4 00A51593	sll   $a1,$a0,#LOG_TCBSZ
FFFC3FD8 3425D583		ldwu  $a1,TCBappid[$a1]
FFFC3FDC 0040006F		jmp		FMTK_ForceReleaseIOFocus
                        	
                        	;-----------------------------------------------------------------------------
                        	; Releasing the I/O focus causes the focus to switch if the running app
                        	; had the I/O focus.
                        	; ForceReleaseIOFocus forces the release of the IO focus for a app
                        	; different than the one currently running.
                        	; 
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		$a1 = app id to release
                        	; Returns:
                        	;		$a0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        		align	16                        	
                        	FMTK_ForceReleaseIOFocus:
FFFC3FE0 FFC10113		sub		$sp,$sp,#4
FFFC3FE4 00112023		stt		$ra,[$sp]
FFFC3FE8 FA8FE0EF		call	LockOS
FFFC3FEC 00A59293		sll		$t0,$a1,#LOG_PGSZ
FFFC3FF0 3C228303		ldb		$t1,ACBHasFocus[$t0]
FFFC3FF4 06030463		beqz	$t1,.noFocus	    ; does it even have the focus?
FFFC3FF8 3C028123		stb   $x0,ACBHasFocus[$t0]
FFFC3FFC 000018B7		ldt   $t1,IOFocusNdx
FFFC4000 08088893
FFFC4004 000888B3
FFFC4008 0008A303
FFFC400C 02629C63		bne   $t0,$t1,.notAtTop
FFFC4010 3382A303		ldt   $t1,ACBiofNext[$t0]
FFFC4014 02531063		bne   $t1,$t0,.0001
                        		; removing last entry
FFFC4018 000018B7		stt   $x0,IOFocusNdx
FFFC401C 08088893
FFFC4020 000888B3
FFFC4024 0008A023
FFFC4028 3202AC23		stt   $x0,ACBiofNext[$t0]
FFFC402C 3402A023		stt   $x0,ACBiofPrev[$t0]
FFFC4030 02000663		bra		.noFocus
                        	.0001:	
FFFC4034 000018B7		stt   $t1,IOFocusNdx
FFFC4038 08088893
FFFC403C 000888B3
FFFC4040 0068A023
                        	.notAtTop:
FFFC4044 3382A303		ldt   $t1,ACBiofNext[$t0]
FFFC4048 3402A383		ldt   $t2,ACBiofPrev[$t0]
FFFC404C 34732023		stt   $t2,ACBiofPrev[$t1]
FFFC4050 3263AC23		stt   $t1,ACBiofNext[$t2]
FFFC4054 3202AC23		stt   $x0,ACBiofNext[$t0]
FFFC4058 3402A023		stt   $x0,ACBiofPrev[$t0]
                        	.noFocus:
FFFC405C F74FE0EF		call	UnlockOS
FFFC4060 00012083		ldt		$ra,[$sp]
FFFC4064 00410113		add		$sp,$sp,#4
FFFC4068 00006513		ldi		$a0,#E_Ok
FFFC406C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;     Wait for the IO Focus. Returns only when focus is present. This function
                        	; calls PeekChar() to see if there's a CTRL-T in the buffer which means to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;   a1 = device # to check, 5 = COM1 serial port, 1 = KBD keyboard
                        	;------------------------------------------------------------------------------
                        	
                        		align	16                        	
                        	_WaitForIOFocus:
                        	WaitForIOFocus:
FFFC4070 FF410113	  sub 	$sp,$sp,#12
FFFC4074 00A12023	  stt   $a0,[$sp]
FFFC4078 00B12223	  stt   $a1,4[$sp]
FFFC407C 00C12423	  stt   $a2,8[$sp]
                        	.WFF1:
FFFC4080 01406513		ldi		$a0,#20           ; FMTK Has Focus
FFFC4084 00000073		ecall
FFFC4088 04059663		bnez	$a1,.HasFocus
FFFC408C 01A06513		ldi   $a0,#26           ; FMTK_IO
FFFC4090 00506593		ldi   $a1,#5            ; hardcoded to serial port for now
FFFC4094 00906613		ldi   $a2,#9            ; peekchar function
FFFC4098 00000073		ecall
                        	;	call	SerialPeekChar
FFFC409C 0005C263		bltz  $a1,.0001
                        	.0001:
FFFC40A0 01406513		ldi		$a0,#$14					; CTRL-T
FFFC40A4 02A59063		bne		$a1,$a0,.WFF2
                        	;	call	SerialGetChar
                        		; eat up the CTRL-T
FFFC40A8 01A06513		ldi		$a0,#26						; FMTK_IO
FFFC40AC 00506593		ldi   $a1,#5  ;4[$sp]        ; get back device #
FFFC40B0 00806613		ldi		$a2,#8						; getchar function
FFFC40B4 00000073		ecall
FFFC40B8 01506513		ldi		$a0,#21						; switch IO Focus
FFFC40BC 00000073		ecall
FFFC40C0 FC0000E3		bra		.WFF1
                        	.WFF2:
FFFC40C4 00506513		ldi		$a0,#5            ; FMTK Sleep() function
FFFC40C8 00106593		ldi		$a1,#1
FFFC40CC 00000073		ecall
FFFC40D0 FA0008E3		bra		.WFF1
                        	.HasFocus:
FFFC40D4 00012503	  ldt   $a0,[$sp]
FFFC40D8 00412583	  ldt   $a1,4[$sp]
FFFC40DC 00812603	  ldt   $a2,8[$sp]
FFFC40E0 00C10113	  add   $sp,$sp,#12
FFFC40E4 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	
FFFC40E8 00000000		align	1
FFFC40EC 00000000
                        	
                        	GetUIFlag:
FFFC40F0 FF410113	  sub 	$sp,$sp,#12
FFFC40F4 00C12223	  stt   $a2,4[$sp]
FFFC40F8 00D12423	  stt   $a3,8[$sp]
FFFC40FC 01B06513	  ldi   $a0,#27           ; Get DCB Field
FFFC4100 04206613	  ldi   $a2,#DCB_fUI      ; Get UI Flag
FFFC4104 00106693	  ldi   $a3,#1            ; 1 byte
FFFC4108 00000073	  ecall
FFFC410C 00412603	  ldt   $a2,4[$sp]
FFFC4110 00812683	  ldt   $a3,8[$sp]
FFFC4114 00C10113	  add   $sp,$sp,#12
FFFC4118 00008067	  ret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15   VIA							VIA1
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	.file "../fmtk/io.r5a",62
                        		code
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = function
                        	;		a3 = data
                        	;------------------------------------------------------------------------------
FFFC411C 00000000		align	1
                        	
                        	FMTK_IO:
                        	;  mEI
FFFC4120 FFC10113		sub		$sp,$sp,#4
FFFC4124 00112023		stt		$ra,[$sp]
FFFC4128 7C10F073		csrrc	$x0,#$7C1,#1				; clear OS running semaphore
FFFC412C 02006513		ldi		$a0,#32
FFFC4130 04A5F663		bgeu	$a1,$a0,.badDev
FFFC4134 02006393		ldi		$t2,#32
FFFC4138 02767A63		bgeu	$a2,$t2,.badFunc
FFFC413C 00759E13		sll		$t3,$a1,#7					; each device allowed 32 functions (*128)
FFFC4140 00261393		sll		$t2,$a2,#2					; function number *4
FFFC4144 000028B7		add		$t3,$t3,#DVF_Base		; base address of function table
FFFC4148 00088893
FFFC414C 01C88E33
FFFC4150 007E0E33		add		$t3,$t3,$t2
FFFC4154 000E2E03		ldt		$t3,[$t3]
FFFC4158 000E0A63		beqz	$t3,.badFunc
FFFC415C 000E00E7		call	[$t3]
FFFC4160 00012083		ldt		$ra,[$sp]
FFFC4164 00410113		add		$sp,$sp,#4
                        	.xit:
FFFC4168 00008067		ret
                        	.badFunc:
FFFC416C 02206513		ldi		$a0,#E_BadDevOp
FFFC4170 00012083		ldt		$ra,[$sp]
FFFC4174 00410113		add		$sp,$sp,#4
FFFC4178 00008067		ret
                        	.badDev:
FFFC417C 02006513		ldi		$a0,#E_BadDevNum
FFFC4180 00012083		ldt		$ra,[$sp]
FFFC4184 00410113		add		$sp,$sp,#4
FFFC4188 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = field offset
                        	;   a3 = 0 = get word, 1 = get byte
                        	;------------------------------------------------------------------------------
FFFC418C 00000000		align 1
                        	
                        	FMTK_GetDCBField:
FFFC4190 02006393		ldi		$t2,#32
FFFC4194 0475F063		bgeu	$a1,$t2,.badDev
FFFC4198 06006E13		ldi		$t3,#DCB_Size
FFFC419C 03C67863		bgeu	$a2,$t3,.badFunc
FFFC41A0 03C583B3		mul		$t2,$a1,$t3		      ; each device allowed (96 bytes)
FFFC41A4 000038B7		add		$t2,$t2,#DCB_Base		; base address of function table
FFFC41A8 00088893
FFFC41AC 007883B3
FFFC41B0 00C383B3		add   $t2,$t2,$a2         ; add field offset
FFFC41B4 00068663		beqz  $a3,.ldWord
FFFC41B8 00038583		ldb   $a1,[$t2]
FFFC41BC 00000463		bra   .ok
                        	.ldWord:
FFFC41C0 0003A583	  ldt   $a1,[$t2]
                        	.ok:
FFFC41C4 00006513	  ldi   $a0,#E_Ok
                        	.xit:
FFFC41C8 00008067		ret
                        	.badFunc:
FFFC41CC 01A06513		ldi		$a0,#E_BadDCBOffset
FFFC41D0 00008067		ret
                        	.badDev:
FFFC41D4 02006513		ldi		$a0,#E_BadDevNum
FFFC41D8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = field offset
                        	;   a3 = 0 = get word, 1 = get byte
                        	;   a4 = value to set
                        	;------------------------------------------------------------------------------
FFFC41DC 00000000		align	1
                        	
                        	ISetDCBField:
FFFC41E0 02006393		ldi		$t2,#32
FFFC41E4 0475F063		bgeu	$a1,$t2,.badDev
FFFC41E8 06006E13		ldi		$t3,#DCB_Size
FFFC41EC 03C67863		bgeu	$a2,$t3,.badFunc
FFFC41F0 03C583B3		mul		$t2,$a1,$t3		      ; each device allowed (96 bytes)
FFFC41F4 000038B7		add		$t2,$t2,#DCB_Base		; base address of function table
FFFC41F8 00088893
FFFC41FC 007883B3
FFFC4200 00C383B3		add   $t2,$t2,$a2         ; add field offset
FFFC4204 00068663		beqz  $a3,.stWord
FFFC4208 00E38023		stb   $a4,[$t2]
FFFC420C 00000463		bra   .ok
                        	.stWord:
FFFC4210 00E3A023	  stt   $a4,[$t2]
                        	.ok:
FFFC4214 00006513	  ldi   $a0,#E_Ok
                        	.xit:
FFFC4218 00008067		ret
                        	.badFunc:
FFFC421C 01A06513		ldi		$a0,#E_BadDCBOffset
FFFC4220 00008067		ret
                        	.badDev:
FFFC4224 02006513		ldi		$a0,#E_BadDevNum
FFFC4228 00008067		ret
                        	
FFFC422C 00000000		align	1
                        	
                        	FMTK_SetDCBField:
FFFC4230 FB1FF0EF		call	ISetDCBField
FFFC4234 97DFE06F		jmp		OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = I/O channel
                        	;		a1 = points to function table
                        	;------------------------------------------------------------------------------
FFFC4238 00000000		align	1
FFFC423C 00000000
                        	
                        	CopyDevFuncTbl:
FFFC4240 00751393		sll		$t2,$a0,#7					; each device allowed 32 functions (*128)
FFFC4244 000028B7		add		$t2,$t2,#DVF_Base		; base address of function table
FFFC4248 00088893
FFFC424C 007883B3
FFFC4250 02006293		ldi		$t0,#32							; 32 functions to copy
                        	.again:
FFFC4254 0005A683		ldt		$a3,[$a1]
FFFC4258 00D3A023		stt		$a3,[$t2]
FFFC425C 00458593		add		$a1,$a1,#4
FFFC4260 00438393		add		$t2,$t2,#4
FFFC4264 FFF28293		sub		$t0,$t0,#1
FFFC4268 FE5046E3		bgtz	$t0,.again
FFFC426C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	CopyDevDCB:
FFFC4270 06006393	  ldi   $t2,#DCB_Size
FFFC4274 027503B3	  mul   $t2,$a0,$t2
FFFC4278 000038B7	  add   $t2,$t2,#DCB_Base
FFFC427C 00088893
FFFC4280 007883B3
FFFC4284 01806293		ldi		$t0,#24							; 24 words to copy
                        	.again:
FFFC4288 0005A683		ldt		$a3,[$a1]
FFFC428C 00D3A023		stt		$a3,[$t2]
FFFC4290 00458593		add		$a1,$a1,#4
FFFC4294 00438393		add		$t2,$t2,#4
FFFC4298 FFF28293		sub		$t0,$t0,#1
FFFC429C FE5046E3		bgtz	$t0,.again
FFFC42A0 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;    Compare the current APPID against the device owner to see if the device
                        	; is owned.
                        	;------------------------------------------------------------------------------
FFFC42A4 00000000		align	1
FFFC42A8 00000000
FFFC42AC 00000000
                        	
                        	CheckDevOwner:
FFFC42B0 FFC10113	  sub   $sp,$sp,#4
FFFC42B4 00912023	  stt   $s1,[$sp]
FFFC42B8 0040E073		csrrs $x0,#$004,#1        ; enable gc interrupt
FFFC42BC 00E06513	  ldi   $a0,#14             ; FMTK: GetCurrentTid
FFFC42C0 00000073	  ecall
FFFC42C4 0005E4B3	  mov   $s1,$a1
FFFC42C8 01B06513	  ldi   $a0,#27             ; FMTK Get DCB Field
FFFC42CC 04806613	  ldi   $a2,#DCB_hJob
FFFC42D0 00006693	  ldi   $a3,#0              ; get word
FFFC42D4 00000073	  ecall
FFFC42D8 0FF5F593	  and   $a1,$a1,#$FF
FFFC42DC 0095C5B3	  xor   $a1,$a1,$s1
FFFC42E0 00059A63	  bnez  $a1,.notOwner
FFFC42E4 00006513	  ldi   $a0,#E_Ok
                        	.xit:
FFFC42E8 00012483	  ldt   $s1,[$sp]
FFFC42EC 00410113	  add   $sp,$sp,#4
FFFC42F0 00008067	  ret
                        	.notOwner:
FFFC42F4 01C06513	  ldi   $a0,#28             ; FMTK Set DCB field
FFFC42F8 0004E5B3	  mov   $a1,$s1
FFFC42FC 01806613	  ldi   $a2,#DCB_LastErc
FFFC4300 00006693	  ldi   $a3,#0              ; word
FFFC4304 01206713	  ldi   $a4,#E_NotOwner
FFFC4308 00000073	  ecall                     
FFFC430C 00076533	  mov   $a0,$a4
FFFC4310 FC000CE3	  bra   .xit
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/finalizer.r5a",1
                        	.file "../fmtk/finalizer.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; The Finalizer task examines the undead queue looking for tasks that haven't
                        	; been finalized yet. If there is no finalizer the task is marked dead, 
                        	; otherwise the task's execution point is changed to the task finalizer and
                        	; the task is placed back into the ready queue. The task finalizer should
                        	; exit by invoking the FinalizerExit routine of the OS.
                        	
                        	.file "../fmtk/finalizer.r5a",31
                        	  code  18 bits
FFFC4314 00000000	  align 1
FFFC4318 00000000
FFFC431C 00000000
                        	
                        	Finalizer:
FFFC4320 01806513	  ldi   $a0,#24               ; request I/O focus
FFFC4324 00000073	  ecall
FFFC4328 FFFC4537	  ldi   $a0,#msgFinalizerRunning
FFFC432C 41C50513
FFFC4330 8B1FC0EF	  call  PutString
FFFC4334 01606513	  ldi   $a0,#22               ; release I/O focus
FFFC4338 00000073	  ecall
FFFC433C 00406513	  ldi   $a0,#4                ; set task priority
FFFC4340 00306593	  ldi   $a1,#PRI_LOW
FFFC4344 00000073	  ecall
                        	.yield:
FFFC4348 00506513	  ldi   $a0,#5                ; Sleep
FFFC434C 00006593	  ldi   $a1,#0                ; 0 to yeild
FFFC4350 00000073	  ecall
                        	.nxt2:
FFFC4354 01106513	  ldi   $a0,#17               ; RunAsOS
FFFC4358 FFFC45B7	  ldi   $a1,.oscode
FFFC435C 36858593
FFFC4360 00000073	  ecall
FFFC4364 FE0008E3	  bra   .nxt2
                        	.oscode:
FFFC4368 00706293	  ldi   $t0,#UNDEADQ
FFFC436C 1A02850D	  popq  $a0,$t0
  bge   $a0,$x0,.nxt2         ; valid entry?
FFFC4370 FE0552E3
FFFC4374 000048B7	  and   $t1,$a0,#$4000        ; queue empty?
FFFC4378 00088893
FFFC437C 00A8F333
FFFC4380 FC0314E3	  bnez  $t1,.yield            ; go back to yield
FFFC4384 0FF57313	  and   $t1,$a0,#$FF
FFFC4388 000008B7	  ldt   $a1,TidTcbMap[$t1]    ; get pointer to task
FFFC438C 3AE88893
FFFC4390 006888B3
FFFC4394 0008A583
FFFC4398 FFF808B7	  and   $t1,$t1,#$FFF803FF    ; valid task pointer
FFFC439C 3FF88893
FFFC43A0 0068F333
FFFC43A4 FA0318E3	  bnez  $t1,.nxt2
FFFC43A8 0305A303	  ldt   $t1,OBJFinalizer[$a1] ; Finalizer code?
FFFC43AC 00030C63	  beqz  $t1,.noFinalizer
                        	  ; If there is finalizer code to run, the task is placed back into the ready
                        	  ; queue with the operating address set to the finalizer code.
FFFC43B0 2C65A023	  stt   $t1,TCBepc[$a1]       ; Cause task to return to finalizer
FFFC43B4 00306313	  ldi   $t1,#PRI_LOW
FFFC43B8 2C6584A3	  stb		$t1,TCBPriority[$a1]
FFFC43BC 0005E533	  mov		$a0,$a1
FFFC43C0 DD0FF0EF	  call	InsertIntoReadyQueue
                        	;  pushq $a0,$t1
                        	.noFinalizer:
FFFC43C4 00206313	  ldi   $t1,#TS_DEAD
FFFC43C8 2C658423	  stb   $t1,TCBStatus[$a1]
FFFC43CC 08006313	  ldi   $t1,#OST_DEAD
FFFC43D0 00658C23	  stb   $t1,OBJState[$a1]
FFFC43D4 00006513	  ldi   $a0,#E_Ok
FFFC43D8 00008067	  ret
FFFC43DC F6000CE3	  bra   .nxt2
                        	
                        	FMTK_TCBFinalizerExit:
                        	  
FFFC43E0 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC43E4 0FF57313	and   $t1,$a0,#$FF
FFFC43E8 000008B7	  ldt   $a1,TidTcbMap[$t1]    ; get pointer to task
FFFC43EC 3AE88893
FFFC43F0 006888B3
FFFC43F4 0008A583
FFFC43F8 FFF808B7	  and   $t1,$t1,#$FFF803FF    ; valid task pointer
FFFC43FC 3FF88893
FFFC4400 0068F333
FFFC4404 00031A63	  bnez  $t1,.0001
FFFC4408 00206313	  ldi   $t1,#TS_DEAD
FFFC440C 2C658423	  stb   $t1,TCBStatus[$a1]
FFFC4410 08006313	  ldi   $t1,#OST_DEAD
FFFC4414 00658C23	  stb   $t1,OBJState[$a1]
                        	.0001:
FFFC4418 00008067	  ret
                        	
                        	msgFinalizerRunning:
FFFC441C 616E6946	  db  "Finalizer task running",CR,0
FFFC4420 657A696C
FFFC4424 61742072
FFFC4428 72206B73
FFFC442C 696E6E75
FFFC4430 000D676E
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/gcIncremental.r5a",1
                        	.file "../fmtk/gcIncremental.r5a",1
                        	; Garbage Collector
                        	
                        	gcIncrement:
FFFC4434 00008067	  ret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "TinyBasic.r5a",1
                        	.file "TinyBasic.r5a",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x6C0
                        	FILEBUF		EQU		0x07F600
                        	OSSP		EQU		0x700
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	SRCHLN    EQU   CURRNT+4
                        	; Reserved four byte area before BUFFER in case line number stuffed into it
                        	; is less than four digits.
                        	BUFFER		EQU		SRCHLN+8
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x001800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x00F000	; end of available memory
                        	STACKOFFS	EQU		0x00FFFC	; stack offset
                        	
                        	
                        	.file "TinyBasic.r5a",86
                        			code
FFFC4438 00000000			align	25
FFFC443C 00000000
FFFC4440 00000000
FFFC4444 00000000
FFFC4448 00000000
FFFC444C 00000000
FFFC4450 00000000
FFFC4454 00000000
FFFC4458 00000000
FFFC445C 00000000
FFFC4460 00000000
FFFC4464 00000000
FFFC4468 00000000
FFFC446C 00000000
FFFC4470 00000000
FFFC4474 00000000
FFFC4478 00000000
FFFC447C 00000000
FFFC4480 00000000
FFFC4484 00000000
FFFC4488 00000000
FFFC448C 00000000
FFFC4490 00000000
FFFC4494 00000000
FFFC4498 00000000
FFFC449C 00000000
FFFC44A0 00000000
FFFC44A4 00000000
FFFC44A8 00000000
FFFC44AC 00000000
FFFC44B0 00000000
FFFC44B4 00000000
FFFC44B8 00000000
FFFC44BC 00000000
FFFC44C0 00000000
FFFC44C4 00000000
FFFC44C8 00000000
FFFC44CC 00000000
FFFC44D0 00000000
FFFC44D4 00000000
FFFC44D8 00000000
FFFC44DC 00000000
FFFC44E0 00000000
FFFC44E4 00000000
FFFC44E8 00000000
FFFC44EC 00000000
FFFC44F0 00000000
FFFC44F4 00000000
FFFC44F8 00000000
FFFC44FC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC4500 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC4504 0EC0006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC4508 5B50106F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC450C 5B50106F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC4510 000008B7			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC4514 3DE88067
                        	GOAUXI:	
FFFC4518 000008B7			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC451C 3E088067
                        	GOBYE:	
FFFC4520 5D10106F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC4524 00000000		align	1
FFFC4528 00000000
FFFC452C 00000000
                        	
                        	//message "CSTART"
                        	public CSTART:
	; First save off the link register and OS sp value
FFFC4530 00E06513		ldi		$a0,#14							; Get current tid
FFFC4534 00000073		ecall                     ; $a1 = task id
FFFC4538 01206513		ldi   $a0,#18             ; Get task app id
FFFC453C 00000073		ecall
FFFC4540 01806513		ldi		$a0,#24							; RequestIOFocus
FFFC4544 00000073		ecall
FFFC4548 02506513		ldi		$a0,#37							; Allocate memory
FFFC454C 00010637		ldi		$a2,#$10000					; request 64k
FFFC4550 00060613
FFFC4554 00000073		ecall
FFFC4558 0005E1B3		mov		$gp,$a1
FFFC455C 7021A023		stt		$sp,OSSP[$gp]
FFFC4560 000108B7		add		$sp,$gp,#STACKOFFS	; initialize stack pointer
FFFC4564 FFC88893
FFFC4568 00388133
                        	;	call	_DBGHomeCursor[pc]
FFFC456C 00006533		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC4570 FFFC6537		ldi		$a0,#msgInit  ;	tell who we are
FFFC4574 30450513
FFFC4578 34D010EF		call	PRMESG
FFFC457C 000028B7		add		$a0,$gp,#TXTBGN	;	init. end-of-program pointer
FFFC4580 80088893
FFFC4584 00388533
FFFC4588 70A1A223		stt		$a0,TXTUNF[$gp]
FFFC458C 0000F8B7		add		$a0,$gp,#ENDMEM	;	get address of end of memory
FFFC4590 00088893
FFFC4594 00388533
FFFC4598 0001E533		mov		$a0,$gp
FFFC459C 000108B7		add		$a0,$a0,#$F800	; 2k stack
FFFC45A0 80088893
FFFC45A4 00A88533
                        	;	ldi		$a0,#$7F800 ; 2k stack
FFFC45A8 7AA1A223		stt		$a0,STKBOT[$gp]
FFFC45AC 0000F8B7		add		$a0,$gp,#ENDMEM
FFFC45B0 00088893
FFFC45B4 00388533
FFFC45B8 70A1A623		stt		$a0,VAREND[$gp]
FFFC45BC CE050513		sub		$a0,$a0,#800  ;   100 vars
FFFC45C0 70A1A423		stt   $a0,VARBGN[$gp]
FFFC45C4 4AC000EF		call  clearVars   ; clear the variable area
FFFC45C8 7A01A623		stt		$x0,IRQROUT[$gp]
FFFC45CC 7081A503		ldt   $a0,VARBGN[$gp]  ; calculate number of bytes free
FFFC45D0 7041A583		ldt		$a1,TXTUNF[$gp]
FFFC45D4 40B50533		sub   $a0,$a0,$a1
FFFC45D8 00606593		ldi		$a1,#6		; max 6 digits
FFFC45DC 00A06613		ldi		$a2,#10	  ; base 10
FFFC45E0 011010EF		call  PRTNUM
FFFC45E4 FFFC6537		ldi		$a0,#msgBytesFree
FFFC45E8 3A550513
FFFC45EC 2D9010EF		call	PRMESG
                        	WSTART:
FFFC45F0 7001A823		stt		$x0,LOPVAR[$gp]  ; initialize internal variables
FFFC45F4 7001AA23		stt		$x0,STKGOS[$gp]
FFFC45F8 7001AC23		stt		$x0,CURRNT[$gp]	;	current line number pointer = 0
FFFC45FC 000108B7		add		$sp,$gp,#STACKOFFS	;	init S.P. again, just in case
FFFC4600 FFC88893
FFFC4604 00388133
FFFC4608 FFFC6537		ldi		$a0,#msgReady	;	display "Ready"
FFFC460C 3B250513
FFFC4610 2B5010EF		call	PRMESG
                        	BASPRMPT:
FFFC4614 00E06513		ldi		$a0,#14		; get current tid
FFFC4618 00000073		ecall
FFFC461C 0005E533		mov		$a0,$a1   ;
FFFC4620 D40FC0EF		call	PutHexByte
FFFC4624 03E06513		ldi		$a0,#'>'	; Prompt with a '>' and
FFFC4628 4BC010EF		call	GETLN		  ; read a line.
FFFC462C 1E9010EF		call	TOUPBUF 	; convert to upper case
FFFC4630 72418393		add		$t2,$gp,#BUFFER	; point to the beginning of line
FFFC4634 139010EF		call	TSTNUM		; is there a number there?
FFFC4638 1A5010EF		call	IGNBLK		; skip trailing blanks
FFFC463C 0003CB03		ldbu	$s6,[$t2]
FFFC4640 00DB4B13		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC4644 260C8E63		beqz	$s9,DIRECT		; if not, it's a direct statement ($s9 = num digits)
FFFC4648 00100337		ldi		$t1,#$FFFFF
FFFC464C FFF30313
FFFC4650 01837863		bleu	$s8,$t1,ST2	; see if line no. is <= 20 bits
FFFC4654 FFFC6537		ldi		$a0,#msgLineRange	; if not, we've overflowed
FFFC4658 3CD50513
FFFC465C 4440106F		jmp		ERROR
                        	ST2:
FFFC4660 000C6533	  mov		$a0,$s8		; a0 = line number
FFFC4664 0003EAB3	  mov		$s5,$t2			; save line buffer pointer
FFFC4668 FFB38393		sub		$t2,$t2,#5
FFFC466C 00A3A0A3	  stt		$a0,1[$t2]  ;	This will end up in buffer (requires unaligned store capability)
FFFC4670 568010EF		call	FNDLN		; find this line in save area
FFFC4674 000E6BB3		mov		$s7,$t3		; $s7 = save possible line pointer
FFFC4678 000C0663		beqz	$s8,INSLINE	; if not found, insert
FFFC467C 000E6533		mov		$a0,$t3
FFFC4680 050000EF		call	DeleteLine
                        	INSLINE:
FFFC4684 F80B08E3		beqz	$s6,BASPRMPT	; line was empty
FFFC4688 000AE533		mov		$a0,$s5			; a0 = buffer pointer
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC468C 094000EF		call	GetBuflen
FFFC4690 005C0A13		add		$s4,$s8,#5  ; update length, needed later
FFFC4694 FF4A8DA3		stb   $s4,-5[$s5] ; put length into buffer
FFFC4698 000BE533		mov		$a0,$s7
FFFC469C 000A65B3		mov		$a1,$s4
FFFC46A0 0AC000EF		call	OpenSpace
FFFC46A4 000C1863		bnez	$s8,.0001	  ; space available?
FFFC46A8 FFFC6537		ldi		$a0,#msgTooBig  ; no space available
FFFC46AC 49F50513
FFFC46B0 3F00106F		jmp		ERROR
                        	.0001:
FFFC46B4 000AE533	  mov   $a0,$s5
FFFC46B8 D28FC0EF		call  PutString	
FFFC46BC 000BE533		mov		$a0,$s7			; target
FFFC46C0 FFBA8593		sub		$a1,$s5,#5	; source (incl lineno)
FFFC46C4 000A6633		mov		$a2,$s4			; length
FFFC46C8 038000EF		call	InsertLine
FFFC46CC F40004E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
FFFC46D0 00054283		ldbu  $t0,[$a0]     ; $t0 = length
FFFC46D4 00A282B3		add		$t0,$t0,$a0		; t0 = pointer to line past line number and length
FFFC46D8 70402E03		ldt		$t3,TXTUNF		; last text address
                        		; pull text after eol overtop
                        	.0003:
FFFC46DC 0002CE83		ldbu	$t4,[$t0]			; copy from next line
FFFC46E0 01D50023		stb		$t4,[$a0]			; overtop deleted line
FFFC46E4 00128293		add		$t0,$t0,#1		; increment pointers
FFFC46E8 00150513		add		$a0,$a0,#1
FFFC46EC FE5E78E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC46F0 40A28533		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC46F4 40AE0E33		sub		$t3,$t3,$a0		
FFFC46F8 71C02223		stt		$t3,TXTUNF
FFFC46FC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC4700 00060E63		beqz	$a2,.done		    ; zero length? Probably a SW error
                        	.0001:
FFFC4704 0005C303		ldbu	$t1,[$a1]				; get from source text
FFFC4708 00650023		stb		$t1,[$a0]				; store to insertion point
FFFC470C 00158593		add		$a1,$a1,#1			; increment pointers
FFFC4710 00150513		add		$a0,$a0,#1
FFFC4714 FFF60613		sub		$a2,$a2,#1			; decrement length
FFFC4718 FEC046E3		bgtz	$a2,.0001
                        	.done:
FFFC471C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		s8 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC4720 00006C13		ldi		$s8,#0
FFFC4724 00D06E13		ldi		$t3,#CR
FFFC4728 00056F33		mov		$t5,$a0
                        	.0002:
FFFC472C 000F4383		ldbu	$t2,[$t5]
FFFC4730 001F0F13		add		$t5,$t5,#1
FFFC4734 00038A63		beqz	$t2,.0001
FFFC4738 01C38663		beq		$t2,$t3,.0004
FFFC473C 001C0C13		add		$s8,$s8,#1
FFFC4740 FE0006E3		bra		.0002
                        	.0004:
FFFC4744 001C0C13		add		$s8,$s8,#1
                        	.0001:
FFFC4748 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		s8 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC474C 7041A383		ldt		$t2,TXTUNF[$gp]
FFFC4750 0003EE33		mov		$t3,$t2				; t3 = old end of text
FFFC4754 00B383B3		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC4758 7081A303		ldt		$t1,VARBGN[$gp]		; compare to start of variables
FFFC475C 0263F263		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC4760 70702223		stt		$t2,TXTUNF		; yes, set new end of text
                        	.0003:
FFFC4764 000E4F03		ldbu	$t5,[$t3]			; copy old text
FFFC4768 01E38023		stb		$t5,[$t2]			; to new text loc
FFFC476C FFFE0E13		sub		$t3,$t3,#1		; decrement pointers
FFFC4770 FFF38393		sub		$t2,$t2,#1
FFFC4774 FEAE78E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC4778 00106C13		ldi		$s8,#1				; return success
FFFC477C 00008067		ret
                        	.noSpace:
FFFC4780 00006C13		ldi		$s8,#0
FFFC4784 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC4788 D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC478C C4414F4C		db	"LOA",'D'+0x80
FFFC4790 52D7454E		db	"NE",'W'+0x80
FFFC4793 53CE5552		db	"RU",'N'+0x80
FFFC4796 C5564153		db	"SAV",'E'+0x80
FFFC479A 45454C53		db  "SLEE",'P'+0x80
FFFC479E 58454ED0
                        	TAB2:
FFFC479F D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC47A3 49D4454C		db	"LE",'T'+0x80
FFFC47A6 4F47C649		db	"I",'F'+0x80
FFFC47A8 CF544F47		db	"GOT",'O'+0x80
FFFC47AC 55534F47		db	"GOSU",'B'+0x80
FFFC47B0 544552C2
FFFC47B1 55544552		db	"RETUR",'N'+0x80
FFFC47B5 4552CE52
FFFC47B7 46CD4552		db	"RE",'M'+0x80
FFFC47BA 49D24F46		db	"FO",'R'+0x80
FFFC47BD 55504E49		db	"INPU",'T'+0x80
FFFC47C1 495250D4
FFFC47C2 4E495250		db	"PRIN",'T'+0x80
FFFC47C6 4B4F50D4
FFFC47C7 C54B4F50		db	"POK",'E'+0x80
FFFC47CB 454B4F50		db	"POKE",'W'+0x80
FFFC47CF 4B4F50D7
FFFC47D0 454B4F50		db	"POKE",'H'+0x80
FFFC47D4 454959C8
FFFC47D5 4C454959		db	"YIEL",'D'+0x80
FFFC47D9 4F5453C4
FFFC47DA D04F5453		db	"STO",'P'+0x80
FFFC47DE 53C55942		db	"BY",'E'+0x80
FFFC47E1 43D35953		db	"SY",'S'+0x80
FFFC47E4 43D34C43		db	"CL",'S'+0x80
FFFC47E7 52D24C43	    db  "CL",'R'+0x80
FFFC47EA C6434452	    db	"RDC",'F'+0x80
FFFC47EE 52494E4F	    db	"ONIR",'Q'+0x80
FFFC47F2 494157D1
FFFC47F3 D4494157	    db	"WAI",'T'+0x80
FFFC47F7 45455000		db	0
                        	TAB4:
FFFC47F8 CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC47FC 4B454550		db	"PEEK",'W'+0x80
FFFC4800 454550D7
FFFC4801 4B454550		db	"PEEK",'H'+0x80
FFFC4805 C44E52C8
FFFC4806 41C44E52		db	"RN",'D'+0x80
FFFC4809 53D34241		db	"AB",'S'+0x80
FFFC480C 54CE4753		db  "SG",'N'+0x80
FFFC480F CB434954		db	"TIC",'K'+0x80
FFFC4813 C55A4953		db	"SIZ",'E'+0x80
FFFC4817 41D25355		db  "US",'R'+0x80
FFFC481A 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC481E D8424D43
FFFC4822 444E4553	  db	"SENDMS",'G'+0x80
FFFC4826 57C7534D
FFFC4829 54494157	  db	"WAITMS",'G'+0x80
FFFC482D 00C7534D
FFFC4830 00CF5400		db	0
                        	TAB5:
FFFC4831 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC4833 45545300		db	0
                        	TAB6:
FFFC4834 D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC4838 3CBD3E00		db	0
                        	TAB8:
FFFC4839 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC483B BDBEBE3C		db	'<','>'+0x80
FFFC483D BD3CBDBE		db	'>'+0x80
FFFC483E BCBD3CBD		db	'='+0x80
FFFC483F 00BCBD3C		db	'<','='+0x80
FFFC4841 4E4100BC		db	'<'+0x80
FFFC4842 C44E4100		db	0
                        	TAB9:
FFFC4843 00C44E41	    db  "AN",'D'+0x80
FFFC4846 00D24F00	    db  0
                        	TAB10:
FFFC4847 E400D24F	    db  "O",'R'+0x80
FFFC4849 C44AE400	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
                        		align	2                        	
                        	TAB1_1:
FFFC484A 4FC44AE4		dh	LISTX			;Direct commands
FFFC484C 49404FC4		dh	LOAD3
FFFC484E 49984940		dh	NEW
FFFC4850 502C4998		dh	RUN
FFFC4852 495C502C		dh	SAVE3
FFFC4854 4CE4495C		dh  SLEEP
                        	TAB2_1:
FFFC4856 4E7C4CE4		dh	NEXT		;	Direct / statement
FFFC4858 4D5C4E7C		dh	LET
FFFC485A 4A444D5C		dh	IF0
FFFC485C 4BD04A44		dh	GOTO
FFFC485E 4C144BD0		dh	GOSUB
FFFC4860 4D684C14		dh	RETURN
FFFC4862 4C584D68		dh	IF2			; REM
FFFC4864 4DB04C58		dh	FOR
FFFC4866 4B304DB0		dh	INPUT
FFFC4868 518C4B30		dh	PRINT
FFFC486A 51B8518C		dh	POKE
FFFC486C 51E451B8		dh	POKEW
FFFC486E 499051E4		dh	POKEH
FFFC4870 49544990		dh	YIELD0
FFFC4872 45204954		dh	STOP
FFFC4874 521C4520		dh	GOBYE
FFFC4876 0422521C		dh	SYSX
FFFC4878 4A680422		dh	_cls
FFFC487A 04244A68		dh  _clr
FFFC487C 4AA80424		dh	_rdcf
FFFC487E 4AD04AA8		dh  ONIRQ
FFFC4880 4E704AD0		dh	WAITIRQ
FFFC4882 58384E70		dh	DEFLT
                        	TAB4_1:
FFFC4884 58505838		dh	PEEK			;Functions
FFFC4886 58685850		dh	PEEKW
FFFC4888 58C05868		dh	PEEKH
FFFC488A 000058C0		dh	RND
FFFC488C 59540000		dh	ABS
FFFC488E 59405954		dh  SGN
FFFC4890 59905940		dh	TICKX
FFFC4892 58805990		dh	SIZEX
FFFC4894 60DC5880		dh  USRX
FFFC4896 614860DC		dh	ALLOCMBX
FFFC4898 61E46148		dh	SENDMSG
FFFC489A 561461E4		dh	WAITMSG
FFFC489C 4C785614		dh	XP40
                        	TAB5_1
FFFC489E 5A984C78		dh	FR1			;"TO" in "FOR"
FFFC48A0 4C945A98		dh	QWHAT
                        	TAB6_1
FFFC48A2 4C9C4C94		dh	FR2			;"STEP" in "FOR"
FFFC48A4 53CC4C9C		dh	FR3
                        	TAB8_1
FFFC48A6 53E453CC		dh	XP11	;>=		Relational operators
FFFC48A8 53FC53E4		dh	XP12	;<>
FFFC48AA 542C53FC		dh	XP13	;>
FFFC48AC 5414542C		dh	XP15	;=
FFFC48AE 54445414		dh	XP14	;<=
FFFC48B0 54845444		dh	XP16	;<
FFFC48B2 52DC5484		dh	XP17
                        	TAB9_1
FFFC48B4 52F052DC	    dh  XP_AND
FFFC48B6 527C52F0	    dh  XP_ANDX
                        	TAB10_1
FFFC48B8 5290527C	    dh  XP_OR
FFFC48BA 00005290	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC48BC 00000000		align	1
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC48C0 FFFC4E37		ldi		$t3,#TAB1
FFFC48C4 788E0E13
FFFC48C8 FFFC5EB7		ldi		$t4,#TAB1_1
FFFC48CC 84AE8E93
                        	EXEC:
FFFC48D0 70C010EF		call	IGNBLK		; ignore leading blanks
FFFC48D4 0003EF33		mov		$t5,$t2		; save the pointer
FFFC48D8 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC48DC 0003C503		ldbu	$a0,[$t2]		; get the program character
FFFC48E0 00138393		add		$t2,$t2,#1
FFFC48E4 000E4583		ldbu	$a1,[$t3]		; get the table character
FFFC48E8 00059663		bnez	$a1,EXNGO		; If end of table,
FFFC48EC 000F63B3		mov		$t2,$t5		;	restore the text pointer and...
FFFC48F0 02000E63		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC48F4 02350C63		beq		$a0,r3,EXGO	; Else check for period... if so, execute
FFFC48F8 07F5F593		and		$a1,$a1,#$7f  ; ignore the table's high bit
FFFC48FC 02A58063		beq		$a1,$a0,EXMAT	;		is there a match?
FFFC4900 002E8E93		add		$t4,$t4,#2	;if not, try the next entry
FFFC4904 000F63B3		mov		$t2,$t5		; reset the program pointer
FFFC4908 000061B3		mov		r3,$x0		; sorry, no match
                        	EX1:
FFFC490C 000E0503		ldb	  $a0,[$t3]		; get to the end of the entry
FFFC4910 001E0E13		add		$t3,$t3,#1
FFFC4914 FE055CE3		bge   $a0,$x0,EX1
                        	;	and		$t1,$a0,#$80
                        	;	beq		$t1,$r0,EX1	; test for bit 7 set
FFFC4918 FC0002E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC491C 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC4920 000E0503		ldb	  $a0,[$t3]		; end of table entry?
FFFC4924 001E0E13		add		$t3,$t3,#1
FFFC4928 FA055AE3		bge   $a0,$x0,EXLP
                        	;	and		$t1,$a0,#$80
                        	;	beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC492C 000ED503		ldwu	$a0,[$t4]	; get the low mid order byte
FFFC4930 FFFC08B7		or		$a0,$a0,#$FFFC0000  ; add in ROM base
FFFC4934 00088893
FFFC4938 00A8E533
FFFC493C 00050067		jmp		[$a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC4940 110010EF		call	ENDCHK
FFFC4944 00002C37		ldi		$s8,#TXTBGN
FFFC4948 800C0C13
FFFC494C 7181A223		stt		$s8,TXTUNF[$gp]	;	set the end pointer
FFFC4950 120000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC4954 0FC010EF		call	ENDCHK
FFFC4958 C99FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SLEEP:
FFFC495C 0ED000EF		call	OREXPR		;evaluate the following expression
FFFC4960 000C64B3		mov   $s1,$s8
FFFC4964 0EC010EF	  call  ENDCHK
                        	SLEEP1:
FFFC4968 01606513	  ldi   $a0,#22   ; FMTK release I/O focus
FFFC496C 00000073	  ecall
FFFC4970 00506513	  ldi   $a0,#5    ; FMTK sleep function
FFFC4974 0004E5B3	  mov   $a1,$s1
FFFC4978 00000073	  ecall
FFFC497C 00E06513	  ldi   $a0,#14   ; FMTK get current tid
FFFC4980 00000073	  ecall
FFFC4984 01806513	  ldi   $a0,#24   ; FMTK request I/O focus
FFFC4988 00000073	  ecall
FFFC498C 23C0006F	  jmp   FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC4990 00006493	  ldi   $s1,#0
FFFC4994 FC000AE3	  bra   SLEEP1
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC4998 0B8010EF		call	ENDCHK
FFFC499C 000023B7		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC49A0 80038393
FFFC49A4 7071AC23		stt		$t2,CURRNT[$gp]
FFFC49A8 0C8000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC49AC 7181A383		ldt		$t2,CURRNT[$gp]	; executing a program?
FFFC49B0 00039463		bnez	$t2,RUN3	  ; if not, we've finished a direct stat.
                        	RUN2:
FFFC49B4 C3DFF06F		jmp		WSTART
                        	RUN3:
FFFC49B8 7071AE23	  stt   $t2,SRCHLN[$gp]
FFFC49BC 0003CE03	  ldbu  $t3,[$t2]
FFFC49C0 01C383B3	  add   $t2,$t2,$t3
FFFC49C4 7AC1A503		ldt		$a0,IRQROUT[$gp]	; are we handling IRQ's ?
FFFC49C8 04050463		beqz  $a0,RUN1
FFFC49CC 02306513		ldi   $a0,#35       ; Get IRQ flag, was there an IRQ?
FFFC49D0 00000073		ecall
FFFC49D4 020C0E63		beqz	$s8,RUN1
FFFC49D8 02406513		ldi   $a0,#36       ; Set IRQ flag
FFFC49DC 00006593		ldi   $a1,#0        ; set the flag to zero
FFFC49E0 00000073		ecall
FFFC49E4 2C8010EF		call	PUSHA_		; the same code as a GOSUB
FFFC49E8 FF410113		sub		$sp,$sp,#12
FFFC49EC 7141A503		ldt		$a0,STKGOS[$gp]
FFFC49F0 00A12023		stt		$a0,[$sp]
FFFC49F4 7181A503		ldt		$a0,CURRNT[$gp]
FFFC49F8 00A12223		stt		$a0,4[$sp]
FFFC49FC 00712423		stt		$t2,8[$sp]
FFFC4A00 7001A823		stt		$x0,LOPVAR[$gp]		; load new values
FFFC4A04 7021AA23		stt		$sp,STKGOS[$gp]
FFFC4A08 7AC1AE03		ldt		$t3,IRQROUT[$gp]
FFFC4A0C 00000C63		bra		RUNTSL
                        	RUN1:
FFFC4A10 0003EE33		mov		$t3,$t2
FFFC4A14 00006533		mov		$a0,$x0
FFFC4A18 218010EF		call	FNDNXT  		; else find the next line number
FFFC4A1C 7041A303		ldt		$t1,TXTUNF[$gp]	; if we've fallen off the end, stop
FFFC4A20 F86E7AE3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC4A24 71C1AC23		stt		$t3,CURRNT[$gp]	; set CURRNT to point to the line no.
FFFC4A28 005E0393		add		$t2,$t3,#5	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC4A2C 668010EF		call	CHKIO		; see if a control-C was pressed
FFFC4A30 FFFC4E37		ldi		$t3,#TAB2		; find command in TAB2
FFFC4A34 79FE0E13
FFFC4A38 FFFC5EB7		ldi		$t4,#TAB2_1
FFFC4A3C 856E8E93
FFFC4A40 E91FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC4A44 005000EF		call	OREXPR		;evaluate the following expression
FFFC4A48 000C62B3		mov   $t0,$s8
FFFC4A4C 004010EF		call 	ENDCHK		;must find end of line
FFFC4A50 0002E533		mov   $a0,$t0
FFFC4A54 184010EF		call 	FNDLN		; find the target line
FFFC4A58 FC0C16E3		bnez	$s8,RUNTSL  ; go do it
FFFC4A5C FFFC6537		ldi		$a0,#msgBadGotoGosub
FFFC4A60 46D50513
FFFC4A64 03C0106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC4A68 008000EF	    call    clearVars
FFFC4A6C 15C0006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC4A70 FF810113		sub		$sp,$sp,#8
FFFC4A74 00612023		stt		r6,[$sp]
FFFC4A78 00112223		stt		$ra,4[$sp]
FFFC4A7C 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC4A80 7081AC03	  ldt   $s8,VARBGN[$gp]
                        	.cv1:
FFFC4A84 000C2023	  stt		x0,[$s8]		; variable name
FFFC4A88 000C2223	  stt		x0,4[$s8]		; and value
FFFC4A8C 008C0C13	  add		s8,s8,#8
FFFC4A90 FFF30313	  sub		r6,r6,#1
FFFC4A94 FE6048E3		bgt		r6,x0,.cv1
FFFC4A98 00012303	  ldt		r6,[$sp]
FFFC4A9C 00412083	  ldt		$ra,4[$sp]
FFFC4AA0 00810113	  add		$sp,$sp,#8
FFFC4AA4 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC4AA8 7A0000EF		call	OREXPR		;evaluate the following expression
FFFC4AAC 000C62B3		mov   $t0,$s8
FFFC4AB0 7A1000EF		call 	ENDCHK		;must find end of line
FFFC4AB4 0002E533		mov   $a0,$t0
FFFC4AB8 120010EF		call 	FNDLN		; find the target line
FFFC4ABC 000C1663		bnez	$s8,ONIRQ1
FFFC4AC0 7A01A623		stt		$x0,IRQROUT[$gp]
FFFC4AC4 1040006F		jmp		FINISH
                        	ONIRQ1:
FFFC4AC8 7BC1A623		stt		$t3,IRQROUT[$gp]
FFFC4ACC 0FC0006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC4AD0 5C4010EF		call	CHKIO		; see if a control-C was pressed
FFFC4AD4 02306513		ldi   $a0,#35
FFFC4AD8 00000073		ecall
FFFC4ADC FE050AE3		beqz	$a0,WAITIRQ
FFFC4AE0 0E80006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC4AE4 488010EF		call		TSTNUM		; see if there's a line no.
FFFC4AE8 000C62B3		mov      r5,$s8
FFFC4AEC 765000EF		call		ENDCHK		; if not, we get a zero
FFFC4AF0 0002E533		mov      $a0,r5
FFFC4AF4 0E4010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC4AF8 000C1663		bnez		$s8,LS4
                        	LS5:
FFFC4AFC 7041A303		ldt		$t1,TXTUNF[$gp]
FFFC4B00 AE6E78E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC4B04 000E6533		mov		$a0,$t3
FFFC4B08 3BC010EF		call	PRTLN		; print the line
FFFC4B0C 00054E03		ldbu  $t3,[$a0]
FFFC4B10 00AE0E33		add   $t3,$t3,$a0 ; set pointer for next
                        	;	mov		$t3,$s8		
FFFC4B14 580010EF		call	CHKIO		; check for listing halt request
FFFC4B18 00050A63		beqz	$a0,LS3
FFFC4B1C 01306313		ldi		$t1,#CTRLS
FFFC4B20 00651663		bne		$a0,$t1,LS3 ; pause the listing?
                        	LS2:
FFFC4B24 570010EF		call 	CHKIO		; if so, wait for another keypress
FFFC4B28 FE050EE3		beqz	$a0,LS2
                        	LS3:
                        	;	mov		$s8,$x0
FFFC4B2C FC0008E3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC4B30 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC4B34 3EC010EF		call	TSTC		; if null list and ":"
FFFC4B38 0000003A		dw		':'
FFFC4B3C 00000663		bra		PR2
FFFC4B40 57C010EF		call	CRLF		; give CR-LF and continue
FFFC4B44 EE9FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC4B48 3D8010EF		call	TSTC		;if null list and <CR>
FFFC4B4C 0000000D		dw		CR
FFFC4B50 00000663		bra		PR0
FFFC4B54 568010EF		call	CRLF		;also give CR-LF and
FFFC4B58 E55FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC4B5C 3C4010EF		call	TSTC		;else is it a format?
FFFC4B60 00000023		dw		'#'
FFFC4B64 00000863		bra		PR1
FFFC4B68 6E0000EF		call	OREXPR		; yes, evaluate expression
FFFC4B6C 000C62B3		mov		r5,s8	; and save it as print width
FFFC4B70 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC4B74 3AC010EF		call	TSTC	;	is character expression? (MRL)
FFFC4B78 00000024		dw		'$'
FFFC4B7C 00000863		bra		PR4
FFFC4B80 6C8000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC4B84 985FF0EF		call	GOOUT	;	print low byte (MRL)
FFFC4B88 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC4B8C 1CC010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC4B90 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC4B94 38C010EF		call		TSTC	;	if ",", go find next
FFFC4B98 0000002C		dw		','
FFFC4B9C 00000663		bra		PR6
FFFC4BA0 675000EF		call		FIN		;in the list.
FFFC4BA4 FA000CE3		bra		PR0
                        	PR6:
FFFC4BA8 514010EF		call		CRLF		;list ends here
FFFC4BAC 01C0006F		jmp		FINISH
                        	PR8:
FFFC4BB0 698000EF		call	OREXPR		; evaluate the expression
FFFC4BB4 000C6533		mov		$a0,$s8
FFFC4BB8 00506593		ldi		$a1,#5		; set the width
FFFC4BBC 00A06613		ldi		$a2,#10
FFFC4BC0 230010EF		call	PRTNUM		; print its value
FFFC4BC4 FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC4BC8 64D000EF		call	FIN		; Check end of command
FFFC4BCC 6CD0006F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC4BD0 0DC010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC4BD4 674000EF		call	OREXPR		; get line number
FFFC4BD8 000C6533		mov		$a0,$s8
FFFC4BDC 7FD000EF		call	FNDLN		; find the target line
FFFC4BE0 000C1863		bnez	$s8,gosub1
FFFC4BE4 FFFC6537		ldi		a0,#msgBadGotoGosub
FFFC4BE8 46D50513
FFFC4BEC 6B50006F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC4BF0 FF410113		sub		$sp,$sp,#12
FFFC4BF4 71402503		lw		a0,STKGOS	; 'STKGOS'
FFFC4BF8 00A12023		sw		a0,[$sp]
FFFC4BFC 7181A503		lw		a0,CURRNT[$gp]	; found it, save old 'CURRNT'...
FFFC4C00 00A12223		sw		a0,4[$sp]
FFFC4C04 00712423		sw		$t2,8[$sp]
FFFC4C08 7001A823		sw		$x0,LOPVAR[$gp]		; load new values
FFFC4C0C 7021AA23		sw		$sp,STKGOS[$gp]
FFFC4C10 E15FF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC4C14 63D000EF		call	ENDCHK		; there should be just a <CR>
FFFC4C18 7141A583		ldt		$a1,STKGOS[$gp]		; get old stack pointer
FFFC4C1C 00059863		bne		a1,x0,return1
FFFC4C20 FFFC6537		ldi		a0,#msgRetWoGosub
FFFC4C24 48950513
FFFC4C28 6790006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC4C2C 0005E133		mov		$sp,a1		; else restore it
FFFC4C30 00012503		lw		a0,[$sp]
FFFC4C34 00410113		add		$sp,$sp,#4
FFFC4C38 70A1AA23		sw		a0,STKGOS[$gp]	; and the old 'STKGOS'
FFFC4C3C 00012503		lw		a0,[$sp]
FFFC4C40 00410113		add		$sp,$sp,#4
FFFC4C44 70A1AC23		stt		$a0,CURRNT[$gp]	; and the old 'CURRNT'
FFFC4C48 00012383		lw		$t2,[$sp]	; and the old text pointer
FFFC4C4C 00410113		add		$sp,$sp,#4
FFFC4C50 024010EF		call	POPA_		;and the old 'FOR' parameters
FFFC4C54 F75FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC4C58 054010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC4C5C 551000EF		call	SETVAL		; set the control variable
FFFC4C60 7181A823		stt		$s8,LOPVAR[$gp]		; save its address
FFFC4C64 FFFC5E37		ldi		$t3,#TAB5
FFFC4C68 831E0E13
FFFC4C6C FFFC5EB7		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC4C70 89EE8E93
FFFC4C74 C5DFF06F		jmp		EXEC
                        	FR1:
FFFC4C78 5D0000EF		call	OREXPR		; evaluate the limit
FFFC4C7C 7981A223		stt		$s8,LOPLMT[$gp]	; save that
FFFC4C80 FFFC5E37		ldi		$t3,#TAB6
FFFC4C84 834E0E13
FFFC4C88 FFFC5EB7		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC4C8C 8A2E8E93
FFFC4C90 C41FF06F		jmp		EXEC
                        	FR2:
FFFC4C94 5B4000EF		call	OREXPR		; found it, get the step value
FFFC4C98 00000463		bra		FR4
                        	FR3:
FFFC4C9C 00106C13		ldi		s8,#1		; not found, step defaults to 1
                        	FR4:
FFFC4CA0 7981A023		sw		s8,LOPINC[$gp]	; save that too
                        	FR5:
FFFC4CA4 7181A583		lw		a1,CURRNT[$gp]
FFFC4CA8 76B1AE23		sw		a1,LOPLN[$gp]	; save address of current line number
FFFC4CAC 7671AC23		sw		$t2,LOPPT[$gp]	; and text pointer
FFFC4CB0 000161B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC4CB4 7101A303		lw		r6,LOPVAR[$gp]
FFFC4CB8 00000463		bra		FR7
                        	FR6:
FFFC4CBC 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC4CC0 0001A583		lw		a1,[r3]		; is it zero?
FFFC4CC4 00058E63		beq		a1,x0,FR8	; if so, we're done
FFFC4CC8 FE659AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC4CCC 0001E533	  mov		a0,r3	   ; Else remove 5 words from...
FFFC4CD0 000165B3		mov		a1,$sp
FFFC4CD4 01418613		add		a2,r3,#20  ; inside the stack.
FFFC4CD8 795000EF		call	MVDOWN
FFFC4CDC 01410113		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC4CE0 EE9FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC4CE4 00006533		mov		a0,x0		; don't allocate it
FFFC4CE8 1A1000EF		call	TSTV		; get address of variable
FFFC4CEC 000C1863		bne		s8,x0,NX4
FFFC4CF0 FFFC6537		ldi		a0,#msgNextVar
FFFC4CF4 44A50513
FFFC4CF8 5A0004E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC4CFC 000C6E33		mov		$t3,s8	; save variable's address
                        	NX0:
FFFC4D00 7101A503		lw		a0,LOPVAR[$gp]	; If 'LOPVAR' is zero, we never...
FFFC4D04 00051863		bne		a0,x0,NX5	; had a FOR loop
FFFC4D08 FFFC6537		ldi		a0,#msgNextFor
FFFC4D0C 43850513
FFFC4D10 580008E3		bra		ERROR
                        	NX5:
FFFC4D14 01C50663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC4D18 75D000EF		call	POPA_		; nope, let's see the next frame
FFFC4D1C FE0002E3		bra		NX0
                        	NX2:
FFFC4D20 000E2503		lw		a0,[$t3]		; get control variable's value
FFFC4D24 7801A583		lw		a1,LOPINC[$gp]
FFFC4D28 00B50533		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC4D2C 00AE2023		sw		a0,[$t3]		; save control variable's new value
FFFC4D30 7841A183		lw		r3,LOPLMT[$gp]	; get loop's limit value
FFFC4D34 0005D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC4D38 00354E63		blt		a0,r3,NXPurge	; test against limit
FFFC4D3C 00000463		bra     NX3
                        	NX1:
FFFC4D40 00A1CA63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC4D44 77C1A383		lw		$t2,LOPLN[$gp]	; Within limit, go back to the...
FFFC4D48 7071AC23		sw		$t2,CURRNT[$gp]
FFFC4D4C 7781A383		lw		$t2,LOPPT[$gp]	; saved 'CURRNT' and text pointer.
FFFC4D50 E79FF06F		jmp		FINISH
                        	NXPurge:
FFFC4D54 721000EF	  call    POPA_        ; purge this loop
FFFC4D58 E71FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC4D5C 4EC000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC4D60 000C0463	  beqz	$s8,IF2	; is it zero? if not, continue
FFFC4D64 CC9FF06F	  jmp		RUNSML
                        	IF2:
FFFC4D68 0003EE33	  mov		$t3,$t2	; set lookup pointer
FFFC4D6C 00006533		mov		$a0,$x0		; find line #0 (impossible)
FFFC4D70 7181A503		ldt   $a0,CURRNT[$gp]  ; move to the next line
FFFC4D74 00054583		ldbu  $a1,[$a0]
FFFC4D78 00A585B3		add   $a1,$a1,$a0
FFFC4D7C 70B1AC23		stt   $a1,CURRNT[$gp]
FFFC4D80 7041A503		ldt   $a0,TXTUNF[$gp]  ; do a warm start if past end
FFFC4D84 00A5E463		bltu  $a1,$a0,IF3
FFFC4D88 869FF06F		jmp		WSTART
                        	IF3:
FFFC4D8C 0005EE33	  mov   $t3,$a1
FFFC4D90 C95FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC4D94 7A002103		ldt		$sp,STKINP		; restore the old stack pointer
FFFC4D98 00012503		ldt		$a0,[$sp]
FFFC4D9C 00410113		add		$sp,$sp,#4
FFFC4DA0 70A1AC23		stt		$a0,CURRNT[$gp]		; and old 'CURRNT'
FFFC4DA4 00012383		ldt		$t2,[$sp]		; and old text pointer
FFFC4DA8 00410113		add		$sp,$sp,#4
FFFC4DAC 01410113		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC4DB0 FEC10113		sub		$sp,$sp,#20	; allocate five words on stack
FFFC4DB4 00512823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC4DB8 00712023		sw		$t2,[$sp]	; save in case of error
FFFC4DBC 79D000EF		call	QTSTG		; is next item a string?
FFFC4DC0 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC4DC4 00106513		ldi		a0,#1		; allocate var
FFFC4DC8 0C1000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC4DCC 08050463		beq    a0,r0,IP4   ; if not, brnch
FFFC4DD0 00056EB3		mov		$t4,a0		; put away the variable's address
FFFC4DD4 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC4DD8 00712223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC4DDC 00106513		ldi		a0,#1
FFFC4DE0 0A9000EF		call	TSTV		; must be a variable now
FFFC4DE4 00051A63		bne		a0,r0,IP7
FFFC4DE8 FFFC6537		ldi		a0,#msgInputVar
FFFC4DEC 41C50513
FFFC4DF0 01410113		add		$sp,$sp,#20	; cleanup stack
FFFC4DF4 4A0006E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC4DF8 00056EB3		mov		$t4,a0		; put away the variable's address
FFFC4DFC 0003C283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC4E00 00038023		sb		x0,[$t2]
FFFC4E04 000065B3		mov		a1,x0
FFFC4E08 00412503		lw		a0,4[$sp]	; get back text pointer
FFFC4E0C 6E5000EF		call	PRTSTG		; print string as prompt
FFFC4E10 00538023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC4E14 00712223		sw		$t2,4[$sp]	; save in case of error
FFFC4E18 7181A503		lw		a0,CURRNT[$gp]
FFFC4E1C 00A12423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC4E20 FFF06513		ldi		a0,#-1
FFFC4E24 70A1AC23		sw		a0,CURRNT[$gp]	; flag that we are in INPUT
FFFC4E28 7A21A023		sw		$sp,STKINP[$gp]	; save the stack pointer too
FFFC4E2C 01D12623		sw		$t4,12[$sp]	; save the variable address
FFFC4E30 03A06513		ldi		a0,#':'		; print a colon first
FFFC4E34 4B1000EF		call	GETLN		; then get an input line
FFFC4E38 72418393		add		$t2,$gp,#BUFFER	; point to the buffer
FFFC4E3C 40C000EF		call	OREXPR		; evaluate the input
FFFC4E40 00C12E83		lw		$t4,12[$sp]	; restore the variable address
FFFC4E44 00AEA023		sw		a0,[$t4]	; save value in variable
FFFC4E48 00812503		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC4E4C 70A1AC23		sw		a0,CURRNT[$gp]
FFFC4E50 00412383		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC4E54 0CC010EF		call	TSTC
FFFC4E58 0000002C		dw		','
FFFC4E5C 00000463		bra		IP5
FFFC4E60 F4000CE3		bra		IP6			; yes, more items
                        	IP5:
FFFC4E64 01012283		lw		r5,16[$sp]
FFFC4E68 01410113		add		$sp,$sp,#20	; cleanup stack
FFFC4E6C D5DFF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC4E70 0003C503	  lbu    	a0,[$t2]
FFFC4E74 00D06313	  ldi			$t1,#CR
FFFC4E78 D46508E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC4E7C 331000EF	  call	SETVAL		; do the assignment
FFFC4E80 0A0010EF		call	TSTC		; check for more 'LET' items
FFFC4E84 0000002C		dw		','
FFFC4E88 D41FF06F		jmp		FINISH
FFFC4E8C FE0008E3		bra	    LET
                        	LT1:
FFFC4E90 D39FF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC4E94 000023B7		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC4E98 80038393
FFFC4E9C 00D06513		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC4EA0 E70FF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC4EA4 E74FF0EF		call	GOAUXI		; look for start of line
FFFC4EA8 FEA05EE3		ble		a0,r0,LOD1
FFFC4EAC 04006313		ldi		$t1,#'@'
FFFC4EB0 02650E63		beq		a0,$t1,LODEND	; end of program?
FFFC4EB4 01A06313		ldi		$t1,#$1A
FFFC4EB8 02650A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC4EBC 03A06313		ldi		$t1,#':'
FFFC4EC0 FE6512E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC4EC4 030000EF		call	GCHAR		; get line number
FFFC4EC8 00A3A023		sw		a0,[$t2]		; store it
FFFC4ECC 00438393		add		$t2,$t2,#4
                        	LOD2:
FFFC4ED0 E48FF0EF		call	GOAUXI		; get another text char.
FFFC4ED4 FEA05EE3		ble		a0,r0,LOD2
FFFC4ED8 00A38023		sb		a0,[$t2]		; store it
FFFC4EDC 00138393		add		$t2,$t2,#1
FFFC4EE0 00D06313		ldi		$t1,#CR
FFFC4EE4 FE6516E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC4EE8 FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC4EEC 70702223		sw		$t2,TXTUNF	; set end-of program pointer
FFFC4EF0 F00FF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC4EF4 FF410113		sub		$sp,$sp,#12
FFFC4EF8 00512023		sw		r5,[$sp]
FFFC4EFC 00612223		sw		r6,4[$sp]
FFFC4F00 00112423		sw		$ra,8[$sp]
FFFC4F04 00806313		ldi		r6,#8       ; repeat ten times
FFFC4F08 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC4F0C E0CFF0EF		call	GOAUXI		; get a char
FFFC4F10 FEA05EE3		ble		a0,r0,GCHAR1
FFFC4F14 02C000EF		call	asciiToHex
FFFC4F18 00429293		sll		r5,r5,#4
FFFC4F1C 00A2E2B3		or		r5,r5,a0
FFFC4F20 FFF30313		sub		r6,r6,#1
FFFC4F24 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC4F28 0002E533		mov		a0,r5
FFFC4F2C 00012283		lw		r5,[$sp]
FFFC4F30 00412303		lw		r6,4[$sp]
FFFC4F34 00812083		lw		$ra,8[$sp]
FFFC4F38 00C10113		add		$sp,$sp,#12
FFFC4F3C 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC4F40 03906313		ldi		$t1,#'9'
FFFC4F44 00A37463		bleu	a0,$t1,a2h1; less than '9'
FFFC4F48 FF950513		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC4F4C FD050513		sub		a0,a0,#'0'
FFFC4F50 00F57513		and		a0,a0,#15	; make sure a nybble
FFFC4F54 00008067		ret
                        	
                        	GetFilename:
FFFC4F58 FFC10113		sub		$sp,$sp,#4
FFFC4F5C 00112023		sw		$ra,[$sp]
FFFC4F60 7C1000EF		call	TSTC
FFFC4F64 00000022		dw		'"'
FFFC4F68 04000C63		bra		gfn1
FFFC4F6C 000061B3		mov		r3,r0
                        	gfn2:
FFFC4F70 0003C503		lbu		a0,[$t2]		; get text character
FFFC4F74 00138393		add		$t2,$t2,#1
FFFC4F78 02206313		ldi		$t1,#'"'
FFFC4F7C 02650263		beq		a0,$t1,gfn3
FFFC4F80 02050063		beq		a0,r0,gfn3
FFFC4F84 6CA18023		sb		a0,FILENAME[r3]
FFFC4F88 00118193		add		r3,r3,#1
FFFC4F8C 04006313		ldi		$t1,#64
FFFC4F90 FE61E0E3		bltu	r3,$t1,gfn2
FFFC4F94 00012083		lw		$ra,[$sp]
FFFC4F98 00410113		add		$sp,$sp,#4
FFFC4F9C 00008067		ret
                        	gfn3:
FFFC4FA0 02006513		ldi		a0,#' '
FFFC4FA4 6CA18023		sb		a0,FILENAME[r3]
FFFC4FA8 00118193		add		r3,r3,#1
FFFC4FAC 04006313		ldi		$t1,#64
FFFC4FB0 FE61E8E3		bltu	r3,$t1,gfn3
FFFC4FB4 00012083		lw		$ra,[$sp]
FFFC4FB8 00410113		add		$sp,$sp,#4
FFFC4FBC 00008067		ret
                        	gfn1:
FFFC4FC0 E30FF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC4FC4 F95FF0EF		call	GetFilename
FFFC4FC8 000008B7		call	AUXIN_INIT
FFFC4FCC 49D880E7
FFFC4FD0 EC5FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC4FD4 000015B7		ldi		a1,#$E00
FFFC4FD8 E0058593
FFFC4FDC 000008B7		call	SDReadSector
FFFC4FE0 49E880E7
FFFC4FE4 00150513		add		a0,a0,#1
FFFC4FE8 000025B7		ldi		a1,#TXTBGN
FFFC4FEC 80058593
                        	LOAD4:
FFFC4FF0 FFC10113		sub		$sp,$sp,#4
FFFC4FF4 00A12023		sw		a0,[$sp]
FFFC4FF8 000008B7		call	SDReadSector
FFFC4FFC 49E880E7
FFFC5000 20058593		add		a1,a1,#512
FFFC5004 00012503		lw		a0,[$sp]
FFFC5008 00410113		add		$sp,$sp,#4
FFFC500C 00150513		add		a0,a0,#1
FFFC5010 00002237		ldi		r4,#TXTBGN
FFFC5014 80020213
FFFC5018 000108B7		add		r4,r4,#65536
FFFC501C 00088893
FFFC5020 00488233
FFFC5024 FC45C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC5028 DC000463		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC502C F2DFF0EF		call	GetFilename
FFFC5030 000008B7		call	AUXOUT_INIT
FFFC5034 4A1880E7
FFFC5038 0600006F		jmp		SAVE
                        	
FFFC503C 20C000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC5040 000015B7		ldi		a1,#$E00	; starting address to write
FFFC5044 E0058593
FFFC5048 000008B7		call	SDWriteSector
FFFC504C 4A3880E7
FFFC5050 00150513		add		a0,a0,#1
FFFC5054 000025B7		ldi		a1,#TXTBGN
FFFC5058 80058593
                        	SAVE4:
FFFC505C FFC10113		sub		$sp,$sp,#4
FFFC5060 00A12023		sw		a0,[$sp]
FFFC5064 000008B7		call	SDWriteSector
FFFC5068 4A3880E7
FFFC506C 20058593		add		a1,a1,#512
FFFC5070 00012503		lw		a0,[$sp]
FFFC5074 00410113		add		$sp,$sp,#4
FFFC5078 00150513		add		a0,a0,#1
FFFC507C 00002237		ldi		r4,#TXTBGN
FFFC5080 80020213
FFFC5084 000108B7		add		r4,r4,#65536
FFFC5088 00088893
FFFC508C 00488233
FFFC5090 FC45C6E3		blt		a1,r4,SAVE4
FFFC5094 D4000E63		bra		WSTART
                        	
                        	SAVE:
FFFC5098 000028B7		add		$t2,$gp,#TXTBGN	;set pointer to start of prog. area
FFFC509C 80088893
FFFC50A0 003883B3
FFFC50A4 7041AE03		lw		$t3,TXTUNF[$gp]	;set pointer to end of prog. area
                        	SAVE1:
FFFC50A8 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC50AC 027E4863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC50B0 03A06513		ldi		a0,#':'		; if not, start a line
FFFC50B4 C5CFF0EF		call	GOAUXO
FFFC50B8 0003A503		lw		a0,[$t2]		; get line number
FFFC50BC 00438393		add		$t2,$t2,#4
FFFC50C0 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC50C4 0003C503		lbu		a0,[$t2]		; get a text char.
FFFC50C8 00138393		add		$t2,$t2,#1
FFFC50CC 00D06313		ldi		$t1,#CR
FFFC50D0 FC650CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC50D4 C3CFF0EF		call	GOAUXO		; send it out
FFFC50D8 FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC50DC 04006513		ldi		a0,#'@'		; send end-of-program indicator
FFFC50E0 C30FF0EF		call	GOAUXO
FFFC50E4 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC50E8 01A06513		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC50EC C24FF0EF		call	GOAUXO
FFFC50F0 000008B7		call	AUXOUT_FLUSH
FFFC50F4 4AA880E7
FFFC50F8 CE000C63		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC50FC FFC10113		sub		$sp,$sp,#4
FFFC5100 00112023		sw		$ra,[$sp]
FFFC5104 00D06513	  ldi		a0,#CR
FFFC5108 C08FF0EF	  call	GOAUXO
FFFC510C 00A06513	  ldi		a0,#LINEFD
FFFC5110 C00FF0EF	  call	GOAUXO
FFFC5114 00012083	  lw		$ra,[$sp]
FFFC5118 00410113	  add		$sp,$sp,#4
FFFC511C 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC5120 FF810113		sub		$sp,$sp,#8
FFFC5124 00512023		sw		r5,[$sp]
FFFC5128 00112223		sw		$ra,4[$sp]
FFFC512C 7AA18293		add		r5,$gp,#NUMWKA+14
FFFC5130 00056233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC5134 00026533	  mov   a0,r4	    ; a0 = value
FFFC5138 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC513C 038000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC5140 00A28023	  sb    a0,[r5]		; save in work area
FFFC5144 FFF28293	  sub		r5,r5,#1
FFFC5148 79C18313	  add		$t1,$gp,#NUMWKA
FFFC514C FE62D4E3		bge		r5,$t1,pword1
                        	pword2:
FFFC5150 00128293	  add		r5,r5,#1
FFFC5154 0002C503	  lbu   a0,[r5]     ; get char to output
FFFC5158 BB8FF0EF		call	GOAUXO		; send it
FFFC515C 7AA18313		add		$t1,$gp,#NUMWKA+14
FFFC5160 FE62C8E3		blt		r5,$t1,pword2
FFFC5164 00012283		lw		r5,[$sp]
FFFC5168 00412083		lw		$ra,4[$sp]
FFFC516C 00810113		add		$sp,$sp,#8
FFFC5170 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC5174 00F57513		and		a0,a0,#15	; make sure it's a nybble
FFFC5178 00A06313		ldi		$t1,#10
FFFC517C 00654463		blt		a0,$t1,tah1	; > 10 ?
FFFC5180 00750513		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC5184 03050513		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC5188 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC518C 0BC000EF		call	OREXPR		; get the memory address
FFFC5190 591000EF		call	TSTC		; it must be followed by a comma
FFFC5194 0000002C		dw		','
FFFC5198 06000C63		bra		PKER
FFFC519C FFC10113		sub		$sp,$sp,#4
FFFC51A0 00A12023		sw		a0,[$sp]	; save the address
FFFC51A4 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC51A8 00012583		lw		a1,[$sp]	; get the address back
FFFC51AC 00410113		add		$sp,$sp,#4
FFFC51B0 00A58023		sb		a0,[a1]		; store the byte in memory
FFFC51B4 A15FF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC51B8 090000EF		call	OREXPR		; get the memory address
FFFC51BC 565000EF		call	TSTC		; it must be followed by a comma
FFFC51C0 0000002C		dw		','
FFFC51C4 04000663		bra		PKER
FFFC51C8 FFC10113		sub		$sp,$sp,#4
FFFC51CC 00A12023		sw		a0,[$sp]	; save the address
FFFC51D0 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC51D4 00012583		lw		a1,[$sp]	; get the address back
FFFC51D8 00410113		add		$sp,$sp,#4
FFFC51DC 00A5A023		sw		a0,[a1]		; store the byte in memory
FFFC51E0 9E9FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC51E4 064000EF		call	OREXPR		; get the memory address
FFFC51E8 539000EF		call	TSTC		; it must be followed by a comma
FFFC51EC 0000002C		dw		','
FFFC51F0 02000063		bra		PKER
FFFC51F4 FFC10113		sub		$sp,$sp,#4
FFFC51F8 00A12023		sw		a0,[$sp]	; save the address
FFFC51FC 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC5200 00012583		lw		a1,[$sp]	; get the address back
FFFC5204 00410113		add		$sp,$sp,#4
FFFC5208 00A59023		sh		a0,[a1]		; store the byte in memory
FFFC520C 9BDFF06F		jmp		FINISH
                        	
                        	PKER:
FFFC5210 FFFC6537		ldi		a0,#msgComma
FFFC5214 3BA50513
FFFC5218 0890006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC521C 02C000EF		call	OREXPR		; get the subroutine's address
FFFC5220 000C1863		bne		s8,r0,sysx1; make sure we got a valid address
FFFC5224 FFFC6537		ldi		a0,#msgSYSBad
FFFC5228 40B50513
FFFC522C 0750006F		jmp		ERROR
                        	sysx1:
FFFC5230 FFC10113		sub		$sp,$sp,#4
FFFC5234 00712023		stt		$t2,[$sp]	; save the text pointer
FFFC5238 000C00E7		call	[s8]			; jump to the subroutine
FFFC523C 00012383		ldt		$t2,[$sp]	; restore the text pointer
FFFC5240 00410113		add		$sp,$sp,#4
FFFC5244 985FF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC5248 FF41310D		gcsub	$sp,$sp,#12
FFFC524C 00112023		sw		$ra,[$sp]
FFFC5250 00312223		sw		r3,4[$sp]
FFFC5254 00412423		sw		r4,8[$sp]
FFFC5258 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC525C FF810113		sub		$sp,$sp,#8
FFFC5260 01812023		sw		$s8,[$sp]		; save <ANDEXPR> value
FFFC5264 01912223		sw		$s9,4[$sp]	; save type
FFFC5268 FFFC5E37		ldi		$t3,#TAB10	; look up a logical operator
FFFC526C 847E0E13
FFFC5270 FFFC5EB7		ldi		$t4,#TAB10_1
FFFC5274 8B8E8E93
FFFC5278 E58FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC527C 034000EF	  call	ANDEXPR
FFFC5280 00012503	  lw		$a0,[$sp]
FFFC5284 00810113	  add		$sp,$sp,#8
FFFC5288 00AC6C33	  or    s8,s8,a0
FFFC528C FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC5290 00012C03	  lw		$s8,[$sp]
FFFC5294 00412C83	  lw		$s9,4[$sp]
FFFC5298 00810113	  add		$sp,$sp,#8
FFFC529C 00012083		lw		$ra,[$sp]
FFFC52A0 00412183		lw		r3,4[$sp]
FFFC52A4 00812203		lw		r4,8[$sp]
FFFC52A8 00C10113		add		$sp,$sp,#12
FFFC52AC 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC52B0 FFC10113		sub		$sp,$sp,#4
FFFC52B4 00112023		sw		$ra,[$sp]
FFFC52B8 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC52BC FF810113		sub		$sp,$sp,#8
FFFC52C0 01812023		sw		$s8,[$sp]		; save <EXPR> value
FFFC52C4 01912223		sw		$s9,4[$sp]	; save type
FFFC52C8 FFFC5E37		ldi		$t3,#TAB9		; look up a logical operator
FFFC52CC 843E0E13
FFFC52D0 FFFC5EB7		ldi		$t4,#TAB9_1
FFFC52D4 8B4E8E93
FFFC52D8 DF8FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC52DC 0C4000EF	  call	EXPR
FFFC52E0 00012503	  lw		$a0,[$sp]
FFFC52E4 00810113	  add		$sp,$sp,#8
FFFC52E8 00AC7C33	  and   s8,s8,a0
FFFC52EC FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC52F0 00012C03	  lw		$s8,[$sp]
FFFC52F4 00412C83	  lw		$s9,4[$sp]
FFFC52F8 00810113	  add		$sp,$sp,#8
FFFC52FC 00012083		lw		$ra,[$sp]
FFFC5300 00410113		add		$sp,$sp,#4
FFFC5304 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC5308 03006313		ldi		$t1,#'0'
FFFC530C 00654A63		blt		$a0,$t1,isDigitFalse
FFFC5310 03906313		ldi		$t1,#'9'
FFFC5314 00A34663		bgt		$a0,$t1,isDigitFalse
FFFC5318 00106C13		ldi		$s8,#1
FFFC531C 00008067	  ret
                        	isDigitFalse:
FFFC5320 00006C33	  mov		$s8,$x0
FFFC5324 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC5328 04106313		ldi		$t1,#'A'
FFFC532C 02654263		blt		$a0,$t1,isAlphaFalse
FFFC5330 05A06313		ldi		$t1,#'Z'
FFFC5334 00A35A63		ble		$a0,$t1,isAlphaTrue
FFFC5338 06106313		ldi		$t1,#'a'
FFFC533C 00654A63		blt		$a0,$t1,isAlphaFalse
FFFC5340 07A06313		ldi		$t1,#'z'
FFFC5344 00A34663		bgt		$a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC5348 00106C13	  ldi		$s8,#1
FFFC534C 00008067	  ret
                        	isAlphaFalse:
FFFC5350 00006C33	  mov		$s8,$x0
FFFC5354 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC5358 FFC10113		sub		$sp,$sp,#4
FFFC535C 00112023		sw		$ra,[$sp]
FFFC5360 FA9FF0EF	  call	isDigit
FFFC5364 000C1463		bne		s8,r0,isDigitx	; if it is a digit
FFFC5368 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC536C 00012083		lw		$ra,[$sp]
FFFC5370 00410113		add		$sp,$sp,#4
FFFC5374 00008067	  ret
                        	
                        	FORCEFIT:
FFFC5378 03958263		beq		a1,s9,.0001				; types match
FFFC537C 00006293		ldi		$t0,#0
FFFC5380 00558663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$s8
FFFC5384 00106513		ldi		a0,#1
FFFC5388 00008067		ret
                        	.intAnd:
FFFC538C 00106293		ldi		$t0,#1
FFFC5390 005C9663		bne		$s9,$t0,.0001
                        	;	itof	$f2,$a1
FFFC5394 00106593		ldi		$a1,#1
FFFC5398 00008067		ret
                        	.0001:
FFFC539C 00008067		ret
                        	
                        	EXPR:
FFFC53A0 FFC10113		sub		$sp,$sp,#4
FFFC53A4 00112023		sw		$ra,[$sp]
FFFC53A8 11C000EF		call	ADDEXPR
FFFC53AC FF810113		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC53B0 01812023		sw		s8,[$sp]
FFFC53B4 01912223		sw		s9,4[$sp]					; save type
FFFC53B8 FFFC5E37		ldi		$t3,#TAB8		; look up a relational operator
FFFC53BC 839E0E13
FFFC53C0 FFFC5EB7		ldi		$t4,#TAB8_1
FFFC53C4 8A6E8E93
FFFC53C8 D08FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC53CC 00012503		lw		a0,[$sp]
FFFC53D0 00412583		lw		a1,4[$sp]
FFFC53D4 00810113		add		$sp,$sp,#8
FFFC53D8 0C4000EF		call	XP18	; is it ">="?
FFFC53DC 09855A63		bge		a0,s8,XPRT1	; no, return s8=1
FFFC53E0 06000E63		bra		XPRT0	; else return s8=0
                        	XP12:
FFFC53E4 00012503		lw		a0,[$sp]
FFFC53E8 00412583		lw		a1,4[$sp]
FFFC53EC 00810113		add		$sp,$sp,#8
FFFC53F0 0AC000EF		call	XP18	; is it "<>"?
FFFC53F4 07851E63		bne		a0,s8,XPRT1	; no, return a1=1
FFFC53F8 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC53FC 00012503		lw		a0,[$sp]
FFFC5400 00412583		lw		a1,4[$sp]
FFFC5404 00810113		add		$sp,$sp,#8
FFFC5408 094000EF		call	XP18	; is it ">"?
FFFC540C 06AC4263		bgt		a0,s8,XPRT1	; no, return a1=1
FFFC5410 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC5414 00012503		lw		a0,[$sp]
FFFC5418 00412583		lw		a1,4[$sp]
FFFC541C 00810113		add		$sp,$sp,#8
FFFC5420 07C000EF		call	XP18	; is it "<="?
FFFC5424 04AC5663		ble		a0,s8,XPRT1	; no, return a1=1
FFFC5428 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC542C 00012503		lw		a0,[$sp]
FFFC5430 00412583		lw		a1,4[$sp]
FFFC5434 00810113		add		$sp,$sp,#8
FFFC5438 064000EF		call	XP18	; is it "="?
FFFC543C 03850A63		beq		a0,s8,XPRT1	; if not, return a1=1
FFFC5440 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC5444 00012503		lw		a0,[$sp]
FFFC5448 00412583		lw		a1,4[$sp]
FFFC544C 00810113		add		$sp,$sp,#8
FFFC5450 04C000EF		call	XP18	; is it "<"?
FFFC5454 01854E63		blt		a0,s8,XPRT1	; if not, return a1=1
FFFC5458 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC545C 00006C33		mov		s8,x0   ; return a0=0 (false)
FFFC5460 00006CB3		mov		s9,x0		; type = int
FFFC5464 00012083		lw		$ra,[$sp]
FFFC5468 00410113		add		$sp,$sp,#4
FFFC546C 00008067		ret
                        	XPRT1:
FFFC5470 00106C13		ldi		s8,#1	; return a0=1 (true)
FFFC5474 00006C93		ldi		s9,#0	; type = int
FFFC5478 00012083		lw		$ra,[$sp]
FFFC547C 00410113		add		$sp,$sp,#4
FFFC5480 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC5484 00012C03		lw		s8,[$sp]; return a1=<ADDEXPR>
FFFC5488 00412C83		lw		s9,4[$sp]
FFFC548C 00810113		add		$sp,$sp,#8
FFFC5490 00012083		lw		$ra,[$sp]
FFFC5494 00410113		add		$sp,$sp,#4
FFFC5498 00008067		ret
                        	
                        	XP18:
FFFC549C FF410113		sub		$sp,$sp,#12
FFFC54A0 00112023		sw		$ra,[$sp]
FFFC54A4 01812223		sw		s8,4[$sp]
FFFC54A8 01912423		sw		s9,8[$sp]
FFFC54AC 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC54B0 00412503		lw		a0,4[$sp]
FFFC54B4 00812583		lw		a1,8[$sp]
FFFC54B8 00012083		lw		$ra,[$sp]
FFFC54BC 00C10113		add		$sp,$sp,#12
FFFC54C0 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC54C4 FFC10113		sub		$sp,$sp,#4
FFFC54C8 00112023		sw		$ra,[$sp]
FFFC54CC 255000EF		call	TSTC		; negative sign?
FFFC54D0 0000002D		dw		'-'
FFFC54D4 00000C63		bra		XP21
FFFC54D8 00006C33		mov		s8,r0		; yes, fake '0-'
FFFC54DC FF810113		sub		$sp,$sp,#8
FFFC54E0 01812023		sw		s8,[$sp]
FFFC54E4 01912223		sw		s9,4[$sp]
FFFC54E8 04000863		bra		XP26
                        	XP21:
FFFC54EC 235000EF		call	TSTC		; positive sign? ignore it
FFFC54F0 0000002B		dw		'+'
FFFC54F4 00000263		bra		XP22
                        	XP22:
FFFC54F8 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC54FC FF810113		sub		$sp,$sp,#8; yes, save the value
FFFC5500 01812023		sw		s8,[$sp]
FFFC5504 01912223		sw		s9,4[$sp]	; and type
FFFC5508 219000EF		call	TSTC		; add?
FFFC550C 0000002B		dw		'+'
FFFC5510 00000E63		bra		XP25
FFFC5514 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC5518 00012503		lw		a0,[$sp]
FFFC551C 00412583		lw		a1,4[$sp]
FFFC5520 00810113		add		$sp,$sp,#8
FFFC5524 00AC0C33		add		s8,s8,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC5528 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC552C 1F5000EF		call	TSTC		; subtract?
FFFC5530 0000002D		dw		'-'
FFFC5534 00000863		bra		XP45
                        	XP26:
FFFC5538 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC553C 41800C33		sub		s8,r0,s8	; change its sign
FFFC5540 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC5544 00012C03		lw		s8,[$sp]
FFFC5548 00412C83		lw		s9,4[$sp]
FFFC554C 00810113		add		$sp,$sp,#8
FFFC5550 00012083		lw		$ra,[$sp]
FFFC5554 00410113		add		$sp,$sp,#4
FFFC5558 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC555C FFC10113		sub		$sp,$sp,#4
FFFC5560 00112023		sw		$ra,[$sp]
FFFC5564 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC5568 FF810113		sub		$sp,$sp,#8
FFFC556C 01812023		sw		s8,[$sp]; yes, save that first result
FFFC5570 01912223		sw		s9,4[$sp]
FFFC5574 1AD000EF		call	TSTC		; multiply?
FFFC5578 0000002A		dw		'*'
FFFC557C 00000E63		bra		XP34
FFFC5580 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC5584 00012503		lw		a0,[$sp]
FFFC5588 00412583		lw		a1,4[$sp]
FFFC558C 00810113		add		$sp,$sp,#8
FFFC5590 02AC0C33		mul		s8,s8,a0	; multiply the two
FFFC5594 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC5598 189000EF		call	TSTC		; divide?
FFFC559C 0000002F		dw		'/'
FFFC55A0 00000E63		bra		XP35
FFFC55A4 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC55A8 00012503		lw		a0,[$sp]
FFFC55AC 00412583		lw		a1,4[$sp]
FFFC55B0 00810113		add		$sp,$sp,#8
FFFC55B4 02AC4C33		div		s8,s8,a0	; do the division
FFFC55B8 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC55BC 165000EF		call	TSTC
FFFC55C0 00000025		dw		'%'
FFFC55C4 00000E63		bra		XP47
FFFC55C8 030000EF		call	FUNCEXPR
FFFC55CC 00012503		lw		a0,[$sp]
FFFC55D0 00412583		lw		a1,4[$sp]
FFFC55D4 00810113		add		$sp,$sp,#8
FFFC55D8 02AC6C33		rem		s8,s8,a0
FFFC55DC F80006E3		bra		XP31
                        	XP47:
FFFC55E0 00012C03		lw		s8,[$sp]
FFFC55E4 00412C83		lw		s9,4[$sp]
FFFC55E8 00810113		add		$sp,$sp,#8
FFFC55EC 00012083		lw		$ra,[$sp]
FFFC55F0 00410113		add		$sp,$sp,#4
FFFC55F4 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC55F8 FFC1310D		gcsub	$sp,$sp,#4
FFFC55FC 00112023		stt		$ra,[$sp]
FFFC5600 FFFC4E37	  ldi		$t3,#TAB4		; find possible function
FFFC5604 7F8E0E13
FFFC5608 FFFC5EB7	  ldi		$t4,#TAB4_1
FFFC560C 884E8E93
FFFC5610 AC0FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC5614 00006533		mov		$a0,$x0
FFFC5618 070000EF		call	TSTV
FFFC561C 000C0A63		beqz  $s8,XP41	  ; not a variable
FFFC5620 000C2C03		ldt		$s8,[$s8]		; if a variable, return its value in s8
FFFC5624 00012083		ldt		$ra,[$sp]
FFFC5628 00410113		add		$sp,$sp,#4
FFFC562C 00008067		ret
                        	XP41:
FFFC5630 13D000EF		call	TSTNUM		; or is it a number?
FFFC5634 000C9463		bnez	$s9,XP46	; (if not, # of digits will be zero) if so, return it in s8
FFFC5638 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC563C 00012083		ldt		$ra,[$sp]
FFFC5640 00410113		add		$sp,$sp,#4
FFFC5644 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC5648 FFC1310D		gcsub	$sp,$sp,#4
FFFC564C 00112023		stt		$ra,[$sp]	
FFFC5650 0D1000EF		call	TSTC		; else look for ( OREXPR )
FFFC5654 00000028		dw		'('
FFFC5658 02000063		bra		XP43
FFFC565C BEDFF0EF		call	OREXPR
FFFC5660 0C1000EF		call	TSTC
FFFC5664 00000029		dw		')'
FFFC5668 00000863		bra		XP43
                        	XP42:
FFFC566C 00012083		ldt		$ra,[$sp]
FFFC5670 00410113		add		$sp,$sp,#4
FFFC5674 00008067		ret
                        	XP43:
FFFC5678 00410113		add		$sp,$sp,#4		; get rid of return address
FFFC567C FFFC6537		ldi		$a0,#msgWhat
FFFC5680 34050513
FFFC5684 41C0006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		s8 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC5688 FF810113		sub		$sp,$sp,#8
FFFC568C 00512023		sw		r5,[$sp]
FFFC5690 00112223		sw		$ra,4[$sp]
FFFC5694 000562B3		mov		r5,a0		; r5=allocate flag
FFFC5698 145000EF		call	IGNBLK
FFFC569C 0003C503		lbu		a0,[$t2]		; look at the program text
FFFC56A0 04006313		ldi		$t1,#'@'
FFFC56A4 06654263		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC56A8 02651E63		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC56AC 00138393		add		$t2,$t2,#1	; If it is, it should be
FFFC56B0 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC56B4 00000263		bra		TV3
                        	TV3:
FFFC56B8 FFC10113		sub		$sp,$sp,#4	; save the index
FFFC56BC 01812023		sw		s8,[$sp]
FFFC56C0 2D0000EF		call	SIZEX		; get amount of free memory
FFFC56C4 00012583		lw		a1,[$sp]
FFFC56C8 00410113		add		$sp,$sp,#4	; get back the index
FFFC56CC 0185C663		blt		a1,s8,TV2		; see if there's enough memory
FFFC56D0 00810113		add		$sp,$sp,#8
FFFC56D4 3B80006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC56D8 7081A503		lw		a0,VARBGN[$gp]	; put address of array element...
FFFC56DC 40B50C33		sub   s8,a0,a1    ; into a0 (neg. offset is used)
FFFC56E0 00000C63		bra   TSTVRT
                        	TV1:	
FFFC56E4 038000EF	  call	getVarName      ; get variable name
FFFC56E8 000C0863	  beq   s8,x0,TSTVRT    ; if not, return s8=0
FFFC56EC 000C6533	  mov		a0,s8
FFFC56F0 0002E5B3	  mov		a1,r5
FFFC56F4 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC56F8 00012283		lw		r5,[$sp]
FFFC56FC 00412083		lw		$ra,4[$sp]
FFFC5700 00810113		add		$sp,$sp,#8
FFFC5704 00008067		ret								; s8<>0 (if found)
                        	tstv_notfound:
FFFC5708 00012283		lw		r5,[$sp]
FFFC570C 00412083		lw		$ra,4[$sp]
FFFC5710 00810113		add		$sp,$sp,#8
FFFC5714 00006C33		mov		s8,x0				; s8=0 if not found
FFFC5718 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   s8 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC571C FF41310D		gcsub	$sp,$sp,#12
FFFC5720 00512023		sw		r5,[$sp]
FFFC5724 00112223		sw		$ra,4[$sp]
FFFC5728 0003C503	  lbu   a0,[$t2]		; get first character
FFFC572C 00A12423	  sw		a0,8[$sp]		; save off current name
FFFC5730 BF9FF0EF	  call	isAlpha
FFFC5734 080C0063	  beq   s8,r0,gvn1
FFFC5738 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC573C 00138393		add		$t2,$t2,#1
FFFC5740 0003C503		lbu   a0,[$t2]		; do we have another char ?
FFFC5744 C15FF0EF		call	isAlnum
FFFC5748 020C0863		beq   s8,x0,gvn2	; nope
FFFC574C 00812503		lw		a0,8[$sp]		; get varname
FFFC5750 00851513		sll		a0,a0,#8
FFFC5754 0003C583		lbu   a1,[$t2]
FFFC5758 00B56533		or    a0,a0,a1   	; add in new char
FFFC575C 00A12423	  sw		a0,8[$sp]		; save off current name again
FFFC5760 FFF28293	  sub		r5,r5,#1
FFFC5764 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC5768 00138393		add		$t2,$t2,#1
FFFC576C 0003C503		lbu   a0,[$t2]		; do we have another char ?
FFFC5770 BE9FF0EF	  call  isAlnum
FFFC5774 FE0C1AE3	  bne   s8,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC5778 0003C583		lbu   a1,[$t2]
FFFC577C 02506313		ldi		$t1,#'%'
FFFC5780 00658A63		beq		a1,$t1,gvn3
FFFC5784 02406313		ldi		$t1,#'$'
FFFC5788 00658663		beq		a1,$t1,gvn3
FFFC578C FFF38393	  sub		$t2,$t2,#1
FFFC5790 02E06593	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC5794 00138393		add		$t2,$t2,#1
FFFC5798 00812503		lw		a0,8[$sp]		; get varname
FFFC579C 00851513		sll		a0,a0,#8
FFFC57A0 00B56C33	  or    s8,a0,a1    ; add in variable type
FFFC57A4 00012283	  lw		r5,[$sp]
FFFC57A8 00412083	  lw		$ra,4[$sp]
FFFC57AC 00C10113	  add		$sp,$sp,#12
FFFC57B0 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC57B4 00012283		lw		r5,[$sp]
FFFC57B8 00412083	  lw		$ra,4[$sp]
FFFC57BC 00C10113		add		$sp,$sp,#12
FFFC57C0 00006C33	  mov		s8,x0       ; return s8 = 0 if not a varname
FFFC57C4 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   s8 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC57C8 FF810113		sub		$sp,$sp,#8
FFFC57CC 00712023		sw		x7,[$sp]
FFFC57D0 00312223		sw		x3,4[$sp]
FFFC57D4 7081A183	  lw    x3,VARBGN[$gp]
                        	fv4:
FFFC57D8 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC57DC 02038663	  beq   x7,x0,fv3		; no more vars ?
FFFC57E0 02750863	  beq   a0,x7,fv1		; match ?
FFFC57E4 00818193		add		x3,x3,#8		; move to next var
FFFC57E8 70C1A383	  ldt   x7,VAREND[$gp]		; 
FFFC57EC FE71C6E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC57F0 00012383	  lw		x7,[$sp]
FFFC57F4 00412183	  lw		x3,4[$sp]
FFFC57F8 00810113	  add		$sp,$sp,#8
FFFC57FC FFFC6537	  ldi		a0,#msgVarSpace
FFFC5800 38E50513
FFFC5804 29C0006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC5808 00058E63		beq		a1,x0,fv2
FFFC580C 00A1A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC5810 00418C13	  add		s8,x3,#4
FFFC5814 00012383	  lw		x7,[$sp]
FFFC5818 00412183	  lw		x3,4[$sp]
FFFC581C 00810113	  add		$sp,$sp,#8
FFFC5820 00008067	  ret			    			; s8 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC5824 00012383	  lw		x7,[$sp]
FFFC5828 00412183	  lw		x3,4[$sp]
FFFC582C 00810113	  add		$sp,$sp,#8
FFFC5830 00006C33		mov		s8,x0				; s8 = nullptr
FFFC5834 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC5838 E11FF0EF		call	PARN		; get the memory address
FFFC583C 000C0C03		ldb		$s8,[$s8]	; get the addressed byte
FFFC5840 00006CB3		mov		$s9,$x0		; type = int
FFFC5844 00012083		ldt		$ra,[$sp]
FFFC5848 00410113		add		$sp,$sp,#4
FFFC584C 00008067		ret
                        	PEEKW:
FFFC5850 DF9FF0EF		call	PARN		; get the memory address
FFFC5854 000C2C03		ldt		$s8,[$s8]		; get the addressed word
FFFC5858 00006CB3		mov		$s9,$x0			; type = int
FFFC585C 00012083		ldt		$ra,[$sp]
FFFC5860 00410113		add		$sp,$sp,#4
FFFC5864 00008067		ret
                        	PEEKH:
FFFC5868 DE1FF0EF		call	PARN		; get the memory address
FFFC586C 000C1C03		ldw		$s8,[$s8]		; get the addressed byte
FFFC5870 00006CB3		mov		$s9,$x0			; type = int
FFFC5874 00012083		ldt		$ra,[$sp]
FFFC5878 00410113		add		$sp,$sp,#4
FFFC587C 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC5880 FFC1310D		gcsub	$sp,$sp,#4
FFFC5884 00512023		stt		$t0,[$sp]
FFFC5888 DC1FF0EF		call	PARN		; get expression value
FFFC588C 000C6533		mov		$a0,$s8
FFFC5890 000CE5B3		mov		$a1,$s9
FFFC5894 FFC1310D		gcsub	$sp,$sp,#4	; save the text pointer
FFFC5898 00712023		stt		$t2,[$sp]
FFFC589C 7A81A283		ldt		$t0,usrJmp[$gp]
FFFC58A0 000280E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC58A4 00012383		ldt		$t2,[$sp]	; restore the text pointer
FFFC58A8 00410113		add		$sp,$sp,#4
FFFC58AC 00012283		ldt		$t0,[$sp]
FFFC58B0 00410113		add		$sp,$sp,#4
FFFC58B4 00012083		ldt		$ra,[$sp]
FFFC58B8 00410113		add		$sp,$sp,#4
FFFC58BC 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC58C0 D89FF0EF		call	PARN		; get the upper limit
FFFC58C4 040C0063		beq		s8,r0,rnd2	; it must be positive and non-zero
FFFC58C8 020C4663		blt		s8,r0,rnd1
FFFC58CC 000C65B3		mov		a1,s8
FFFC58D0 000C6CB3		mov		s9,s8
FFFC58D4 000008B7		call	gen_rand	; generate a random number
FFFC58D8 4EC880E7
FFFC58DC 039C6C33		rem		s8,s8,s9
FFFC58E0 001C0C13		add		s8,s8,#1
FFFC58E4 00006CB3		mov		s9,x0
FFFC58E8 00012083		lw		$ra,[$sp]
FFFC58EC 00410113		add		$sp,$sp,#4
FFFC58F0 00008067		ret
                        	rnd1:
FFFC58F4 FFFC6537		ldi		a0,#msgRNDBad
FFFC58F8 3F850513
FFFC58FC 00410113		add		$sp,$sp,#4
FFFC5900 1A00006F		jmp		ERROR
                        	rnd2:
FFFC5904 000008B7		call	gen_rand	; generate a random number
FFFC5908 4EC880E7
FFFC590C 00006CB3		mov		s9,x0
FFFC5910 00012083		lw		$ra,[$sp]
FFFC5914 00410113		add		$sp,$sp,#4
FFFC5918 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC591C D2DFF0EF		call	PARN		; get the following expr.'s value
FFFC5920 000C4863		blt		s8,r0,ABS1
FFFC5924 00012083		lw		$ra,[$sp]
FFFC5928 00410113		add		$sp,$sp,#4
FFFC592C 00008067		ret
                        	ABS1:
FFFC5930 41800C33		sub		s8,x0,s8
FFFC5934 00012083		lw		$ra,[$sp]
FFFC5938 00410113		add		$sp,$sp,#4
FFFC593C 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC5940 C0001C73		csrrw	s8,#$C00,x0
FFFC5944 00006CB3		mov		s9,x0
FFFC5948 00012083		lw		$ra,[$sp]
FFFC594C 00410113		add		$sp,$sp,#4
FFFC5950 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC5954 CF5FF0EF		call	PARN		; get the following expr.'s value
FFFC5958 00006CB3		mov		s9,x0
FFFC595C 020C0463		beq		s8,r0,SGN1
FFFC5960 000C4A63		blt		s8,r0,SGN2
FFFC5964 00106C13		ldi		s8,#1
FFFC5968 00012083		lw		$ra,[$sp]
FFFC596C 00410113		add		$sp,$sp,#4
FFFC5970 00008067		ret
                        	SGN2:
FFFC5974 FFF06C13		ldi		s8,#-1
FFFC5978 00012083		lw		$ra,[$sp]
FFFC597C 00410113		add		$sp,$sp,#4
FFFC5980 00008067		ret
                        	SGN1:
FFFC5984 00012083		lw		$ra,[$sp]
FFFC5988 00410113		add		$sp,$sp,#4
FFFC598C 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in s8.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC5990 7081AC03		ldt		s8,VARBGN[$gp]	; get the number of free bytes...
FFFC5994 7041AC83		ldt		s9,TXTUNF[$gp]	; between 'TXTUNF' and 'VARBGN'
FFFC5998 419C0C33		sub		s8,s8,s9
FFFC599C 00006CB3		mov		s9,x0			; type = int
FFFC59A0 00012083		lw		$ra,[$sp]
FFFC59A4 00410113		add		$sp,$sp,#4
FFFC59A8 00008067		ret					; return the number in s8
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC59AC FFC10113		sub		$sp,$sp,#4
FFFC59B0 00112023		sw		$ra,[$sp]
FFFC59B4 00106513	  ldi		a0,#1		; allocate var
FFFC59B8 CD1FF0EF	  call	TSTV		; variable name?
FFFC59BC 000C1A63	  bne		s8,x0,.sv2
FFFC59C0 FFFC6537	 	ldi		a0,#msgVar
FFFC59C4 3E250513
FFFC59C8 00410113		add		$sp,$sp,#4
FFFC59CC 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC59D0 FFC10113		sub		$sp,$sp,#4
FFFC59D4 01812023		sw		s8,[$sp]	; save the variable's address
FFFC59D8 548000EF		call	TSTC			; get past the "=" sign
FFFC59DC 0000003D		dw		'='
FFFC59E0 02000663		bra		SV1
FFFC59E4 865FF0EF		call	OREXPR		; evaluate the expression
FFFC59E8 00012583		lw		a1,[$sp]	; get back the variable's address
FFFC59EC 00410113		add		$sp,$sp,#4
FFFC59F0 0185A023		sw    s8,[a1]   ; and save value in the variable
FFFC59F4 0005EC33		mov		s8,a1			; return s8 = variable address
FFFC59F8 FFC5AC83		lw		s9,-4[a1]
FFFC59FC 0FFCFC93		and		s9,s9,#$FF
FFFC5A00 00012083		lw		$ra,[$sp]
FFFC5A04 00410113		add		$sp,$sp,#4
FFFC5A08 00008067		ret
                        	SV1:
FFFC5A0C 00410113		add		$sp,$sp,#4
FFFC5A10 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC5A14 FFC1310D		gcsub	$sp,$sp,#4
FFFC5A18 00112023		stt		$ra,[$sp]
FFFC5A1C 504000EF		call	TSTC		; *** FIN ***
FFFC5A20 0000003A		dw		':'
FFFC5A24 00000663		bra		FI1
FFFC5A28 00410113		add		$sp,$sp,#4	; if ":", discard return address
FFFC5A2C 800FF06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC5A30 4F0000EF		call	TSTC		; not ":", is it a CR?
FFFC5A34 0000000D		dw		CR
FFFC5A38 00000663		bra		FI2
                        							; else return to the caller
FFFC5A3C 00410113		add		$sp,$sp,#4	; yes, purge return address
FFFC5A40 F6DFE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC5A44 00012083		ldt		$ra,[$sp]
FFFC5A48 00410113		add		$sp,$sp,#4
FFFC5A4C 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC5A50 FFC1310D		gcsub	$sp,$sp,#4
FFFC5A54 00112023		stt		$ra,[$sp]
FFFC5A58 584000EF		call	IGNBLK
FFFC5A5C 0003C503		ldbu	$a0,[$t2]
FFFC5A60 00D06313		ldi		$t1,#CR
FFFC5A64 00650863		beq		$a0,$t1,ec1	; does it end with a CR?
FFFC5A68 FFFC6537		ldi		$a0,#msgExtraChars
FFFC5A6C 4B350513
FFFC5A70 0300006F		jmp		ERROR
                        	ec1:
FFFC5A74 00012083		ldt		$ra,[$sp]
FFFC5A78 00410113		add		$sp,$sp,#4
FFFC5A7C 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC5A80 FFFC6537		ldi		a0,#msgTooBig
FFFC5A84 49F50513
FFFC5A88 00000C63		bra		ERROR
                        	QSORRY:
FFFC5A8C FFFC6537	  ldi		a0,#SRYMSG
FFFC5A90 34750513
FFFC5A94 00000663		bra	    ERROR
                        	QWHAT:
FFFC5A98 FFFC6537		ldi		a0,#msgWhat
FFFC5A9C 34050513
                        	ERROR:
FFFC5AA0 624000EF		call	PRMESG		; display the error message
FFFC5AA4 7181A503		ldt		$a0,CURRNT[$gp]	; get the current line pointer
FFFC5AA8 02050C63		beqz	$a0,ERROR1	; if zero, do a warm start
FFFC5AAC FFF06313		ldi		$t1,#-1
FFFC5AB0 AE650263		beq		$a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC5AB4 0003C283		ldbu	r5,[$t2]		; save the char. pointed to
FFFC5AB8 00038023		stb		$x0,[$t2]		; put a zero where the error is
FFFC5ABC 7181A503		ldt		$a0,CURRNT[$gp]	; point to start of current line
FFFC5AC0 404000EF		call	PRTLN		; display the line in error up to the 0
FFFC5AC4 00056333		mov     r6,$a0	    ; save off end pointer
FFFC5AC8 00538023		sb		r5,[$t2]		; restore the character
FFFC5ACC 03F06513		ldi		$a0,#'?'		; display a "?"
FFFC5AD0 A39FE0EF		call	GOOUT
FFFC5AD4 000065B3		mov		$a1,$x0		; stop char = 0
FFFC5AD8 FFF30513		sub		$a0,r6,#1	; point back to the error char.
FFFC5ADC 214000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC5AE0 B11FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC5AE4 FF81310D		gcsub	$sp,$sp,#8
FFFC5AE8 00512023		stt		r5,[$sp]
FFFC5AEC 00112223		stt		$ra,4[$sp]
FFFC5AF0 A19FE0EF		call	GOOUT		; display the prompt
FFFC5AF4 00106513		ldi		$a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC5AF8 02006513		ldi		$a0,#' '		; and a space
FFFC5AFC A0DFE0EF		call	GOOUT
FFFC5B00 72418393		add		$t2,$gp,#BUFFER	; $t2 is the buffer pointer
                        	.GL1:
FFFC5B04 590000EF		call	CHKIO		; check keyboard
FFFC5B08 FE050EE3		beqz	$a0,.GL1	; wait for a char. to come in
FFFC5B0C 00806313		ldi		$t1,#CTRLH
FFFC5B10 04650463		beq		$a0,$t1,.GL3	; delete last character? if so
FFFC5B14 01806313		ldi		$t1,#CTRLX
FFFC5B18 06650463		beq		$a0,$t1,.GL4	; delete the whole line?
FFFC5B1C 00D06313		ldi		$t1,#CR
FFFC5B20 00650663		beq		$a0,$t1,.GL2		; accept a CR
FFFC5B24 02006313		ldi		$t1,#' '
FFFC5B28 FC654EE3		blt		$a0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC5B2C 00A38023		stb		$a0,[$t2]		; save the char.
FFFC5B30 00138393		add		$t2,$t2,#1
FFFC5B34 FFC1310D		gcsub	$sp,$sp,#4
FFFC5B38 00A12023		stt		$a0,[$sp]
FFFC5B3C 9CDFE0EF		call	GOOUT		  ; echo the char back out
FFFC5B40 00012503		ldt		$a0,[$sp] ; get char back (GOOUT destroys a0)
FFFC5B44 00410113		add		$sp,$sp,#4
FFFC5B48 00D06313		ldi		$t1,#CR
FFFC5B4C 06650863		beq		$a0,$t1,.GL7			; if it's a CR, end the line
FFFC5B50 77718313		add		$t1,$gp,#BUFFER+BUFLEN-1
FFFC5B54 FA63C8E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC5B58 00806513		ldi		$a0,#CTRLH	; delete a char. if possible
FFFC5B5C 9ADFE0EF		call	GOOUT
FFFC5B60 02006513		ldi		$a0,#' '
FFFC5B64 9A5FE0EF		call	GOOUT
FFFC5B68 72418313		add		$t1,$gp,#BUFFER
FFFC5B6C F8735CE3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC5B70 00806513		ldi		$a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC5B74 995FE0EF		call	GOOUT
FFFC5B78 FFF38393		sub		$t2,$t2,#1	; decrement the text pointer
FFFC5B7C F80004E3		bra		.GL1		; back for more
                        	.GL4:
FFFC5B80 0003E533		mov		$a0,$t2		; delete the whole line
FFFC5B84 72418E13		add		$t3,$gp,#BUFFER	; figure out how many backspaces we need
FFFC5B88 41C502B3		sub		r5,$a0,$t3 
FFFC5B8C 02028463		beqz	r5,.GL6		  ; if none needed, branch
FFFC5B90 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC5B94 00806513		ldi		$a0,#CTRLH		; and display BS-space-BS sequences
FFFC5B98 971FE0EF		call	GOOUT
FFFC5B9C 02006513		ldi		$a0,#' '
FFFC5BA0 969FE0EF		call	GOOUT
FFFC5BA4 00806513		ldi		$a0,#CTRLH
FFFC5BA8 961FE0EF		call	GOOUT
FFFC5BAC FFF28293		sub		r5,r5,#1
FFFC5BB0 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC5BB4 72418393		add		$t2,$gp,#BUFFER	; reinitialize the text pointer
FFFC5BB8 F40006E3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC5BBC 00038023		stb		$x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC5BC0 00A06513		ldi		$a0,#LINEFD	; echo a LF for the CR
FFFC5BC4 945FE0EF		call	GOOUT
FFFC5BC8 00012283		ldt		r5,[$sp]
FFFC5BCC 00412083		ldt		$ra,4[$sp]
FFFC5BD0 00810113		add		$sp,$sp,#8
FFFC5BD4 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $s8 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $s8 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $s8 = 0.
                        	; $s8=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC5BD8 00100337		ldi		$t1,#$FFFFF
FFFC5BDC FFF30313
FFFC5BE0 00654863		blt		$a0,$t1,fl1	; line no. must be < 1048576
FFFC5BE4 FFFC6537		ldi		$a0,#msgLineRange
FFFC5BE8 3CD50513
FFFC5BEC EB5FF06F		jmp		ERROR
                        	fl1:
FFFC5BF0 000028B7		add		$t3,$gp,#TXTBGN	; init. the text save pointer
FFFC5BF4 80088893
FFFC5BF8 00388E33
FFFC5BFC 71C1AE23		stt   $t3,SRCHLN[$gp]
FFFC5C00 00000663	  bra   FNDLNP
                        	FNDLNT:
FFFC5C04 7181AE03	  ldt   $t3,CURRNT[$gp]
FFFC5C08 71C1AE23	  stt   $t3,SRCHLN[$gp]
                        	FNDLNP:
FFFC5C0C 7041AE83		ldt		$t4,TXTUNF[$gp]	; check if we passed the end
FFFC5C10 01DE7863		bgeu	$t3,$t4,FNDRET1 ; if so, return with r9=0,a0=0
                        		;call	LoadWord		; get line number
FFFC5C14 001E2C03		ldt   $s8,1[$t3]
                        	;	gcsub $sp,$sp,#8
                        	;	stt   $ra,[$sp]
                        	;	stt   $a0,4[$sp]
                        	;	mov   $a0,$s8
                        	;	call  PutHexWord
                        	;	ldt   $ra,[$sp]
                        	;	ldt   $a0,4[$sp]
                        	;	add   $sp,$sp,#8
FFFC5C18 00AC0863		beq		$s8,$a0,FNDRET2
FFFC5C1C 00AC6A63		bltu	$s8,$a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET1:
FFFC5C20 00006C33		mov		$s8,$x0	; line not found, but $t3=next line pointer
FFFC5C24 00008067		ret
                        	FNDRET2:
FFFC5C28 00106C13		ldi		$s8,#1	; line found
FFFC5C2C 00008067		ret
                        	
                        	; Move from the current line to the next one.
                        	FNDNXT:
FFFC5C30 71C1AC03	  ldt   $s8,SRCHLN[$gp]
FFFC5C34 000C4C83		ldbu	$s9,[$s8]
FFFC5C38 019C0E33		add		$t3,$s8,$s9
FFFC5C3C 71C1AE23		stt   $t3,SRCHLN[$gp]
FFFC5C40 FC0006E3		bra   FNDLNP
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC5C44 00050203		lb		r4,[a0]
FFFC5C48 00458023		sb		r4,[a1]
FFFC5C4C 00150513		add		a0,a0,#1
FFFC5C50 00158593		add		a1,a1,#1
                        	MVUP:
FFFC5C54 FEC518E3		bne		a0,a2,MVUP1
FFFC5C58 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC5C5C FFF50513		sub		a0,a0,#1
FFFC5C60 FFF58593		sub		a1,a1,#1
FFFC5C64 00050203		lb		r4,[a0]
FFFC5C68 00458023		sb		r4,[a1]
                        	MVDOWN:
FFFC5C6C FEC518E3		bne		a0,a2,MVDOWN1
FFFC5C70 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC5C74 00012503		ldt		$a0,[$sp]
FFFC5C78 00410113		add		$sp,$sp,#4
FFFC5C7C 70A1A823		stt		$a0,LOPVAR[$gp]	; restore LOPVAR, but zero means no more
FFFC5C80 02050463		beqz	$a0,PP1
FFFC5C84 00012503		ldt		$a0,[$sp]
FFFC5C88 76A1AC23		stt		$a0,LOPPT[$gp]
FFFC5C8C 00412503		ldt		$a0,4[$sp]
FFFC5C90 76A1AE23		stt		$a0,LOPLN[$gp]
FFFC5C94 00812503		ldt		$a0,8[$sp]
FFFC5C98 78A1A223		stt		$a0,LOPLMT[$gp]
FFFC5C9C 00C12503		ldt		$a0,12[$sp]
FFFC5CA0 78A1A023		stt		$a0,LOPINC[$gp]
FFFC5CA4 01010113		add		$sp,$sp,#16
                        	PP1:
FFFC5CA8 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC5CAC 7A41A503		ldt		$a0,STKBOT[$gp]	; Are we running out of stack room?
FFFC5CB0 01450513		add		$a0,$a0,#20	; we might need this many bytes
FFFC5CB4 DCA14CE3		blt		$sp,$a0,QSORRY	; out of stack space
FFFC5CB8 7101A583		ldt		$a1,LOPVAR[$gp]		; save loop variables
FFFC5CBC 02058463		beqz	$a1,PU1		; if LOPVAR is zero, that's all
FFFC5CC0 FF010113		sub		$sp,$sp,#16
FFFC5CC4 7781A503		ldt		$a0,LOPPT[$gp]
FFFC5CC8 00A12023		stt		$a0,[$sp]
FFFC5CCC 77C1A503		ldt		$a0,LOPLN[$gp]
FFFC5CD0 00A12223		stt		$a0,4[$sp]
FFFC5CD4 7841A503		ldt		$a0,LOPLMT[$gp]
FFFC5CD8 00A12423		stt		$a0,8[$sp]
FFFC5CDC 7801A503		ldt		$a0,LOPINC[$gp]
FFFC5CE0 00A12623		stt		$a0,12[$sp]
                        	PU1:
FFFC5CE4 FFC10113		sub		$sp,$sp,#4
FFFC5CE8 00B12023		stt		a1,[$sp]
FFFC5CEC 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return s8 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC5CF0 FEC10113		sub		$sp,$sp,#20
FFFC5CF4 00512023		stt		x5,[$sp]
FFFC5CF8 00612223		stt		x6,4[$sp]
FFFC5CFC 00712423		stt		x7,8[$sp]
FFFC5D00 00112623		stt		$ra,12[$sp]
FFFC5D04 00A12823		stt		$a0,16[$sp]
FFFC5D08 000562B3		mov   x5,a0	    ; r5 = pointer
FFFC5D0C 0005E333		mov   x6,a1	    ; r6 = stop char
                        	.PS1:
FFFC5D10 0002C383	  ldbu  x7,[x5]     ; get a text character
FFFC5D14 00128293		add		x5,x5,#1
FFFC5D18 00638E63		beq	  x7,x6,.PRTRET	; same as stop character? if so, return
FFFC5D1C 0003E533		mov   $a0,x7
FFFC5D20 FE8FE0EF		call	GOOUT		; display the char.
FFFC5D24 00D06313		ldi		$t1,#CR
FFFC5D28 FE6394E3		bne   x7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC5D2C 00A06513		ldi		$a0,#LINEFD  ; yes, add a L.F.
FFFC5D30 FD8FE0EF		call	GOOUT
                        	.PRTRET:
FFFC5D34 0003ECB3	  mov   $s9,x7	    ; return a1 = stop char
FFFC5D38 0002EC33		mov		$s8,x5		; return a0 = line pointer
FFFC5D3C 00012283		ldt		$x5,[$sp]
FFFC5D40 00412303		ldt		$x6,4[$sp]
FFFC5D44 00812383		ldt		$x7,8[$sp]
FFFC5D48 00C12083		ldt		$ra,12[$sp]
FFFC5D4C 01012503		ldt		$a0,16[$sp]
FFFC5D50 01410113		add		$sp,$sp,#20
FFFC5D54 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC5D58 FFC10113		sub		$sp,$sp,#4
FFFC5D5C 00112023		stt		$ra,[$sp]
FFFC5D60 1C0000EF		call	TSTC		; *** QTSTG ***
FFFC5D64 00000022		dw		'"'
FFFC5D68 02000063		bra		QT3
FFFC5D6C 02206593		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC5D70 0003E533		mov		a0,$t2
FFFC5D74 F7DFF0EF		call	PRTSTG		; print until another
FFFC5D78 000C63B3		mov		$t2,s8
FFFC5D7C 00D06313		ldi		$t1,#CR
FFFC5D80 026C9863		bne		s9,$t1,QT2	; was last one a CR?
FFFC5D84 C29FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC5D88 198000EF		call	TSTC		; is it a single quote?
FFFC5D8C 0000005C		dw		'\''
FFFC5D90 00000663		bra		QT4
FFFC5D94 02706593		ldi		a1,#'\''	; if so, do same as above
FFFC5D98 FC000CE3		bra		QT1
                        	QT4:
FFFC5D9C 184000EF		call	TSTC		; is it an underline?
FFFC5DA0 0000005F		dw		'_'
FFFC5DA4 00000C63		bra		QT5
FFFC5DA8 00D06513		ldi		a0,#CR		; if so, output a CR without LF
FFFC5DAC F5CFE0EF		call	GOOUT
                        	QT2:
FFFC5DB0 00012083		lw		$ra,[$sp]		; get return address
FFFC5DB4 00410113		add		$sp,$sp,#4
FFFC5DB8 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC5DBC 00012083		lw		$ra,[$sp]		; get return address
FFFC5DC0 00410113		add		$sp,$sp,#4
FFFC5DC4 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC5DC8 FFC10113		sub		$sp,$sp,#4
FFFC5DCC 00112023		stt		$ra,[$sp]
FFFC5DD0 00D06513		ldi		$a0,#CR
FFFC5DD4 F34FE0EF		call	GOOUT
FFFC5DD8 00A06513		ldi		$a0,#LINEFD
FFFC5DDC F2CFE0EF		call	GOOUT
FFFC5DE0 00012083		ldt		$ra,[$sp]
FFFC5DE4 00410113		add		$sp,$sp,#4
FFFC5DE8 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
FFFC5DEC 00000000		align	1
                        	
FFFC5DF0 FEC10113	public PRTNUM:
	sub		$sp,$sp,#20
FFFC5DF4 00912023		stt		$s1,[$sp]
FFFC5DF8 01212223		stt		$s2,4[$sp]
FFFC5DFC 01312423		stt		$s3,8[$sp]
FFFC5E00 01412623		stt		$s4,12[$sp]
FFFC5E04 00112823		stt		$ra,16[$sp]
FFFC5E08 79C18A13		add		$s4,$gp,#NUMWKA	; r7 = pointer to numeric work area
FFFC5E0C 000569B3		mov		$s3,$a0		; save number for later
FFFC5E10 0005E933		mov		$s2,$a1		; s2 = min number of chars
FFFC5E14 00055663		bge		$a0,$x0,.PN2	; is it negative? if not
FFFC5E18 40A00533		sub		$a0,$x0,$a0	; else make it positive
FFFC5E1C FFF90913		sub		$s2,$s2,#1	; one less for width count
                        	.PN2:
FFFC5E20 00A06313		ldi		$t1,#10
                        	.PN1:
FFFC5E24 02C565B3		rem		$a1,$a0,$a2	; a1 = a0 mod base
FFFC5E28 02C54533		div		$a0,$a0,$a2	; a0 /= divide by base
FFFC5E2C 00B67463		bleu	$a1,$a2,.PN7
FFFC5E30 00758593		add		$a1,$a1,#'A'-10-'0'
                        	.PN7:
FFFC5E34 03058593		add		$a1,$a1,#'0'	; convert remainder to ascii
FFFC5E38 00BA0023		stb		$a1,[$s4]		; and store in buffer
FFFC5E3C 001A0A13		add		$s4,$s4,#1
FFFC5E40 FFF90913		sub		$s2,$s2,#1	; decrement width
FFFC5E44 FE0510E3		bnez	$a0,.PN1
FFFC5E48 01205A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC5E4C 02006513		ldi		$a0,#' '		; display the required leading spaces
FFFC5E50 EB8FE0EF		call	GOOUT
FFFC5E54 FFF90913		sub		$s2,$s2,#1
FFFC5E58 FF204AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC5E5C 0009D663		bge		$s3,$x0,.PN5	; is number negative?
FFFC5E60 02D06513		ldi		$a0,#'-'		; if so, display the sign
FFFC5E64 EA4FE0EF		call	GOOUT
                        	.PN5:
FFFC5E68 79C18313		add		$t1,$gp,#NUMWKA
                        	.PN6:
FFFC5E6C FFFA0A13		sub		$s4,$s4,#1
FFFC5E70 000A4503		ldbu	$a0,[$s4]		; now unstack the digits and display
FFFC5E74 E94FE0EF		call	GOOUT
FFFC5E78 FF436AE3		bgtu	$s4,$t1,.PN6
                        	
FFFC5E7C 00012483		ldt		$s1,[$sp]
FFFC5E80 00412903		ldt		$s2,4[$sp]
FFFC5E84 00812983		ldt		$s3,8[$sp]
FFFC5E88 00C12A03		ldt		$s4,12[$sp]
FFFC5E8C 01012083		ldt		$ra,16[$sp]
FFFC5E90 01410113		add		$sp,$sp,#20
FFFC5E94 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		s8 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC5E98 00054C03	  lbu		$s8,[$a0]	
FFFC5E9C 00154C83	  lbu		$s9,1[$a0]
FFFC5EA0 008C9C93	  sll		$s9,$s9,#8
FFFC5EA4 019C6C33	  or		$s8,$s8,$s9
FFFC5EA8 00254C83	  lbu		$s9,2[$a0]
FFFC5EAC 010C9C93	  sll		$s9,$s9,#16
FFFC5EB0 019C6C33	  or		$s8,$s8,$s9
FFFC5EB4 00354C83	  lbu		$s9,3[$a0]
FFFC5EB8 018C9C93	  sll		$s9,$s9,#24
FFFC5EBC 019C6C33	  or		$s8,$s8,$s9
FFFC5EC0 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	$a0 = pointer to line
                        	; Returns:
                        	;		$s8 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC5EC4 FF01310D		gcsub	$sp,$sp,#16
FFFC5EC8 00512023		stt		$t0,[$sp]
FFFC5ECC 00112223		stt		$ra,4[$sp]
FFFC5ED0 00A12423		stt		$a0,8[$sp]
FFFC5ED4 00B12623		stt		$a1,12[$sp]
FFFC5ED8 000562B3	  mov		$t0,$a0		; $t0 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
                        	  ;call	LoadWord
FFFC5EDC 0012AC03	  ldt   $s8,1[$t0]    ; we can do unaligned loads
FFFC5EE0 00528293		add		$t0,$t0,#5
FFFC5EE4 000C6533	  mov		$a0,$s8
FFFC5EE8 00506593	  ldi		$a1,#5       ; display a 0 or more digit line no.
FFFC5EEC 00A06613	  ldi		$a2,#10
FFFC5EF0 F01FF0EF		call	PRTNUM
FFFC5EF4 02006513		ldi		$a0,#' '     ; followed by a blank
FFFC5EF8 E10FE0EF		call	GOOUT
FFFC5EFC 000065B3		mov		$a1,$x0     ; stop char. is a zero
FFFC5F00 0002E533		mov		$a0,$t0
FFFC5F04 DEDFF0EF		call  PRTSTG		  ; display the rest of the line
FFFC5F08 00012283		ldt		$t0,[$sp]
FFFC5F0C 00412083		ldt		$ra,4[$sp]
FFFC5F10 00812503		ldt		$a0,8[$sp]
FFFC5F14 00C12583		ldt		$a1,12[$sp]
FFFC5F18 01010113		add		$sp,$sp,#16
FFFC5F1C 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC5F20 FF41310D		gcsub	$sp,$sp,#12
FFFC5F24 00A12023		stt		$a0,[$sp]
FFFC5F28 00112223		stt		$ra,4[$sp]
FFFC5F2C 00B12423		stt		$a1,8[$sp]
FFFC5F30 0AC000EF		call	IGNBLK		; ignore leading blanks
FFFC5F34 00412083		ldt		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC5F38 0003C503		ldbu	$a0,[$t2]
FFFC5F3C 0000C583		ldbu	$a1,[$ra]
FFFC5F40 00A58A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC5F44 00012503		ldt		$a0,[$sp]		; restore a0
FFFC5F48 00812583		ldt		$a1,8[$sp]
FFFC5F4C 00C10113		add		$sp,$sp,#12	;
FFFC5F50 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC5F54 00138393		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC5F58 00012503		ldt		$a0,[$sp]
FFFC5F5C 00412083		ldt		$ra,4[$sp]
FFFC5F60 00812583		ldt		$a1,8[$sp]
FFFC5F64 00C10113		add		$sp,$sp,#12
FFFC5F68 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $s8 and the number of digits in $s9,
                        	;	else return zero in $s8 and $s9.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	s8 = number
                        	;		s9 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC5F6C FF81310D		gcsub	$sp,$sp,#8
FFFC5F70 00112223		stt		$ra,4[$sp]
FFFC5F74 00512023		stt		$t0,[$sp]
FFFC5F78 064000EF		call	IGNBLK		; skip over blanks
FFFC5F7C 00006C33		mov		$s8,$x0		; initialize return parameters
FFFC5F80 00006CB3		mov		$s9,$x0
                        	TN1:
FFFC5F84 0003C283		ldbu	$t0,[$t2]
FFFC5F88 03006313		ldi		$t1,#'0'
FFFC5F8C 0462C063		blt		$t0,$t1,TSNMRET; is it less than zero?
FFFC5F90 03906313		ldi		$t1,#'9'
FFFC5F94 02534C63		bgt		$t0,$t1,TSNMRET; is it greater than nine?
FFFC5F98 08000337		ldi		$t1,#$7FFFFFF
FFFC5F9C FFF30313
FFFC5FA0 01837863		bleu	$s8,$t1,TN2; see if there's room for new digit
FFFC5FA4 FFFC6537		ldi		$a0,#msgNumTooBig
FFFC5FA8 36950513
FFFC5FAC AF5FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC5FB0 00138393		add		$t2,$t2,#1	; adjust text pointer
FFFC5FB4 00A06E13		ldi   $t3,#10
FFFC5FB8 03CC0C33		mul   $s8,$s8,$t3 ; quickly multiply result by 10
FFFC5FBC FD028293		sub   $t0,$t0,#'0'  ; convert ascii to binary
FFFC5FC0 005C0C33		add		$s8,$s8,$t0 ; add in the new digit
FFFC5FC4 001C8C93		add		$s9,$s9,#1	; increment the no. of digits
FFFC5FC8 FA000EE3		bra		TN1
                        	TSNMRET:
FFFC5FCC 00012283		ldt		$t0,[$sp]
FFFC5FD0 00412083		ldt		$ra,4[$sp]
FFFC5FD4 00810113		add		$sp,$sp,#8
FFFC5FD8 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC5FDC FF81310D		gcsub	$sp,$sp,#8
FFFC5FE0 00A12023		stt		$a0,[$sp]
FFFC5FE4 00612223		stt   $t1,4[$sp]
                        	IGB2:
FFFC5FE8 0003C503		ldbu	$a0,[$t2]			; get char
FFFC5FEC 02006313		ldi		$t1,#' '
FFFC5FF0 00650663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC5FF4 00906313		ldi		$t1,#'\t'
FFFC5FF8 00651663		bne		$a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC5FFC 00138393		add		$t2,$t2,#1		; increment the text pointer
FFFC6000 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC6004 00012503		ldt		$a0,[$sp]
FFFC6008 00412303		ldt   $t1,4[$sp]
FFFC600C 00810113		add		$sp,$sp,#8
FFFC6010 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC6014 FFC10113		sub		$sp,$sp,#4
FFFC6018 00112023		stt		$ra,[$sp]
FFFC601C 72418393		add		$t2,$gp,#BUFFER	; set up text pointer
FFFC6020 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC6024 0003C503		lbu		$a0,[$t2]		; get the next text char.
FFFC6028 00138393		add		$t2,$t2,#1
FFFC602C 00D06313		ldi		$t1,#CR
FFFC6030 02650E63		beq		$a0,$t1,TOUPBRT		; is it end of line?
FFFC6034 02206313		ldi		$t1,#'"'
FFFC6038 00650E63		beq		$a0,$t1,DOQUO	; a double quote?
FFFC603C 02706313		ldi		$t1,#'\''     ; '
FFFC6040 00650A63		beq		$a0,$t1,DOQUO	; or a single quote?
FFFC6044 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC6048 030000EF		call	toUpper 	; convert to upper case
FFFC604C FEA38FA3		stb		$a0,-1[$t2]	; store it
FFFC6050 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC6054 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC6058 000561B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC605C FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC6060 FCA192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC6064 000061B3		mov		r3,r0		; else clear quote flag
FFFC6068 FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC606C 00012083		ldt		$ra,[$sp]
FFFC6070 00410113		add		$sp,$sp,#4
FFFC6074 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	;toUpper:
                        	;  sge     $cr0,$a0,#'a'
                        	;  sle.and $cr0,$a0,#'z'
                        	;  asl     $t1,$cr0.C,#5
                        	;  sub     $a0,$a0,$t1
                        	;  ret
                        	
                        	toUpper:
FFFC6078 06152313		slt		$t1,$a0,#'a'
FFFC607C 00031A63		bnez  $t1,TOUPRET	    ; is it < 'a'?
FFFC6080 07B06313		ldi		$t1,#'z'+1
FFFC6084 00652333		slt   $t1,$a0,$t1     ; >= 'a' and <= 'z'?
FFFC6088 00531313		sll   $t1,$t1,#5
FFFC608C 40650533		sub		$a0,$a0,$t1	    ; if not, make it upper case
                        	TOUPRET:
FFFC6090 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC6094 FFC10113		sub		$sp,$sp,#4
FFFC6098 00112023		stt		$ra,[$sp]
FFFC609C 224000EF		call	INCH		    ; get input if possible
FFFC60A0 00050863		beqz	$a0,CHKRET  ; if Zero, no input
FFFC60A4 00354C93		xor		$s9,$a0,#CTRLC
FFFC60A8 000C9463		bnez	$s9,CHKRET  ; is it control-C?
FFFC60AC D44FE06F		jmp		WSTART		  ; if so, do a warm start
                        	CHKRET:
FFFC60B0 00012083		ldt		$ra,[$sp]
FFFC60B4 00410113		add		$sp,$sp,#4
FFFC60B8 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC60BC FFFC6537		ldi		a0,#CLMSG
FFFC60C0 34D50513
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC60C4 FFC10113		sub	  $sp,$sp,#4
FFFC60C8 00112023		stt		$ra,[$sp]
FFFC60CC B15FA0EF		call	PutString
FFFC60D0 00012083		ldt		$ra,[$sp]
FFFC60D4 00410113		add		$sp,$sp,#4
FFFC60D8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC60DC E45FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC60E0 00000028		dw		'('
FFFC60E4 04000C63		bra		.paren
FFFC60E8 00106513		ldi		a0,#1
FFFC60EC D9CFF0EF		call	TSTV
FFFC60F0 000C1863		bne		s8,x0,.0001
FFFC60F4 FFFC6537		ldi		a0,#msgVar
FFFC60F8 3E250513
FFFC60FC 9A5FF06F		jmp		ERROR
                        	.0001:
FFFC6100 E21FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC6104 00000029		dw		')'
FFFC6108 02000A63		bra		.paren
FFFC610C 000C64B3		mov		s1,s8
FFFC6110 00E06513		ldi		a0,#14			; get current tid
FFFC6114 00000073		ecall
FFFC6118 0004E633		mov		a2,s1
FFFC611C 00606513		ldi		a0,#6
FFFC6120 00000073		ecall
FFFC6124 00051463		bne		a0,x0,.0002
FFFC6128 0194A023		sw		s9,[s1]				; save handle in variable
                        	.0002:
FFFC612C 00006CB3		mov		s9,x0
FFFC6130 00012083		lw		$ra,[$sp]
FFFC6134 00410113		add		$sp,$sp,#4
FFFC6138 00008067		ret
                        	.paren:
FFFC613C FFFC6537		ldi		a0,#msgParen
FFFC6140 4EF50513
FFFC6144 95DFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC6148 DD9FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC614C 00000028		dw		'('
FFFC6150 08000463		bra		.paren
FFFC6154 8F4FF0EF		call	OREXPR	; get the mailbox handle
FFFC6158 000C64B3		mov		s1,s8
FFFC615C DC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC6160 0000002C		dw		','
FFFC6164 06000463		bra		.err
FFFC6168 8E0FF0EF		call	OREXPR	; get the memory address
FFFC616C 000C6933		mov		s2,s8
FFFC6170 DB1FF0EF		call	TSTC		; it must be followed by a comma
FFFC6174 0000002C		dw		','
FFFC6178 04000A63		bra		.err
FFFC617C 8CCFF0EF		call	OREXPR	; get the memory address
FFFC6180 000C69B3		mov		s3,s8
FFFC6184 D9DFF0EF		call	TSTC		; it must be followed by a comma
FFFC6188 0000002C		dw		','
FFFC618C 04000063		bra		.err
FFFC6190 8B8FF0EF		call	OREXPR	; get the memory address
FFFC6194 000C6A33		mov		s4,s8
FFFC6198 D89FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC619C 00000029		dw		')'
FFFC61A0 02000C63		bra		.paren
FFFC61A4 00906513		ldi		a0,#9		; SendMsg
FFFC61A8 0004E5B3		mov		a1,s1
FFFC61AC 00096633		mov		a2,s2
FFFC61B0 0009E6B3		mov		a3,s3
FFFC61B4 000A6733		mov		a4,s4
FFFC61B8 00000073		ecall
FFFC61BC 00006CB3		mov		s9,x0
FFFC61C0 00012083		lw		$ra,[$sp]
FFFC61C4 00410113		add		$sp,$sp,#4
FFFC61C8 00008067		ret
                        	.err:
FFFC61CC FFFC6537		ldi		a0,#msgComma
FFFC61D0 3BA50513
FFFC61D4 8CDFF06F		jmp		ERROR
                        	.paren:
FFFC61D8 FFFC6537		ldi		a0,#msgParen
FFFC61DC 4EF50513
FFFC61E0 8C1FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC61E4 D3DFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC61E8 00000028		dw		'('
FFFC61EC 0C000263		bra		.paren
FFFC61F0 858FF0EF		call	OREXPR	; get the mailbox handle
FFFC61F4 000C64B3		mov		s1,s8
FFFC61F8 D29FF0EF		call	TSTC		; it must be followed by a comma
FFFC61FC 0000002C		dw		','
FFFC6200 0A000263		bra		.err
FFFC6204 00106513		ldi		a0,#1
FFFC6208 C80FF0EF		call	TSTV
FFFC620C 000C1863		bne		s8,x0,.0001
                        	.0002:
FFFC6210 FFFC6537		ldi		a0,#msgVar
FFFC6214 3E250513
FFFC6218 889FF06F		jmp		ERROR
                        	.0001:
FFFC621C D05FF0EF		call	TSTC		; it must be followed by a comma
FFFC6220 0000002C		dw		','
FFFC6224 08000063		bra		.err
FFFC6228 000C6933		mov		s2,s8
FFFC622C 00106513		ldi		a0,#1
FFFC6230 C58FF0EF		call	TSTV
FFFC6234 FC0C0EE3		beq		s8,x0,.0002
FFFC6238 CE9FF0EF		call	TSTC		; it must be followed by a comma
FFFC623C 0000002C		dw		','
FFFC6240 06000263		bra		.err
FFFC6244 000C69B3		mov		s3,s8
FFFC6248 00106513		ldi		a0,#1
FFFC624C C3CFF0EF		call	TSTV
FFFC6250 FC0C00E3		beq		s8,x0,.0002
FFFC6254 000C6A33		mov		s4,s8
FFFC6258 CC9FF0EF		call	TSTC		; it must be followed by a comma
FFFC625C 0000002C		dw		','
FFFC6260 04000263		bra		.err
FFFC6264 FE5FE0EF		call	OREXPR	; get queue remove flag
FFFC6268 000C67B3		mov		a5,s8
FFFC626C 000C6A33		mov		s4,s8
FFFC6270 CB1FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC6274 00000029		dw		')'
FFFC6278 02000C63		bra		.paren
FFFC627C 00A06513		ldi		a0,#10		; WaitMsg
FFFC6280 0004E5B3		mov		a1,s1
FFFC6284 00096633		mov		a2,s2
FFFC6288 0009E6B3		mov		a3,s3
FFFC628C 000A6733		mov		a4,s4
FFFC6290 00000073		ecall
FFFC6294 00006CB3		mov		s9,x0
FFFC6298 00012083		lw		$ra,[$sp]
FFFC629C 00410113		add		$sp,$sp,#4
FFFC62A0 00008067		ret
                        	.err:
FFFC62A4 FFFC6537		ldi		a0,#msgComma
FFFC62A8 3BA50513
FFFC62AC FF4FF06F		jmp		ERROR
                        	.paren:
FFFC62B0 FFFC6537		ldi		a0,#msgParen
FFFC62B4 4EF50513
FFFC62B8 FE8FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC62BC 924FA06F		jmp		Putch
                        	
                        	; ===== Input a character from the console into register s8 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC62C0 FFC10113		sub		$sp,$sp,#4
FFFC62C4 00112023		sw		$ra,[$sp]
FFFC62C8 8E8FA0EF		call	Getch
FFFC62CC 00150513		add		$a0,$a0,#1			; prepare test -1
FFFC62D0 00050A63		beqz	$a0,INCH1			  ; was = -1
FFFC62D4 FFF50513		sub		$a0,$a0,#1			; get char back
FFFC62D8 00012083		ldt		$ra,[$sp]
FFFC62DC 00410113		add		$sp,$sp,#4
FFFC62E0 00008067		ret
                        	INCH1:
FFFC62E4 00012083		ldt		$ra,[$sp]		; return a zero for no-char
FFFC62E8 00410113		add		$sp,$sp,#4
FFFC62EC 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	;message "BYEBYE"
                        	BYEBYE:
                        	;	call	ReleaseIOFocus
FFFC62F0 01606513	  ldi   $a0,#22     ; release I/O focus
FFFC62F4 00000073	  ecall
FFFC62F8 70002103		ldt		$sp,OSSP
FFFC62FC 02206513		ldi   $a0,#34     ; activate Monitor
FFFC6300 00000073		ecall
                        	 
                        	
FFFC6304 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.3",CR,LINEFD,"(C) 2017-2021  Robert Finch",CR,CR,0
FFFC6308 54203130
FFFC630C 20796E69
FFFC6310 49534142
FFFC6314 31762043
FFFC6318 0A0D332E
FFFC631C 20294328
FFFC6320 37313032
FFFC6324 3230322D
FFFC6328 52202031
FFFC632C 7265626F
FFFC6330 69462074
FFFC6334 0D68636E
FFFC6338 0A0D000D
FFFC633A 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC633E 6857000D
FFFC6340 74616857	msgWhat	db	"What?",CR,0
FFFC6344 53000D3F
FFFC6347 72726F53	SRYMSG	db	"Sorry."
FFFC634B 000D2E79
FFFC634D 6F43000D	CLMSG	db	CR,0
FFFC634F 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC6353 20746361
FFFC6357 53414C46
FFFC635B 65722048
FFFC635F 65206461
FFFC6363 726F7272
FFFC6367 754E000D
FFFC6369 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC636D 69207265
FFFC6371 6F742073
FFFC6375 6962206F
FFFC6379 44000D67
FFFC637C 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC6380 6E6F6973
FFFC6384 20796220
FFFC6388 6F72657A
FFFC638C 754F000D
FFFC638E 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC6392 7620666F
FFFC6396 61697261
FFFC639A 20656C62
FFFC639E 63617073
FFFC63A2 20000D65
FFFC63A5 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC63A9 66207365
FFFC63AD 0D656572
FFFC63B1 65520D00
FFFC63B2 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC63B6 000D7964
FFFC63BA 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC63BE 6E697463
FFFC63C2 20612067
FFFC63C6 6D6D6F63
FFFC63CA 4C000D61
FFFC63CD 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC63D1 6D756E20
FFFC63D5 20726562
FFFC63D9 206F6F74
FFFC63DD 0D676962
FFFC63E1 70784500
FFFC63E2 65707845	msgVar			db "Expecting a variable",CR,0
FFFC63E6 6E697463
FFFC63EA 20612067
FFFC63EE 69726176
FFFC63F2 656C6261
FFFC63F6 4E52000D
FFFC63F8 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC63FC 20646162
FFFC6400 61726170
FFFC6404 6574656D
FFFC6408 53000D72
FFFC640B 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC640F 20646162
FFFC6413 72646461
FFFC6417 0D737365
FFFC641B 504E4900
FFFC641C 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC6420 78652054
FFFC6424 74636570
FFFC6428 20676E69
FFFC642C 61762061
FFFC6430 62616972
FFFC6434 000D656C
FFFC6438 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC643C 74697720
FFFC6440 74756F68
FFFC6444 524F4620
FFFC6448 454E000D
FFFC644A 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC644E 70786520
FFFC6452 69746365
FFFC6456 6120676E
FFFC645A 66656420
FFFC645E 64656E69
FFFC6462 72617620
FFFC6466 6C626169
FFFC646A 47000D65
FFFC646D 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC6471 534F472F
FFFC6475 62204255
FFFC6479 6C206461
FFFC647D 20656E69
FFFC6481 626D756E
FFFC6485 000D7265
FFFC6489 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC648D 77204E52
FFFC6491 6F687469
FFFC6495 47207475
FFFC6499 4255534F
FFFC649D 7250000D
FFFC649F 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC64A3 206D6172
FFFC64A7 74207369
FFFC64AB 62206F6F
FFFC64AF 000D6769
FFFC64B3 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC64B7 68632061
FFFC64BB 63617261
FFFC64BF 73726574
FFFC64C3 206E6F20
FFFC64C7 656E696C
FFFC64CB 6E676920
FFFC64CF 6465726F
FFFC64D3 4520000D
FFFC64D5 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC64D9 6E6F7269
FFFC64DD 746E656D
FFFC64E1 6C616320
FFFC64E5 6166206C
FFFC64E9 64656C69
FFFC64ED 7845000D
FFFC64EF 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC64F3 6E697463
FFFC64F7 61702067
FFFC64FB 746E6572
FFFC64FF 69736568
FFFC6503 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
1344 symbols
  Symbol Name                              seg     address bits
  ABS                                        code  fffc591c 18
  ABS1                                       code  fffc5930 18
  ACBCommandLine                            const  00034e 11
  ACBCursorCol                              const  000363 11
  ACBCursorRow                              const  000362 11
  ACBDataSize                               const  000048 8
  ACBEnd                                    const  001000 14
  ACBExitRunFile                            const  00034c 11
  ACBGCMarkingQue                           const  000078 8
  ACBGCMarkingQueEmpty                      const  000081 9
  ACBGCMarkingQueFull                       const  000080 9
  ACBGCNdx                                  const  000070 8
  ACBGCOverflow                             const  000082 9
  ACBGCRootCnt                              const  000068 8
  ACBGCRoots                                const  000060 8
  ACBGarbageList                            const  000098 9
  ACBHasFocus                               const  0003c2 11
  ACBHeap                                   const  0000a0 9
  ACBKeyState1                              const  000368 11
  ACBKeyState2                              const  00036a 11
  ACBKeybdBuffer                            const  000370 11
  ACBKeybdHead                              const  00036e 11
  ACBKeybdTail                              const  00036f 11
  ACBKeybdWaitFlag                          const  00036c 11
  ACBNext                                   const  0003b8 11
  ACBNormAttr                               const  000364 11
  ACBObject                                 const  000000 1
  ACBObjectList                             const  000090 9
  ACBPad                                    const  000bc8 13
  ACBPath                                   const  00034a 11
  ACBPtrs                                   const  000280 11
  ACBStatus                                 const  0003c6 11
  ACBStrings                                const  000c00 13
  ACBTask                                   const  0003c0 11
  ACBTemplates                              const  0003c8 11
  ACBUIDataSize                             const  000058 8
  ACBUserName                               const  000348 11
  ACBVideoCols                              const  000361 11
  ACBVideoRows                              const  000360 11
  ACB_MAGIC                                 const  20414342 31
  ACBiofNext                                const  000338 11
  ACBiofPrev                                const  000340 11
  ACBmid                                    const  0003c4 11
  ACBnumber                                 const  0003b0 11
  ACBpCode                                  const  000086 9
  ACBpData                                  const  000040 8
  ACBpUIData                                const  000050 8
  ACBpVidMem                                const  000350 11
  ACBpVirtVidMem                            const  000358 11
  ADDEXPR                                    code  fffc54c4 18
  ALLOCMBX                                   code  fffc60dc 18
  ALLOCMBX.0001                              code  fffc6100 18
  ALLOCMBX.0002                              code  fffc612c 18
  ALLOCMBX.paren                             code  fffc613c 18
  ANDEXPR                                    code  fffc52b0 18
  APPID_POOL                                const  0002f0 11
  ASRAffinity                               const  000004 4
  ASRCodeSize                               const  000008 5
  ASRDataSize                               const  000010 6
  ASRHeapSize                               const  000020 7
  ASRIUDataSize                              code  800000000000035e 32
  ASRPageSize                               const  000000 1
  ASRPriority                               const  000001 2
  ASRRegset                                 const  000002 3
  ASRStackSize                              const  000028 7
  ASRUIDataSize                             const  000018 6
  ASR_SIZE                                  const  000048 8
  ASRmid                                    const  000003 3
  ASRpCode                                  const  000030 7
  ASRpData                                  const  000038 7
  ASRpUIData                                const  000040 8
  AS_DEAD                                   const  000002 3
  AS_LIVE                                   const  000001 2
  AS_NONE                                   const  000000 1
  AS_UNDEAD                                 const  000004 4
  AUXIN                                      code  80000000000003e0 32
  AUXIN_INIT                                 code  800000000000049d 32
  AUXOCRLF                                   code  fffc50fc 18
  AUXOUT                                     code  80000000000003de 32
  AUXOUT_FLUSH                               code  80000000000004aa 32
  AUXOUT_INIT                                code  80000000000004a1 32
  AccountTime                                code  fffc2bf8 18
  Alloc                                      code  fffc15b0 18
  Alloc.0001                                 code  fffc160c 18
  Alloc.allocZero                            code  fffc1674 18
  Alloc.enough                               code  fffc15e4 18
  Alloc.noRun                                code  fffc1654 18
  Alloc.noRun2                               code  fffc15dc 18
  Alloc.xit                                  code  fffc1658 18
  Alloc.zm                                   code  fffc163c 18
  AllocAppId                                 code  fffc3720 18
  AllocAppId.0001                            code  fffc3740 18
  AllocAppId.0002                            code  fffc3728 18
  AllocMsg                                   code  fffc3370 18
  AllocMsg.0001                              code  fffc33dc 18
  AllocMsg.gotMsg                            code  fffc33f4 18
  AllocMsg.outOfMem                          code  fffc341c 18
  AllocStack                                 code  fffc1680 18
  AllocStack.0001                            code  fffc16c0 18
  AllocStack.xit                             code  fffc16d8 18
  BASPRMPT                                   code  fffc4614 18
  BS                                        const  000008 5
  BUFFER                                    const  000724 12
  BUFLEN                                    const  000054 8
  BYEBYE                                     code  fffc62f0 18
  CHAINA0                                   const  000378 11
  CHAINA1                                   const  000380 11
  CHAINA2                                   const  000388 11
  CHAINA3                                   const  000390 11
  CHAINA4                                   const  000398 11
  CHAINA5                                   const  0003a0 11
  CHKIO                                      code  fffc6094 18
  CHKRET                                     code  fffc60b0 18
  CLMSG                                      code  fffc634d 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc60bc 18
  CSR_IMSTACK                               const  0007c5 12
  CSR_MEPC                                  const  000341 11
  CSR_MSEMA                                 const  0007c1 12
  CSR_MSTATUS                               const  000300 11
  CSR_PMSTACK                               const  0007c4 12
  CSR_REGSET                                const  0007c0 12
  CSR_RSSTACK                               const  0007c3 12
  CSR_SATP                                  const  000180 10
  CSR_TASKID                                const  0007c2 12
  CSR_TRACECTRL                             const  0007a0 12
  CSR_UIE                                   const  000004 4
  CSTART                                     code  fffc4530 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLT                                     const  000014 6
  CTRLX                                     const  000018 6
  CURIN                                     const  000370 11
  CUROUT                                    const  000371 11
  CURRNT                                    const  000718 12
  CheckDevOwner                              code  fffc42b0 18
  CheckDevOwner.notOwner                     code  fffc42f4 18
  CheckDevOwner.xit                          code  fffc42e8 18
  CopyDevDCB                                 code  fffc4270 18
  CopyDevDCB.again                           code  fffc4288 18
  CopyDevFuncTbl                             code  fffc4240 18
  CopyDevFuncTbl.again                       code  fffc4254 18
  CurrentTid                                const  000210 11
  CursorFlash                               const  0007b8 12
  DCB_Base                                  const  003000 15
  DCB_LastErc                               const  000018 6
  DCB_Limit                                 const  003c00 15
  DCB_Mbx                                   const  000050 8
  DCB_Name                                  const  000000 1
  DCB_ReentCount                            const  000040 8
  DCB_Resv1                                 const  000060 8
  DCB_Size                                  const  000060 8
  DCB_StartBlock                            const  000020 7
  DCB_Type                                  const  00000c 5
  DCB_fSingleUser                           const  000041 8
  DCB_fUI                                   const  000042 8
  DCB_hJob                                  const  000048 8
  DCB_nBPB                                  const  000010 6
  DCB_nBlocks                               const  000028 7
  DCB_pCmdProc                              const  000030 7
  DCB_pIRQProc                              const  000038 7
  DCB_pSema                                 const  000058 8
  DEFLT                                      code  fffc4e70 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc48c0 18
  DOQUO                                      code  fffc6054 18
  DOQUO1                                     code  fffc6060 18
  DRSP_DONE                                 const  000001 2
  DVC_BuildBPB                              const  000005 4
  DVC_Close                                 const  000007 4
  DVC_FlushInput                            const  000014 6
  DVC_FlushOutput                           const  000015 6
  DVC_GetChar                               const  000008 5
  DVC_GetCharDirect                         const  00000a 5
  DVC_IOCTRL_READ                           const  000018 6
  DVC_IOCTRL_WRITE                          const  000019 6
  DVC_IRQ                                   const  000016 6
  DVC_Initialize                            const  000002 3
  DVC_InputStatus                           const  00000c 5
  DVC_IsRemoveable                          const  000017 6
  DVC_IsUI                                  const  00001b 6
  DVC_MediaCheck                            const  000004 4
  DVC_Nop                                   const  000000 1
  DVC_Open                                  const  000006 4
  DVC_OutputStatus                          const  000013 6
  DVC_OutputUntilBusy                       const  00001a 6
  DVC_PeekChar                              const  000009 5
  DVC_PeekCharDirect                        const  00000b 5
  DVC_PutChar                               const  00000d 5
  DVC_ReadBlock                             const  000010 6
  DVC_SetPosition                           const  00000f 5
  DVC_Setup                                 const  000001 2
  DVC_Status                                const  000003 3
  DVC_VerifyBlock                           const  000012 6
  DVC_WriteBlock                            const  000011 6
  DVF_Base                                  const  002000 15
  DVF_Limit                                 const  003000 15
  DeleteLine                                 code  fffc46d0 18
  DeleteLine.0003                            code  fffc46dc 18
  DumpReadyQueue                             code  fffc3bf0 18
  DumpReadyQueue.0002                        code  fffc3c58 18
  DumpReadyQueue.0004                        code  fffc3cc4 18
  DumpReadyQueue.0005                        code  fffc3cb0 18
  DumpReadyQueue.0006                        code  fffc3c28 18
  DumpReadyQueue.0007                        code  fffc3c84 18
  DumpReadyQueue.0008                        code  fffc3ca4 18
  DumpReadyQueue.brk                         code  fffc3cb0 18
  DumpReadyQueue.nxtT                        code  fffc3d3c 18
  DumpTimeoutList                            code  fffc3d80 18
  DumpTimeoutList.0002                       code  fffc3db4 18
  DumpTimeoutList.brk                        code  fffc3df4 18
  DumpTraceQueue                             code  fffc0c14 18
  DumpTraceQueue.dmpTrace                    code  fffc0c20 18
  DumpTraceQueue.dmpTraceEmpty               code  fffc0c50 18
  DumpTraceQueue.inf                         code  fffc0c58 18
  ENDCHK                                     code  fffc5a50 18
  ENDMEM                                    const  00f000 17
  EOF                                       const  00001a 6
  ERETx2                                     code  fffc0e78 18
  ERROR                                      code  fffc5aa0 18
  ERROR1                                     code  fffc5ae0 18
  EX1                                        code  fffc490c 18
  EXEC                                       code  fffc48d0 18
  EXGO                                       code  fffc492c 18
  EXLP                                       code  fffc48dc 18
  EXMAT                                      code  fffc491c 18
  EXNGO                                      code  fffc48f4 18
  EXPR                                       code  fffc53a0 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadAppId                                const  00001c 6
  E_BadBlockNum                             const  000025 7
  E_BadDCBOffset                            const  00001a 6
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_BadTcbPointer                           const  000027 7
  E_BadTid                                  const  000028 7
  E_Busy                                    const  00001b 6
  E_DCBInUse                                const  000019 6
  E_Func                                    const  000002 3
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  000047 8
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreAppIds                            const  000046 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc0840 18
  FI1                                        code  fffc5a30 18
  FI2                                        code  fffc5a44 18
  FILEBUF                                   const  07f600 20
  FILENAME                                  const  0006c0 12
  FIN                                        code  fffc5a14 18
  FINISH                                     code  fffc4bc8 18
  FMTKInit                                   code  fffc24f0 18
  FMTKInit.0001                              code  fffc2608 18
  FMTKInit.0003                              code  fffc259c 18
  FMTK_Alloc                                 code  fffc1800 18
  FMTK_AllocMbx                              code  fffc3118 18
  FMTK_AllocMbx.0001                         code  fffc31c4 18
  FMTK_AllocMbx.gotMbx                       code  fffc31dc 18
  FMTK_AllocMbx.outOfMem                     code  fffc322c 18
  FMTK_ExitApp                               code  fffc3960 18
  FMTK_ExitTask                              code  fffc3020 18
  FMTK_ForceReleaseIOFocus                   code  fffc3fe0 18
  FMTK_ForceReleaseIOFocus.0001              code  fffc4034 18
  FMTK_ForceReleaseIOFocus.noFocus           code  fffc405c 18
  FMTK_ForceReleaseIOFocus.notAtTop          code  fffc4044 18
  FMTK_FreeMbx                               code  fffc3240 18
  FMTK_GetAppTaskId                          code  fffc26e0 18
  FMTK_GetCurrentAppId                       code  fffc26a0 18
  FMTK_GetCurrentTid                         code  fffc2650 18
  FMTK_GetDCBField                           code  fffc4190 18
  FMTK_GetDCBField.badDev                    code  fffc41d4 18
  FMTK_GetDCBField.badFunc                   code  fffc41cc 18
  FMTK_GetDCBField.ldWord                    code  fffc41c0 18
  FMTK_GetDCBField.ok                        code  fffc41c4 18
  FMTK_GetDCBField.xit                       code  fffc41c8 18
  FMTK_GetTaskAppId                          code  fffc26b0 18
  FMTK_HasIOFocus                            code  fffc3eb0 18
  FMTK_HasIOFocus.hasFocus                   code  fffc3ed8 18
  FMTK_HasIOFocus.notEqual                   code  fffc3ee4 18
  FMTK_IO                                    code  fffc4120 18
  FMTK_IO.badDev                             code  fffc417c 18
  FMTK_IO.badFunc                            code  fffc416c 18
  FMTK_IO.xit                                code  fffc4168 18
  FMTK_Initialize                            code  fffc2630 18
  FMTK_KillApp                               code  fffc3970 18
  FMTK_KillApp.immortal                      code  fffc3988 18
  FMTK_KillTask                              code  fffc3030 18
  FMTK_KillTask.immortal                     code  fffc3064 18
  FMTK_MapOSVars                             code  fffc2740 18
  FMTK_MapOSVars.mapMore                     code  fffc2758 18
  FMTK_MapOSVars.noMem                       code  fffc277c 18
  FMTK_PeekMsg                               code  fffc3620 18
  FMTK_PostMsg                               code  80000000000002ec 32
  FMTK_ReleaseIOFocus                        code  fffc3fd0 18
  FMTK_RequestIOFocus                        code  fffc3f40 18
  FMTK_RequestIOFocus.badAppId               code  fffc3fc0 18
  FMTK_RequestIOFocus.notEmpty               code  fffc3f94 18
  FMTK_RequestIOFocus.ret                    code  fffc3fa8 18
  FMTK_RunAsOS                               code  fffc2730 18
  FMTK_RunAsOS.badFunc                       code  fffc2738 18
  FMTK_SendMsg                               code  fffc3550 18
  FMTK_SetDCBField                           code  fffc4230 18
  FMTK_SetTaskAppId                          code  fffc26c0 18
  FMTK_SetTaskId                             code  fffc26f0 18
  FMTK_SetTaskPriority                       code  fffc2700 18
  FMTK_SetTaskPriority.badPtr                code  fffc271c 18
  FMTK_SetTaskPriority.badTid                code  fffc2714 18
  FMTK_Sleep                                 code  fffc2d70 18
  FMTK_StartApp                              code  fffc3760 18
  FMTK_StartApp.0001                         code  fffc382c 18
  FMTK_StartApp.0002                         code  fffc3898 18
  FMTK_StartApp.0003                         code  fffc3850 18
  FMTK_StartApp.0004                         code  fffc3848 18
  FMTK_StartApp.0005                         code  fffc38b0 18
  FMTK_StartApp.0006                         code  fffc38c8 18
  FMTK_StartApp.0007                         code  fffc38e0 18
  FMTK_StartApp.noMem                        code  fffc3950 18
  FMTK_StartApp.noMoreApps                   code  fffc394c 18
  FMTK_StartApp.norm                         code  fffc3900 18
  FMTK_StartApp.tskErr                       code  fffc3940 18
  FMTK_StartTask                             code  fffc2e80 18
  FMTK_SwitchIOFocus                         code  fffc3f30 18
  FMTK_TCBFinalizerExit                      code  fffc43e0 18
  FMTK_TCBFinalizerExit.0001                 code  fffc4418 18
  FMTK_WaitMsg                               code  fffc3630 18
  FMTK_WaitMsg.qempty                        code  fffc36b4 18
  FMTK_WaitMsg.qt                            code  fffc3660 18
  FMTK_WaitMsg.setA                          code  fffc36bc 18
  FNDLN                                      code  fffc5bd8 18
  FNDLNP                                     code  fffc5c0c 18
  FNDLNT                                     code  fffc5c04 18
  FNDNXT                                     code  fffc5c30 18
  FNDRET1                                    code  fffc5c20 18
  FNDRET2                                    code  fffc5c28 18
  FOR                                        code  fffc4c58 18
  FORCEFIT                                   code  fffc5378 18
  FORCEFIT.0001                              code  fffc539c 18
  FORCEFIT.intAnd                            code  fffc538c 18
  FR1                                        code  fffc4c78 18
  FR2                                        code  fffc4c94 18
  FR3                                        code  fffc4c9c 18
  FR4                                        code  fffc4ca0 18
  FR5                                        code  fffc4ca4 18
  FR6                                        code  fffc4cbc 18
  FR7                                        code  fffc4cc0 18
  FR8                                        code  fffc4ce0 18
  FUNCEXPR                                   code  fffc55f8 18
  FetchMemoryWord                            code  fffc17f0 18
  FillMem                                    code  fffc0900 18
  FillMem.0001                               code  fffc091c 18
  Finalizer                                  code  fffc4320 18
  Finalizer.noFinalizer                      code  fffc43c4 18
  Finalizer.nxt2                             code  fffc4354 18
  Finalizer.oscode                           code  fffc4368 18
  Finalizer.yield                            code  fffc4348 18
  Find                                       code  fffc0930 18
  Find.0001                                  code  fffc0988 18
  Find.endOfWord                             code  fffc0968 18
  Find.found                                 code  fffc09c4 18
  Find.fwe                                   code  fffc0948 18
  Find.loop                                  code  fffc0978 18
  Find.next                                  code  fffc09a4 18
  Find.notFound                              code  fffc09dc 18
  FindRun                                    code  fffc1550 18
  FindRun.0001                               code  fffc156c 18
  FindRun.0002                               code  fffc157c 18
  FindRun.empty0                             code  fffc1584 18
  FindRun.empty1                             code  fffc1588 18
  FindRun.foundEnough                        code  fffc15a8 18
  FreeAll                                    code  fffc16f0 18
  FreeAll.0001                               code  fffc173c 18
  FreeAll.nxt                                code  fffc1700 18
  FreeMbx                                   const  000c08 13
  FreeMbx1                                   code  fffc32a8 18
  FreeMbx1.0001                              code  fffc3300 18
  FreeMbx1.0002                              code  fffc32ac 18
  FreeMbx1.0003                              code  fffc32d4 18
  FreeMbx1.badMbx                            code  fffc3354 18
  FreeMsg                                   const  000c00 13
  FreeMsgRout                                code  fffc3430 18
  FreeTID                                    code  800000000000030c 32
  GCHAR                                      code  fffc4ef4 18
  GCHAR1                                     code  fffc4f0c 18
  GETLN                                      code  fffc5ae4 18
  GETLN.GL1                                  code  fffc5b04 18
  GETLN.GL2                                  code  fffc5b2c 18
  GETLN.GL3                                  code  fffc5b58 18
  GETLN.GL4                                  code  fffc5b80 18
  GETLN.GL5                                  code  fffc5b94 18
  GETLN.GL6                                  code  fffc5bb4 18
  GETLN.GL7                                  code  fffc5bbc 18
  GOAUXI                                     code  fffc4518 18
  GOAUXO                                     code  fffc4510 18
  GOBYE                                      code  fffc4520 18
  GOIN                                       code  fffc450c 18
  GOOUT                                      code  fffc4508 18
  GOSTART                                    code  fffc4500 18
  GOSUB                                      code  fffc4bd0 18
  GOTO                                       code  fffc4a44 18
  GOWARM                                     code  fffc4504 18
  GetBuflen                                  code  fffc4720 18
  GetBuflen.0001                             code  fffc4748 18
  GetBuflen.0002                             code  fffc472c 18
  GetBuflen.0004                             code  fffc4744 18
  GetCurrentTid                              code  fffc2640 18
  GetDecNum                                  code  fffc0ab0 18
  GetDecNum.0001                             code  fffc0ad4 18
  GetDecNum.isDigit                          code  fffc0ae0 18
  GetDecNum.next                             code  fffc0ac0 18
  GetFilename                                code  fffc4f58 18
  GetHexNum                                  code  fffc0a10 18
  GetHexNum.0001                             code  fffc0a54 18
  GetHexNum.isDigit                          code  fffc0a90 18
  GetHexNum.isHexLower                       code  fffc0a78 18
  GetHexNum.isHexUpper                       code  fffc0a60 18
  GetHexNum.next                             code  fffc0a20 18
  GetIRQFlag                                 code  fffc2660 18
  GetPamBit                                  code  fffc1b50 18
  GetUIFlag                                  code  fffc40f0 18
  Getch                                      code  fffc03b0 18
  HEADRDY                                   const  000400 12
  HEADRDY0                                  const  000400 12
  HEADRDY1                                  const  000404 12
  HEADRDY2                                  const  000408 12
  HEADRDY3                                  const  00040c 12
  HEADRDY4                                  const  000410 12
  HEADRDY5                                  const  000414 12
  HEADRDY6                                  const  000418 12
  HEADRDY7                                  const  00041c 12
  IF0                                        code  fffc4d5c 18
  IF1                                        code  fffc4d60 18
  IF2                                        code  fffc4d68 18
  IF3                                        code  fffc4d8c 18
  IGB1                                       code  fffc5ffc 18
  IGB2                                       code  fffc5fe8 18
  IGBRET                                     code  fffc6004 18
  IGNBLK                                     code  fffc5fdc 18
  INBUF                                     const  000100 10
  INCH                                       code  fffc62c0 18
  INCH1                                      code  fffc62e4 18
  INPERR                                     code  fffc4d94 18
  INPPTR                                    const  0007b4 12
  INPUT                                      code  fffc4db0 18
  INSLINE                                    code  fffc4684 18
  INSLINE.0001                               code  fffc46b4 18
  IOF_NEXT                                   code  8000000000000330 32
  IOF_PREV                                   code  8000000000000331 32
  IOFocusNdx                                const  001080 14
  IOFocusTbl                                const  001088 14
  IP2                                        code  fffc4dd8 18
  IP3                                        code  fffc4e14 18
  IP4                                        code  fffc4e54 18
  IP5                                        code  fffc4e64 18
  IP6                                        code  fffc4db8 18
  IP7                                        code  fffc4df8 18
  IRQCause                                  const  001098 14
  IRQFlag                                   const  001090 14
  IRQROUT                                   const  0007ac 12
  IRQRout                                    code  fffc0d10 18
  IRQRout.InitDev                            code  fffc0e20 18
  IRQRout.devAgain                           code  fffc0df4 18
  IRQRout.ecall                              code  fffc0d68 18
  IRQRout.gcIrq                              code  fffc0e74 18
  IRQRout.illegal                            code  fffc0d30 18
  IRQRout.illegal1                           code  fffc0d44 18
  IRQRout.instAlign                          code  fffc0d50 18
  IRQRout.instAlign1                         code  fffc0d64 18
  IRQRout.isIRQ                              code  fffc0d7c 18
  IRQRout.noIRQ                              code  fffc0e14 18
  IRQRout.notSerial                          code  fffc0e48 18
  IRQRout.notVia                             code  fffc0e70 18
  IRQRout.soc                                code  fffc0d4c 18
  IRQRout.softwareIrq                        code  fffc0e1c 18
  IRQRout.timerIrq                           code  fffc0e1c 18
  ISendMsg                                   code  fffc3470 18
  ISendMsg.badMbx                            code  fffc3538 18
  ISendMsg.mbxEmpty                          code  fffc3520 18
  ISendMsg.noMsg                             code  fffc3530 18
  ISendMsg.noWaiters                         code  fffc34f4 18
  ISendMsg.xit                               code  fffc353c 18
  ISetDCBField                               code  fffc41e0 18
  ISetDCBField.badDev                        code  fffc4224 18
  ISetDCBField.badFunc                       code  fffc421c 18
  ISetDCBField.ok                            code  fffc4214 18
  ISetDCBField.stWord                        code  fffc4210 18
  ISetDCBField.xit                           code  fffc4218 18
  ISleep                                     code  fffc2cb0 18
  ISleep.0001                                code  fffc2ce4 18
  ISleep.noCtxSwitch                         code  fffc2d40 18
  ISleep.noException                         code  fffc2d30 18
  ISleep.xit                                 code  fffc2d48 18
  IStartTask                                 code  fffc2e80 18
  IStartTask.appidZero                       code  fffc2ed8 18
  IStartTask.err                             code  fffc300c 18
  IStartTask.notIdleTask                     code  fffc2fe0 18
  IStartTask.xit                             code  fffc2fec 18
  IdleTask                                   code  fffc02a0 18
  IdleTask.0001                              code  fffc0388 18
  IdleTask.IdleCode                          code  fffc0328 18
  IdleTask.addToReady                        code  fffc036c 18
  IdleTask.loop                              code  fffc02c0 18
  IdleTask.loop2                             code  fffc02b0 18
  IdleTask.noAnnounce                        code  fffc02fc 18
  IdleTask.noMsg                             code  fffc02fc 18
  IdleTask.nxtObj                            code  fffc032c 18
  IdleTaskId                                const  000c2a 13
  IdleTaskMbx                               const  000c10 13
  IdleTaskMsgD1                             const  000c18 13
  IdleTaskMsgD2                             const  000c20 13
  IdleTaskMsgD3                             const  000c28 13
  InsertIntoReadyQueue                       code  fffc3990 18
  InsertIntoReadyQueue.qempty                code  fffc39e8 18
  InsertIntoReadyQueue.retx                  code  fffc39e4 18
  InsertIntoTimeoutList                      code  fffc3ab0 18
  InsertIntoTimeoutList.atHead               code  fffc3b34 18
  InsertIntoTimeoutList.lessThan             code  fffc3b18 18
  InsertIntoTimeoutList.listEmpty            code  fffc3b08 18
  InsertIntoTimeoutList.loop                 code  fffc3ad8 18
  InsertIntoTimeoutList.retx                 code  fffc3b48 18
  InsertIntoTimeoutList.xit                  code  fffc3b38 18
  InsertLine                                 code  fffc4700 18
  InsertLine.0001                            code  fffc4704 18
  InsertLine.done                            code  fffc471c 18
  LET                                        code  fffc4e7c 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc4ae4 18
  LOAD                                       code  fffc4e94 18
  LOAD3                                      code  fffc4fc4 18
  LOAD4                                      code  fffc4ff0 18
  LOAD5                                      code  fffc5028 18
  LOD1                                       code  fffc4ea4 18
  LOD2                                       code  fffc4ed0 18
  LODEND                                     code  fffc4eec 18
  LOG_ACBSZ                                 const  00000c 5
  LOG_PGSZ                                  const  00000a 5
  LOG_TCBSZ                                 const  00000a 5
  LOPINC                                    const  000780 12
  LOPLMT                                    const  000784 12
  LOPLN                                     const  00077c 12
  LOPPT                                     const  000778 12
  LOPVAR                                    const  000710 12
  LS1                                        code  fffc4af8 18
  LS2                                        code  fffc4b24 18
  LS3                                        code  fffc4b2c 18
  LS4                                        code  fffc4b04 18
  LS5                                        code  fffc4afc 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc4e90 18
  LoadWord                                   code  fffc5e98 18
  LockOS                                     code  fffc2790 18
  LockOS.spin                                code  fffc2794 18
  LockOSSemaphore                            code  fffc2790 18
  MAX_DEV_OP                                const  00001f 6
  MAX_TID                                   const  00000f 5
  MBX_BLOCKPTR_BUFSZ                        const  000008 5
  MBX_LINK                                  const  000004 4
  MBX_MAGIC                                 const  204d4258 31
  MBX_MQHEAD                                const  00000c 5
  MBX_MQTAIL                                const  000010 6
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000014 6
  MBX_TQHEAD                                const  000004 4
  MBX_TQTAIL                                const  000008 5
  MEMSZ                                     const  000200 11
  MEPC0                                     const  000350 11
  MEPC1                                     const  000358 11
  MEPC2                                     const  000360 11
  MEPC3                                     const  000368 11
  MMUInit                                    code  fffc1480 18
  MMUInit.0001                               code  fffc14ac 18
  MMUInit.0002                               code  fffc1508 18
  MMUInit.0003                               code  fffc14d0 18
  MMUInit.0004                               code  fffc14a0 18
  MMUInit.0005                               code  fffc14cc 18
  MMUInit.0006                               code  fffc14ec 18
  MMUInit.0007                               code  fffc1520 18
  MMUInit.0008                               code  fffc14c8 18
  MSG_D1                                    const  000008 5
  MSG_D2                                    const  00000c 5
  MSG_D3                                    const  000010 6
  MSG_LINK                                  const  000000 1
  MSG_MAGIC                                 const  204d5347 31
  MSG_RETADR                                const  000004 4
  MSG_SIZE                                  const  000014 6
  MSG_TGTADR                                const  000005 4
  MSG_TYPE                                  const  000006 4
  MT_ANNOUNCE                               const  000010 6
  MT_IRQ                                    const  ffffffff 33
  MULEXPR                                    code  fffc555c 18
  MVDOWN                                     code  fffc5c6c 18
  MVDOWN1                                    code  fffc5c5c 18
  MVUP                                       code  fffc5c54 18
  MVUP1                                      code  fffc5c44 18
  MachineStart                               code  fffc0100 18
  MbxBlockCounter                           const  0010e0 14
  MbxBlockPtr                               const  0010a0 14
  MbxBlockPtrEnd                            const  0010c0 14
  MbxFinalizer                               code  800000000000033a 32
  MbxRemoveTask                              code  fffc3070 18
  MbxRemoveTask.atHead                       code  fffc30a8 18
  MbxRemoveTask.tqEmpty                      code  fffc30ec 18
  MbxRemoveTask.xit                          code  fffc30f4 18
  MonEntry                                   code  fffc04f8 18
  Monitor                                    code  fffc0510 18
  Monitor.0001                               code  fffc054c 18
  Monitor.0002                               code  fffc058c 18
  Monitor.0003                               code  fffc05bc 18
  Monitor.0004                               code  fffc05fc 18
  Monitor.0005                               code  fffc0744 18
  Monitor.0006                               code  fffc06a8 18
  Monitor.0007                               code  fffc06cc 18
  Monitor.0008                               code  fffc06d8 18
  Monitor.0009                               code  fffc06f8 18
  Monitor.0010                               code  fffc0710 18
  Monitor.0011                               code  fffc072c 18
  Monitor.0012                               code  fffc0744 18
  Monitor.basSize                            code  fffc064c 18
  Monitor.doBackspace                        code  fffc05ac 18
  Monitor.doDelete                           code  fffc0584 18
  Monitor.getFocus                           code  fffc0510 18
  Monitor.hasFocus                           code  fffc0530 18
  Monitor.noT                                code  fffc06c4 18
  Monitor.notFind                            code  fffc06f4 18
  Monitor.notX                               code  fffc061c 18
  Monitor.procLine                           code  fffc05dc 18
  Monitor.skip                               code  fffc05e4 18
  Monitor.skip2                              code  fffc05f4 18
  MonitorASR                                 code  fffc0e94 18
  MsgFinalizer                               code  fffc3710 18
  NEW                                        code  fffc4940 18
  NEXT                                       code  fffc4ce4 18
  NPAGES                                    const  000300 11
  NR_DCB                                    const  000020 7
  NR_DCB.done                                code  000000 18
  NR_DCB.noWait                              code  000000 18
  NR_TCB                                    const  000020 7
  NTASK                                     const  000020 7
  NUMWKA                                    const  00079c 12
  NX0                                        code  fffc4d00 18
  NX1                                        code  fffc4d40 18
  NX2                                        code  fffc4d20 18
  NX3                                        code  fffc4d44 18
  NX4                                        code  fffc4cfc 18
  NX5                                        code  fffc4d14 18
  NXPurge                                    code  fffc4d54 18
  OBJCollectionIndex                        const  00001c 6
  OBJFWAddr                                 const  000028 7
  OBJFinalizer                              const  000030 7
  OBJID                                     const  000014 6
  OBJMagic                                  const  000000 1
  OBJOwningMap                              const  00001a 6
  OBJPad1                                   const  00001b 6
  OBJPad3                                   const  000024 7
  OBJScavcnt                                const  000019 6
  OBJSize                                   const  000008 5
  OBJState                                  const  000018 6
  OBJTypenum                                const  000010 6
  OBJUsedInMap                              const  000020 7
  OBJ_SIZE                                  const  000040 8
  OKMSG                                      code  fffc633a 18
  ONIRQ                                      code  fffc4aa8 18
  ONIRQ1                                     code  fffc4ac8 18
  OREXPR                                     code  fffc5248 18
  OSCallTbl                                  code  fffc2458 18
  OSECALL                                    code  fffc2b20 18
  OSECALL.badFunc                            code  fffc2ba8 18
  OSEcallTbl                                 code  fffc2462 18
  OSExit                                     code  fffc2bb0 18
  OSOCall                                    code  fffc2a90 18
  OSOCall.badFunc                            code  fffc2b14 18
  OSPAGES                                   const  000010 6
  OSSP                                      const  000700 12
  OST_BLACK                                 const  000002 3
  OST_DEAD                                  const  000080 9
  OST_GREY                                  const  000001 2
  OST_UNDEAD                                const  000040 8
  OST_WHITE                                 const  000000 1
  OS_SEMA                                   const  ffdb0000 33
  OUTC                                       code  fffc62bc 18
  OUTPTR                                    const  0007b0 12
  OpenSpace                                  code  fffc474c 18
  OpenSpace.0003                             code  fffc4764 18
  OpenSpace.noSpace                          code  fffc4780 18
  PAGESZ                                    const  000400 12
  PAM                                       const  001000 14
  PAMAlloc                                   code  fffc18c0 18
  PAMAlloc.markNext                          code  fffc1908 18
  PAMAlloc.outOfMem                          code  fffc1940 18
  PAMAlloc.xit                               code  fffc1928 18
  PAMAlloc.xit2                              code  fffc1948 18
  PAMDump                                    code  fffc1b70 18
  PAMDump.0001                               code  fffc1b7c 18
  PAMFindRun                                 code  fffc1810 18
  PAMFindRun.foundRun                        code  fffc18a0 18
  PAMFindRun.nextPage                        code  fffc1840 18
  PAMFindRun.notAvailable                    code  fffc188c 18
  PAMFindRun.outOfMem                        code  fffc1898 18
  PAMFindRun.runInc                          code  fffc1854 18
  PAMFindRun.xit                             code  fffc18a4 18
  PAMFree                                    code  fffc1960 18
  PAMFree.endOfRun                           code  fffc19c4 18
  PAMFree.lastPage                           code  fffc19b4 18
  PAMFree.nextPage                           code  fffc1988 18
  PAMFree.xit                                code  fffc19d0 18
  PAMGetbitPair                              code  fffc1aa0 18
  PAMInit                                    code  fffc1ad0 18
  PAMInit.0001                               code  fffc1b00 18
  PAMInit.0002                               code  fffc1adc 18
  PAMInit.0003                               code  fffc1b20 18
  PAMMarkPage                                code  fffc19e0 18
  PAMMarkPage.0001                           code  fffc19f4 18
  PAMMarkPage.gotFree                        code  fffc1a14 18
  PAMMarkPage.xit                            code  fffc1a20 18
  PAMPtr                                    const  000ff8 13
  PAMSetbitPair                              code  fffc1a50 18
  PAMUnmarkPage                              code  fffc1a30 18
  PAMend                                    const  001080 14
  PAMxit                                     code  fffc1a9c 18
  PARN                                       code  fffc5648 18
  PEEK                                       code  fffc5838 18
  PEEKH                                      code  fffc5868 18
  PEEKW                                      code  fffc5850 18
  PKER                                       code  fffc5210 18
  POKE                                       code  fffc518c 18
  POKEH                                      code  fffc51e4 18
  POKEW                                      code  fffc51b8 18
  POPA_                                      code  fffc5c74 18
  PP1                                        code  fffc5ca8 18
  PR0                                        code  fffc4b5c 18
  PR1                                        code  fffc4b74 18
  PR2                                        code  fffc4b48 18
  PR3                                        code  fffc4b94 18
  PR4                                        code  fffc4b8c 18
  PR6                                        code  fffc4ba8 18
  PR8                                        code  fffc4bb0 18
  PRINT                                      code  fffc4b30 18
  PRI_LOW                                   const  000003 3
  PRI_NORMAL                                const  000002 3
  PRMESG                                     code  fffc60c4 18
  PRTLN                                      code  fffc5ec4 18
  PRTNUM                                     code  fffc5df0 32
  PRTNUM.PN1                                 code  fffc5e24 18
  PRTNUM.PN2                                 code  fffc5e20 18
  PRTNUM.PN3                                 code  fffc5e4c 18
  PRTNUM.PN4                                 code  fffc5e5c 18
  PRTNUM.PN5                                 code  fffc5e68 18
  PRTNUM.PN6                                 code  fffc5e6c 18
  PRTNUM.PN7                                 code  fffc5e34 18
  PRTSTG                                     code  fffc5cf0 18
  PRTSTG.PRTRET                              code  fffc5d34 18
  PRTSTG.PS1                                 code  fffc5d10 18
  PU1                                        code  fffc5ce4 18
  PUSHA_                                     code  fffc5cac 18
  PWORD                                      code  fffc5120 18
  PeekMsg                                    code  fffc3560 18
  PeekMsg.badMbx                             code  fffc360c 18
  PeekMsg.noMsg                              code  fffc3604 18
  PeekMsg.nod1                               code  fffc35d4 18
  PeekMsg.nod2                               code  fffc35e8 18
  PeekMsg.nod3                               code  fffc35fc 18
  PeekMsg.nodq                               code  fffc35b4 18
  PeekMsg.ret                                code  fffc3610 18
  PutHexByte                                 code  fffc0b60 18
  PutHexHalf                                 code  fffc0b30 18
  PutHexNybble                               code  fffc0b90 18
  PutHexNybble.0001                          code  fffc0bc4 18
  PutHexNybble.lt10                          code  fffc0bbc 18
  PutHexWord                                 code  fffc0b00 18
  PutString                                  code  fffc0be0 18
  PutString.0001                             code  fffc0bf0 18
  PutString.done                             code  fffc0c04 18
  Putch                                      code  fffc03e0 18
  QNDX                                      const  000304 11
  QSORRY                                     code  fffc5a8c 18
  QT1                                        code  fffc5d70 18
  QT2                                        code  fffc5db0 18
  QT3                                        code  fffc5d88 18
  QT4                                        code  fffc5d9c 18
  QT5                                        code  fffc5dbc 18
  QTSTG                                      code  fffc5d58 18
  QWHAT                                      code  fffc5a98 18
  RDYQ1                                     const  000500 12
  RDYQ2                                     const  000600 12
  RDYQ3                                     const  000700 12
  READYQ                                    const  000400 12
  RETURN                                     code  fffc4c14 18
  RND                                        code  fffc58c0 18
  RUN                                        code  fffc4998 18
  RUN1                                       code  fffc4a10 18
  RUN2                                       code  fffc49b4 18
  RUN3                                       code  fffc49b8 18
  RUNNXL                                     code  fffc49ac 18
  RUNSML                                     code  fffc4a2c 18
  RUNTSL                                     code  fffc4a24 18
  RegsetTid                                 const  0010f0 14
  RemoveFromReadyQueue                       code  fffc3a10 18
  RemoveFromReadyQueue.emptyList             code  fffc3a50 18
  RemoveFromReadyQueue.hr1                   code  fffc3a60 18
  RemoveFromReadyQueue.hr2                   code  fffc3a70 18
  RemoveFromReadyQueue.hr3                   code  fffc3a80 18
  RemoveFromReadyQueue.hr4                   code  fffc3a90 18
  RemoveFromReadyQueue.retx                  code  fffc3a4c 18
  RemoveFromReadyQueue.xit                   code  fffc3a40 18
  RemoveFromTimeoutList                      code  fffc3b50 18
  RemoveFromTimeoutList.0001                 code  fffc3b6c 18
  RemoveFromTimeoutList.atHead               code  fffc3ba8 18
  RemoveFromTimeoutList.atTail2              code  fffc3bcc 18
  RemoveFromTimeoutList.found                code  fffc3b80 18
  RemoveFromTimeoutList.retx                 code  fffc3be4 18
  RemoveFromTimeoutList.xit                  code  fffc3bd8 18
  SAVE                                       code  fffc5098 18
  SAVE1                                      code  fffc50a8 18
  SAVE2                                      code  fffc50c4 18
  SAVE3                                      code  fffc502c 18
  SAVE4                                      code  fffc505c 18
  SAVEND                                     code  fffc50dc 18
  SDReadSector                               code  800000000000049e 32
  SDWriteSector                              code  80000000000004a3 32
  SENDMSG                                    code  fffc6148 18
  SENDMSG.err                                code  fffc61cc 18
  SENDMSG.paren                              code  fffc61d8 18
  SETVAL                                     code  fffc59ac 18
  SETVAL.sv2                                 code  fffc59d0 18
  SGN                                        code  fffc5954 18
  SGN1                                       code  fffc5984 18
  SGN2                                       code  fffc5974 18
  SIZEX                                      code  fffc5990 18
  SLEEP                                      code  fffc495c 18
  SLEEP1                                     code  fffc4968 18
  SRCHLN                                    const  00071c 12
  SRYMSG                                     code  fffc6347 18
  ST2                                        code  fffc4660 18
  STACKOFFS                                 const  00fffc 17
  STKBOT                                    const  0007a4 12
  STKGOS                                    const  000714 12
  STKINP                                    const  0007a0 12
  STOP                                       code  fffc4954 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc5a0c 18
  SYSX                                       code  fffc521c 18
  SchedulerIRQ                               code  fffc2d80 18
  SchedulerIRQ.0001                          code  fffc2da8 18
  SchedulerIRQ.noCtxSwitch                   code  fffc2e60 18
  SchedulerIRQ.noException                   code  fffc2e58 18
  SchedulerIRQ.noOS                          code  fffc2d90 18
  SchedulerIRQ.rmvFromTol                    code  fffc2dd0 18
  SchedulerIRQ.toDone                        code  fffc2e08 18
  SelectTaskToRun                            code  fffc27f0 18
  SelectTaskToRun.checkAgain                 code  fffc27f8 18
  SelectTaskToRun.dq                         code  fffc2850 18
  SelectTaskToRun.mod                        code  fffc283c 18
  SelectTaskToRun.nxtQ                       code  fffc2824 18
  SelectTaskToRun.xit                        code  fffc286c 18
  SerHeadRcv                                const  001c00 14
  SerHeadXmit                               const  001c08 14
  SerRcvBuf                                 const  001400 14
  SerRcvXoff                                const  001c11 14
  SerRcvXon                                 const  001c10 14
  SerTailRcv                                const  001c04 14
  SerTailXmit                               const  001c0c 14
  SerXmitBuf                                const  001800 14
  SerialDCB                                  code  fffc1c28 18
  SerialFinishCmd                            code  fffc1e04 18
  SerialFinishCmd.0001                       code  fffc1e38 18
  SerialFuncTbl                              code  fffc1ba8 18
  SerialGetChar                              code  fffc1e40 18
  SerialGetChar.0001                         code  fffc1ef8 18
  SerialGetChar.0002                         code  fffc1ea8 18
  SerialGetChar.noChars                      code  fffc1ef8 18
  SerialGetChar.xit                          code  fffc1efc 18
  SerialGetUI                                code  fffc2220 18
  SerialIRQ                                  code  fffc2130 18
  SerialIRQ.0001                             code  fffc216c 18
  SerialIRQ.notRxInt                         code  fffc2214 18
  SerialIRQ.nxtByte                          code  fffc2130 18
  SerialIRQ.rxFull                           code  fffc2214 18
  SerialInit                                 code  fffc1cd0 18
  SerialNOP                                  code  fffc1d80 18
  SerialPeekChar                             code  fffc1f20 18
  SerialPeekChar.0001                        code  fffc1f68 18
  SerialPeekChar.noChars                     code  fffc1f68 18
  SerialPeekChar.xit                         code  fffc1f6c 18
  SerialPeekCharDirect                       code  fffc1f90 18
  SerialPeekCharDirect.0001                  code  fffc1fcc 18
  SerialPeekCharDirect.xit                   code  fffc1fd0 18
  SerialPutChar                              code  fffc1ff0 18
  SerialPutChar.0001                         code  fffc2018 18
  SerialPutChar.0003                         code  fffc2008 18
  SerialPutChar.goSleep                      code  fffc2068 18
  SerialPutChar.noFunc                       code  fffc2080 18
  SerialPutChar.xit                          code  fffc204c 18
  SerialPutCharEx                            code  fffc20c0 18
  SerialPutCharEx.0001                       code  fffc20c0 18
  SerialRcvCount                             code  fffc20f0 18
  SerialRcvCount.xit                         code  fffc2124 18
  SerialService                              code  fffc1d9c 18
  SerialServiceInit                          code  fffc1d84 18
  SerialServiceLoop                          code  fffc1db8 18
  SerialServiceLoop.0001                     code  fffc1db8 18
  SerialSetup                                code  fffc1c90 18
  SetIRQFlag                                 code  fffc2680 18
  SkipSpaces                                 code  fffc09f0 18
  SkipSpaces.skip1                           code  fffc0a08 18
  SkipSpaces.skip2                           code  fffc09f0 18
  StackTbl                                   code  fffc0c70 18
  StackTbl2                                  code  fffc0cf0 18
  SwapContext                                code  fffc2880 18
  SwitchIOFocusHelper                        code  fffc3ef0 18
  SwitchIOFocusHelper.notSame                code  fffc3f24 18
  SwitchIOFocusHelper.zeroAppid              code  fffc3f1c 18
  SysHeapEnd                                const  020000 19
  SysHeapStart                              const  004000 16
  SysSema                                   const  000340 11
  SystemASR                                  code  fffc0edc 18
  TAB                                       const  000009 5
  TAB1                                       code  fffc4788 18
  TAB10                                      code  fffc4847 18
  TAB10_1                                    code  fffc48b8 18
  TAB1_1                                     code  fffc484a 18
  TAB2                                       code  fffc479f 18
  TAB2_1                                     code  fffc4856 18
  TAB4                                       code  fffc47f8 18
  TAB4_1                                     code  fffc4884 18
  TAB5                                       code  fffc4831 18
  TAB5_1                                     code  fffc489e 18
  TAB6                                       code  fffc4834 18
  TAB6_1                                     code  fffc48a2 18
  TAB8                                       code  fffc4839 18
  TAB8_1                                     code  fffc48a6 18
  TAB9                                       code  fffc4843 18
  TAB9_1                                     code  fffc48b4 18
  TAILRDY                                   const  000420 12
  TAILRDY0                                  const  000420 12
  TAILRDY1                                  const  000424 12
  TAILRDY2                                  const  000428 12
  TAILRDY3                                  const  00042c 12
  TAILRDY4                                  const  000430 12
  TAILRDY5                                  const  000434 12
  TAILRDY6                                  const  000438 12
  TAILRDY7                                  const  00043c 12
  TBASR                                      code  80000000000001d6 32
  TC1                                        code  fffc5f54 18
  TCBEndTick                                const  0002d8 11
  TCBException                              const  000308 11
  TCBFltRegs                                const  000140 10
  TCBHasFocus                               const  0002cd 11
  TCBImMask                                 const  000345 11
  TCBIntRegs                                const  000040 8
  TCBMbxNext                                const  000348 11
  TCBMbxPrev                                const  000350 11
  TCBMsgD1                                  const  0002d8 11
  TCBMsgD2                                  const  0002e0 11
  TCBMsgD3                                  const  0002e8 11
  TCBName                                   const  000360 11
  TCBNext                                   const  000310 11
  TCBObject                                 const  000000 1
  TCBOpMode                                 const  000344 11
  TCBPTR_MASK                               const  fff803ff 33
  TCBPrev                                   const  000318 11
  TCBPriority                               const  0002c9 11
  TCBRegsEnd                                const  000240 11
  TCBRegset                                 const  0002cc 11
  TCBStackBot                               const  0002d0 11
  TCBStartTick                              const  0002d0 11
  TCBStatus                                 const  0002c8 11
  TCBTaskNum                                const  000358 11
  TCBTicks                                  const  000300 11
  TCBTimeout                                const  000320 11
  TCBWaitMbx                                const  0002ca 11
  TCB_MAGIC                                 const  20544342 31
  TCBappid                                  const  000342 11
  TCBbases                                  const  000240 11
  TCBepc                                    const  0002c0 11
  TCBmid                                    const  000340 11
  TCBtid                                    const  000338 11
  TCBxA0                                    const  000090 9
  TCBxA1                                    const  000098 9
  TCBxA2                                    const  0000a0 9
  TCBxA3                                    const  0000a8 9
  TCBxA4                                    const  0000b0 9
  TCBxA5                                    const  0000b8 9
  TCBxA6                                    const  0000c0 9
  TCBxA7                                    const  0000c8 9
  TCBxFP                                    const  000080 9
  TCBxGP                                    const  000058 8
  TCBxRA                                    const  000048 8
  TCBxS1                                    const  000088 9
  TCBxS10                                   const  000110 10
  TCBxS11                                   const  000118 10
  TCBxS2                                    const  0000d0 9
  TCBxS3                                    const  0000d8 9
  TCBxS4                                    const  0000e0 9
  TCBxS5                                    const  0000e8 9
  TCBxS6                                    const  0000f0 9
  TCBxS7                                    const  0000f8 9
  TCBxS8                                    const  000100 10
  TCBxS9                                    const  000108 10
  TCBxSP                                    const  000050 8
  TCBxT0                                    const  000068 8
  TCBxT1                                    const  000070 8
  TCBxT2                                    const  000078 8
  TCBxT3                                    const  000120 10
  TCBxT4                                    const  000128 10
  TCBxT5                                    const  000130 10
  TCBxT6                                    const  000138 10
  TCBxTP                                    const  000060 8
  TICKX                                      code  fffc5940 18
  TID_POOL                                  const  000310 11
  TN1                                        code  fffc5f84 18
  TN2                                        code  fffc5fb0 18
  TOOBIG                                     code  fffc5a80 18
  TOUPB1                                     code  fffc6024 18
  TOUPBRT                                    code  fffc606c 18
  TOUPBUF                                    code  fffc6014 18
  TOUPRET                                    code  fffc6090 18
  TSNMRET                                    code  fffc5fcc 18
  TSTC                                       code  fffc5f20 18
  TSTNUM                                     code  fffc5f6c 18
  TSTV                                       code  fffc5688 18
  TSTVRT                                     code  fffc56f8 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_UNDEAD                                 const  000040 8
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc56e4 18
  TV2                                        code  fffc56d8 18
  TV3                                        code  fffc56b8 18
  TXTBGN                                    const  001800 14
  TXTUNF                                    const  000704 12
  TaskNum                                   const  000220 11
  Tick                                      const  000330 11
  TidTcbMap                                  code  80000000000003ae 32
  TimeoutList                               const  000328 11
  TinyBasic                                  code  fffc4500 18
  TinyBasicASR                               code  fffc0f24 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  UNDEADQ                                   const  000007 4
  USRX                                       code  fffc5880 18
  UnlockOS                                   code  fffc27d0 18
  UnlockOSSemaphore                          code  fffc27d0 18
  UpdateMsgFields                            code  fffc2c30 18
  UpdateMsgFields.noMsg                      code  fffc2c80 18
  UpdateMsgFields.notWaiting                 code  fffc2c94 18
  UserStart                                  code  fffc01a8 18
  UserStart2                                 code  fffc01b4 18
  UserStart2.appBad                          code  fffc01c4 18
  UserStart3                                 code  fffc0248 18
  UserStart3.0002                            code  fffc0284 18
  UserStart3.0003                            code  fffc0298 18
  UserStart3.0004                            code  fffc0274 18
  UserStart3.noMbx                           code  fffc0284 18
  VARBGN                                    const  000708 12
  VAREND                                    const  00070c 12
  VIA                                       const  ffdc0600 33
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IER                                   const  000038 7
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  VIA_T2CH                                  const  000024 7
  VIA_T2CL                                  const  000020 7
  ViaDCB                                     code  fffc22b8 18
  ViaFuncTbl                                 code  fffc2238 18
  ViaIRQ                                     code  fffc23c0 18
  ViaIRQ.0001                                code  fffc23d4 18
  ViaIRQ.timer2irq                           code  fffc2408 18
  ViaIRQ.timer3irq                           code  fffc23e0 18
  ViaInit                                    code  fffc2360 18
  ViaNOP                                     code  fffc2354 18
  ViaSetup                                   code  fffc2320 18
  ViaTime                                    code  fffc2420 18
  VirtToLinear                               code  fffc1750 18
  VirtToPhys                                 code  fffc1780 18
  VirtToPhys.notMapped                       code  fffc17b8 18
  VirtToPhys2                                code  fffc17d0 18
  VirtToPhys2.notMapped                      code  fffc17d8 18
  WAITIRQ                                    code  fffc4ad0 18
  WAITMSG                                    code  fffc61e4 18
  WAITMSG.0001                               code  fffc621c 18
  WAITMSG.0002                               code  fffc6210 18
  WAITMSG.err                                code  fffc62a4 18
  WAITMSG.paren                              code  fffc62b0 18
  WSTART                                     code  fffc45f0 18
  WaitForIOFocus                             code  fffc4070 18
  WaitForIOFocus.0001                        code  fffc40a0 18
  WaitForIOFocus.HasFocus                    code  fffc40d4 18
  WaitForIOFocus.WFF1                        code  fffc4080 18
  WaitForIOFocus.WFF2                        code  fffc40c4 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc53cc 18
  XP12                                       code  fffc53e4 18
  XP13                                       code  fffc53fc 18
  XP14                                       code  fffc5414 18
  XP15                                       code  fffc542c 18
  XP16                                       code  fffc5444 18
  XP17                                       code  fffc5484 18
  XP18                                       code  fffc549c 18
  XP21                                       code  fffc54ec 18
  XP22                                       code  fffc54f8 18
  XP23                                       code  fffc54fc 18
  XP24                                       code  fffc5518 18
  XP25                                       code  fffc552c 18
  XP26                                       code  fffc5538 18
  XP31                                       code  fffc5568 18
  XP34                                       code  fffc5598 18
  XP35                                       code  fffc55bc 18
  XP40                                       code  fffc5614 18
  XP41                                       code  fffc5630 18
  XP42                                       code  fffc566c 18
  XP43                                       code  fffc5678 18
  XP45                                       code  fffc5544 18
  XP46                                       code  fffc563c 18
  XP47                                       code  fffc55e0 18
  XPRT0                                      code  fffc545c 18
  XPRT1                                      code  fffc5470 18
  XP_AND                                     code  fffc52dc 18
  XP_AND1                                    code  fffc52bc 18
  XP_ANDX                                    code  fffc52f0 18
  XP_OR                                      code  fffc527c 18
  XP_OR1                                     code  fffc525c 18
  XP_ORX                                     code  fffc5290 18
  YIELD0                                     code  fffc4990 18
  _WaitForIOFocus                            code  fffc4070 18
  _clr                                       code  fffc4a68 18
  _cls                                       code  8000000000000422 32
  _end_init_data                           rodata  fffc7000 32
  _rdcf                                      code  8000000000000424 32
  a2h1                                       code  fffc4f4c 18
  asciiToHex                                 code  fffc4f40 18
  begin_init_data                          rodata  fffc7000 32
  clearVars                                  code  fffc4a70 18
  clearVars.cv1                              code  fffc4a84 18
  doMem                                      code  fffc0750 18
  doMem.0001                                 code  fffc0768 18
  doMem.0002                                 code  fffc07e8 18
  doMem.0003                                 code  fffc082c 18
  doMem.0004                                 code  fffc0810 18
  doMem.loop                                 code  fffc07c4 18
  doMem.loop2                                code  fffc079c 18
  doMem.unprintable                          code  fffc0824 18
  doMem.userMem                              code  fffc07e4 18
  doPStat                                    code  fffc08c0 18
  doPStat.0001                               code  fffc08d4 18
  doVMem                                     code  fffc0860 18
  doVMem.0001                                code  fffc0870 18
  doVMem.notLF                               code  fffc0888 18
  ec1                                        code  fffc5a74 18
  end_init_data                            rodata  fffc7000 32
  fgetc                                      code  fffc0490 18
  fgetc.0001                                 code  fffc04c4 18
  fgetc.0002                                 code  fffc04d8 18
  fgetc.0003                                 code  fffc04d4 18
  fgetc.checkOwner                           code  fffc04b8 18
  fgetc.notOwner                             code  fffc04f0 18
  findVar                                    code  fffc57c8 18
  fl1                                        code  fffc5bf0 18
  flt10                                      code  fffc10a5 18
  flt20                                      code  fffc1095 18
  flt50                                      code  fffc1085 18
  fltMillion                                 code  fffc147c 18
  fltOne                                     code  fffc1474 18
  fltTen                                     code  fffc1478 18
  fltToString                                code  fffc10b5 18
  fltToString.0001                           code  fffc1116 18
  fltToString.0002                           code  fffc1196 18
  fltToString.0003                           code  fffc1182 18
  fltToString.0004                           code  fffc11e2 18
  fltToString.0005                           code  fffc11da 18
  fltToString.0006                           code  fffc11c2 18
  fltToString.0007                           code  fffc11fe 18
  fltToString.0008                           code  fffc1212 18
  fltToString.0009                           code  fffc120e 18
  fltToString.0010                           code  fffc1232 18
  fltToString.0011                           code  fffc12be 18
  fltToString.0012                           code  fffc1276 18
  fltToString.0013                           code  fffc1262 18
  fltToString.0014                           code  fffc1292 18
  fltToString.0015                           code  fffc12ae 18
  fltToString.0016                           code  fffc124a 18
  fltToString.0017                           code  fffc12b6 18
  fltToString.0018                           code  fffc12be 18
  fltToString.0019                           code  fffc12f2 18
  fltToString.0020                           code  fffc12fe 18
  fltToString.0021                           code  fffc1322 18
  fltToString.0022                           code  fffc132e 18
  fltToString.0023                           code  fffc133e 18
  fltToString.0024                           code  fffc134a 18
  fltToString.0025                           code  fffc1336 18
  fltToString.0026                           code  fffc135e 18
  fltToString.0027                           code  fffc1366 18
  fltToString.0028                           code  fffc136e 18
  fltToString.0029                           code  fffc137a 18
  fltToString.0030                           code  fffc1386 18
  fltToString.0031                           code  fffc1392 18
  fltToString.0032                           code  fffc139a 18
  fltToString.0034                           code  fffc13a2 18
  fltToString.0035                           code  fffc13ae 18
  fltToString.0036                           code  fffc13be 18
  fltToString.0037                           code  fffc13ca 18
  fltToString.0038                           code  fffc13d2 18
  fltToString.0039                           code  fffc13e6 18
  fltToString.0040                           code  fffc13da 18
  fltToString.0041                           code  fffc1442 18
  fltToString.0042                           code  fffc1406 18
  fltToString.0043                           code  fffc1416 18
  fltToString.0044                           code  fffc142a 18
  fltToString.0045                           code  fffc140e 18
  fltToString.0046                           code  fffc1436 18
  fltToString.0047                           code  fffc1442 18
  fltToString.0048                           code  fffc142e 18
  fltToString.0050                           code  fffc1462 18
  fltToString.0051                           code  fffc145e 18
  fltToString.0052                           code  fffc144e 18
  fltToString.inf                            code  fffc10fe 18
  fltToString.notZero                        code  fffc1152 18
  fltToString.pos                            code  fffc113e 18
  fltToString.prt                            code  fffc13f6 18
  fputc                                      code  fffc0410 18
  fputc.0001                                 code  fffc044c 18
  fputc.checkOwner                           code  fffc0444 18
  fputc.noBypass                             code  fffc0430 18
  fputc.notOwner                             code  fffc047c 18
  fputc.xit                                  code  fffc0460 18
  fv1                                        code  fffc5810 18
  fv2                                        code  fffc5824 18
  fv3                                        code  fffc5808 18
  fv4                                        code  fffc57d8 18
  gcIncrement                                code  fffc4434 18
  gen_rand                                   code  80000000000004ec 32
  getVarName                                 code  fffc571c 18
  gfn1                                       code  fffc4fc0 18
  gfn2                                       code  fffc4f70 18
  gfn3                                       code  fffc4fa0 18
  gosub1                                     code  fffc4bf0 18
  gvn1                                       code  fffc57b4 18
  gvn2                                       code  fffc5778 18
  gvn3                                       code  fffc5794 18
  gvn4                                       code  fffc573c 18
  gvn6                                       code  fffc5768 18
  isAlnum                                    code  fffc5358 18
  isAlpha                                    code  fffc5328 18
  isAlphaFalse                               code  fffc5350 18
  isAlphaTrue                                code  fffc5348 18
  isDigit                                    code  fffc5308 18
  isDigitFalse                               code  fffc5320 18
  isDigitx                                   code  fffc536c 18
  mbxs                                      const  000800 13
  mbxs_end                                  const  000c00 13
  milliseconds                              const  000208 11
  missed_ticks                              const  000320 11
  msgBadGotoGosub                            code  fffc646d 18
  msgBytesFree                               code  fffc63a5 18
  msgCRLF                                    code  fffc1082 18
  msgComma                                   code  fffc63ba 18
  msgDivZero                                 code  fffc637c 18
  msgEnvFail                                 code  fffc64d5 18
  msgExtraChars                              code  fffc64b3 18
  msgFinalizerRunning                        code  fffc441c 18
  msgIdleAnnounce                            code  fffc0390 18
  msgInf                                     code  fffc146c 18
  msgInit                                    code  fffc6304 18
  msgInputVar                                code  fffc641c 18
  msgLineRange                               code  fffc63cd 18
  msgMonHelp                                 code  fffc0f82 18
  msgNan                                     code  fffc1470 18
  msgNextFor                                 code  fffc6438 18
  msgNextVar                                 code  fffc644a 18
  msgNumTooBig                               code  fffc6369 18
  msgParen                                   code  fffc64ef 18
  msgRNDBad                                  code  fffc63f8 18
  msgReadError                               code  fffc634f 18
  msgReady                                   code  fffc63b2 18
  msgReadyQueue                              code  fffc3e1c 18
  msgRetWoGosub                              code  fffc6489 18
  msgSYSBad                                  code  fffc640b 18
  msgStart                                   code  fffc0f6c 18
  msgTaskInfo                                code  fffc3e46 18
  msgTaskStart                               code  fffc1074 18
  msgTimeoutList                             code  fffc3e75 18
  msgTooBig                                  code  fffc649f 18
  msgVar                                     code  fffc63e2 18
  msgVarSpace                                code  fffc638e 18
  msgWhat                                    code  fffc6340 18
  nmeSerial                                  code  fffc222c 18
  prCRLF                                     code  fffc5dc8 18
  pword1                                     code  fffc5134 18
  pword2                                     code  fffc5150 18
  qToChk                                     code  fffc24c2 18
  return1                                    code  fffc4c2c 18
  rnd1                                       code  fffc58f4 18
  rnd2                                       code  fffc5904 18
  switchflag                                const  000200 11
  sysx1                                      code  fffc5230 18
  tah1                                       code  fffc5184 18
  toAsciiHex                                 code  fffc5174 18
  toUpper                                    code  fffc6078 18
  tstv_notfound                              code  fffc5708 18
  usrJmp                                    const  0007a8 12

Undefined Symbols
  ASRIUDataSize                              code  800000000000035e 32
  AUXIN                                      code  80000000000003e0 32
  AUXIN_INIT                                 code  800000000000049d 32
  AUXOUT                                     code  80000000000003de 32
  AUXOUT_FLUSH                               code  80000000000004aa 32
  AUXOUT_INIT                                code  80000000000004a1 32
  FMTK_PostMsg                               code  80000000000002ec 32
  FreeTID                                    code  800000000000030c 32
  IOF_NEXT                                   code  8000000000000330 32
  IOF_PREV                                   code  8000000000000331 32
  MbxFinalizer                               code  800000000000033a 32
  SDReadSector                               code  800000000000049e 32
  SDWriteSector                              code  80000000000004a3 32
  TBASR                                      code  80000000000001d6 32
  TidTcbMap                                  code  80000000000003ae 32
  _cls                                       code  8000000000000422 32
  _rdcf                                      code  8000000000000424 32
  gen_rand                                   code  80000000000004ec 32

  Macro Name
 mDI                                       -842150451

  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts

 mEI                                       -842150451

  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts

 mGetAppMid                                -842150451

  sll   $a0,$a0,#LOG_PGSZ
  ldb   $a0,ACBmid[$a0]

 mGetCurrentTid                            -842150451

  csrrw $a0,#CSR_TASKID,$x0

 mHasFocus                                 -842150451

	ldi		$a0,#20
	ecall

 mMbxHandleToPointer                       -842150451

  srl   $t0,$a0,#8    ; extract collection index
  sll   $t0,$t0,#2
  ldt   $t0,MbxBlockPtr[$t0]
  and   $a0,$a0,#$FF
  sll   $a0,$a0,#2
  or    $a0,$a0,$t0

 mMbxHandleToPointer2                      2

    srl   1,0,#8        ; extract collection index
    sll   1,1,#2
    ldt   1,MbxBlockPtr[1]
    and   0,0,#$FF
    sll   0,0,#2
    or    0,0,1

 mSleep                                    1

		ldi				$a0,#5                        ; FMTK Sleep() function
		ldi				$a1,#0
		ecall

 mTimeSliceDI                              -842150451

	ldi		$t0,#$100						; disable timer3 (time slice) interrupts
	stt		$t0,VIA_IER+VIA
	nop                   ; make sure disable has time for effect
	nop

 mTimeSliceEI                              -842150451

	ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
	stt		$t0,VIA_IER+VIA

 mTimeSliceEI2                             1

		ldi				$t0,#$000180|(0<<24)				; enable timer3 interrupts after tm cycles
		stt				$t0,VIA_IER+VIA

 mUnlockSemaphore                          1

		ldi				a0,#-1
		stt				a0,0

 mWaitForFocus                             -842150451

.WFF1@:
  mov   $t2,$a1
	
	ldi		$a0,#20
	ecall
bnez	$a1,.HasFocus@
	ldi   $a0,#26             ; FMTK_IO
	mov   $a1,$t2
	ldi   $a2,#9              ; peekchar function
	ecall
	ldi		$t3,#$14						; CTRL-T
	bne		$a0,$t3,.WFF2@
	; eat up the CTRL-T
	ldi		$a0,#26							; FMTK_IO
	mov   $a1,$t2
	ldi		$a2,#8							; getchar function
	ecall
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
		ldi				$a0,#5                        ; FMTK Sleep() function
		ldi				$a1,#1
		ecall

	bra		.WFF1@
.HasFocus@:

0 compressable instructions
The top 1024 are:
Comp  Opcode  Count

number of bytes: 22152.000000
number of instructions: 5538
number of compressed instructions: 0
4.000000 bytes (32 bits) per instruction
Compression ratio: 0.000000%
Number of long branches: 0
