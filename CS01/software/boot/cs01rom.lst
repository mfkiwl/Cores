                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_UNDEAD   EQU   64
                        	TS_RUNNING	EQU		128
                        	
                        	AS_NONE     EQU   0
                        	AS_LIVE     EQU   1
                        	AS_DEAD     EQU   2
                        	AS_UNDEAD   EQU   4
                        	
                        	PRI_NORMAL  EQU   2
                        	PRI_LOW     EQU   3
                        	
                        	OST_WHITE   EQU   0
                        	OST_GREY    EQU   1
                        	OST_BLACK   EQU   2
                        	OST_UNDEAD  EQU   64    ; no longer alive, but not dead yet (finalizer hasn't been called)
                        	OST_DEAD    EQU   128   ; completely dead, finalizer called already
                        	
                        	TCB_MAGIC     EQU   ((' ' << 24) | ('T' << 16) | ('C' << 8) | 'B')
ACB_MAGIC     EQU   ((' ' << 24) | ('A' << 16) | ('C' << 8) | 'B')
MSG_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('S' << 8) | 'G')
MBX_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('B' << 8) | 'X')

                        	OT_TCB		EQU		0
                        	OT_ACB		EQU		1
                        	OT_MSG		EQU		2
                        	OT_MBX		EQU		3
                        	
                        	UNDEADQ     EQU   7
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_Func  =   0x02
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadDCBOffset = 0x1A
                        	E_Busy = 0x1B
                        	E_BadAppId = 0x1C
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	E_BadTcbPointer = 0x27
                        	E_BadTid = 0x28
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	= 0x44
                        	E_NoMoreTcbs	=	0x45
                        	E_NoMoreAppIds = 0x46
                        	E_NoMem = 0x47
                        	
                        	CSR_SATP		= $180
                        	CSR_MSTATUS = $300
                        	CSR_MEPC    = $341
                        	CSR_TRACECTRL = $7A0
                        	CSR_REGSET  = $7C0
                        	CSR_MSEMA   = $7C1
                        	CSR_TASKID  = $7C2
                        	CSR_RSSTACK = $7C3
                        	CSR_PMSTACK = $7C4
                        	CSR_IMSTACK = $7C5
                        	TCBPTR_MASK = $FFF803FF
                        	
                        	; Message types
                        	MT_ANNOUNCE = $00000010
                        	MT_IRQ      = $FFFFFFFF
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/types.r5a",1
                        	.file "../fmtk/types.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	OBJMagic    EQU   0
                        	OBJSize     EQU   8
                        	OBJTypenum  EQU   16
                        	OBJID       EQU   20
                        	OBJState    EQU   24    ; WHITE, GREY, BLACK
                        	OBJScavcnt  EQU   25    ; scavange count
                        	OBJOwningMap  EQU   26
                        	OBJPad1       EQU   27
                        	OBJCollectionIndex  EQU   28
                        	OBJUsedInMap  EQU   32    ; used in map
                        	OBJPad3       EQU   36
                        	OBJFWAddr     EQU   40    ; forwarding address
                        	OBJFinalizer  EQU   48
                        	OBJ_SIZE      EQU   64
                        	
                        	; Task Control Block
                        	TCBObject   EQU   $000    ; Object structure, state
                        	TCBIntRegs  EQU   $040    ; integer register set storage area (room for 64-bit)
                        	TCBxRA      EQU   $048
                        	TCBxSP      EQU   $050
                        	TCBxGP      EQU   $058
                        	TCBxTP      EQU   $060
                        	TCBxT0      EQU   $068
                        	TCBxT1      EQU   $070
                        	TCBxT2      EQU   $078
                        	TCBxFP      EQU   $080
                        	TCBxS1      EQU   $088
                        	TCBxA0      EQU   $090
                        	TCBxA1      EQU   $098
                        	TCBxA2      EQU   $0A0
                        	TCBxA3      EQU   $0A8
                        	TCBxA4      EQU   $0B0
                        	TCBxA5      EQU   $0B8
                        	TCBxA6      EQU   $0C0
                        	TCBxA7      EQU   $0C8
                        	TCBxS2      EQU   $0D0
                        	TCBxS3      EQU   $0D8
                        	TCBxS4      EQU   $0E0
                        	TCBxS5      EQU   $0E8
                        	TCBxS6      EQU   $0F0
                        	TCBxS7      EQU   $0F8
                        	TCBxS8      EQU   $100
                        	TCBxS9      EQU   $108
                        	TCBxS10     EQU   $110
                        	TCBxS11     EQU   $118
                        	TCBxT3      EQU   $120
                        	TCBxT4      EQU   $128
                        	TCBxT5      EQU   $130
                        	TCBxT6      EQU   $138
                        	TCBFltRegs  EQU   $140    ; float register set storage area
                        	TCBRegsEnd  EQU   $240
                        	; First 128 bytes are for integer register set
                        	; Second 128 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBbases  	EQU		$240		; base register storage
                        	TCBepc  		EQU		$2C0
                        	TCBStatus		EQU		$2C8
                        	TCBPriority	EQU		$2C9
                        	TCBWaitMbx	EQU		$2CA
                        	TCBRegset   EQU   $2CC
                        	TCBHasFocus EQU   $2CD
                        	TCBStackBot	EQU		$2D0
                        	TCBMsgD1		EQU		$2D8
                        	TCBMsgD2		EQU		$2E0
                        	TCBMsgD3		EQU		$2E8
                        	TCBStartTick	EQU	$2D0
                        	TCBEndTick	EQU		$2D8
                        	TCBTicks		EQU		$300
                        	TCBException	EQU	$308
                        	TCBNext			EQU		$310
                        	TCBPrev			EQU		$318
                        	TCBTimeout	EQU		$320
                        	TCBtid      EQU   $338
                        	TCBmid      EQU   $340
                        	TCBappid    EQU   $342
                        	TCBOpMode   EQU   $344
                        	TCBImMask		EQU		$345
                        	TCBMbxNext  EQU   $348
                        	TCBMbxPrev  EQU   $350
                        	TCBTaskNum  EQU   $358
                        	TCBName			EQU		$360
                        	
                        	; Application Control Block
                        	ACBObject     EQU   0
                        	ACBpData      EQU   64
                        	ACBDataSize   EQU   72
                        	ACBpUIData    EQU   80
                        	ACBUIDataSize EQU   88
                        	ACBGCRoots    EQU   96
                        	ACBGCRootCnt  EQU   104
                        	ACBGCNdx      EQU   112
                        	ACBGCMarkingQue EQU   120
                        	ACBGCMarkingQueFull   EQU   128
                        	ACBGCMarkingQueEmpty  EQU   129
                        	ACBGCOverflow EQU   130
                        	ACBpCode      EQU   134
                        	ACBObjectList EQU   144
                        	ACBGarbageList  EQU   152
                        	ACBHeap       EQU   160   ; 640+ bytes for heap object info
                        	ACBiofNext    EQU   824
                        	ACBiofPrev    EQU   832
                        	ACBUserName   EQU   840   ; 2 byte index of string in string area
                        	ACBPath       EQU   842   ; 2 byte index of string in string area
                        	ACBExitRunFile  EQU   844 ; 2 byte index of string in string area
                        	ACBCommandLine  EQU   846 ; 2 byte index of string in string area
                        	ACBpVidMem    EQU   848
                        	ACBpVirtVidMem  EQU 856
                        	ACBVideoRows  EQU   864
                        	ACBVideoCols  EQU   865
                        	ACBCursorRow  EQU   866
                        	ACBCursorCol  EQU   867
                        	ACBNormAttr   EQU   868
                        	ACBKeyState1  EQU   872
                        	ACBKeyState2  EQU   874
                        	ACBKeybdWaitFlag  EQU   876
                        	ACBKeybdHead  EQU   878
                        	ACBKeybdTail  EQU   879
                        	ACBKeybdBuffer  EQU   880
                        	ACBnumber     EQU   944
                        	ACBNext       EQU   952
                        	ACBTask       EQU   960
                        	ACBHasFocus   EQU   962
                        	ACBmid        EQU   964
                        	ACBStatus     EQU   966
                        	ACBTemplates  EQU   968   ; 256 * 8 bytes reserved for template pointers
                        	ACBPad        EQU   3016
                        	ACBStrings    EQU   3072  ; start of 1kB string area
                        	ACBEnd        EQU   4096
                        	
                        	; Application startup record
                        	ASRPageSize   EQU   0
                        	ASRPriority   EQU   1
                        	ASRRegset     EQU   2
                        	ASRmid        EQU   3
                        	ASRAffinity   EQU   4
                        	ASRCodeSize   EQU   8
                        	ASRDataSize   EQU   16
                        	ASRUIDataSize EQU   24
                        	ASRHeapSize   EQU   32
                        	ASRStackSize  EQU   40
                        	ASRpCode      EQU   48
                        	ASRpData      EQU   56
                        	ASRpUIData    EQU   64
                        	ASR_SIZE      EQU   72
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	;MBX_WTIDS			equ		4		; tasks waiting at mailbox
                        	MBX_LINK      equ   4
                        	MBX_TQHEAD    equ   4   ; link field for free list shared with task queue head
                        	MBX_TQTAIL    equ   8
                        	MBX_MQHEAD		equ		12		
                        	MBX_MQTAIL		equ		16
                        	MBX_SIZE			equ		20
                        	
                        	MSG_LINK	  equ		0
                        	MSG_RETADR  equ   4
                        	MSG_TGTADR  equ   5
                        	MSG_TYPE    equ   6
                        	MSG_D1		  equ		8
                        	MSG_D2		  equ		12
                        	MSG_D3		  equ		16
                        	MSG_SIZE	  equ		20
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	MAX_TID		EQU		63
                        	NR_TCB		EQU		64
                        	NTASK     EQU   32    ; number of tasks allowed
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		10
                        	LOG_ACBSZ EQU   12
                        	OSPAGES		EQU		48		; pages of memory dedicated to OS
                        	PAGESZ    EQU   1024  ; size of a page of memory
                        	MEMSZ     EQU   512   ; 512 pages
                        	MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_pIRQProc		EQU		0x38		; pointer to IRQ processing routine
                        	DCB_ReentCount		EQU		0x40		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x41
                        	DCB_fUI       EQU   0x42    ; user interface device
                        	DCB_hJob			EQU		0x48		; handle to associated job
                        	DCB_Mbx				EQU		0x50
                        	DCB_pSema			EQU		0x58		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x60		; 96 bytes
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	DVC_IsUI          EQU   27
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Front Panel 		FP
                        	;11
                        	;12		Hard disk				HD1
                        	;13		Hard disk				HD2
                        	;14
                        	;15   Time slice / GP	VIA
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; disable interrupts
                        	macro mDI
  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
endm
                        	
                        	; disable interrupts
                        	macro mEI
  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
endm
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		a0,#-1
	stt		a0,adr
endm
                        	
                        	macro mGetCurrentTid
  csrrw $a0,#CSR_TASKID,$x0
endm
                        	
                        	macro	mHasFocus
	ldi		$a0,#20
	ecall
endm
                        	
                        	macro mSleep(tm)
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#tm
	ecall
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   a1 = device # to check
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
  mov   $t2,$a1
	
	ldi		$a0,#20
	ecall
bnez	$a1,.HasFocus@
	ldi   $a0,#26             ; FMTK_IO
	mov   $a1,$t2
	ldi   $a2,#9              ; peekchar function
	ecall
	ldi		$t3,#$14						; CTRL-T
	bne		$a0,$t3,.WFF2@
	; eat up the CTRL-T
	ldi		$a0,#26							; FMTK_IO
	mov   $a1,$t2
	ldi		$a2,#8							; getchar function
	ecall
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
		ldi				$a0,#5                        ; FMTK Sleep() function
		ldi				$a1,#1
		ecall

	bra		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = mailbox handle
                        	; Modifies:
                        	;   $t0
                        	; Returns:
                        	;   $a0 = mailbox pointer
                        	;------------------------------------------------------------------------------
                        	
                        	macro mMbxHandleToPointer
  srl   $t0,$a0,#8    ; extract collection index
  sll   $t0,$t0,#2
  ldt   $t0,MbxBlockPtr[$t0]
  and   $a0,$a0,#$FF
  sll   $a0,$a0,#2
  or    $a0,$a0,$t0
endm
                        	
                        	macro mMbxHandleToPointer2(handle,temp)
  srl   temp,handle,#8    ; extract collection index
  sll   temp,temp,#2
  ldt   temp,MbxBlockPtr[temp]
  and   handle,handle,#$FF
  sll   handle,handle,#2
  or    handle,handle,temp
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list pointer to TCB
                        	;------------------------------------------------------------------------------
                        	
                        	;macro mPopTimeoutList
                        	;	lbu		$v1,TCBStatus[$v0]		; no longer a waiting status
                        	;	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
                        	;	beqz	$t1,.noWait@
                        	;	ldbu  $a0,TCBtid[$v0]
                        	;	mMbxRemoveTask							; remove task from mailbox list
                        	.noWait@:
                        	;	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
                        	;	stb		$v1,TCBStatus[$v0]
                        	;	ldt		$v1,TCBNext[$v0]			; get next task on timeout list
                        	;	stt		$v1,TimeoutList				; update list head
                        	;	beqz	$v1,.done@
                        	;	stt		$x0,TCBPrev[$v1]			; TimeoutList->prev = 0
                        	.done@:
                        	;	stt		$x0,TCBNext[$v0]
                        	;	stt		$x0,TCBPrev[$v0]
                        	endm
                        	
                        	macro mGetAppMid
  sll   $a0,$a0,#2
  ldt		$a0,ACBPtrs[$a0]
  and		$a0,$a0,#$FFC00
  ldb   $a0,ACBmid[$a0]
endm
                        	
                        	; Macros to enable and disable time-slice interrupts
                        	macro mTimeSliceEI
	ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
	stt		$t0,VIA_IER+VIA
endm
                        	
                        	macro mTimeSliceEI2(tm)
	ldi		$t0,#$000180|(tm<<24)		; enable timer3 interrupts after tm cycles
	stt		$t0,VIA_IER+VIA
endm
                        	
                        	macro mTimeSliceDI
	ldi		$t0,#$100						; disable timer3 (time slice) interrupts
	stt		$t0,VIA_IER+VIA
	nop                   ; make sure disable has time for effect
	nop
endm
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/globals.r5a",1
                        	.file "../fmtk/globals.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	INBUF				equ		$FF000100
                        	switchflag	equ		$FF000200
                        	milliseconds	equ		$FF000208
                        	CurrentTid  equ   $FF000210
                        	TaskNum     equ   $FF000220
                        	TCBID_TL		equ		$FF000230
                        	APPID_POOL  EQU   $FF0002F0
                        	TCBID_POOL	EQU		$FF0002F8
                        	NPAGES	equ		$FF000300
                        	QNDX		EQU		$FF000304
                        	READYQ	EQU		$0308
                        	TID_POOL  EQU		$FF000310
                        	missed_ticks	equ		$FF000320
                        	TimeoutList		equ		$FF000328
                        	Tick		EQU		$FF000330
                        	SysSema	EQU		$FF000340
                        	MEPC0   EQU   $FF000350
                        	MEPC1   EQU   $FF000358
                        	MEPC2   EQU   $FF000360
                        	MEPC3   EQU   $FF000368
                        	CURIN   EQU   $FF000370
                        	CUROUT  EQU   $FF000371
                        	CHAINA0 EQU   $FF000378
                        	CHAINA1 EQU   $FF000380
                        	CHAINA2 EQU   $FF000388
                        	CHAINA3 EQU   $FF000390
                        	CHAINA4 EQU   $FF000398
                        	CHAINA5 EQU   $FF0003A0
                        	READYQ  EQU   $FF000400
                        	HEADRDY		EQU		$FF000400
                        	HEADRDY0	EQU		$FF000400
                        	HEADRDY1	EQU		$FF000404
                        	HEADRDY2	EQU		$FF000408
                        	HEADRDY3	EQU		$FF00040C
                        	HEADRDY4	EQU		$FF000410
                        	HEADRDY5	EQU		$FF000414
                        	HEADRDY6	EQU		$FF000418
                        	HEADRDY7	EQU		$FF00041C	; Undead queue
                        	TAILRDY		EQU		$FF000420
                        	TAILRDY0	EQU		$FF000420
                        	TAILRDY1	EQU		$FF000424
                        	TAILRDY2	EQU		$FF000428
                        	TAILRDY3	EQU		$FF00042C
                        	TAILRDY4	EQU		$FF000430
                        	TAILRDY5	EQU		$FF000434
                        	TAILRDY6	EQU		$FF000438
                        	TAILRDY7	EQU		$FF00043C	; Undead queue
                        	TCBPtrs	EQU		$FF000500
                        	ACBPtrs EQU 	$FF000600
                        	mbxs		EQU		$FF000800
                        	mbxs_end	EQU	$FF000C00
                        	FreeMsg	EQU		$FF000C00
                        	FreeMbx EQU   $FF000C08
                        	IdleTaskMbx EQU   $FF000C10
                        	IdleTaskMsgD1 EQU   $FF000C18
                        	IdleTaskMsgD2 EQU   $FF000C20
                        	IdleTaskMsgD3 EQU   $FF000C28
                        	IdleTaskId    EQU   $FF000C2A
                        	PAMPtr  EQU   $FF000FF8
                        	PAM     EQU   $FF001000
                        	PAMend  EQU   $FF001080
                        	IOFocusNdx		EQU		$FF001080
                        	IOFocusTbl		EQU		$FF001088
                        	IRQFlag   EQU $FF001090
                        	IRQCause  EQU $FF001098
                        	MbxBlockPtr EQU   $FF0010A0
                        	MbxBlockPtrEnd  EQU MbxBlockPtr + MBX_BLOCKPTR_BUFSZ * 4
                        	MbxBlockCounter EQU $FF0010E0
                        	RegsetTid   EQU   $FF0010F0
                        	SerRcvBuf		EQU		$FF001400
                        	SerXmitBuf	EQU		$FF001800
                        	SerHeadRcv	EQU		$FF001C00
                        	SerTailRcv	EQU		$FF001C04
                        	SerHeadXmit	EQU		$FF001C08
                        	SerTailXmit	EQU		$FF001C0C
                        	SerRcvXon		EQU		$FF001C10
                        	SerRcvXoff	EQU		$FF001C11
                        	; The following must be at least 128 byte aligned
                        	DVF_Base		EQU		$FF002000
                        	DVF_Limit		EQU		$FF003000
                        	DCB_Base    EQU   $FF003000
                        	DCB_Limit   EQU   $FF003C00
                        	
                        	SysHeapStart  EQU   $4000
                        	SysHeapEnd    EQU   $20000
                        	
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	
                        	CTRLC				equ		$03
                        	CTRLT       equ   $14
                        	BS					equ		$08
                        	LF					equ		$0A
                        	LNFD				equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	EOF         equ   $1A
                        	DEL					equ		$7F
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_T2CL    equ   $20
                        	VIA_T2CH    equ   $24
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        	TMOQ				equ		$FFDC0400
                        	OS_SEMA			equ		$FFDB0000
                        	
                        	CSR_UIE     equ   $004
                        	
                        	.file "cs01rom.r5a",34
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0000				; user mode exception
FFFC0000 0500106F		jmp		IRQRout
FFFC0004 00000000		org 	$FFFC00C0				; machine mode exception
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 00000000
FFFC0044 00000000
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 00000000
FFFC0084 00000000
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 7910006F		jmp		IRQRout
FFFC00C4 00000000		org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F		jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; Reset starting address.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0100
                        	MachineStart:
FFFC0100 000002B7		ldi   $t0,#$FFFFFC1C  		; select register set #28, user register set #0
FFFC0104 C1C28293
FFFC0108 7C329073		csrrw $x0,#CSR_RSSTACK,$t0
FFFC010C 2007E137		ldi		$sp,#$2007E800-4		; setup machine mode stack pointer
FFFC0110 7FC10113
FFFC0114 7A00E073		csrrs $x0,#CSR_TRACECTRL,#1 ; turn on tracing
FFFC0118 00106293		ldi		$t0,#1
FFFC011C FFDB48B7		stt		$t0,OS_SEMA+$4000		; prime OS semaphore = 1
FFFC0120 00088893
FFFC0124 000888B3
FFFC0128 0058A023
FFFC012C 00006293		ldi		$t0,#0
FFFC0130 7C129073		csrrw $x0,#CSR_MSEMA,$t0  ; turn off semaphores
FFFC0134 7C229073		csrrw $x0,#CSR_TASKID,$t0 ; clear task id
FFFC0138 748010EF		call	MMUInit					; initialize MMU for address space zero.
FFFC013C 1E5020EF		call	FMTKInit
FFFC0140 7D0020EF		call	ViaSetup
FFFC0144 02C020EF		call	SerialSetup
                        	
FFFC0148 FF07D137		ldi		$sp,#$FF07CFFC
FFFC014C FFC10113
                        	ramtest:
FFFC0150 FFFC1537		ldi		$a0,#msgRamTest
FFFC0154 22450513
FFFC0158 5A9000EF		call	PutString
FFFC015C FF0002B7		ldi		$t0,#$FF000000
FFFC0160 00028293
FFFC0164 55555337		ldi		$t1,#$55555555
FFFC0168 55530313
                        	.0001:
FFFC016C 0062A023		stt		$t1,[$t0]
FFFC0170 00131313		sll		$t1,$t1,#1
FFFC0174 0062A223		stt		$t1,4[$t0]
FFFC0178 00135313		srl		$t1,$t1,#1
FFFC017C 00828293		add		$t0,$t0,#8
FFFC0180 FF07DE37		ldi		$t3,#$FF07CFE0
FFFC0184 FE0E0E13
FFFC0188 FFC2E2E3		bltu	$t0,$t3,.0001
                        	
FFFC018C FF0002B7		ldi		$t0,#$FF000000
FFFC0190 00028293
FFFC0194 55555337		ldi		$t1,#$55555555
FFFC0198 55530313
                        	.0002:
FFFC019C 0002A383		ldt		$t2,[$t0]
FFFC01A0 00638A63		beq		$t2,$t1,.0003
FFFC01A4 0002E533		mov		$a0,$t0
FFFC01A8 479000EF		call	PutHexWord
FFFC01AC 02006513		ldi		$a0,#' '
FFFC01B0 330000EF		call	Putch
                        	.0003:
FFFC01B4 00131313		sll		$t1,$t1,#1
FFFC01B8 0042A383		ldt		$t2,4[$t0]
FFFC01BC 00638A63		beq		$t2,$t1,.0004
FFFC01C0 0002E533		mov		$a0,$t0
FFFC01C4 45D000EF		call	PutHexWord
FFFC01C8 02006513		ldi		$a0,#' '
FFFC01CC 314000EF		call	Putch
                        	.0004:
FFFC01D0 00135313		srl		$t1,$t1,#1
FFFC01D4 00828293		add		$t0,$t0,#8
FFFC01D8 FF07DE37		ldi		$t3,#$FF07CFE0
FFFC01DC FE0E0E13
FFFC01E0 FBC2EEE3		bltu	$t0,$t3,.0002
                        	
                        		; re-run setup, it got toasted by the ram test
FFFC01E4 69C010EF		call	MMUInit					; initialize MMU for address space zero.
FFFC01E8 139020EF		call	FMTKInit
FFFC01EC 724020EF		call	ViaSetup
FFFC01F0 781010EF		call	SerialSetup
                        	
FFFC01F4 00506293		ldi   $t0,#5          ; set current input and output to serial port
FFFC01F8 FF0008B7		stb   $t0,CURIN
FFFC01FC 37088893
FFFC0200 000888B3
FFFC0204 00588023
FFFC0208 FF0008B7		stb   $t0,CUROUT
FFFC020C 37188893
FFFC0210 000888B3
FFFC0214 00588023
FFFC0218 FFFC02B7		ldi		$t0,#$FFFC0000
FFFC021C 00028293
FFFC0220 30129073		csrrw $x0,#$301,$t0		; set tvec
FFFC0224 FFFC02B7		ldi		$t0,#UserStart
FFFC0228 26828293
FFFC022C 34129073		csrrw	$x0,#$341,$t0		; set mepc
FFFC0230 FF0008B7		stt   $t0,MEPC1
FFFC0234 35888893
FFFC0238 000888B3
FFFC023C 0058A023
FFFC0240 00506513	  ldi   $a0,#5         	; start app
FFFC0244 FFFC15B7	  ldi   $a1,#UserASR
FFFC0248 30858593
FFFC024C 0B4030EF	  call  OSOCall
FFFC0250 7C259073	  csrrw $x0,#CSR_TASKID,$a1
FFFC0254 7C501573	  csrrw	$a0,#CSR_IMSTACK,$x0
FFFC0258 F0057513	  and		$a0,$a0,#$FFFFFF00
FFFC025C 7C551073		csrrw	$x0,#CSR_IMSTACK,$a0	; set lowest IRQ level on return
FFFC0260 7C446073	  csrrs $x0,#CSR_PMSTACK,#8 	; enable interrupts on return
                        	;	csrrc $x0,#CSR_TRACECTRL,#0 ; turn off tracing
                        	;	call	DumpReadyQueue
FFFC0264 30200073		mret                      	; switch to user mode
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	; First thing to do is start a task so that the startup code may run on the
                        	; first task switch.
                        	;------------------------------------------------------------------------------
                        	UserStart:
                        	;	ldi		$sp,#$2007fff0
                        	;  call  DumpTraceQueue
FFFC0268 20080137		ldi		$sp,#$2007FFF8-4		; setup machine mode stack pointer
FFFC026C FF410113
FFFC0270 5E1010EF		call	PAMDump
                        	;  wfi                   ; wait for task switch
                        	UserStart2:
FFFC0274 00C06513	  ldi   $a0,#12         ; start app
FFFC0278 FFFC15B7	  ldi   $a1,#SystemASR
FFFC027C 27858593
FFFC0280 00000073	  ecall
                        	.appBad:
FFFC0284 01B06293		ldi		$t0,#E_Busy
FFFC0288 FE5506E3		beq		$a0,$t0,UserStart2
FFFC028C 000108B7		stt		$a0,$10004
FFFC0290 00488893
FFFC0294 000888B3
FFFC0298 00A8A023
                        	;  bnez  $a0,.appBad
FFFC029C 0005E4B3	  mov   $s1,$a1
                        	.0001:
FFFC02A0 0004E5B3	  mov   $a1,$s1
FFFC02A4 00E06513	  ldi   $a0,#14         ; get current tid
FFFC02A8 00000073	  ecall                 ; $a1 = task id
FFFC02AC 01B06293		ldi		$t0,#E_Busy
FFFC02B0 FE5508E3		beq		$a0,$t0,.0001
                        	
FFFC02B4 0005E933	  mov		$s2,$a1
                        	.0002:
FFFC02B8 000965B3	  mov		$a1,$s2
FFFC02BC FF0018B7	  stw		$s2,IdleTaskId
FFFC02C0 C2A88893
FFFC02C4 000888B3
FFFC02C8 01289023
FFFC02CC 01E06513	  ldi   $a0,#30         ; set task's app id
FFFC02D0 0004E633	  mov   $a2,$s1         ; $a2 = app id
FFFC02D4 00000073	  ecall
FFFC02D8 01B06293		ldi		$t0,#E_Busy
FFFC02DC FC550EE3		beq		$a0,$t0,.0002
                        	
FFFC02E0 0005E4B3	  mov   $s1,$a1         ; s1 = app id
FFFC02E4 2007A137		ldi		$sp,#$2007A000-4  ; setup user mode stack pointer
FFFC02E8 FFC10113
                        	
                        	.0003:
FFFC02EC 00C06513	  ldi   $a0,#12         ; start app
FFFC02F0 FFFC15B7	  ldi   $a1,#TinyBasicASR
FFFC02F4 2C058593
FFFC02F8 00000073	  ecall
FFFC02FC 01B06293		ldi		$t0,#E_Busy
FFFC0300 FE5506E3		beq		$a0,$t0,.0003
                        	
FFFC0304 00106513		ldi		$a0,#1          ; Start finalizer task, task #1
                        	.0004:
FFFC0308 0004E5B3		mov   $a1,$s1
FFFC030C 00006613		ldi		$a2,#0
FFFC0310 FFFC56B7		ldi		$a3,#Finalizer
FFFC0314 28068693
FFFC0318 00B06713		ldi   $a4,#$0B        ; user mode, regset 11
FFFC031C 00000073		ecall
FFFC0320 01B06293		ldi		$t0,#E_Busy
FFFC0324 FE5502E3		beq		$a0,$t0,.0004
                        	.0005:
FFFC0328 00C06513	  ldi   $a0,#12         ; start app
FFFC032C FFFC15B7	  ldi   $a1,#MonitorASR
FFFC0330 23058593
FFFC0334 00000073	  ecall
FFFC0338 01B06293		ldi		$t0,#E_Busy
FFFC033C FE5506E3		beq		$a0,$t0,.0005
                        	;	ldi		$a0,#1          ; Start task for monitor, task #2
                        	;	mov   $a1,$s1
                        	;	ldi		$a2,#0
                        	;	ldi		$a3,#MonEntry
                        	;	ldi   $a4,#$0A        ; user mode, regset 10
                        	;	ecall
                        	.0006:
FFFC0340 01906513	  ldi   $a0,#25         ; map OS vars
FFFC0344 00000073	  ecall
FFFC0348 0005E1B3	  mov   $gp,$a1
FFFC034C 01B06293		ldi		$t0,#E_Busy
FFFC0350 FE5508E3		beq		$a0,$t0,.0006
                        	
                        	UserStart3:
FFFC0354 20079137		ldi		$sp,#$20079800-4  ; setup user mode stack pointer
FFFC0358 7FC10113
FFFC035C 01806513		ldi		$a0,#24							; RequestIOFocus
FFFC0360 0004E5B3		mov   $a1,$s1
FFFC0364 00000073		ecall
                        	;	ldi		$sp,#$70000		      ; setup temporary user mode stack pointer
                        	;	mov   $a0,$a1             ; $a0 = tid
                        	;	call  AllocStack
                        	;	add   $sp,$v1,#1020       ; place stack pointer at top of allocated region
FFFC0368 00806293		ldi		$t0,#$08						; turn on the LED
FFFC036C FFDC08B7		stt		$t0,VIA+VIA_PARAW
FFFC0370 63C88893
FFFC0374 000888B3
FFFC0378 0058A023
FFFC037C 01006913		ldi		$s2,#16							; send an XON just in case
                        	.0004:
FFFC0380 01106693		ldi		$a3,#XON
FFFC0384 15C000EF		call	Putch
FFFC0388 FFF90913		sub		$s2,$s2,#1
FFFC038C FE091AE3		bnez	$s2,.0004
                        	.0002:
                        	;  ldi   $a0,#25             ; Map OS vars
                        	;  ecall
                        	;  mov   $gp,$a1
                        	  ; Request that the idle task announce itself.
                        	;  ldi   $a0,#9              ; SendMsg
                        	;  ldwu  $a1,IdleTaskMbx[$gp]
                        	;  beqz  $a1,.noMbx
                        	;  ldi   $a2,#MT_ANNOUNCE
                        	;  ldi   $a3,#0
                        	;  ldi   $a4,#0
                        	;  ecall
                        	.noMbx:
FFFC0390 FFFC1537		ldi		$a0,#msgStart				; spit out a startup message
FFFC0394 35050513
FFFC0398 369000EF		call	PutString
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		ecall
                        	;	call	DumpReadyQueue
FFFC039C 2440006F		jmp		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#9							; peekchar function
                        	;	ecall
                        	;	mov   $v0,$v1
                        	;	bltz	$v1,.0003
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#8							; getchar function
                        	;	ecall
                        	;	mov		$a3,$v1
                        	;	mov   $a0,$a3
                        	;	call  PutHexByte
                        	;	bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	; This task runs only if nothing else can run. It must run at the machine
                        	; operating mode.
                        	; Search for ready tasks and add them back into the ready queue.
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	IdleTask:
                        	;  ldi   $a0,#6                ; alloc mailbox
                        	;  ldi   $a1,#0                ; app #0
                        	;  ecall
FFFC03A0 FF0018B7	  stw   $a1,IdleTaskMbx[$gp]  ; save mailbox handle off
FFFC03A4 C1088893
FFFC03A8 003888B3
FFFC03AC 00B89023
                        	.loop2:
FFFC03B0 10100073		wfi
FFFC03B4 000042B7	  ldi   $t0,#$4000
FFFC03B8 00028293
FFFC03BC 00106313	  ldi   $t1,#1
                        	.loop:
FFFC03C0 00B06513	  ldi   $a0,#11               ; PeekMsg
FFFC03C4 FF0018B7	  ldwu  $a1,IdleTaskMbx[$gp]
FFFC03C8 C1088893
FFFC03CC 003888B3
FFFC03D0 0008D583
FFFC03D4 FF001637	  ldi   $a2,#IdleTaskMsgD1
FFFC03D8 C1860613
FFFC03DC FF0016B7	  ldi   $a3,#IdleTaskMsgD2
FFFC03E0 C2068693
FFFC03E4 FF001737	  ldi   $a4,#IdleTaskMsgD3
FFFC03E8 C2870713
FFFC03EC 00106793	  ldi   $a5,#1                ; remove from queue if present
                        	;  ecall
                        	;  bnez  $a0,.noMsg
                        	;  ldt   $a0,IdleTaskMsgD1
                        	;  xor   $t1,$a0,#MT_ANNOUNCE
                        	;  bnez  $t1,.noAnnounce
FFFC03F0 FFFC0537	  ldi   $a0,#msgIdleAnnounce
FFFC03F4 49050513
FFFC03F8 309000EF	  call  PutString
                        	.noAnnounce:
                        	.noMsg:
FFFC03FC 01106513	  ldi   $a0,#17               ; run as OS
FFFC0400 FFFC05B7	  ldi   $a1,#.IdleCode
FFFC0404 42858593
FFFC0408 0002E633	  mov   $a2,$t0
FFFC040C 00000073	  ecall
FFFC0410 40028293	  add   $t0,$t0,#PAGESZ
FFFC0414 000808B7	  slt   $t2,$t0,#MEMSZ*1024
FFFC0418 00088893
FFFC041C 0112A3B3
FFFC0420 FA0390E3	  bnez  $t2,.loop
FFFC0424 F80006E3		bra		.loop2
                        	  ; This section of code runs as part of the OS
                        	  ; Don't call any functions though as there's no stack available
                        	.IdleCode:
FFFC0428 00006613		ldi		$a2,#$00
                        	.nxtObj:
FFFC042C 40060613		add		$a2,$a2,#$400					; 1k blocks
FFFC0430 00080E37		ldi		$t3,#$80000
FFFC0434 000E0E13
FFFC0438 05C60863		beq		$a2,$t3,.0001
                        		; Check if block contains a TCB
FFFC043C 00062283	  ldt   $t0,OBJMagic[$a2]
FFFC0440 20544E37	  ldi   $t3,#TCB_MAGIC
FFFC0444 342E0E13
FFFC0448 FFC292E3	  bne   $t0,$t3,.nxtObj
                        	  ; Is it ready?
FFFC044C 2C83CE03	  ldbu  $t3,TCBStatus[$t2]    ; get status
FFFC0450 001E7E13	  and   $t3,$t3,#TS_READY
FFFC0454 FC0E0CE3	  beqz  $t3,.nxtObj
                        	  ; On Ready queue?
FFFC0458 3103AE03	  ldt		$t3,TCBNext[$t2]
FFFC045C 000E0863	  beqz	$t3,.addToReady
FFFC0460 2C8E2E03	  ldt		$t3,TCBStatus[$t3]
FFFC0464 001E7E13	  and		$t3,$t3,#TS_READY
FFFC0468 FC0E12E3	  bnez	$t3,.nxtObj
                        	  ; The task was ready, but not found in the ready queue. So add it
                        	.addToReady:
FFFC046C 00066533	  mov		$a0,$a2
FFFC0470 FFC10113	  sub		$sp,$sp,#4
FFFC0474 00112023	  stt		$ra,[$sp]
FFFC0478 2B8040EF	  call	InsertIntoReadyQueue
FFFC047C 00012083	  ldt		$ra,[$sp]
FFFC0480 00410113	  add		$sp,$sp,#4
FFFC0484 FA0004E3	  bra		.nxtObj
                        	.0001:
FFFC0488 00006513	  ldi   $a0,#E_Ok
FFFC048C 00008067	  ret
                        	
                        	msgIdleAnnounce:
FFFC0490 656C6449	  db  "Idle task running.",CR,0
FFFC0494 73617420
FFFC0498 7572206B
FFFC049C 6E696E6E
FFFC04A0 000D2E67
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		$a0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
FFFC04A4 00000000	  align 1
FFFC04A8 00000000
FFFC04AC 00000000
                        	
                        	Getch:
FFFC04B0 FF410113		sub		$sp,$sp,#12
FFFC04B4 00112023		stt		$ra,[$sp]
FFFC04B8 00B12423		stt		$a1,8[$sp]
FFFC04BC 00506593		ldi   $a1,#5  ;CURIN
FFFC04C0 0C0000EF		call  fgetc
FFFC04C4 00012083		ldt		$ra,[$sp]
FFFC04C8 00812583		ldt		$a1,8[$sp]
FFFC04CC 00C10113		add		$sp,$sp,#12
FFFC04D0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = character to put
                        	;------------------------------------------------------------------------------
FFFC04D4 00000000	  align 1
FFFC04D8 00000000
FFFC04DC 00000000
                        	
                        	Putch:
FFFC04E0 FEC10113		sub		$sp,$sp,#20
FFFC04E4 00112023		stt		$ra,[$sp]
FFFC04E8 00D12423		stt		$a3,8[$sp]
FFFC04EC 00B12823		stt		$a1,16[$sp]
FFFC04F0 000566B3		mov		$a3,$a0
FFFC04F4 00506593		ldi		$a1,#5  ;CUROUT    ; serial port
FFFC04F8 018000EF		call	fputc
FFFC04FC 00012083		ldt		$ra,[$sp]
FFFC0500 00812683		ldt		$a3,8[$sp]
FFFC0504 01012583		ldt		$a1,16[$sp]
FFFC0508 01410113		add		$sp,$sp,#20
FFFC050C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   EOF if error occurred, otherwise character to put
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	fputc:
FFFC0510 FE410113		sub		$sp,$sp,#28
FFFC0514 00112023		stt		$ra,[$sp]
FFFC0518 00A12423		stt		$a0,8[$sp]
FFFC051C 00B12823		stt		$a1,16[$sp]
FFFC0520 00C12A23		stt		$a2,20[$sp]
FFFC0524 00D12C23		stt		$a3,24[$sp]
FFFC0528 04284813		xor   $a6,$a6,#'B'
FFFC052C 00081263		bnez  $a6,.noBypass
                        	;	call  SerialPutChar
                        	;	jmp   .xit
                        	.noBypass:
                        		; If the device is a UI device there may be multiple owning jobs. It doesn't
                        		; do any good to check for ownership. Instead the I/O focus is checked to
                        		; see if it's present.
FFFC0530 02000063		bra		.0001
FFFC0534 30D040EF		call  GetUIFlag
FFFC0538 00058863		beqz  $a1,.checkOwner
FFFC053C 01012583	  ldt   $a1,16[$sp]
FFFC0540 281040EF		call  WaitForIOFocus
FFFC0544 00000663		bra   .0001
                        	.checkOwner:
FFFC0548 4C9040EF	  call  CheckDevOwner
FFFC054C 02051263	  bnez  $a0,.notOwner
                        	.0001:
FFFC0550 180020EF		call	SerialPutCharEx
                        	;  ldt   $a1,16[$sp]
                        	;  ldt		$a3,24[$sp]
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi		$a2,#13							; putchar function
                        	;	ecall
                        	.xit:
FFFC0554 00012083		ldt		$ra,[$sp]
FFFC0558 00812503		ldt		$a0,8[$sp]
FFFC055C 01012583		ldt		$a1,16[$sp]
FFFC0560 01412603		ldt		$a2,20[$sp]
FFFC0564 01812683		ldt		$a3,24[$sp]
FFFC0568 01C10113		add		$sp,$sp,#28
FFFC056C 00008067		ret
                        	.notOwner:
FFFC0570 01A06513	  ldi   $a0,#EOF
FFFC0574 FE0000E3	  bra   .xit
                        	 
                        	;------------------------------------------------------------------------------
                        	; fgetc - get a character from an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device getchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		a0 character, -1 if none available
                        	;------------------------------------------------------------------------------
FFFC0578 00000000	  align 1
FFFC057C 00000000
                        	
                        	fgetc:
FFFC0580 FE810113		sub		$sp,$sp,#24
FFFC0584 00112023		stt		$ra,[$sp]
FFFC0588 00B12823		stt		$a1,16[$sp]
FFFC058C 00C12A23		stt		$a2,20[$sp]
FFFC0590 02000263		bra		.0001
FFFC0594 2AD040EF		call  GetUIFlag
FFFC0598 00058863		beqz  $a1,.checkOwner
FFFC059C 01012583		ldt		$a1,16[$sp]
FFFC05A0 221040EF		call  WaitForIOFocus
FFFC05A4 00000863		bra   .0001
                        	.checkOwner:
FFFC05A8 01012583		ldt		$a1,16[$sp]
FFFC05AC 465040EF	  call  CheckDevOwner
FFFC05B0 02051463	  bnez  $a0,.notOwner
                        	.0001:
FFFC05B4 795010EF		call	SerialPeekCharEx
FFFC05B8 0005C463		bltz	$a1,.0003
FFFC05BC 641010EF		call	SerialGetCharEx
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldt		$a1,16[$sp]
                        	;	ldi		$a2,#8							; getchar function
                        	;	ecall
                        	.0003:
FFFC05C0 0005E533		mov   $a0,$a1
                        	.0002:
FFFC05C4 00012083		ldt		$ra,[$sp]
FFFC05C8 01012583		ldt		$a1,16[$sp]
FFFC05CC 01412603		ldt		$a2,20[$sp]
FFFC05D0 01810113		add		$sp,$sp,#24
FFFC05D4 00008067		ret
                        	.notOwner:
FFFC05D8 FFF06513	  ldi   $a0,#-1
FFFC05DC FE0004E3	  bra   .0002
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;  ldi   $a0,#25         ; map OS vars
                        	;  ecall
                        	;  mov   $gp,$a1
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC05E0 00A06513			ldi		$a0,#10
FFFC05E4 00606613			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
FFFC05E8 02606513		ldi		$a0,#38					; Get current app id
FFFC05EC 00000073		ecall
FFFC05F0 01806513		ldi		$a0,#24					; request I/O focus
FFFC05F4 00000073		ecall
                        	
                        	Monitor:
                        	.getFocus:
FFFC05F8 02606513		ldi		$a0,#38					; Get current app id
FFFC05FC 00000073		ecall
FFFC0600 01406513		ldi   $a0,#20       	; has IO focus
FFFC0604 00000073		ecall
FFFC0608 00059863		bnez  $a1,.hasFocus
FFFC060C 01506513		ldi   $a0,#21       	; switch focus
FFFC0610 00000073		ecall
FFFC0614 FE0002E3		bra   .getFocus
                        	.hasFocus:
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFC0618 00006493		ldi		$s1,#0					; s1 = input pointer
FFFC061C 00D06513		ldi		$a0,#CR
FFFC0620 EC1FF0EF		call	Putch
FFFC0624 00006513		ldi		$a0,#LF
	call	Putch
FFFC0628 EB9FF0EF
FFFC062C 02406513		ldi		$a0,#'$'
FFFC0630 EB1FF0EF		call	Putch
                        	.0001:
FFFC0634 E7DFF0EF		call	Getch						; wait until character pressed
FFFC0638 FE054EE3		bltz	$a0,.0001
FFFC063C 00054293		xor		$t0,$a0,#LF			; ignore line feed
	beqz	$t0,.procLine
FFFC0640 10028463
FFFC0644 00D54293		xor		$t0,$a0,#CR
FFFC0648 10028063		beqz	$t0,.procLine
FFFC064C 00854293		xor		$t0,$a0,#BS
FFFC0650 08028A63		beqz	$t0,.doBackspace
FFFC0654 07F54293		xor		$t0,$a0,#DEL
FFFC0658 02028863		beqz	$t0,.doDelete
FFFC065C FF0008B7		stb		$a0,INBUF[$s1]
FFFC0660 10088893
FFFC0664 009888B3
FFFC0668 00A88023
FFFC066C 00148493		add		$s1,$s1,#1
FFFC0670 05006293		ldi		$t0,#80
FFFC0674 0054B2B3		sltu	$t0,$s1,$t0
FFFC0678 00029463		bnez	$t0,.bufndx1
FFFC067C FFF48493		sub		$s1,$s1,#1
                        	.bufndx1:
FFFC0680 E61FF0EF		call	Putch
FFFC0684 FA0008E3		bra		.0001
                        	.doDelete:
FFFC0688 0004E933		mov		$s2,$s1
FFFC068C 00190913		add		$s2,$s2,#1
                        	.0002:
FFFC0690 FF0008B7		ldb		$t0,INBUF[$s2]
FFFC0694 10088893
FFFC0698 012888B3
FFFC069C 00088283
FFFC06A0 FF0008B7		stb		$t0,INBUF-1[$s2]
FFFC06A4 0FF88893
FFFC06A8 012888B3
FFFC06AC 00588023
FFFC06B0 00190913		add		$s2,$s2,#1
FFFC06B4 FF0008B7		add		$t0,$s2,#INBUF
FFFC06B8 10088893
FFFC06BC 011902B3
FFFC06C0 FF0008B7		slt		$t0,$t0,#INBUF+$7F
FFFC06C4 17F88893
FFFC06C8 0112A2B3
FFFC06CC FC0292E3		bne		$t0,$x0,.0002
FFFC06D0 FF0008B7		stb		$x0,INBUF[$s2]
FFFC06D4 10088893
FFFC06D8 012888B3
FFFC06DC 00088023
FFFC06E0 F4000AE3		bra		.0001
                        	.doBackspace:
FFFC06E4 F40488E3		beq		$s1,$x0,.0001		; can't backspace anymore
FFFC06E8 DF9FF0EF		call	Putch           ; show the backspace
FFFC06EC FFF48493		sub		$s1,$s1,#1
FFFC06F0 0004E933		mov		$s2,$s1
                        	.0003:
FFFC06F4 FF0008B7		ldb		$t0,INBUF+1[$s2]
FFFC06F8 10188893
FFFC06FC 012888B3
FFFC0700 00088283
FFFC0704 FF0008B7		stb		$t0,INBUF[$s2]
FFFC0708 10088893
FFFC070C 012888B3
FFFC0710 00588023
FFFC0714 00190913		add		$s2,$s2,#1
FFFC0718 FF0008B7		add		$t0,$s2,#INBUF
FFFC071C 10088893
FFFC0720 011902B3
FFFC0724 FF0008B7		slt		$t0,$t0,#INBUF+$7F
FFFC0728 17F88893
FFFC072C 0112A2B3
FFFC0730 FC0292E3		bne		$t0,$x0,.0003
FFFC0734 FF0008B7		stb		$x0,INBUF[$s2]
FFFC0738 10088893
FFFC073C 012888B3
FFFC0740 00088023
FFFC0744 EE0008E3		bra		.0001
                        	.procLine:
FFFC0748 FF0008B7		stb		$x0,INBUF[$s1]
FFFC074C 10088893
FFFC0750 009888B3
FFFC0754 00088023
FFFC0758 00006493		ldi		$s1,#0
                        	.skip:
FFFC075C FF0008B7		ldb		$t0,INBUF[$s1]
FFFC0760 10088893
FFFC0764 009888B3
FFFC0768 00088283
FFFC076C 16028263		beq		$t0,$x0,.0005
FFFC0770 03E2C313		xor		$t1,$t0,#'>'
FFFC0774 00031663		bne		$t1,$x0,.0004
                        	.skip2:
FFFC0778 00148493		add		$s1,$s1,#1
FFFC077C FE0000E3		bra		.skip
                        	.0004:
FFFC0780 0202C313		xor		$t1,$t0,#' '
FFFC0784 FE030AE3		beq		$t1,$x0,.skip2
FFFC0788 0092C313		xor		$t1,$t0,#'\t'
FFFC078C FE0306E3		beq		$t1,$x0,.skip2
FFFC0790 0582C313		xor   $t1,$t0,#'X'  ; exit from monitor
FFFC0794 00031663		bnez  $t1,.notX
FFFC0798 00006513		ldi   $a0,#E_Ok
FFFC079C 00008067		ret
                        	.notX:
FFFC07A0 04D2C313		xor		$t1,$t0,#'M'
FFFC07A4 26030663		beqz	$t1,doMem
FFFC07A8 0562C313		xor   $t1,$t0,#'V'
FFFC07AC 38030A63		beqz  $t1,doVMem
FFFC07B0 0502C313		xor   $t1,$t0,#'P'
FFFC07B4 3E030663		beqz  $t1,doPStat
FFFC07B8 04206313		ldi		$t1,#'B'
FFFC07BC 04629863		bne		$t0,$t1,.0006
FFFC07C0 600000EF		call  GetDecNum
FFFC07C4 00051663		bnez  $a0,.basSize
FFFC07C8 00008537		ldi   $a0,#32000
FFFC07CC D0050513
                        	.basSize:
FFFC07D0 00C06513		ldi		$a0,#12					; Start App
FFFC07D4 000005B7		ldi   $a1,#TBASR
FFFC07D8 1ED58593
FFFC07DC 00000073		ecall
FFFC07E0 0005E4B3		mov		$s1,$a1					; save a1
FFFC07E4 FFFC1537		ldi		$a0,#msgCRLF
FFFC07E8 47650513
FFFC07EC 714000EF		call	PutString
FFFC07F0 0004E533		mov		$a0,$s1					; get back a1
FFFC07F4 68C000EF		call	PutHexByte
FFFC07F8 FFFC1537		ldi		$a0,#msgTaskStart
FFFC07FC 46850513
FFFC0800 700000EF		call	PutString
                        	;	call  DumpReadyQueue
                        		; The monitor is running in machine mode. A return instruction is used to
                        		; switch to user mode. The return address must be set to the desired user
                        		; code address.
                        	;	mDI                     ; disable interrupts
                        	;	ldi   $t0,#CSTART       ; pick start of Tiny Basic
                        	;	csrrw $x0,#$341,$t0     ; set as return address
                        	;	ldi   $t0,#$00011111    ; bits to select register set #1
                        	;	csrrw $x0,#CSR_REGSET,$t0     ; select register set #1 (will decrement to zero then on mret)
                        	;	mret                    ; will begin running Tiny Basic in user mode
                        		;ldi		$a0,#5					; Reschedule task
                        		;ldi		$a1,#1					; sleep(0)
                        		;ecall
FFFC0804 42D0406F		jmp		CSTART
FFFC0808 DF1FF06F		jmp		Monitor
                        	.0006:
FFFC080C 04406313		ldi		$t1,#'D'
FFFC0810 02629863		bne		$t0,$t1,.0007
FFFC0814 FF0008B7		lb		$t0,INBUF+1[$s1]
FFFC0818 10188893
FFFC081C 009888B3
FFFC0820 00088283
FFFC0824 05406313		ldi		$t1,#'T'
FFFC0828 00629663		bne		$t0,$t1,.noT
FFFC082C 3C4040EF		call	DumpTimeoutList
FFFC0830 DC9FF06F		jmp		Monitor
                        	.noT:
FFFC0834 02706513		ldi		$a0,#39						; Dump ready queue
FFFC0838 00000073		ecall
                        		;call 	DumpReadyQueue
FFFC083C DBDFF06F		jmp		Monitor
                        	.0007:
FFFC0840 04506313		ldi		$t1,#'E'
FFFC0844 00629463		bne		$t0,$t1,.0008
FFFC0848 2D80006F		jmp		EditMem
                        	.0008:
FFFC084C 04606313		ldi		$t1,#'F'
FFFC0850 02629463		bne		$t0,$t1,.0009
FFFC0854 FF0008B7		ldb   $t0,INBUF+1[$s1]
FFFC0858 10188893
FFFC085C 009888B3
FFFC0860 00088283
FFFC0864 04906313		ldi   $t1,#'I'
FFFC0868 00531663		bne   $t1,$t0,.notFind
FFFC086C 00148493		add   $s1,$s1,#1
FFFC0870 3A00006F		jmp   Find
                        	.notFind:
FFFC0874 36C0006F		jmp		FillMem
                        	.0009:
FFFC0878 05306313		ldi		$t1,#'S'
FFFC087C 00629A63		bne		$t0,$t1,.0010
FFFC0880 00506513		ldi		$a0,#5					; sleep(0)
FFFC0884 00106593		ldi		$a1,#1
FFFC0888 00000073		ecall
FFFC088C D6DFF06F		jmp		Monitor
                        	.0010:
FFFC0890 04B06313		ldi		$t1,#'K'
FFFC0894 00629C63		bne		$t0,$t1,.0011
FFFC0898 488000EF		call	GetHexNum
FFFC089C 000565B3		mov		$a1,$a0					; a0 = pid
FFFC08A0 00306513		ldi		$a0,#3					; kill task
FFFC08A4 00000073		ecall
FFFC08A8 D51FF06F		jmp		Monitor
                        	.0011:
FFFC08AC 03F06313		ldi		$t1,#'?'
FFFC08B0 00629A63		bne		$t0,$t1,.0012
FFFC08B4 FFFC1537		ldi		$a0,#msgMonHelp
FFFC08B8 36650513
FFFC08BC 644000EF		call	PutString
FFFC08C0 D39FF06F		jmp		Monitor
                        	.0012:
FFFC08C4 05206313		ldi		$t1,#'R'
FFFC08C8 00629463		bne		$t0,$t1,.0013
FFFC08CC 0140006F		jmp		DumpRegs
                        	.0013:
                        	.0005:
FFFC08D0 D29FF06F		jmp		Monitor
                        	
FFFC08D4 00000000	  align 1
FFFC08D8 00000000
FFFC08DC 00000000
                        	
                        	DumpRegs:
FFFC08E0 00148493	  add   $s1,$s1,#1
FFFC08E4 4DC000EF	  call  GetDecNum
FFFC08E8 0FF06313	  ldi		$t1,#255
FFFC08EC 00651863	  bne		$a0,$t1,.0001
FFFC08F0 00E06513	  ldi   $a0,#14         ; get current tid
FFFC08F4 00000073	  ecall                 ; $a1 = task id
FFFC08F8 0005E533	  mov		$a0,$a1
                        	.0001:
FFFC08FC 00056933	  mov		$s2,$a0
FFFC0900 FF0008B7	  ldt		$s2,TCBPtrs[$s2]
FFFC0904 50088893
FFFC0908 012888B3
FFFC090C 0008A903
FFFC0910 34494503	  ldbu	$a0,TCBOpMode[$s2]
FFFC0914 56C000EF	  call  PutHexByte
FFFC0918 00006A13	  ldi		$s4,#0
                        	.0003:
FFFC091C 002A1993	  sll		$s3,$s4,#2
FFFC0920 FFFC18B7	  add		$s3,$s3,#msgRegName
FFFC0924 98088893
FFFC0928 011989B3
FFFC092C 0009C503	  ldbu	$a0,[$s3]
FFFC0930 BB1FF0EF	  call	Putch
FFFC0934 0019C503	  ldbu	$a0,1[$s3]
FFFC0938 BA9FF0EF	  call	Putch
FFFC093C 0029C503	  ldbu	$a0,2[$s3]
FFFC0940 BA1FF0EF	  call	Putch
FFFC0944 0039C503	  ldbu	$a0,3[$s3]
FFFC0948 B99FF0EF	  call	Putch
FFFC094C 03A06513	  ldi		$a0,#':'
FFFC0950 B91FF0EF	  call	Putch
FFFC0954 002A1993	  sll		$s3,$s4,#2
FFFC0958 0409A503	  ldt		$a0,TCBIntRegs[$s3]
FFFC095C 4C4000EF	  call	PutHexWord
FFFC0960 003A7993	  and		$s3,$s4,#3
FFFC0964 00099663	  bnez	$s3,.0002
FFFC0968 00D06513	  ldi		$a0,#CR
FFFC096C B75FF0EF	  call	Putch
                        	.0002:
FFFC0970 001A0A13	  add		$s4,$s4,#1
FFFC0974 02006513	  ldi		$a0,#32
FFFC0978 FAAA62E3	  bltu	$s4,$a0,.0003
FFFC097C C7DFF06F	  jmp		Monitor
                        	
                        	msgRegName:
FFFC0980 20307820		db	" x0 "," ra "," sp "," gp "," tp "," t0 "," t1 "," t2 "," fp "," s1 "
FFFC0984 20617220
FFFC0988 20707320
FFFC098C 20706720
FFFC0990 20707420
FFFC0994 20307420
FFFC0998 20317420
FFFC099C 20327420
FFFC09A0 20706620
FFFC09A4 20317320
FFFC09A8 20306120		db	" a0 "," a1 "," a2 "," a3 "," a4 "," a5 "," a6 "," a7 "," s2 "," s3 "
FFFC09AC 20316120
FFFC09B0 20326120
FFFC09B4 20336120
FFFC09B8 20346120
FFFC09BC 20356120
FFFC09C0 20366120
FFFC09C4 20376120
FFFC09C8 20327320
FFFC09CC 20337320
FFFC09D0 20347320		db	" s4 "," s5 "," s6 "," s7 "," s8 "," s9 "," s10"," s11"," t3 "," t4 "
FFFC09D4 20357320
FFFC09D8 20367320
FFFC09DC 20377320
FFFC09E0 20387320
FFFC09E4 20397320
FFFC09E8 30317320
FFFC09EC 31317320
FFFC09F0 20337420
FFFC09F4 20347420
FFFC09F8 20357420		db	" t5 "," t6 "
FFFC09FC 20367420
                        	msgPC:
FFFC0A00 20637020		db	" pc ",0
FFFC0A04 00000000
                        	
FFFC0A05 00000000	  align 1
FFFC0A09 00000000
FFFC0A0D 13000000
                        	
                        	doMem:
FFFC0A10 FFC10113		sub		$sp,$sp,#4
FFFC0A14 00148493		add		$s1,$s1,#1
FFFC0A18 FF0008B7		ldb		$t0,INBUF[$s1]
FFFC0A1C 10088893
FFFC0A20 009888B3
FFFC0A24 00088283
FFFC0A28 04F2C293		xor   $t0,$t0,#'O'
FFFC0A2C 00029463		bnez  $t0,.0001
FFFC0A30 00148493		add		$s1,$s1,#1
                        	.0001:
FFFC0A34 00912023		stt		$s1,[$sp]
FFFC0A38 00D06513		ldi		$a0,#CR
FFFC0A3C AA5FF0EF		call	Putch
FFFC0A40 FF000537		ldi		$a0,#INBUF
FFFC0A44 10050513
FFFC0A48 4B8000EF		call	PutString
FFFC0A4C 00012483		ldt		$s1,[$sp]
FFFC0A50 00410113		add		$sp,$sp,#4
FFFC0A54 2CC000EF		call	GetHexNum
FFFC0A58 000569B3		mov		$s3,$a0
FFFC0A5C 00056AB3		mov   $s5,$a0
FFFC0A60 00148493		add		$s1,$s1,#1
FFFC0A64 2BC000EF		call	GetHexNum
FFFC0A68 01350A33		add		$s4,$a0,$s3
                        	.loop2:
FFFC0A6C A45FF0EF		call	Getch						; check for ctrl-c
FFFC0A70 00354513		xor		$a0,$a0,#3
FFFC0A74 B80502E3		beq		$a0,$x0,Monitor
FFFC0A78 00D06513		ldi		$a0,#CR
FFFC0A7C A65FF0EF		call	Putch
FFFC0A80 0009E533		mov		$a0,$s3
FFFC0A84 39C000EF		call	PutHexWord
FFFC0A88 03A06513		ldi		$a0,#':'
FFFC0A8C A55FF0EF		call	Putch
FFFC0A90 00706913		ldi		$s2,#7
                        	.loop:
FFFC0A94 02006513		ldi		$a0,#' '
FFFC0A98 A49FF0EF		call	Putch
FFFC0A9C 00029C63		bnez  $t0,.userMem
FFFC0AA0 02106513		ldi   $a0,#33         ; Fetch memory word
FFFC0AA4 0009E5B3		mov   $a1,$s3
FFFC0AA8 00000073		ecall
FFFC0AAC 0005E533		mov   $a0,$a1
FFFC0AB0 00000463		bra   .0002
                        	.userMem
FFFC0AB4 00098503		ldb		$a0,[$s3]
                        	.0002:
FFFC0AB8 3C8000EF		call	PutHexByte
FFFC0ABC 00198993		add		$s3,$s3,#1
FFFC0AC0 FFF90913		sub		$s2,$s2,#1
FFFC0AC4 FC0958E3		bge		$s2,$x0,.loop
                        	
FFFC0AC8 FF898993		sub		$s3,$s3,#8
FFFC0ACC 00706913		ldi		$s2,#7
                        	.0004:
FFFC0AD0 0009C503		ldbu  $a0,[$s3]
FFFC0AD4 02052293		slt   $t0,$a0,#$20
FFFC0AD8 00029663		bnez  $t0,.unprintable
FFFC0ADC A05FF0EF		call  Putch
FFFC0AE0 00000663		bra   .0003
                        	.unprintable:
FFFC0AE4 02E06513	  ldi   $a0,#'.'
FFFC0AE8 9F9FF0EF	  call  Putch
                        	.0003:
FFFC0AEC 00198993	  add   $s3,$s3,#1
FFFC0AF0 FFF90913		sub		$s2,$s2,#1
FFFC0AF4 FC095EE3		bge		$s2,$x0,.0004
FFFC0AF8 F749EAE3		bltu	$s3,$s4,.loop2
FFFC0AFC 02006513		ldi		$a0,#' '
FFFC0B00 9E1FF0EF		call	Putch
FFFC0B04 02006513		ldi		$a0,#' '
FFFC0B08 9D9FF0EF		call	Putch
                        	
FFFC0B0C 000AE9B3		mov   $s3,$s5
FFFC0B10 AE9FF06F		jmp		Monitor		
                        	
FFFC0B14 00000000	  align 1
FFFC0B18 00000000
FFFC0B1C 00000000
                        	
                        	EditMem:
FFFC0B20 0040E073		csrrs $x0,#CSR_UIE,#1        ; enable gc interrupt
FFFC0B24 1FC000EF		call	GetHexNum			; get address to edit
FFFC0B28 000569B3		mov		$s3,$a0
FFFC0B2C 00148493		add		$s1,$s1,#1
FFFC0B30 1F0000EF		call	GetHexNum			; get value to set
FFFC0B34 01350023		stb		$s3,[$a0]			; update mem
FFFC0B38 AC1FF06F		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >V 0
                        	; Displays the virtual memory map for the specified app.
                        	;------------------------------------------------------------------------------
                        	
FFFC0B3C 00000000	  align 1
                        	
                        	doVMem:
FFFC0B40 00148493	  add   $s1,$s1,#1
FFFC0B44 27C000EF	  call  GetDecNum
FFFC0B48 00006993	  ldi   $s3,#0
FFFC0B4C 01051913	  sll   $s2,$a0,#16
                        	.0001:
FFFC0B50 0039F513	  and   $a0,$s3,#3
FFFC0B54 00051A63	  bnez  $a0,.notLF
FFFC0B58 00D06513	  ldi   $a0,#CR
FFFC0B5C 985FF0EF	  call  Putch
FFFC0B60 00006513	  ldi   $a0,#LF
  call  Putch
FFFC0B64 97DFF0EF
                        	.notLF:
FFFC0B68 00096533	  mov   $a0,$s2
FFFC0B6C 2B4000EF	  call  PutHexWord
FFFC0B70 03A06513	  ldi   $a0,#':'
FFFC0B74 96DFF0EF	  call  Putch
FFFC0B78 0320050D	  mvmap $a0,$x0,$s2
FFFC0B7C 2D4000EF	  call  PutHexHalf
FFFC0B80 02006513	  ldi   $a0,#' '
FFFC0B84 95DFF0EF	  call  Putch
FFFC0B88 00190913	  add   $s2,$s2,#1
FFFC0B8C 00198993	  add   $s3,$s3,#1
FFFC0B90 1009A513	  slt   $a0,$s3,#256
FFFC0B94 FA051EE3	  bnez  $a0,.0001  
FFFC0B98 A61FF06F	  jmp   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >P
                        	; Display the PAM bits status.
                        	;------------------------------------------------------------------------------
                        	
FFFC0B9C 00000000	  align 1
                        	
                        	doPStat:
FFFC0BA0 00D06513	  ldi   $a0,#CR
FFFC0BA4 93DFF0EF	  call  Putch
FFFC0BA8 00006513	  ldi   $a0,#LF
  call  Putch
FFFC0BAC 935FF0EF
FFFC0BB0 00006313	  ldi   $t1,#0        ; $a1 = bit number
                        	.0001:
FFFC0BB4 02006513	  ldi   $a0,#32       ; Get PAM bit pair
FFFC0BB8 00000073	  ecall
FFFC0BBC 03058513	  add   $a0,$a1,#'0'
FFFC0BC0 921FF0EF	  call  Putch
FFFC0BC4 00130313	  add   $t1,$t1,#1
FFFC0BC8 20032513	  slt   $a0,$t1,#MEMSZ
FFFC0BCC FE0514E3	  bnez  $a0,.0001
FFFC0BD0 A29FF06F	  jmp   Monitor
                        	 
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
FFFC0BD4 00000000	  align 1
FFFC0BD8 00000000
FFFC0BDC 00000000
                        	
                        	FillMem:
FFFC0BE0 140000EF		call	GetHexNum			; get address
FFFC0BE4 000569B3		mov		$s3,$a0
FFFC0BE8 00148493		add		$s1,$s1,#1
FFFC0BEC 134000EF		call	GetHexNum			; get length
FFFC0BF0 00056A33		mov		$s4,$a0
FFFC0BF4 00148493		add		$s1,$s1,#1
FFFC0BF8 128000EF		call	GetHexNum			; get byte to use
                        	.0001:
FFFC0BFC 00A98023		stb		$a0,[$s3]
FFFC0C00 FFFA0A13		sub		$s4,$s4,#1
FFFC0C04 FF404CE3		bgt		$s4,$x0,.0001
FFFC0C08 9F1FF06F		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; FI Hello
                        	;------------------------------------------------------------------------------
                        	
FFFC0C0C 00000000	  align 1
                        	
                        	Find:
FFFC0C10 00D06513	  ldi   $a0,#CR
FFFC0C14 8CDFF0EF	  call  Putch
FFFC0C18 00006513	  ldi   $a0,#LF
  call  Putch
FFFC0C1C 8C5FF0EF
FFFC0C20 0D4000EF	  call  SkipSpaces
FFFC0C24 0004E933	  mov   $s2,$s1
                        	.fwe:
FFFC0C28 FF0008B7	  ldbu  $t0,INBUF[$s2]
FFFC0C2C 10088893
FFFC0C30 012888B3
FFFC0C34 0008C283
FFFC0C38 00028E63	  beqz  $t0,.endOfWord
FFFC0C3C 02006313	  ldi   $t1,#' '
FFFC0C40 00628A63	  beq   $t0,$t1,.endOfWord
FFFC0C44 00D06313	  ldi   $t1,#CR
FFFC0C48 00628663	  beq   $t0,$t1,.endOfWord
FFFC0C4C 00190913	  add   $s2,$s2,#1
FFFC0C50 FC000CE3	  bra   .fwe
                        	.endOfWord:
FFFC0C54 FF0008B7	  stb   $x0,INBUF[$s2]
FFFC0C58 10088893
FFFC0C5C 012888B3
FFFC0C60 00088023
FFFC0C64 0004E933	  mov   $s2,$s1
FFFC0C68 00006513	  ldi   $a0,#0
FFFC0C6C 00006593	  ldi   $a1,#0
                        	.loop:
FFFC0C70 841FF0EF		call	Getch						; check for ctrl-c
FFFC0C74 00354513		xor		$a0,$a0,#3
FFFC0C78 00051463		bnez	$a0,.0001
FFFC0C7C 97DFF06F		jmp   Monitor
                        	.0001:
FFFC0C80 00054283	  ldbu  $t0,[$a0]
FFFC0C84 FF0008B7	  ldbu  $t1,INBUF[$s2]
FFFC0C88 10088893
FFFC0C8C 012888B3
FFFC0C90 0008C303
FFFC0C94 02030A63	  beqz  $t1,.found
FFFC0C98 00629863	  bne   $t0,$t1,.next
FFFC0C9C 00150513	  add   $a0,$a0,#1
FFFC0CA0 00190913	  add   $s2,$s2,#1
FFFC0CA4 FC0006E3	  bra   .loop
                        	.next:
FFFC0CA8 0004E933	  mov   $s2,$s1         ; start over again with $s2
FFFC0CAC 00158513	  add   $a0,$a1,#1      ; start over again with $a0, but increment by one
FFFC0CB0 000803B7	  ldi   $t2,#$80000     ; 512k
FFFC0CB4 00038393
FFFC0CB8 000565B3	  mov   $a1,$a0         ; remember new starting pos.
FFFC0CBC 007523B3	  slt   $t2,$a0,$t2
FFFC0CC0 FA0398E3	  bnez  $t2,.loop
FFFC0CC4 00000E63	  bra   .notFound
                        	.found:
FFFC0CC8 158000EF	  call  PutHexWord
FFFC0CCC 00D06513	  ldi   $a0,#CR
FFFC0CD0 811FF0EF	  call  Putch
FFFC0CD4 00006513	  ldi   $a0,#LF
  call  Putch
FFFC0CD8 809FF0EF
FFFC0CDC FC0006E3	  bra   .next
                        	.notFound:
FFFC0CE0 00D06513	  ldi   $a0,#CR
FFFC0CE4 FFCFF0EF	  call  Putch
FFFC0CE8 00006513	  ldi   $a0,#LF
  call  Putch
FFFC0CEC FF4FF0EF
FFFC0CF0 909FF06F	  jmp   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC0CF4 FF0008B7		ldb		$t0,INBUF[$s1]
FFFC0CF8 10088893
FFFC0CFC 009888B3
FFFC0D00 00088283
FFFC0D04 0202C313		xor		$t1,$t0,#' '
FFFC0D08 00030863		beqz	$t1,.skip1
FFFC0D0C 0092C313		xor		$t1,$t0,#'\t'
FFFC0D10 00030463		beqz	$t1,.skip1
FFFC0D14 00008067		ret
                        	.skip1:
FFFC0D18 00148493		add		$s1,$s1,#1
FFFC0D1C FC000CE3		bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	  align 16                        	
                        	GetHexNum:
FFFC0D20 00006513		ldi		$a0,#0							; a0 = num
FFFC0D24 FFC10113		sub		$sp,$sp,#4
FFFC0D28 00112023		stt		$ra,[$sp]
FFFC0D2C FC9FF0EF		call	SkipSpaces
                        	.next:
FFFC0D30 FF0008B7		ldb		$t0,INBUF[$s1]
FFFC0D34 10088893
FFFC0D38 009888B3
FFFC0D3C 00088283
FFFC0D40 03006393		ldi		$t2,#'0'
FFFC0D44 0272C663		blt		$t0,$t2,.0001
FFFC0D48 03A06393		ldi		$t2,#'9'+1
FFFC0D4C 0672C063		blt		$t0,$t2,.isDigit
FFFC0D50 04106393		ldi		$t2,#'A'
FFFC0D54 0072CE63		blt		$t0,$t2,.0001
FFFC0D58 04706393		ldi		$t2,#'F'+1
FFFC0D5C 0272C063		blt		$t0,$t2,.isHexUpper
FFFC0D60 06106393		ldi		$t2,#'a'
FFFC0D64 0072C663		blt		$t0,$t2,.0001
FFFC0D68 06706393		ldi		$t2,#'f'+1
FFFC0D6C 0272C463		blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC0D70 00012083		ldt		$ra,[$sp]
FFFC0D74 00410113		add		$sp,$sp,#4
FFFC0D78 00008067		ret
                        	.isHexUpper:
FFFC0D7C 00451513		sll		$a0,$a0,#4
FFFC0D80 FBF28293		sub		$t0,$t0,#'A'
FFFC0D84 00A28293		add		$t0,$t0,#10
FFFC0D88 00556533		or		$a0,$a0,$t0
FFFC0D8C 00148493		add		$s1,$s1,#1
FFFC0D90 FA0000E3		bra		.next
                        	.isHexLower:
FFFC0D94 00451513		sll		$a0,$a0,#4
FFFC0D98 F9F28293		sub		$t0,$t0,#'a'
FFFC0D9C 00A28293		add		$t0,$t0,#10
FFFC0DA0 00556533		or		$a0,$a0,$t0
FFFC0DA4 00148493		add		$s1,$s1,#1
FFFC0DA8 F80004E3		bra		.next
                        	.isDigit:
FFFC0DAC 00451513		sll		$a0,$a0,#4
FFFC0DB0 FD028293		sub		$t0,$t0,#'0'
FFFC0DB4 00556533		or		$a0,$a0,$t0
FFFC0DB8 00148493		add		$s1,$s1,#1
FFFC0DBC F6000AE3		bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a decimal number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	GetDecNum:
FFFC0DC0 00006513		ldi		$a0,#0							; a0 = num
FFFC0DC4 FFC10113		sub		$sp,$sp,#4
FFFC0DC8 00112023		stt		$ra,[$sp]
FFFC0DCC F29FF0EF		call	SkipSpaces
                        	.next:
FFFC0DD0 FF0008B7		ldb		$t0,INBUF[$s1]
FFFC0DD4 10088893
FFFC0DD8 009888B3
FFFC0DDC 00088283
FFFC0DE0 03006393		ldi		$t2,#'0'
FFFC0DE4 0072C663		blt		$t0,$t2,.0001
FFFC0DE8 03A06393		ldi		$t2,#'9'+1
FFFC0DEC 0072C863		blt		$t0,$t2,.isDigit
                        	.0001:
FFFC0DF0 00012083		ldt		$ra,[$sp]
FFFC0DF4 00410113		add		$sp,$sp,#4
FFFC0DF8 00008067		ret
                        	.isDigit:
FFFC0DFC 00151393		sll		$t2,$a0,#1    ; multiply by 10
FFFC0E00 00351513		sll   $a0,$a0,#3    ; * 8
FFFC0E04 00750533		add   $a0,$a0,$t2   ; + *2
FFFC0E08 FD028293		sub		$t0,$t0,#'0'
FFFC0E0C 00550533		add		$a0,$a0,$t0
FFFC0E10 00148493		add		$s1,$s1,#1
FFFC0E14 FA000EE3		bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains word to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
FFFC0E18 00000000	  align 1
FFFC0E1C 00000000
                        	
                        	PutHexWord:
FFFC0E20 FF810113		sub		$sp,$sp,#8
FFFC0E24 00112023		stt		$ra,[$sp]
FFFC0E28 00A12223		stt		$a0,4[$sp]
FFFC0E2C 01055513		srl		$a0,$a0,#16
FFFC0E30 020000EF		call	PutHexHalf
FFFC0E34 00012083		ldt		$ra,[$sp]
FFFC0E38 00412503		ldt		$a0,4[$sp]
FFFC0E3C 00810113		add		$sp,$sp,#8	; fall through to PutHexHalf
FFFC0E40 00000863		bra		PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
FFFC0E44 00000000		align	1
FFFC0E48 00000000
FFFC0E4C 00000000
                        	
                        	PutHexHalf:
FFFC0E50 FF810113		sub		$sp,$sp,#8
FFFC0E54 00112023		stt		$ra,[$sp]
FFFC0E58 00A12223		stt		$a0,4[$sp]
FFFC0E5C 00855513		srl		$a0,$a0,#8
FFFC0E60 020000EF		call	PutHexByte
FFFC0E64 00012083		ldt		$ra,[$sp]
FFFC0E68 00412503		ldt		$a0,4[$sp]		
FFFC0E6C 00810113		add		$sp,$sp,#8	; fall through to PutHexByte
FFFC0E70 00000863		bra		PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
FFFC0E74 00000000		align	1
FFFC0E78 00000000
FFFC0E7C 00000000
                        	
                        	PutHexByte:
FFFC0E80 FF810113		sub		$sp,$sp,#8
FFFC0E84 00112023		stt		$ra,[$sp]
FFFC0E88 00A12223		stt		$a0,4[$sp]
FFFC0E8C 00455513		srl		$a0,$a0,#4		; put the high order nybble first
FFFC0E90 020000EF		call	PutHexNybble
FFFC0E94 00012083		ldt		$ra,[$sp]
FFFC0E98 00412503		ldt		$a0,4[$sp]
FFFC0E9C 00810113		add		$sp,$sp,#8		; fall through to PutHexNybble
FFFC0EA0 00000863		bra		PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains nybble to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
FFFC0EA4 00000000		align	1
FFFC0EA8 00000000
FFFC0EAC 00000000
                        	
                        	PutHexNybble:
FFFC0EB0 FF410113		sub		$sp,$sp,#12
FFFC0EB4 00112023		stt		$ra,[$sp]
FFFC0EB8 00A12223		stt		$a0,4[$sp]
FFFC0EBC 00512423		stt   $t0,8[$sp]
FFFC0EC0 00F57513		and		$a0,$a0,#15		; strip off high order bits
FFFC0EC4 00A06293		ldi		$t0,#10
FFFC0EC8 00554A63		blt		$a0,$t0,.lt10
FFFC0ECC FF650513		sub		$a0,$a0,#10
FFFC0ED0 04150513		add		$a0,$a0,#'A'
FFFC0ED4 E0CFF0EF		call	Putch
FFFC0ED8 00000663		bra		.0001
                        	.lt10:
FFFC0EDC 03050513		add		$a0,$a0,#'0'
FFFC0EE0 E00FF0EF		call	Putch
                        	.0001:
FFFC0EE4 00012083		ldt		$ra,[$sp]
FFFC0EE8 00412503		ldt		$a0,4[$sp]
FFFC0EEC 00812283		ldt   $t0,8[$sp]
FFFC0EF0 00C10113		add		$sp,$sp,#12
FFFC0EF4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
FFFC0EF8 00000000	  align 1
FFFC0EFC 00000000
                        	
                        	PutString:
FFFC0F00 FF810113		sub		$sp,$sp,#8				; save link register
FFFC0F04 00112023		stt		$ra,[$sp]
FFFC0F08 00A12223		stt		$a0,4[$sp]				; and argument
FFFC0F0C 00056333		mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0F10 00030503		ldb		$a0,[$t1]
FFFC0F14 00130313		add		$t1,$t1,#1				; advance pointer to next byte
FFFC0F18 00050663		beqz	$a0,.done			    ; branch if done
FFFC0F1C DC4FF0EF		call	Putch							; output character
FFFC0F20 FE0008E3		bra		.0001
                        	.done:
FFFC0F24 00012083		ldt		$ra,[$sp]					; restore return address
FFFC0F28 00412503		ldt		$a0,4[$sp]				; and argument
FFFC0F2C 00810113		add		$sp,$sp,#8
FFFC0F30 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	DumpTraceQueue:
FFFC0F34 FFC10113		sub		$sp,$sp,#4
FFFC0F38 00112023		stt		$ra,[$sp]
FFFC0F3C 05806813		ldi   $a6,#'X'        ; bypass='B' in fputc routine
FFFC0F40 00006493		ldi		$s1,#0
FFFC0F44 00D06513		ldi   $a0,#CR
FFFC0F48 D98FF0EF		call  Putch
                        	.dmpTrace:
FFFC0F4C 00E06593		ldi   $a1,#14         ; processor trace queue
FFFC0F50 1A05850D		popq  $a0,$a1
	bltz  $a0,.dmpTraceEmpty  ; emptied out?
FFFC0F54 04054463
FFFC0F58 001008B7		and   $a0,$a0,#$FFFFF
FFFC0F5C FFF88893
FFFC0F60 01157533
FFFC0F64 EBDFF0EF		call  PutHexWord
FFFC0F68 02006513		ldi		$a0,#' '
FFFC0F6C D74FF0EF		call	Putch
FFFC0F70 00D06593		ldi   $a1,#13         ; processor trace queue
FFFC0F74 1C05850D		peekq $a0,$a1
	call	PutHexWord
FFFC0F78 EA9FF0EF
FFFC0F7C 02006513		ldi		$a0,#' '
FFFC0F80 D60FF0EF		call	Putch
FFFC0F84 00148493		add		$s1,$s1,#1
FFFC0F88 0074F913		and		$s2,$s1,#7
FFFC0F8C AA091163		bnez	$s2,.0001
FFFC0F90 00D06513		ldi		$a0,#CR
FFFC0F94 D4CFF0EF		call	Putch
                        	.00001:
FFFC0F98 FA000AE3		bra   .dmpTrace
                        	.dmpTraceEmpty:
FFFC0F9C 00D06513		ldi   $a0,#CR
FFFC0FA0 D40FF0EF		call  Putch
                        	.inf:
                        	;  bra   .inf
FFFC0FA4 00012083		ldt		$ra,[$sp]
FFFC0FA8 00410113		add		$sp,$sp,#4
FFFC0FAC 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;
                        	; On incoming the register file has been set to the interrupt register file
                        	; or the machine mode register file.
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	; Top of stack for different register sets
                        	StackTbl:
FFFC0FB0 00000000	  dw    $0
FFFC0FB4 00000000	  dw    $0
FFFC0FB8 00000000	  dw    $0
FFFC0FBC 00000000	  dw    $0
FFFC0FC0 00000000	  dw    $0
FFFC0FC4 00000000	  dw    $0
FFFC0FC8 00000000	  dw    $0
FFFC0FCC 00000000	  dw    $0
FFFC0FD0 00000000	  dw    $0
FFFC0FD4 00000000	  dw    $0
FFFC0FD8 00000000	  dw    $0
FFFC0FDC 00000000	  dw    $0
FFFC0FE0 00000000	  dw    $0
FFFC0FE4 00000000	  dw    $0
FFFC0FE8 00000000	  dw    $0
FFFC0FEC 00000000	  dw    $0
FFFC0FF0 00000000	  dw    $0
FFFC0FF4 00000000	  dw    $0
FFFC0FF8 00000000	  dw    $0
FFFC0FFC 00000000	  dw    $0
FFFC1000 00000000	  dw    $0
FFFC1004 00000000	  dw    $0
FFFC1008 00000000	  dw    $0
FFFC100C 00000000	  dw    $0
FFFC1010 00000000	  dw    $0
FFFC1014 00000000	  dw    $0
FFFC1018 00000000	  dw    $0
FFFC101C 00000000	  dw    $0
FFFC1020 F207E7FC	  dw    $F207E800-4
FFFC1024 F607EFFC	  dw    $F607F000-4
FFFC1028 FA07F7FC	  dw    $FA07F800-4
FFFC102C FE07FFFC	  dw    $FE080000-4
                        	
                        	StackTbl2:
FFFC1030 D207A7FC		dw		$D207A800-4
FFFC1034 D607AFFC		dw		$D607B000-4
FFFC1038 DA07B7FC		dw		$DA07B800-4
FFFC103C DE07BFFC		dw		$DE07C000-4
FFFC1040 E207C7FC		dw		$E207C800-4
FFFC1044 E607CFFC		dw		$E607D000-4
FFFC1048 EA07D7FC		dw		$EA07D800-4
FFFC104C EE07DFFC		dw		$EE07E000-4
                        	
                        	.file "cs01rom.r5a",1263
                        		code
                        		align	16                        	
                        	IRQRout:
FFFC1050 342012F3		csrrw	$t0,#$342,$x0			; get cause code
FFFC1054 0602C063		bltz	$t0,.isIRQ		  	; irq or ecall?
FFFC1058 04028063		beqz	$t0,.instAlign
FFFC105C 0192C393		xor		$t2,$t0,#25				; bus error?
FFFC1060 00038C63		beqz	$t2,.busError
FFFC1064 0022C393		xor   $t2,$t0,#2      	; illegal instruction?
FFFC1068 00038863		beqz  $t2,.illegal
FFFC106C FFC2F393		and   $t2,$t0,#$FFFFFFFC
FFFC1070 0083C393		xor   $t2,$t2,#8
FFFC1074 02038E63		beqz  $t2,.ecall
                        		; Some other cause
                        	.busError:
                        	.illegal:
FFFC1078 FE080137		ldi		$sp,#$FE080000-4
FFFC107C FFC10113
FFFC1080 7A00F073		csrrc $x0,#CSR_TRACECTRL,#1 ; turn off tracing
FFFC1084 7C40F073		csrrc	$x0,#CSR_PMSTACK,#1		; disable interrupts
FFFC1088 EADFF0EF		call	DumpTraceQueue
                        	;	ldi   $t0,#DumpTraceQueue
                        	;	csrrw $x0,#CSR_MEPC,$t0
                        	.illegal1:
FFFC108C 00000063		bra		.illegal1
FFFC1090 30200073		mret
                        	.soc:
FFFC1094 00000063	  bra   .soc
                        	
                        	.instAlign:
FFFC1098 FE080137		ldi		$sp,#$FE080000-4
FFFC109C FFC10113
FFFC10A0 7A00F073		csrrc $x0,#CSR_TRACECTRL,#1 ; turn off tracing
FFFC10A4 7C40F073		csrrc	$x0,#CSR_PMSTACK,#1		; disable interrupts
FFFC10A8 E8DFF0EF		call	DumpTraceQueue
                        	.instAlign1:
FFFC10AC 00000063		bra		.instAlign1
                        	
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Environment Call entry point.
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	.ecall:
FFFC10B0 2F00206F		jmp		OSECALL					  ; goto operating system call dispatcher
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; For IRQs the register set is automatically set according to the interrupt
                        	; level active level 0 to 7 use register sets 52 to 59.
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	.isIRQ:
                        		; Switch to map 52 to 59
FFFC10B4 18001373	  csrrw	$t1,#CSR_SATP,$x0
FFFC10B8 F04008B7	  and		$t1,$t1,#$f03fffff			; mask off asid
FFFC10BC FFF88893
FFFC10C0 01137333
FFFC10C4 7C3013F3	  csrrw	$t2,#CSR_RSSTACK,$x0
FFFC10C8 03F3F393	  and		$t2,$t2,#63
FFFC10CC 01639393	  sll		$t2,$t2,#22
FFFC10D0 00736333	  or		$t1,$t1,$t2							; set new asid
FFFC10D4 18031073		csrrw	$x0,#CSR_SATP,$t1				; set satp
                        	  ; Reset stack pointer for interrupt register set.
FFFC10D8 7C5012F3		csrrw	$t0,#CSR_IMSTACK,$x0
FFFC10DC 0072F293		and		$t0,$t0,#7
FFFC10E0 00229393	  sll   $t2,$t0,#2        	; $t2 = table index
FFFC10E4 FFFC18B7		ldt		$sp,StackTbl2[$t2]	; setup machine mode stack pointer
FFFC10E8 03088893
FFFC10EC 007888B3
FFFC10F0 0008A103
FFFC10F4 342012F3		csrrw	$t0,#$342,$x0				; get cause code
FFFC10F8 7C40E073		csrrs	$x0,#CSR_PMSTACK,#1	; enable higher-level interrupts
FFFC10FC FF0018B7	  ldt   $t1,IRQFlag     		; update IRQ flag for Tiny Basic
FFFC1100 09088893
FFFC1104 000888B3
FFFC1108 0008A303
FFFC110C 00130313	  add   $t1,$t1,#1
FFFC1110 FF0018B7	  stt   $t1,IRQFlag
FFFC1114 09088893
FFFC1118 000888B3
FFFC111C 0068A023
FFFC1120 0FF2F293	  and   $t0,$t0,#$FF
FFFC1124 FF0018B7	  stt   $t0,IRQCause    ; update cause code for Tiny Basic
FFFC1128 09888893
FFFC112C 000888B3
FFFC1130 0058A023
FFFC1134 FFF28313	  sub   $t1,$t0,#1
FFFC1138 90030263	  beqz  $t1,.softwareIrq
FFFC113C FFF30313	  sub   $t1,$t1,#1
FFFC1140 8E030E63	  beqz  $t1,.timerIrq
FFFC1144 FFF30313	  sub   $t1,$t1,#1      ; garbage collect interrupt?
FFFC1148 8E030B63	  beqz  $t1,.gcIrq
FFFC114C 01F2FE93		and		$t4,$t0,#31			; interrupting device # is low order 5 bits of cause code
FFFC1150 00506E13		ldi   $t3,#5          ; try 5 times
                        	.devAgain:
FFFC1154 000EEF33		mov   $t5,$t4
FFFC1158 007F1F13		sll		$t5,$t5,#7				; 128 bytes per device func table
FFFC115C FF0028B7		add		$t5,$t5,#DVF_Base+22*4	; load IRQ routine vector from device func table
FFFC1160 05888893
FFFC1164 011F0F33
FFFC1168 000F2F03		ldt		$t5,[$t5]
FFFC116C 8C0F0A63		beqz	$t5,.noIRQ	    ; make sure there's an address to go to
FFFC1170 000F0067		jmp		[$t5]						; jump to the IRQ routine
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; IRQ exit point. All IRQ routines should exit through this piece of code.
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	IRQExit:
                        		; Switch back to app map
FFFC1174 42058013		di		11
FFFC1178 18001373	  csrrw	$t1,#CSR_SATP,$x0
FFFC117C F04008B7	  and		$t1,$t1,#$f03fffff		; mask off asid
FFFC1180 FFF88893
FFFC1184 01137333
FFFC1188 7C3013F3	  csrrw	$t2,#CSR_RSSTACK,$x0
FFFC118C 0063D393	  srl		$t2,$t2,#6
FFFC1190 03F3F393	  and		$t2,$t2,#$3f
FFFC1194 01639393	  sll		$t2,$t2,#22
FFFC1198 00736333	  or		$t1,$t1,$t2						; restore asid
FFFC119C 18031073		csrrw	$x0,#CSR_SATP,$t1			; set satp
FFFC11A0 30200073		mret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	.noIRQ:
FFFC11A4 FFFE0E13	  sub   $t3,$t3,#1
FFFC11A8 000E1463	  bnez  $t3,.InitDev
                        	.softwareIrq:
                        	.timerIrq:
FFFC11AC 30200073	  mret
                        		; The device function tables may have been zeroed out, try initializing them.
                        		; The following uses $a0-$a1, $t0-$t2
                        	.InitDev:
FFFC11B0 00506513		ldi		$a0,#5							; serial device
FFFC11B4 03D51263		bne   $a0,$t4,.notSerial
FFFC11B8 FFFC25B7		ldi		$a1,#SerialFuncTbl
FFFC11BC 08858593
FFFC11C0 7E1030EF		call	CopyDevFuncTbl
FFFC11C4 00506513		ldi		$a0,#5							; serial device
FFFC11C8 FFFC25B7		ldi   $a1,#SerialDCB
FFFC11CC 10858593
FFFC11D0 000040EF		call  CopyDevDCB
FFFC11D4 86000B63		bra   .devAgain
                        	.notSerial:
FFFC11D8 00F06513		ldi		$a0,#15							; VIA device
FFFC11DC 03D51263		bne   $a0,$t4,.notVia
FFFC11E0 FFFC35B7		ldi		$a1,#ViaFuncTbl
FFFC11E4 82858593
FFFC11E8 7B9030EF		call	CopyDevFuncTbl
FFFC11EC 00F06513		ldi		$a0,#15							; VIA device
FFFC11F0 FFFC35B7		ldi		$a1,#ViaDCB
FFFC11F4 8A858593
FFFC11F8 7D9030EF		call	CopyDevDCB
FFFC11FC 84000763		bra   .devAgain
                        	.notVia:
FFFC1200 30200073	  mret
                        	.gcIrq:
                        	;	ldi		$sp,#$7F800-4		; setup interrupt mode stack pointer
FFFC1204 190040EF	  call  gcIncrement
                        	ERETx2:
                        	;  mDI
                        	;  csrrc $x0,#$7C0,#31   ; select machine regs only
                        	;  csrrw $t0,#$7C0,$x0   ; get register sets
                        	;  srl   $t0,$t0,#5      ; extract register set selection
                        	;  sll   $t0,$t0,#3
                        	;  ldt   $t1,MEPC0[$t0]  ; get it
                        	;  csrrw $x0,#$341,$t1   ; set mepc
                        	  
FFFC1208 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC120C 00000013	nop
FFFC1210 00000013	  nop
                        	;  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
                        	;  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
                        	;  sll   $t2,$t0,#2        ; $t2 = table index
                        	;	ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFC1214 30200073		mret
                        	
                        		; In case the pipeline runs ahead into the following table which will
                        		; result in illegal instructions.
FFFC1218 00000013		nop
FFFC121C 00000013		nop
FFFC1220 00000013	  nop
                        	
                        	msgRamTest:
FFFC1224 204D4152		db	"RAM Test:",CR,LNFD,0
FFFC1228 74736554
FFFC122C 000A0D3A
                        	
                        		align	4                        	
                        	; Application startup record for Monitor
                        	MonitorASR:
FFFC1230 3C3C0200	  db    0     ; page size (can't change on this system)
FFFC1231 003C3C02	  db    2     ; priority normal
FFFC1232 00003C3C	  db    60    ; register set for startup task
FFFC1233 0000003C	  db    60    ; memory map #0
FFFC1234 00000000	  dw    0     ; processor affinity
FFFC1238 00000000	  dw    0     ; code size (0 = in ROM, don't move)
FFFC123C 00000000	  dw    0     ; reserved
FFFC1240 00000000	  dw    0     ; data size (preinitialized data)
FFFC1244 00000000	  dw    0     ; reserved
FFFC1248 00000000	  dw    0     ; uninitialized data size
FFFC124C 00000000	  dw    0     ; reserved
FFFC1250 00000000	  dw    0     ; Heap size
FFFC1254 00000000	  dw    0     ; reserved
FFFC1258 00000400	  dw    1024  ; stack size
FFFC125C 00000000	  dw    0     ; reserved
FFFC1260 FFFC05E0	  dw    MonEntry  ; pointer to code
FFFC1264 00000000	  dw    0       ; reserved
FFFC1268 00000000	  dw    0     ; pointer to data
FFFC126C 00000000	  dw    0     ; reserved
FFFC1270 00000000	  dw    0     ; ui data
FFFC1274 00000000	  dw    0     ; reserved
                        	
                        	; Application startup record for system
                        	SystemASR:
FFFC1278 3C3C0200	  db    0     ; page size (can't change on this system)
FFFC1279 003C3C02	  db    2     ; priority normal
FFFC127A 00003C3C	  db    60    ; register set for startup task
FFFC127B 0000003C	  db    60    ; memory map #0
FFFC127C 00000000	  dw    0     ; processor affinity
FFFC1280 00000000	  dw    0     ; code size (0 = in ROM, don't move)
FFFC1284 00000000	  dw    0     ; reserved
FFFC1288 00000000	  dw    0     ; data size (preinitialized data)
FFFC128C 00000000	  dw    0     ; reserved
FFFC1290 00000000	  dw    0     ; uninitialized data size
FFFC1294 00000000	  dw    0     ; reserved
FFFC1298 00000000	  dw    0     ; Heap size
FFFC129C 00000000	  dw    0     ; reserved
FFFC12A0 00000400	  dw    1024  ; stack size
FFFC12A4 00000000	  dw    0     ; reserved
FFFC12A8 FFFC03A0	  dw    IdleTask  ; pointer to code
FFFC12AC 00000000	  dw    0       ; reserved
FFFC12B0 00000000	  dw    0     ; pointer to data
FFFC12B4 00000000	  dw    0     ; reserved
FFFC12B8 00000000	  dw    0     ; ui data
FFFC12BC 00000000	  dw    0     ; reserved
                        	
                        	; Application startup record for Tiny Basic
                        	TinyBasicASR:
FFFC12C0 03030200	  db    0     ; page size (can't change on this system)
FFFC12C1 00030302	  db    2     ; priority normal
FFFC12C2 00000303	  db    3     ; register set
FFFC12C3 00000003	  db    3     ; memory map
FFFC12C4 00000000	  dw    0     ; processor affinity
FFFC12C8 00000000	  dw    0     ; code size (0 = in ROM, don't move)
FFFC12CC 00000000	  dw    0     ; reserved
FFFC12D0 00000000	  dw    0     ; data size (preinitialized data)
FFFC12D4 00000000	  dw    0     ; reserved
FFFC12D8 00008000	  dw    32768 ; uninitialized data size
FFFC12DC 00000000	  dw    0     ; reserved
FFFC12E0 00000000	  dw    0     ; Heap size
FFFC12E4 00000000	  dw    0     ; reserved
FFFC12E8 00000800	  dw    2048  ; stack size
FFFC12EC 00000000	  dw    0     ; reserved
FFFC12F0 FFFC5430	  dw    CSTART  ; pointer to code
FFFC12F4 00000000	  dw    0       ; reserved
FFFC12F8 00000000	  dw    0     ; pointer to data
FFFC12FC 00000000	  dw    0     ; reserved
FFFC1300 00000000	  dw    0     ; ui data
FFFC1304 00000000	  dw    0     ; reserved
                        	    
                        	; Application startup record for Tiny Basic
                        	UserASR:
FFFC1308 00000200	  db    0     ; page size (can't change on this system)
FFFC1309 00000002	  db    2     ; priority normal
FFFC130A 00000000	  db    0     ; register set
FFFC130B 00000000	  db    0     ; memory map
FFFC130C 00000000	  dw    0     ; processor affinity
FFFC1310 00000000	  dw    0     ; code size (0 = in ROM, don't move)
FFFC1314 00000000	  dw    0     ; reserved
FFFC1318 00000000	  dw    0     ; data size (preinitialized data)
FFFC131C 00000000	  dw    0     ; reserved
FFFC1320 00008000	  dw    32768 ; uninitialized data size
FFFC1324 00000000	  dw    0     ; reserved
FFFC1328 00000000	  dw    0     ; Heap size
FFFC132C 00000000	  dw    0     ; reserved
FFFC1330 00000400	  dw    1024  ; stack size
FFFC1334 00000000	  dw    0     ; reserved
FFFC1338 FFFC0274	  dw    UserStart2  ; pointer to code
FFFC133C 00000000	  dw    0       ; reserved
FFFC1340 00000000	  dw    0     ; pointer to data
FFFC1344 00000000	  dw    0     ; reserved
FFFC1348 00000000	  dw    0     ; ui data
FFFC134C 00000000	  dw    0     ; reserved
                        	    
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC1350 31305343			db		"CS01 System Starting.",13
FFFC1354 73795320
FFFC1358 206D6574
FFFC135C 72617453
FFFC1360 676E6974
FFFC1364 6F4D0D2E
                        	msgMonHelp:
FFFC1366 696E6F4D			db		"Monitor Commands",13
FFFC136A 20726F74
FFFC136E 6D6D6F43
FFFC1372 73646E61
FFFC1376 2D20420D
FFFC1377 202D2042			db		"B - start tiny basic",13
FFFC137B 72617473
FFFC137F 69742074
FFFC1383 6220796E
FFFC1387 63697361
FFFC138B 2D20440D
FFFC138C 202D2044			db		"D - dump ready que",13
FFFC1390 706D7564
FFFC1394 61657220
FFFC1398 71207964
FFFC139C 450D6575
FFFC139F 202D2045			db		"E - edit memory",13
FFFC13A3 74696465
FFFC13A7 6D656D20
FFFC13AB 0D79726F
FFFC13AF 202D2046			db		"F - fill memory",13
FFFC13B3 6C6C6966
FFFC13B7 6D656D20
FFFC13BB 0D79726F
FFFC13BF 3C204946			db    "FI <string>- find string in memory",13
FFFC13C3 69727473
FFFC13C7 2D3E676E
FFFC13CB 6E696620
FFFC13CF 74732064
FFFC13D3 676E6972
FFFC13D7 206E6920
FFFC13DB 6F6D656D
FFFC13DF 4B0D7972
FFFC13E2 743C204B			db		"K <tid> - kill task", 13
FFFC13E6 203E6469
FFFC13EA 696B202D
FFFC13EE 74206C6C
FFFC13F2 0D6B7361
FFFC13F6 733C204D			db		"M <start> <length>	- dump memory",13
FFFC13FA 74726174
FFFC13FE 6C3C203E
FFFC1402 74676E65
FFFC1406 2D093E68
FFFC140A 6D756420
FFFC140E 656D2070
FFFC1412 79726F6D
FFFC1416 2D20500D
FFFC1417 202D2050			db    "P - display PAM",13
FFFC141B 70736964
FFFC141F 2079616C
FFFC1423 0D4D4150
FFFC1427 202D2052			db		"R - registers",13
FFFC142B 69676572
FFFC142F 72657473
FFFC1433 20530D73
FFFC1435 202D2053			db		"S - switch task",13
FFFC1439 74697773
FFFC143D 74206863
FFFC1441 0D6B7361
FFFC1445 6D3C2056			db    "V <mid> dump virtual memory map",13
FFFC1449 203E6469
FFFC144D 706D7564
FFFC1451 72697620
FFFC1455 6C617574
FFFC1459 6D656D20
FFFC145D 2079726F
FFFC1461 0D70616D
FFFC1465 20000000			db		0
FFFC1466 74200000			align 
                        	
                        	msgTaskStart:
FFFC1468 73617420			db		" task started."
FFFC146C 7473206B
FFFC1470 65747261
FFFC1474 0A0D2E64
                        	msgCRLF:
FFFC1476 00000A0D			db		13,10,0
                        	flt50:
FFFC1479 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC147D 00000000
FFFC1481 00000000
FFFC1485 40049000
                        	flt20:
FFFC1489 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC148D 00000000
FFFC1491 00000000
FFFC1495 40034000
                        	flt10:
FFFC1499 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC149D 00000000
FFFC14A1 00000000
FFFC14A5 40024000
                        	
                        	.file "fltToString.r5a",1
                        	.file "fltToString.r5a",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC14A9 00639300			ldi		$t2,#0				; $t2 = 0
FFFC14AD 09055300
FFFC14AE E0090553			fmv		$a0,$f18
FFFC14B2 7F8008B7			and		$t0,$a0,#$7F800000
FFFC14B6 00088893
FFFC14BA 011572B3
FFFC14BE 7F800337			ldi		$t1,#$7F800000
FFFC14C2 00030313
FFFC14C6 04629263			bne		$t0,$t1,.0001
FFFC14CA 008008B7			and		$t0,$a0,#$007FFFFF
FFFC14CE FFF88893
FFFC14D2 011572B3
FFFC14D6 00028E63			beq		$t0,$x0,.inf
FFFC14DA FFFC28B7			ldt		$t0,msgNan
FFFC14DE 86488893
FFFC14E2 000888B3
FFFC14E6 0008A283
FFFC14EA 20502023			stt		$t0,STRTMP
FFFC14EE 2E000E63			bra		.prt
                        	.inf:
FFFC14F2 FFFC28B7			ldt		$t0,msgInf
FFFC14F6 86088893
FFFC14FA 000888B3
FFFC14FE 0008A283
FFFC1502 20502023			stt		$t0,STRTMP
FFFC1506 2E000263			bra		.prt
                        	.0001:
FFFC150A 800008B7			and		$t0,$a0,#$80000000
FFFC150E 00088893
FFFC1512 011572B3
FFFC1516 00028E63			beq		$t0,$x0,.pos
FFFC151A 02D06293			ldi		$t0,#'-'
FFFC151E 20538023			stb		$t0,STRTMP[$t2]
FFFC1522 00138393			add		$t2,$t2,#1
FFFC1526 800008B7			and		$a0,$a0,#$7FFFFFFF
FFFC152A FFF88893
FFFC152E 01157533
                        	.pos:
FFFC1532 00051A63			bne		$a0,$x0,.notZero
FFFC1536 03006293			ldi		$t0,#'0'
FFFC153A 20538023			stb		$t0,STRTMP[$t2]
FFFC153E 200380A3			stb		$x0,STRTMP+1[$t2]
FFFC1542 2A000463			bra		.prt		
                        	.notZero:
FFFC1546 00006CB3			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC154A FFFC28B7			flw		$f3,fltOne
FFFC154E 86888893
FFFC1552 000888B3
FFFC1556 0008A187
FFFC155A F0050053			fmv		$f0,$a0
FFFC155E A03912D3			flt		$t0,$f18,$f3
FFFC1562 02028463			beq		$t0,$x0,.0002
FFFC1566 FFFC28B7			flw		$f4,fltMillion
FFFC156A 87088893
FFFC156E 000888B3
FFFC1572 0008A207
                        	.0003:
FFFC1576 A03912D3			flt		$t0,$f18,$f3
FFFC157A 00028863			beq		$t0,$x0,.0002
FFFC157E 10490953			fmul	$f18,$f18,$f4
FFFC1582 FFAC8C93			sub		$s9,$s9,#6
FFFC1586 FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC158A FFFC28B7			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC158E 86888893
FFFC1592 000888B3
FFFC1596 0008A087
FFFC159A 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC159E A12092D3			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC15A2 02028A63			beq		$t0,$x0,.0004
FFFC15A6 FFFC28B7			flw		$f5,fltTen				; $f5 = 10.0
FFFC15AA 86C88893
FFFC15AE 000888B3
FFFC15B2 0008A287
                        	.0006:
FFFC15B6 A12082D3			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC15BA 00028A63			beq		$t0,$x0,.0005
FFFC15BE 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC15C2 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC15C6 001C8C93			add		$s9,$s9,#1				; exp++;
FFFC15CA FE0006E3			bra		.0006
                        	.0005:
FFFC15CE 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC15D2 FFFC8C93			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC15D6 000CCE63			blt		$s9,$x0,.0007
FFFC15DA 00606A93			ldi		$s5,#6
FFFC15DE 015CDA63			bge		$s9,$s5,.0007
FFFC15E2 FFFFE4B3			mov		$s1,#s0						; s1 = digits before decpt
FFFC15E6 00148493			add		$s1,$s1,#1
FFFC15EA 00006C93			ldi		$s9,#0						; exp = 0
FFFC15EE 00000C63			bra		.0008
                        	.0007:
FFFC15F2 FF906A93			ldi		$s5,#-7
FFFC15F6 015CC663			blt		$s9,$s5,.0009
FFFC15FA 00106493			ldi		$s1,#1
FFFC15FE 00000463			bra		.0008
                        	.0009:
FFFC1602 FFF06493			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC1606 FFA06A93			ldi		$s5,#-6
FFFC160A 015CDE63			bge		$s9,$s5,.0010
FFFC160E 03006293			ldi		$t0,#'0'
FFFC1612 20538023			stb		$t0,STRTMP[$t2]
FFFC1616 00138393			add		$t2,$t2,#1
FFFC161A 02E06293			ldi		$t0,#'.'
FFFC161E 20538023			stb		$t0,STRTMP[$t2]
FFFC1622 00138393			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC1626 00006993			ldi		$s3,#0						; s3 = nn = 0
FFFC162A 01E06A93			ldi		$s5,#30
FFFC162E FFFC28B7			flw		$f7,fltTen				; f7 = 10.0
FFFC1632 86C88893
FFFC1636 000888B3
FFFC163A 0008A387
                        	.0016:
FFFC163E 0159A2B3			slt		$t0,$s3,$s5
FFFC1642 06028863			beq		$t0,$x0,.0011
FFFC1646 00006A93			ldi		$s5,#0
FFFC164A 06CAD463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC164E 00006A13			ldi		$s4,#0						; s4 = digit = 0
FFFC1652 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC1656 A12082D3			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC165A 00028863			beq		$t0,$x0,.0012
FFFC165E 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC1662 001A0A13			add		$s4,$s4,#1						; digit++
FFFC1666 FE0008E3			bra		.0013
                        	.0012:
FFFC166A 030A0A93			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC166E 21538023			stb		$s5,STRTMP[$t2]
FFFC1672 00206A93			ldi		$s5,#2						; if (2 < digit)
FFFC1676 014AD863			bge		$s5,$s4,.0014
FFFC167A D00A02D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC167E 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC1682 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC1686 00138393			add		$t2,$t2,#1				; ndx++
FFFC168A FFF48493			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC168E 00049A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC1692 02E06293			ldi		$t0,#'.'
FFFC1696 20538023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC169A 00138393			add		$t2,$t2,#1				; ndx++
FFFC169E 00000663			bra		.0017
                        	.0015:
FFFC16A2 0004D463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC16A6 FFF60613			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC16AA 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC16AE F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC16B2 FFF38393			sub		$t2,$t2,#1				; ndx--
FFFC16B6 20038283			ldb		$t0,STRTMP[$t2]
FFFC16BA 0302C293			xor		$t0,$t0,#'0'
FFFC16BE FE028AE3			beq		$t0,$x0,.0018
FFFC16C2 00138393			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC16C6 20038283			ldb		$t0,STRTMP[$t2]
FFFC16CA 02E2C293			xor		$t0,$t0,#'.'
FFFC16CE 00029C63			bne		$t0,$x0,.0019
FFFC16D2 00138393			add		$t2,$t2,#1
FFFC16D6 03006293			ldi		$t0,#'0'
FFFC16DA 20538023			stb		$t0,STRTMP[$t2]
FFFC16DE 00138393			add		$t2,$t2,#1
FFFC16E2 20038023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC16E6 000C9663			bne		$s9,$x0,.0020
FFFC16EA 20038023			stb		$x0,STRTMP[$t2]
FFFC16EE 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC16F2 04506293			ldi		$t0,#'E'
FFFC16F6 20538023			stb		$t0,STRTMP[$t2]
FFFC16FA 00138393			add		$t2,$t2,#1
FFFC16FE 000CDC63			bge		$s9,$x0,.0021
FFFC1702 02D06293			ldi		$t0,#'-'
FFFC1706 20538023			stb		$t0,STRTMP[$t2]
FFFC170A 00138393			add		$t2,$t2,#1
FFFC170E 41900CB3			sub		$s9,$x0,$s9			; exp = -exp
FFFC1712 00000863			bra		.0022
                        	.0021:
FFFC1716 02B06293			ldi		$t0,#'+'
FFFC171A 20538023			stb		$t0,STRTMP[$t2]
FFFC171E 00138393			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC1722 00006A13			ldi		$s4,#0
FFFC1726 3E806293			ldi		$t0,#1000
                        	.0025:
FFFC172A 005CD463			bge		$s9,$t0,.0023
FFFC172E 00000863			bra		.0024
                        	.0023:
FFFC1732 405C8CB3			sub		$s9,$s9,$t0
FFFC1736 001A0A13			add		$s4,$s4,#1
FFFC173A FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC173E 000A6B33			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC1742 000A1863			bne		$s4,$x0,.0026
FFFC1746 030A0293			add		$t0,$s4,#'0'
FFFC174A 20538023			stb		$t0,STRTMP[$t2]
FFFC174E 00138393			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC1752 00006A13			ldi		$s4,#0
FFFC1756 06406293			ldi		$t0,#100
                        	.0027:
FFFC175A 005CD463			bge		$s9,$t0,.0028
FFFC175E 00000863			bra		.0029
                        	.0028:
FFFC1762 405C8CB3			sub		$s9,$s9,$t0
FFFC1766 001A0A13			add		$s4,$s4,#1
FFFC176A FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC176E 000A6BB3			mov		$s7,$s4				; $s7 = d2
FFFC1772 000B1463			bne		$s6,$x0,.0030
FFFC1776 000A0863			beq		$s4,$x0,.0031
                        	.0030:
FFFC177A 030A0293			add		$t0,$s4,#'0'
FFFC177E 20538023			stb		$t0,STRTMP[$t2]
FFFC1782 00138393			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC1786 00006A13			ldi		$s4,#0
FFFC178A 00A06293			ldi		$t0,#10
                        	.0032:
FFFC178E 005CD463			bge		$s9,$t0,.0034
FFFC1792 00000863			bra		.0035
                        	.0034:
FFFC1796 405C8CB3			sub		$s9,$s9,$t0
FFFC179A 001A0A13			add		$s4,$s4,#1
FFFC179E FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC17A2 000A6C33			mov		$s8,$s4
FFFC17A6 000A1663			bne		$s4,$x0,.0036
FFFC17AA 000B1463			bne		$s6,$x0,.0036
FFFC17AE 000B8863			beq		$s7,$x0,.0037
                        	.0036:
FFFC17B2 030A0293			add		$t0,$s4,#'0'
FFFC17B6 20538023			stb		$t0,STRTMP[$t2]
FFFC17BA 00138393			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC17BE 00006A13			ldi		$s4,#0
FFFC17C2 00106293			ldi		$t0,#1
                        	.0038:
FFFC17C6 005CD463			bge		$s9,$t0,.0040
FFFC17CA 00000863			bra		.0039
                        	.0040:
FFFC17CE 405C8CB3			sub		$s9,$s9,$t0
FFFC17D2 001A0A13			add		$s4,$s4,#1
FFFC17D6 FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC17DA 030A0293			add		$t0,$s4,#'0'
FFFC17DE 20538023			sb		$t0,STRTMP[$t2]
FFFC17E2 00138393			add		$t2,$t2,#1
FFFC17E6 20038023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC17EA 0405C663			blt		$a1,$x0,.0041
FFFC17EE 04058463			beq		$a1,$x0,.0041
FFFC17F2 00B3C463			blt		$t2,$a1,.0042
FFFC17F6 04000063			bra		.0041
                        	.0042:
FFFC17FA 02706993			ldi		$s3,#39					; s3 = nn
FFFC17FE 407582B3			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC1802 0059D463			bge		$s3,$t0,.0043
FFFC1806 00000C63			bra		.0044
                        	.0043:
FFFC180A 40598B33			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC180E 20098303			ldb		$t1,STRTMP[$s3]
FFFC1812 206B0023			stb		$t1,STRTMP[$s6]
FFFC1816 FFF98993			sub		$s3,$s3,#1
FFFC181A FE0004E3			bra		.0045
                        	.0044:
FFFC181E 02006293			ldi		$t0,#' '
                        	.0048:
FFFC1822 0009D463			bge		$s3,$x0,.0046
FFFC1826 00000863			bra		.0047
                        	.0046:
FFFC182A 20598023			stb		$t0,STRTMP[$s3]
FFFC182E FFF98993			sub		$s3,$s3,#1
FFFC1832 FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC1836 0205D063			bge		$a1,$x0,.0050
FFFC183A 40B005B3			sub		$a1,$x0,$a1
FFFC183E 02006293			ldi		$t0,#' '
                        	.0052:
FFFC1842 00B3D863			bge		$t2,$a1,.0051
FFFC1846 20538023			stb		$t0,STRTMP[$t2]
FFFC184A 00138393			add		$t2,$t2,#1
FFFC184E FE000AE3			bra		.0052
                        	.0051:
FFFC1852 20038023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC1856 0003E533			mov		$a0,$t2
FFFC185A 00008067			ret
                        	
FFFC185E 6E490000			align	
                        	
                        	msgInf:
FFFC1860 00666E49			db	"Inf",0
                        	msgNan:
FFFC1864 006E614E			db	"Nan",0
                        	fltOne:
FFFC1868 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC186C 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC1870 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01Mem.r5a",1
                        	.file "cs01Mem.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "cs01Mem.r5a",25
                        			code	18 bits
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC1874 00000000		align	1
FFFC1878 00000000
FFFC187C 00000000
                        	
                        	MMUInit:
FFFC1880 1B806293		ldi		$t0,#MEMSZ-72  ; set number of available pages (72 pages already allocated)
FFFC1884 FF0008B7		stt		$t0,NPAGES
FFFC1888 30088893
FFFC188C 000888B3
FFFC1890 0058A023
                        	
                        		; satp register setting
FFFC1894 602002B7		ldi		$t0,#$60200100			; 32 maps of 256 entries, ASID = 0, custom MMU selected
FFFC1898 10028293
FFFC189C 18029073		csrrw	$x0,#CSR_SATP,$t0	  ; set ASID
                        	
                        		; Free all memory for all tasks
                        		; Sets all pages to map to page zero for all tasks, except for the system
                        		; tasks (task #28 to 31) which pre-allocates the first 16kB of memory.
FFFC18A0 00006293		ldi		$t0,#$00
FFFC18A4 03F06E93		ldi		$t4,#63					; app id
FFFC18A8 03406F13		ldi		$t5,#52
                        	.0004:
FFFC18AC 00006313		ldi		$t1,#$000				; regno
FFFC18B0 10006393		ldi		$t2,#256				; number of registers to update
FFFC18B4 10006E13		ldi		$t3,#256				; number of pages pre-allocated (OS maps)
                        	.0001:
FFFC18B8 010E9493		sll		$s1,$t4,#16			; put app id in place
FFFC18BC 0064E4B3		or		$s1,$s1,$t1			; or in page number
FFFC18C0 0292800D		mvmap	$x0,$t0,$s1
FFFC18C4 00128293		add		$t0,$t0,#$01
FFFC18C8 00130313		add		$t1,$t1,#$01		; increment page number
                        	;	beqz	$t4,.0008
FFFC18CC 01EEC463		blt   $t4,$t5,.0005
                        	.0008:
FFFC18D0 01C36463		bltu	$t1,$t3,.0003
                        	.0005:
FFFC18D4 000062B3		mov		$t0,$x0					; mark pages unallocated
                        	.0003:
FFFC18D8 FFF38393		sub		$t2,$t2,#1
FFFC18DC FC039EE3		bnez	$t2,.0001
FFFC18E0 FFFE8E93		sub		$t4,$t4,#1      ; next app id
FFFC18E4 FC0ED4E3		bge		$t4,$x0,.0004
                        	
                        		; allocate last 24 pages for system stacks
FFFC18E8 01806393		ldi		$t2,#24
FFFC18EC 0FF06313		ldi		$t1,#$FF				
FFFC18F0 1FF06293		ldi		$t0,#$1FF
                        	.0006:
FFFC18F4 0262800D		mvmap	$x0,$t0,$t1
FFFC18F8 FFF30313		sub		$t1,$t1,#1
FFFC18FC FFF28293		sub		$t0,$t0,#1
FFFC1900 FFF38393		sub		$t2,$t2,#1
FFFC1904 FE0398E3		bnez	$t2,.0006
                        	
                        		; Now setup segment registers
FFFC1908 00006293		ldi		$t0,#$0
FFFC190C 00706313		ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC1910 0053000D		mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC1914 00128293		add		$t0,$t0,#1			; pick next segment register
FFFC1918 1002A393		slt		$t2,$t0,#256		; 256 base regs
FFFC191C FE039AE3		bnez	$t2,.0002
FFFC1920 10006293		ldi		$t0,#256
FFFC1924 FFF06313		ldi		$t1,#-1					; t1 = value to load, bounds max
                        	.0007:
FFFC1928 0053000D		mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC192C 00128293		add		$t0,$t0,#1			; pick next segment register
FFFC1930 2002A393		slt		$t2,$t0,#512		; 256 bound regs
FFFC1934 FE039AE3		bnez	$t2,.0007
                        	
                        		; Now ensure all pages in PAM are marked as free or OS allocated
                        		; Cannot use stack until here, after segment regs and mem mapped.
FFFC1938 FFC10113		sub		$sp,$sp,#4
FFFC193C 00112023		stt		$ra,[$sp]
FFFC1940 650000EF		call  PAMInit
FFFC1944 00012083		ldt		$ra,[$sp]
FFFC1948 00410113		add		$sp,$sp,#4
FFFC194C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		a0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	FindRun:
FFFC1950 01F57E13		and			$t3,$a0,#$1F			; t3 = mid
FFFC1954 010E1E13		sll			$t3,$t3,#16				; shift into usable position
FFFC1958 00006313		ldi			$t1,#0						; t1 = count of consecutive empty buckets
FFFC195C 000E63B3		mov			$t2,$t3						; t2 = map entry number
FFFC1960 0303E393		or			$t2,$t2,#OSPAGES	; start looking at page 32 (others are for OS)
FFFC1964 1FF06F13		ldi			$t5,#511					; max number of pages - 1
FFFC1968 01CF6F33		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0001:
FFFC196C 0270050D		mvmap		$a0,$x0,$t2				; get map entry into v0
FFFC1970 00050A63		beq			$a0,$x0,.empty0		; is it empty?
FFFC1974 00138393		add			$t2,$t2,#1
FFFC1978 FFE3EAE3		bltu		$t2,$t5,.0001
                        	.0002:
FFFC197C FFF06513		ldi			$a0,#-1						; got here so no run was found
FFFC1980 00008067		ret
                        	.empty0:
FFFC1984 0003EE33		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC1988 FFE3FAE3		bgeu		$t2,$t5,.0002
FFFC198C 00130313		add			$t1,$t1,#1
FFFC1990 00B37C63		bgeu		$t1,$a1,.foundEnough
FFFC1994 00138393		add			$t2,$t2,#1				; next bucket
FFFC1998 0270050D		mvmap		$a0,$x0,$t2				; get map entry
FFFC199C FE0506E3		beq			$a0,$x0,.empty1
FFFC19A0 00006333		mov			$t1,$x0						; reset counter
FFFC19A4 FC0004E3		bra			.0001							; go back and find another run
                        	.foundEnough:
FFFC19A8 000E6533		mov			$a0,$t3						; v0 = start of run
FFFC19AC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = mid
                        	;		$a1 = amount of memory to allocate
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		$a1 = pointer to allocated memory in virtual address space.
                        	;		$a0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	Alloc:
FFFC19B0 FE810113		sub			$sp,$sp,#24
FFFC19B4 00112023		stt			$ra,[$sp]
FFFC19B8 00912223		stt			$s1,4[$sp]			; these regs must be saved
FFFC19BC 01212423		stt			$s2,8[$sp]
FFFC19C0 01312823		stt			$s3,16[$sp]
FFFC19C4 01412A23		stt     $s4,20[$sp]
FFFC19C8 0C058863		beqz    $a1,.allocZero
                        		; First check if there are enough pages available in the system.
FFFC19CC 3FF58A13		add			$s4,$a1,#PAGESZ-1	; v0 = round memory request
FFFC19D0 00AA5A13		srl			$s4,$s4,#LOG_PGSZ	; v0 = convert to pages required
FFFC19D4 FF0008B7		ldt			$t0,NPAGES				; check number of pages available
FFFC19D8 30088893
FFFC19DC 000888B3
FFFC19E0 0008A283
FFFC19E4 0142F663		bleu		$s4,$t0,.enough
                        	.noRun2:
FFFC19E8 00006593		ldi			$a1,#0						; not enough, return null
FFFC19EC 08000663		bra			.noRun
                        	.enough:
FFFC19F0 000564B3		mov			$s1,$a0
                        		; There are enough pages, but is there a run long enough in map space?
FFFC19F4 000A6933		mov			$s2,$s4				    ; save required # pages
FFFC19F8 000A65B3		mov			$a1,$s4
FFFC19FC F55FF0EF		call		FindRun						; find a run of available slots
FFFC1A00 FE0544E3		bltz		$a0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC1A04 000564B3		mov			$s1,$a0						; s1 = start of run
FFFC1A08 FF0008B7		ldt			$s3,NPAGES				; decrease number of pages available in system
FFFC1A0C 30088893
FFFC1A10 000888B3
FFFC1A14 0008A983
FFFC1A18 412989B3		sub			$s3,$s3,$s2
FFFC1A1C FF0008B7		stt			$s3,NPAGES
FFFC1A20 30088893
FFFC1A24 000888B3
FFFC1A28 0138A023
FFFC1A2C 000569B3		mov			$s3,$a0						; s3 = start of run
                        	.0001:
FFFC1A30 470000EF	  call    PAMMarkPage       ; allocates a page
                        	;	palloc	$v0								; allocate a page (cheat and use hardware)
                        		;call		AllocPage
FFFC1A34 04050263		beqz		$a0,.noRun        ; shouldn't get an error here
FFFC1A38 0335000D		mvmap		$x0,$a0,$s3				; map the page
FFFC1A3C 00198993		add			$s3,$s3,#1				; next bucket
FFFC1A40 FFF90913		sub			$s2,$s2,#1
FFFC1A44 FE0916E3		bnez		$s2,.0001
FFFC1A48 000108B7		and     $a1,$s1,#$FFFF    ; strip out ASID
FFFC1A4C FFF88893
FFFC1A50 0114F5B3
FFFC1A54 00A59593		sll			$a1,$a1,#LOG_PGSZ	; $a1 = virtual address of allocated mem.
FFFC1A58 00C12483		ldt     $s1,12[$sp]
                        		; Clear the allocated memory
FFFC1A5C 0005EA33	  mov     $s4,$a1
                        	.zm:
FFFC1A60 000A2023	  stt     $x0,[$s4]
FFFC1A64 004A0A13	  add     $s4,$s4,#4
FFFC1A68 FFC48493	  sub     $s1,$s1,#4
FFFC1A6C FE04DAE3	  bge     $s1,$x0,.zm	
FFFC1A70 00006513		ldi			$a0,#E_Ok
FFFC1A74 00000463		bra			.xit
                        	.noRun:
FFFC1A78 00906513		ldi			$a0,#E_NotAlloc
                        	.xit
FFFC1A7C 00012083		ldt			$ra,[$sp]
FFFC1A80 00412483		ldt			$s1,4[$sp]			; restore regs
FFFC1A84 00812903		ldt			$s2,8[$sp]
FFFC1A88 01012983		ldt			$s3,16[$sp]
FFFC1A8C 01412A03		ldt     $s4,20[$sp]
FFFC1A90 01810113		add			$sp,$sp,#24
FFFC1A94 00008067		ret
                        	.allocZero:
FFFC1A98 00006593	  ldi     $a1,#0
FFFC1A9C 00006513		ldi			$a0,#E_Ok
FFFC1AA0 FC000EE3	  bra     .xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a task. The stack is located at the highest
                        	; virtual address ($7FC00).
                        	;
                        	; Parameters:
                        	;		$a0 = mid to allocate for
                        	;	Returns:
                        	;		$a0 = physical address, 0 if unsuccessful
                        	;		$a1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
FFFC1AA4 00000000		align 	1
FFFC1AA8 00000000
FFFC1AAC 00000000
                        	
                        	AllocStack:
FFFC1AB0 FF410113	  sub   	$sp,$sp,#12
FFFC1AB4 00112023	  stt     $ra,[$sp]
FFFC1AB8 00912223	  stt     $s1,4[$sp]
FFFC1ABC 01212423	  stt     $s2,8[$sp]
FFFC1AC0 00056933	  mov     $s2,$a0
FFFC1AC4 01051493		sll			$s1,$a0,#16			; 
FFFC1AC8 1FF4E493		or			$s1,$s1,#511		; last page of memory is for stack
FFFC1ACC 0290050D		mvmap		$a0,$x0,$s1			; check if stack already allocated
FFFC1AD0 02051063		bnez		$a0,.0001
FFFC1AD4 FE912E23		stt     $s1,-4[$sp]
FFFC1AD8 FFC10113	  sub     $sp,$sp,#4
FFFC1ADC 3C4000EF		call    PAMMarkPage
FFFC1AE0 00410113	  add     $sp,$sp,#4
FFFC1AE4 FFC12483		ldt     $s1,-4[$sp]
                        	;	palloc	$v0							; allocate a page
FFFC1AE8 02050063		beqz		$a0,.xit		    ; success?
FFFC1AEC 0295000D		mvmap		$x0,$a0,$s1
                        	.0001:
FFFC1AF0 1FF4F493		and			$s1,$s1,#511
FFFC1AF4 00A51513		sll			$a0,$a0,#LOG_PGSZ			; convert pages to addresses
FFFC1AF8 00A49493		sll			$s1,$s1,#LOG_PGSZ
                        	;	beqz    $s2,.xit
FFFC1AFC A00008B7		or      $a1,$s1,#$A0000000    ; set stack segment
FFFC1B00 00088893
FFFC1B04 0114E5B3
                        	.xit:
FFFC1B08 00012083	  ldt     $ra,[$sp]
FFFC1B0C 00412483	  ldt     $s1,4[$sp]
FFFC1B10 00812903	  ldt     $s2,8[$sp]
FFFC1B14 00C10113	  add     $sp,$sp,#12
FFFC1B18 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a task including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		$a0 = mid to free memory for
                        	;	Modifies:
                        	;		a0,t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
FFFC1B1C 00000000		align		1
                        	
                        	FreeAll:
FFFC1B20 FFC10113	  sub   	$sp,$sp,#4
FFFC1B24 00112023	  stt     $ra,[$sp]
FFFC1B28 00006E13		ldi			$t3,#0
FFFC1B2C 01051E93		sll			$t4,$a0,#16
                        	.nxt:
FFFC1B30 200E2313		slt			$t1,$t3,#512		; number of buckets to check
FFFC1B34 04030863		beqz		$t1,.0001
FFFC1B38 001F08B7		and			$t4,$t4,#$1F0000
FFFC1B3C 00088893
FFFC1B40 011EFEB3
FFFC1B44 01CEEEB3		or			$t4,$t4,$t3			; combine pid and bucket number
FFFC1B48 00006513		ldi			$a0,#0					; new page number to set (indicates free)
FFFC1B4C 03D5050D		mvmap		$a0,$a0,$t4			; get page mapping and set to zero
FFFC1B50 001E0E13		add			$t3,$t3,#1			; advance to next bucket
FFFC1B54 FC050EE3		beqz		$a0,.nxt				; 0 = no map in this bucket
FFFC1B58 398000EF		call    PAMUnmarkPage
                        	;	pfree		$t0							; free the page
FFFC1B5C FF0008B7		ldt			$t0,NPAGES			; update the number of available pages
FFFC1B60 30088893
FFFC1B64 000888B3
FFFC1B68 0008A283
FFFC1B6C 00128293		add			$t0,$t0,#1
FFFC1B70 FF0008B7		stt			$t0,NPAGES
FFFC1B74 30088893
FFFC1B78 000888B3
FFFC1B7C 0058A023
FFFC1B80 FA0008E3		bra			.nxt
                        	.0001:
FFFC1B84 00012083	  ldt     $ra,[$sp]
FFFC1B88 00410113	  add     $sp,$sp,#4
FFFC1B8C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a linear one.
                        	;
                        	; Parameters:
                        	;		$a0 = virtual address to convert
                        	; Modifies:
                        	;		$a1,$t0
                        	; Returns:
                        	;		$a0 = linear address
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	VirtToLinear:
FFFC1B90 01C55593		srl   $a1,$a0,#28         ; get segment register of address
FFFC1B94 00B0058D		mvseg $a1,$x0,$a1         ; get segment register value
FFFC1B98 FF05F593		and   $a1,$a1,#$FFFFFFF0  ; mask off acr bits
FFFC1B9C 00659593		sll   $a1,$a1,#6          ; shift into position
FFFC1BA0 100008B7		and   $t0,$a0,#$0FFFFFFF  ; mask off segment
FFFC1BA4 FFF88893
FFFC1BA8 011572B3
FFFC1BAC 00558533		add   $a0,$a1,$t0         ; v0 = linear address (segment base + address)
FFFC1BB0 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a linear one.
                        	;
                        	; Parameters:
                        	;   $a0 = tid
                        	;		$a1 = virtual address to convert
                        	; Modifies:
                        	;		$v1
                        	; Returns:
                        	;		$v0 = linear address
                        	;------------------------------------------------------------------------------
                        	
                        	;VirtToLinear2:
                        	;	srl   $v0,$a1,#28         ; get base register selector of address
                        	;	sll   $v0,$v0,#2          ; convert to index
                        	;	sll   $v1,$a0,#2
                        	;	ldt   $v1,TidTcbMap[$v1]  ; $v1 = pointer to TCB
                        	;	add   $v0,$v0,$v1
                        	;	ldt   $v1,TCBbases[$v0]   ; $v1 = base register value
                        	;	and   $v0,$v1,#$FFFFFFF0  ; mask off acr bits
                        	;	sll   $v0,$v0,#6          ; shift into position
                        	;	and   $v1,$a1,#$0FFFFFFF  ; mask off base selector
                        	;	add   $v0,$v1,$v0         ; v0 = linear address (base + address)
                        	;  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		$a0 = virtual address to convert
                        	; Modifies:
                        	;		$t0, $t1
                        	; Returns:
                        	;		$a0 = physical address
                        	;------------------------------------------------------------------------------
FFFC1BB4 00000000		align	1
FFFC1BB8 00000000
FFFC1BBC 00000000
                        	
                        	VirtToPhys:
FFFC1BC0 FF810113		sub 	$sp,$sp,#8
FFFC1BC4 00112023		stt   $ra,[$sp]
FFFC1BC8 00912223		stt   $s1,4[$sp]
FFFC1BCC 000564B3		mov   $s1,$a0
FFFC1BD0 FC1FF0EF		call  VirtToLinear
FFFC1BD4 02054263		bltz	$a0,.notMapped
FFFC1BD8 00A55293		srl		$t0,$a0,#LOG_PGSZ		; convert virt to page
                        		
FFFC1BDC 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC1BE0 01051513	sll		$a0,$a0,#16
FFFC1BE4 00556533		or		$a0,$a0,$t0					; and in tid
FFFC1BE8 02A0050D		mvmap	$a0,$x0,$a0					; get the translation
FFFC1BEC 00A51513		sll		$a0,$a0,#LOG_PGSZ		; convert page to address
FFFC1BF0 3FF4F293		and		$t0,$s1,#$3FF				; insert LSB's
FFFC1BF4 00556533		or		$a0,$a0,$t0
                        	.notMapped:
FFFC1BF8 00012083		ldt   $ra,[$sp]
FFFC1BFC 00412483		ldt   $s1,4[$sp]
FFFC1C00 00810113		add   $sp,$sp,#8
FFFC1C04 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; VirtToPhys2:
                        	;   Used by the OS to convert virtual to physcial addresses.
                        	; Convert a virtual address to a physical one. Slightly tricky as linear
                        	; addresses are associated with the TID while paged addresses are associated
                        	; with the MID of the task.
                        	;
                        	; Parameters:
                        	;   $a0 = tid
                        	;		$a1 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		$v0 = physical address
                        	;------------------------------------------------------------------------------
FFFC1C08 00000000		align	1
FFFC1C0C 00000000
                        	
                        	VirtToPhys2:
FFFC1C10 FFC10113		sub 	$sp,$sp,#4
FFFC1C14 00112023		stt   $ra,[$sp]
                        	;	call  VirtToLinear2
                        	;	bltz	$v0,.notMapped
                        	;	srl		$t0,$v0,#LOG_PGSZ		; convert virt to page
                        	;	sll   $v1,$a0,#2
                        	;	ldt   $v1,TidTcbMap[$v1]  ; $v1 = pointer to TCB
                        	;	ldbu  $v1,TCBmid[$v1]     ; $v1 = mid
                        	;	sll		$v0,$v1,#16         ; set map id field
                        	;	or		$v0,$v0,$t0					; and in tid
                        	;	mvmap	$v0,$x0,$v0					; get the translation
                        	;	sll		$v0,$v0,#LOG_PGSZ		; convert page to address
                        	;	and		$t0,$a0,#$3FF				; insert LSB's
                        	;	or		$v0,$v0,$t0
                        	.notMapped:
FFFC1C18 00012083		ldt   $ra,[$sp]
FFFC1C1C 00410113		add   $sp,$sp,#4
FFFC1C20 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC1C24 00000000		align	1
FFFC1C28 00000000
FFFC1C2C 00000000
                        	
                        	FetchMemoryWord:
FFFC1C30 0005A583	  ldt   $a1,[$a1]
FFFC1C34 00006513	  ldi   $a0,#E_Ok
FFFC1C38 0390106F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC1C3C 00000000		align	1
                        	
                        	FMTK_Alloc:
FFFC1C40 0005E533		mov		$a0,$a1
FFFC1C44 000665B3		mov		$a1,$a2
FFFC1C48 D69FF0EF		call	Alloc
FFFC1C4C 0250106F		jmp		OSExit
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01PAM.r5a",1
                        	.file "cs01PAM.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	; PAM
                        	; 0 = unallocated
                        	; 1 = reserved
                        	; 2 = end of run of pages
                        	; 3 = allocated
                        	;------------------------------------------------------------------------------
                        	
                        	;------------------------------------------------------------------------------
                        	; PAMFindRun
                        	;    Find a run of unallocated pages.
                        	;
                        	; Parameters:
                        	;   $a0 = number of consecutive pages required
                        	; Returns:
                        	;   $a0 = page starting run, -1 if not enough memory
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	PAMFindRun:
FFFC1C50 FEC10113	  sub 	$sp,$sp,#20
FFFC1C54 00112023	  stt   $ra,[$sp]
FFFC1C58 00912223	  stt   $s1,4[$sp]
FFFC1C5C 01212423	  stt   $s2,8[$sp]
FFFC1C60 01312623	  stt   $s3,12[$sp]
FFFC1C64 01412823	  stt   $s4,16[$sp]
FFFC1C68 000564B3	  mov   $s1,$a0             ; save argument value
FFFC1C6C 03006513	  ldi   $a0,#OSPAGES
                        	.nextPage:
FFFC1C70 00056A33	  mov   $s4,$a0
                        	
                        	;  call  PAMGetbitPair
FFFC1C74 00455393	  srl   $t2,$a0,#4          ; $t2 = word, bit pair num/16
FFFC1C78 00239393	  sll   $t2,$t2,#2          ; $t2 = word index, 4 bytes per word
FFFC1C7C 00F57E13	  and   $t3,$a0,#15         ; $t3 = bit pair num in word = 0 to 15
FFFC1C80 001E1E13	  sll   $t3,$t3,#1          ; $t3 = bit pair index
FFFC1C84 FF0018B7		ldt		$t0,PAM[$t2]        ; get word
FFFC1C88 00088893
FFFC1C8C 007888B3
FFFC1C90 0008A283
FFFC1C94 01C2D3B3		srl   $t2,$t0,$t3         ; extract bits
FFFC1C98 0033F513		and   $a0,$t2,#3          ; return 0,1,2, or 3
                        	
FFFC1C9C 04051C63	  bnez  $a0,.notAvailable
FFFC1CA0 000A69B3	  mov   $s3,$s4             ; remember start of run
FFFC1CA4 0004E933	  mov   $s2,$s1             ; $s2 = run length
                        	.runInc:
FFFC1CA8 FFF90913	  sub   $s2,$s2,#1
FFFC1CAC 04090E63	  beqz  $s2,.foundRun
FFFC1CB0 001A0513	  add   $a0,$s4,#1          ; increment run start
FFFC1CB4 20052313	  slt   $t1,$a0,#MEMSZ
FFFC1CB8 04030463	  beqz  $t1,.outOfMem
FFFC1CBC 00056A33	  mov   $s4,$a0             ; remember $a0
                        	
                        	;  call  PAMGetbitPair
FFFC1CC0 00455393	  srl   $t2,$a0,#4          ; $t2 = word, bit pair num/16
FFFC1CC4 00239393	  sll   $t2,$t2,#2          ; $t2 = word index, 4 bytes per word
FFFC1CC8 00F57E13	  and   $t3,$a0,#15         ; $t3 = bit pair num in word = 0 to 15
FFFC1CCC 001E1E13	  sll   $t3,$t3,#1          ; $t3 = bit pair index
FFFC1CD0 FF0018B7		ldt		$t0,PAM[$t2]        ; get word
FFFC1CD4 00088893
FFFC1CD8 007888B3
FFFC1CDC 0008A283
FFFC1CE0 01C2D3B3		srl   $t2,$t0,$t3         ; extract bits
FFFC1CE4 0033F513		and   $a0,$t2,#3          ; return 0,1,2, or 3
                        	
FFFC1CE8 FC0500E3	  beqz  $a0,.runInc
FFFC1CEC 00198513	  add   $a0,$s3,#1          ; increment run start pos
FFFC1CF0 F80000E3	  bra   .nextPage
                        	.notAvailable:
                        	;	add		$a3,$a0,#'0'
                        	;	call	SerialPutChar
                        	;	stt		$s4,$4030
FFFC1CF4 001A0513	  add   $a0,$s4,#1
FFFC1CF8 20052313	  slt   $t1,$a0,#MEMSZ
FFFC1CFC F6031AE3	  bnez  $t1,.nextPage
                        	.outOfMem:
FFFC1D00 FFF06513	  ldi   $a0,#-1
FFFC1D04 00000463	  bra   .xit
                        	.foundRun:
FFFC1D08 0009E533	  mov   $a0,$s3
                        	.xit:
FFFC1D0C 42038013		di		#7
FFFC1D10 00012083	  ldt   $ra,[$sp]
FFFC1D14 00412483	  ldt   $s1,4[$sp]
FFFC1D18 00812903	  ldt   $s2,8[$sp]
FFFC1D1C 00C12983	  ldt   $s3,12[$sp]
FFFC1D20 01012A03	  ldt   $s4,16[$sp]
FFFC1D24 01410113	  add   $sp,$sp,#20
FFFC1D28 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of pages and mark them all allocated.
                        	;
                        	; Parameters:
                        	;   $a0 = amount of memory to allocate
                        	; Returns:
                        	;   $a0 = pointer to memory, -1 if insufficient memory
                        	;------------------------------------------------------------------------------
FFFC1D2C 00000000		align	1
                        	
                        	PAMAlloc:
FFFC1D30 FF010113	  sub 	$sp,$sp,#16
FFFC1D34 00112023	  stt   $ra,[$sp]
FFFC1D38 00912223	  stt   $s1,4[$sp]
FFFC1D3C 01412423	  stt   $s4,8[$sp]
FFFC1D40 01512623	  stt   $s5,12[$sp]
FFFC1D44 08050463	  beqz  $a0,.outOfMem       ; request sensible?
FFFC1D48 3FF50293	  add   $t0,$a0,#PAGESZ-1   ; round allocation up
FFFC1D4C 00A2D513	  srl   $a0,$t0,#LOG_PGSZ   ; convert size to pages
FFFC1D50 00056A33	  mov   $s4,$a0             ; $s4 = length of run in pages
FFFC1D54 FF0008B7	  ldt   $t0,NPAGES          ; check number of pages of memory available
FFFC1D58 30088893
FFFC1D5C 000888B3
FFFC1D60 0008A283
FFFC1D64 40A282B3	  sub   $t0,$t0,$a0
FFFC1D68 0602C263	  bltz  $t0,.outOfMem
FFFC1D6C FF0008B7	  stt   $t0,NPAGES          ; update the number of available pages
FFFC1D70 30088893
FFFC1D74 000888B3
FFFC1D78 0058A023
FFFC1D7C ED5FF0EF	  call  PAMFindRun
FFFC1D80 04054A63	  bltz  $a0,.xit2
FFFC1D84 000564B3	  mov   $s1,$a0
FFFC1D88 000566B3	  mov   $a3,$a0
FFFC1D8C 00056AB3	  mov   $s5,$a0             ; $s5 = start of run
                        	.markNext:
FFFC1D90 0006E533	  mov   $a0,$a3
FFFC1D94 002A2593	  slt   $a1,$s4,#2          ; if $s4 <= 1
FFFC1D98 0035C593	  xor   $a1,$a1,#3          ; $a1 = 3, 2 if end of run
FFFC1D9C 174000EF	  call  PAMSetbitPair
FFFC1DA0 00168693	  add   $a3,$a3,#1          ; increment page number
FFFC1DA4 FFFA0A13	  sub   $s4,$s4,#1          ; decrement length
FFFC1DA8 FF4044E3	  bgtz  $s4,.markNext
FFFC1DAC 00AA9513	  sll   $a0,$s5,#LOG_PGSZ   ; $a0 = physical address of page
                        	.xit:
FFFC1DB0 42030013		di		#6
FFFC1DB4 00012083	  ldt   $ra,[$sp]
FFFC1DB8 00412483	  ldt   $s1,4[$sp]
FFFC1DBC 00812A03	  ldt   $s4,8[$sp]
FFFC1DC0 00C12A83	  ldt   $s5,12[$sp]
FFFC1DC4 01010113	  add   $sp,$sp,#16
FFFC1DC8 00008067	  ret
                        	.outOfMem:
FFFC1DCC FFF06513	  ldi   $a0,#-1
FFFC1DD0 FE0000E3	  bra   .xit
                        	  ; Failed to find a run so,
                        	  ; restore number of pages available
                        	.xit2:
FFFC1DD4 FF0008B7		ldt		$t0,NPAGES
FFFC1DD8 30088893
FFFC1DDC 000888B3
FFFC1DE0 0008A283
FFFC1DE4 014282B3		add		$t0,$t0,$s4
FFFC1DE8 FF0008B7		stt		$t0,NPAGES
FFFC1DEC 30088893
FFFC1DF0 000888B3
FFFC1DF4 0058A023
FFFC1DF8 FA000CE3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Free memory previously allocated with PAMAlloc.
                        	;
                        	; Parameters:
                        	;   $a0 = pointer to start of memory
                        	; Modifies:
                        	;   $a0,$t0,$t1,$t2,$t3,$t4
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
FFFC1DFC 00000000		align	1
                        	
                        	PAMFree:
FFFC1E00 FF410113	  sub   	$sp,$sp,#12
FFFC1E04 00112023	  stt     $ra,[$sp]
FFFC1E08 00912223	  stt     $s1,4[$sp]
FFFC1E0C 000564B3	  mov     $s1,$a0
FFFC1E10 FFF808B7	  and     $a0,$a0,#$FFF803FF  ; check page 1kB aligned
FFFC1E14 3FF88893
FFFC1E18 01157533
FFFC1E1C 06051663	  bnez    $a0,.xit
FFFC1E20 00A4D513	  srl     $a0,$s1,#LOG_PGSZ   ; convert to page number
FFFC1E24 00106E93	  ldi     $t4,#1
                        	.nextPage:
FFFC1E28 000564B3	  mov     $s1,$a0
FFFC1E2C 134000EF	  call    PAMGetbitPair
FFFC1E30 02050A63	  beqz    $a0,.endOfRun
FFFC1E34 00352513	  slt     $a0,$a0,#3
FFFC1E38 00051E63	  bnez    $a0,.lastPage
FFFC1E3C 0004E533	  mov     $a0,$s1
FFFC1E40 00006593	  ldi     $a1,#0
FFFC1E44 0CC000EF	  call    PAMSetbitPair
FFFC1E48 00150493	  add     $s1,$a0,#1
FFFC1E4C 001E8E93	  add     $t4,$t4,#1
FFFC1E50 FC000CE3	  bra     .nextPage  
                        	.lastPage:
FFFC1E54 0004E533	  mov     $a0,$s1
FFFC1E58 00006593	  ldi     $a1,#0
FFFC1E5C 0B4000EF	  call    PAMSetbitPair
FFFC1E60 001E8E93	  add     $t4,$t4,#1
                        	.endOfRun:
FFFC1E64 FF0008B7	  ldt     $a1,NPAGES
FFFC1E68 30088893
FFFC1E6C 000888B3
FFFC1E70 0008A583
FFFC1E74 01D585B3	  add     $a1,$a1,$t4
FFFC1E78 FF0008B7	  stt     $a1,NPAGES
FFFC1E7C 30088893
FFFC1E80 000888B3
FFFC1E84 00B8A023
                        	.xit:
FFFC1E88 00012083	  ldt     $ra,[$sp]
FFFC1E8C 00412483	  ldt     $s1,4[$sp]
FFFC1E90 00C10113	  add     $sp,$sp,#12
FFFC1E94 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a single page of memory. Available memory is indicated by a bitmmap
                        	; called the PAM for page allocation map.
                        	;
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	; Returns:
                        	;		$a0 = page allocated
                        	;------------------------------------------------------------------------------
FFFC1E98 00000000		align	1
FFFC1E9C 00000000
                        	
                        	PAMMarkPage:
FFFC1EA0 FF810113		sub		$sp,$sp,#8
FFFC1EA4 00112023		stt		$ra,[$sp]
FFFC1EA8 00912223		stt   $s1,4[$sp]
FFFC1EAC 03006513		ldi   $a0,#OSPAGES
FFFC1EB0 000564B3	  mov   $s1,$a0
                        	.0001:
FFFC1EB4 0004E533	  mov   $a0,$s1
FFFC1EB8 0A8000EF		call  PAMGetbitPair
FFFC1EBC 00050C63		beqz  $a0,.gotFree
FFFC1EC0 00148493		add   $s1,$s1,#1
FFFC1EC4 2004A293		slt   $t0,$s1,#MEMSZ
FFFC1EC8 FE0296E3		bnez  $t0,.0001
FFFC1ECC 00006513		ldi   $a0,#0
FFFC1ED0 00000863		bra   .xit
                        	.gotFree:
FFFC1ED4 0004E533	  mov   $a0,$s1
FFFC1ED8 00206593	  ldi   $a1,#2          ; end of run bits
FFFC1EDC 034000EF	  call  PAMSetbitPair
                        	.xit:
FFFC1EE0 00012083		ldt		$ra,[$sp]
FFFC1EE4 00412483		ldt   $s1,4[$sp]
FFFC1EE8 00810113		add		$sp,$sp,#8
FFFC1EEC 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = page number to free
                        	; Modifies:
                        	;		$a1,$t0,$t1,$t2,$t3
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	PAMUnmarkPage:
FFFC1EF0 1FF06393		ldi		$t2,#MEMSZ-1  			; last page is permanently allocated to system stack
FFFC1EF4 06757063		bgeu	$a0,$t2,PAMxit
FFFC1EF8 03006393		ldi		$t2,#OSPAGES
FFFC1EFC 04756C63		bltu	$a0,$t2,PAMxit			; first 64 pages (64kB) allocated permanently to system
FFFC1F00 00006593		ldi   $a1,#0
FFFC1F04 00000663		bra		PAMSetbitPair
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = bit number to set
                        	;   $a1 = value to set 0,1,2 or 3
                        	; Does not modify:
                        	;   $a0, $a1
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	;------------------------------------------------------------------------------
FFFC1F08 00000000		align 1
FFFC1F0C 00000000
                        	
                        	PAMSetbitPair:
FFFC1F10 00455393	  srl   $t2,$a0,#4          ; t2 = word
FFFC1F14 00239393	  sll   $t2,$t2,#2          ; t2 = word index
FFFC1F18 00F57E13	  and   $t3,$a0,#15         ; t3 = bit pair no
FFFC1F1C 001E1E13	  sll   $t3,$t3,#1          ; t3 = bit pair index
FFFC1F20 00306293	  ldi   $t0,#3              ; make a bit mask
FFFC1F24 01C292B3	  sll   $t0,$t0,$t3
FFFC1F28 FFF2C293	  xor   $t0,$t0,#-1         ; get inverted mask
FFFC1F2C 01C595B3	  sll   $a1,$a1,$t3
FFFC1F30 FF0018B7	  add		$t2,$t2,#PAM
FFFC1F34 00088893
FFFC1F38 011383B3
FFFC1F3C 42028013	  di		#5
FFFC1F40 0003A303		ldt		$t1,[$t2]        		; get word
FFFC1F44 005372B3		and		$t0,$t1,$t0					; clear bit
FFFC1F48 00B2E2B3		or    $t0,$t0,$a1         ; set new bit status
FFFC1F4C 0053A023		stt		$t0,[$t2]        		; store word
FFFC1F50 01C5D5B3		srl   $a1,$a1,$t3         ; restore $a1
                        	PAMxit:
FFFC1F54 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = bit pair number to get
                        	; Modifies:
                        	;		$t0,$t2,$t3
                        	; Returns:
                        	;   $a0 = value of bit pair (0, 1, 2 or 3)
                        	;------------------------------------------------------------------------------
FFFC1F58 00000000		align	1
FFFC1F5C 00000000
                        	
                        	PAMGetbitPair:
FFFC1F60 00455393	  srl   $t2,$a0,#4          ; $t2 = word, bit pair num/16
FFFC1F64 00239393	  sll   $t2,$t2,#2          ; $t2 = word index, 4 bytes per word
FFFC1F68 00F57E13	  and   $t3,$a0,#15         ; $t3 = bit pair num in word = 0 to 15
FFFC1F6C 001E1E13	  sll   $t3,$t3,#1          ; $t3 = bit pair index
FFFC1F70 FF0018B7		ldt		$t0,PAM[$t2]        ; get word
FFFC1F74 00088893
FFFC1F78 007888B3
FFFC1F7C 0008A283
FFFC1F80 01C2D3B3		srl   $t2,$t0,$t3         ; extract bits
FFFC1F84 0033F513		and   $a0,$t2,#3          ; return 0,1,2, or 3
FFFC1F88 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC1F8C 00000000		align	1
                        	
                        	PAMInit:
FFFC1F90 FFC10113	  sub 	$sp,$sp,#4
FFFC1F94 00112023	  stt   $ra,[$sp]
                        	
                        		; Set number of pages available
                        		; = memory size - 72 pages for OS vars and stack
FFFC1F98 1B806293	  ldi		$t0,#MEMSZ-72
FFFC1F9C FF0008B7	  stt		$t0,NPAGES
FFFC1FA0 30088893
FFFC1FA4 000888B3
FFFC1FA8 0058A023
                        	
                        	  ; First zero out the entire PAM using word stores
FFFC1FAC 00006513	  ldi   $a0,#0
                        	.0002:
FFFC1FB0 FF0018B7	  stt   $x0,PAM[$a0]
FFFC1FB4 00088893
FFFC1FB8 00A888B3
FFFC1FBC 0008A023
FFFC1FC0 00450513	  add   $a0,$a0,#4
FFFC1FC4 08052293	  slt   $t0,$a0,#32*4   ; 1024 bits = 128 bytes
FFFC1FC8 FE0294E3	  bnez  $t0,.0002
                        	
                        	  ; Now set bits for preallocated memory pages
FFFC1FCC 02F06513	  ldi   $a0,#OSPAGES-1  ; OS pages
FFFC1FD0 00306593	  ldi   $a1,#3
                        	.0001:
FFFC1FD4 F3DFF0EF	  call  PAMSetbitPair
FFFC1FD8 FFF50513	  sub   $a0,$a0,#1
FFFC1FDC FE055CE3	  bge   $a0,$x0,.0001
FFFC1FE0 02F06513	  ldi   $a0,#47         ; Last OS page
FFFC1FE4 00206593	  ldi   $a1,#2          ; set mark end of run
FFFC1FE8 F29FF0EF	  call  PAMSetbitPair
FFFC1FEC 1E806513	  ldi   $a0,#MEMSZ-24   ; OS stack page
FFFC1FF0 01806413	  ldi		$s0,#24					; 24 pages to mark
                        	.0003:
FFFC1FF4 00306593	  ldi   $a1,#3          ; mid of run
FFFC1FF8 F19FF0EF	  call  PAMSetbitPair
FFFC1FFC 00150513		add		$a0,$a0,#1
FFFC2000 00206593	  ldi   $a1,#2          ; end of run
FFFC2004 F0DFF0EF	  call  PAMSetbitPair
FFFC2008 00150513		add		$a0,$a0,#1
FFFC200C FFE40413		sub		$s0,$s0,#2
FFFC2010 FE0412E3		bnez	$s0,.0003  
FFFC2014 00012083	  ldt   $ra,[$sp]
FFFC2018 00410113	  add   $sp,$sp,#4
FFFC201C 00008067	  ret
                        	
                        		align	16                        	
                        	GetPamBit:
FFFC2020 FFC10113		sub		$sp,$sp,#4
FFFC2024 00112023		stt		$ra,[$sp]
FFFC2028 0005E533	  mov   $a0,$a1
FFFC202C F35FF0EF	  call  PAMGetbitPair
FFFC2030 000565B3	  mov   $a1,$a0
FFFC2034 00006513	  ldi   $a0,#E_Ok
FFFC2038 00012083	  ldt		$ra,[$sp]
FFFC203C 00410113	  add		$sp,$sp,#4
FFFC2040 00008067	  ret
                        	
FFFC2044 00000000		align	1
FFFC2048 00000000
FFFC204C 00000000
                        	
                        	PAMDump:
FFFC2050 FFC10113		sub		$sp,$sp,#4
FFFC2054 00112023		stt		$ra,[$sp]
FFFC2058 00006493		ldi		$s1,#0
                        	.0001:
FFFC205C 0004E533		mov		$a0,$s1
FFFC2060 F01FF0EF		call	PAMGetbitPair
FFFC2064 03050513		add		$a0,$a0,#'0'
FFFC2068 C78FE0EF		call	Putch
FFFC206C 00148493		add		$s1,$s1,#1
FFFC2070 2004A313		slt		$t1,$s1,#MEMSZ
FFFC2074 FE0314E3		bnez	$t1,.0001
FFFC2078 00012083		ldt		$ra,[$sp]
FFFC207C 00410113		add		$sp,$sp,#4
FFFC2080 00008067		ret
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        	.file "../fmtk/serial.r5a",29
                        		code
FFFC2084 00000000		align	
                        	
                        	SerialFuncTbl:
FFFC2088 FFFC2260		dw		SerialNOP			; no operation
FFFC208C FFFC2170		dw		SerialSetup		; setup
FFFC2090 00000000		dw		0							; initialize
FFFC2094 00000000		dw		0							; status
FFFC2098 00000000		dw		0							; media check
FFFC209C 00000000		dw		0							; build BPB
FFFC20A0 00000000		dw		0							; open
FFFC20A4 00000000		dw		0							; close
FFFC20A8 FFFC2320		dw		SerialGetChar	; get char
FFFC20AC FFFC24E0		dw		SerialPeekChar
FFFC20B0 00000000		dw		0							; get char direct
FFFC20B4 FFFC25B0		dw		SerialPeekCharDirect	; peek char direct
FFFC20B8 00000000		dw		0							; input status
FFFC20BC FFFC2610		dw		SerialPutChar
FFFC20C0 00000000		dw		0							; reserved
FFFC20C4 00000000		dw		0							; set position
FFFC20C8 00000000		dw		0							; read block
FFFC20CC 00000000		dw		0							; write block
FFFC20D0 00000000		dw		0							; verify block
FFFC20D4 00000000		dw		0							; output status
FFFC20D8 00000000		dw		0							; flush input
FFFC20DC 00000000		dw		0							; flush output
FFFC20E0 FFFC2730		dw		SerialIRQ			; IRQ routine
FFFC20E4 00000000		dw		0							; Is removable
FFFC20E8 00000000		dw		0							; ioctrl read
FFFC20EC 00000000		dw		0							; ioctrl write
FFFC20F0 00000000		dw		0							; output until busy
FFFC20F4 FFFC2810		dw		SerialGetUI		; get ui flag
FFFC20F8 00000000		dw		0
FFFC20FC 00000000		dw		0
FFFC2100 00000000		dw		0
FFFC2104 00000000		dw		0							; 31
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	  align 8                        	
                        	SerialDCB:
FFFC2108 4D4F4304	  db    4,"COM1       "
FFFC210C 20202031
FFFC2110 20202020
FFFC2114 00000000	  dw    0     ; type
FFFC2118 00000000	  dw    0     ; nBPB
FFFC211C 00000000	  dw    0
FFFC2120 00000000	  dw    0     ; last error code
FFFC2124 00000000	  dw    0
                        	; 32
FFFC2128 00000000	  dw    0     ; starting block number
FFFC212C 00000000	  dw    0
FFFC2130 00000000	  dw    0     ; number of blocks
FFFC2134 00000000	  dw    0
FFFC2138 00000000	  dw    0     ; command processing routine
FFFC213C 00000000	  dw		0
FFFC2140 FFFC2730	  dw		SerialIRQ			; IRQ routine
FFFC2144 00000000	  dw    0
                        	;64
FFFC2148 00010000	  db    0     ; reentrancy count
FFFC2149 00000100	  db    0     ; single user flag
FFFC214A 00000001	  db    1     ; user interface device flag
FFFC214B 00000000	  db    0
FFFC214C 00000000	  dw    0
FFFC2150 00000000	  dw    0     ; hJob
FFFC2154 00000000	  dw    0
FFFC2158 00000000	  dw    0     ; Mailbox handle
FFFC215C 00000000	  dw    0
FFFC2160 00000000	  dw    0     ; pointer to device semaphore
FFFC2164 00000000	  dw    0
                        	; 96
                        	;  dw    0     ; reserved
                        	;  dw    0
                        	
FFFC2168 00000000		align	1
FFFC216C 00000000
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	SerialSetup:
FFFC2170 FFC10113		sub		$sp,$sp,#4
FFFC2174 00112023		stt		$ra,[$sp]
FFFC2178 00506513		ldi		$a0,#5							; serial device
FFFC217C FFFC25B7		ldi		$a1,#SerialFuncTbl
FFFC2180 08858593
FFFC2184 01C030EF		call	CopyDevFuncTbl
FFFC2188 00506513		ldi		$a0,#5							; serial device
FFFC218C FFFC25B7		ldi   $a1,#SerialDCB
FFFC2190 10858593
FFFC2194 03C030EF		call  CopyDevDCB
FFFC2198 018000EF		call	SerialInit
FFFC219C 00012083		ldt		$ra,[$sp]
FFFC21A0 00410113		add		$sp,$sp,#4
FFFC21A4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
FFFC21A8 00000000		align	1
FFFC21AC 00000000
                        	
                        	SerialInit:
FFFC21B0 FFC10113		sub		$sp,$sp,#4
FFFC21B4 00112023		stt		$ra,[$sp]
FFFC21B8 FF0028B7		stt		$x0,SerHeadRcv
FFFC21BC C0088893
FFFC21C0 000888B3
FFFC21C4 0008A023
FFFC21C8 FF0028B7		stt		$x0,SerTailRcv
FFFC21CC C0488893
FFFC21D0 000888B3
FFFC21D4 0008A023
FFFC21D8 FF0028B7		stt		$x0,SerHeadXmit
FFFC21DC C0888893
FFFC21E0 000888B3
FFFC21E4 0008A023
FFFC21E8 FF0028B7		stt		$x0,SerTailXmit
FFFC21EC C0C88893
FFFC21F0 000888B3
FFFC21F4 0008A023
FFFC21F8 FF0028B7		stb		$x0,SerRcvXon
FFFC21FC C1088893
FFFC2200 000888B3
FFFC2204 00088023
FFFC2208 FF0028B7		stb		$x0,SerRcvXoff
FFFC220C C1188893
FFFC2210 000888B3
FFFC2214 00088023
FFFC2218 00906293		ldi		$t0,#$09						; dtr,rts active, rxint enabled, no parity
FFFC221C FFDC18B7		stt		$t0,UART+8
FFFC2220 A0888893
FFFC2224 000888B3
FFFC2228 0058A023
FFFC222C 000602B7		ldi		$t0,#$0006001E			; reset the fifo's
FFFC2230 01E28293
FFFC2234 FFDC18B7		stt		$t0,UART+12
FFFC2238 A0C88893
FFFC223C 000888B3
FFFC2240 0058A023
FFFC2244 01E06293		ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC2248 FFDC18B7		stt		$t0,UART+12
FFFC224C A0C88893
FFFC2250 000888B3
FFFC2254 0058A023
FFFC2258 00012083		ldt		$ra,[$sp]
FFFC225C 00410113		add		$sp,$sp,#4
                        	SerialNOP:
FFFC2260 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialServiceInit:
FFFC2264 00106513		ldi		$a0,#1			; start task
FFFC2268 40006593		ldi		$a1,#1024		; memory required
FFFC226C FFFC2637		ldi		$a2,#SerialService
FFFC2270 27C60613
FFFC2274 00000073		ecall
FFFC2278 00008067		ret
                        	
                        	SerialService:
FFFC227C FD810113		sub		$sp,$sp,#40		; allocate stack for local vars
FFFC2280 00E06513		ldi		$a0,#14				; get current tid
FFFC2284 00000073		ecall
FFFC2288 00016633		mov		$a2,$sp				; where to put mailbox handle
FFFC228C 000565B3		mov		$a1,$a0				; a1 = tid
FFFC2290 00606513		ldi		$a0,#6				; alloc mailbox
FFFC2294 00000073		ecall
                        	
                        	SerialServiceLoop:
                        	.0001:
FFFC2298 00A06513		ldi		$a0,#10				; waitmsg
FFFC229C 00012583		lw		$a1,[$sp]			; mailbox handle
FFFC22A0 00410613		add		$a2,$sp,#4		; where to put D1
FFFC22A4 00810693		add		$a3,$sp,#8		; where to put D2
FFFC22A8 00C10713		add		$a4,$sp,#12		; where to put D3
FFFC22AC FFF06793		ldi		$a5,#-1				; timeout
FFFC22B0 00000073		ecall
FFFC22B4 FE0512E3		bnez	$a0,.0001			; E_Ok?
                        	
FFFC22B8 00412283		lw		$t0,4[$sp]
FFFC22BC 00812503		lw		$a0,8[$sp]
FFFC22C0 00C12583		lw		$a1,12[$sp]
FFFC22C4 01F2F293		and		$t0,$t0,#31		; command in bits 0 to 4 of D1
FFFC22C8 00129293		sll		$t0,$t0,#1
FFFC22CC FFFC28B7		lw		$t0,SerialFuncTbl[$t0]
FFFC22D0 08888893
FFFC22D4 005888B3
FFFC22D8 0008A283
FFFC22DC FA028EE3		beqz	$t0,.0001
FFFC22E0 00028067		jmp		[$t0]
                        	
                        	SerialFinishCmd:
FFFC22E4 00412583		lw		$a1,4[$sp]		; reply mbx handle in bits 8 to 23 of D1
FFFC22E8 0085D593		srl		$a1,$a1,#8
FFFC22EC 000108B7		and		$a1,$a1,#$FFFF
FFFC22F0 FFF88893
FFFC22F4 0115F5B3
FFFC22F8 00158593		add		$a1,$a1,#1		; -1 = no reply requested
FFFC22FC 00058E63		beqz	$a1,.0001
FFFC2300 FFF58593		sub		$a1,$a1,#1		; $a1 = mailbox handle again
FFFC2304 00906513		ldi		$a0,#9				; sendmsg
FFFC2308 FFF06613		ldi		$a2,#-1
FFFC230C FFF06693		ldi		$a3,#-1
FFFC2310 FFF06713		ldi		$a4,#-1
FFFC2314 00000073		ecall
                        	.0001:
FFFC2318 F81FF06F		jmp		SerialServiceLoop
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialGetChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. If the buffer is almost empty then send an
                        	; XON.
                        	;
                        	; Stack Space:
                        	;		4 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;		$a1 = character or -1
                        	;------------------------------------------------------------------------------
FFFC231C 00000000		align	1
                        	
                        	SerialGetChar:
FFFC2320 FF010113		sub		$sp,$sp,#16
FFFC2324 00112023		stt		$ra,[$sp]
FFFC2328 00912423		stt		$s1,8[$sp]          ; XON status
FFFC232C 01212623		stt   $s2,12[$sp]         ; interrupt state
FFFC2330 FF0028B7		ldb		$s1,SerRcvXon				; skip sending XON if already sent
FFFC2334 C1088893
FFFC2338 000888B3
FFFC233C 00088483
FFFC2340 421000EF		call	LockOS
FFFC2344 3AC000EF		call	SerialRcvCount			; check number of chars in receive buffer
FFFC2348 00852513		slt		$a0,$a0,#8					; less than 8?
FFFC234C 02050E63		beqz	$a0,.0002
FFFC2350 02049C63		bnez	$s1,.0002           ; XON already sent?
FFFC2354 01106513		ldi		$a0,#XON						; if <8 send an XON
FFFC2358 FF0028B7		stb		$x0,SerRcvXoff			; clear XOFF status
FFFC235C C1188893
FFFC2360 000888B3
FFFC2364 00088023
FFFC2368 FF0028B7		stb		$a0,SerRcvXon				; flag so we don't send it multiple times
FFFC236C C1088893
FFFC2370 000888B3
FFFC2374 00A88023
FFFC2378 FFDC18B7		stb		$a0,UART+UART_TRB
FFFC237C A0088893
FFFC2380 000888B3
FFFC2384 00A88023
                        	.0002:
FFFC2388 FF0028B7		ldbu	$a1,SerHeadRcv			; check if anything is in buffer
FFFC238C C0088893
FFFC2390 000888B3
FFFC2394 0008C583
FFFC2398 FF0028B7		ldbu	$a0,SerTailRcv
FFFC239C C0488893
FFFC23A0 000888B3
FFFC23A4 0008C503
FFFC23A8 02B50863		beq		$a0,$a1,.noChars		; no?
FFFC23AC FF0018B7		ldb		$a0,SerRcvBuf[$a1]	; get byte from buffer
FFFC23B0 40088893
FFFC23B4 00B888B3
FFFC23B8 00088503
FFFC23BC 00158593		add		$a1,$a1,#1					; update head index
FFFC23C0 0FF5F593		and   $a1,$a1,#255        ; ring buffer wrapping
FFFC23C4 FF0028B7		stb		$a1,SerHeadRcv
FFFC23C8 C0088893
FFFC23CC 000888B3
FFFC23D0 00B88023
FFFC23D4 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC23D8 FFF06513		ldi		$a0,#-1
                        	.xit:
FFFC23DC 000565B3	  mov   $a1,$a0
FFFC23E0 00006513	  ldi   $a0,#E_Ok
FFFC23E4 3BD000EF	  call	UnlockOS
                        	;	csrrc $x0,#$004,#1
FFFC23E8 00012083		ldt		$ra,[$sp]
FFFC23EC 00812483		ldt		$s1,8[$sp]
FFFC23F0 00C12903		ldt   $s2,12[$sp]
FFFC23F4 01010113		add		$sp,$sp,#16
FFFC23F8 00008067		ret
                        	
                        	SerialGetCharEx:
FFFC23FC FF010113		sub		$sp,$sp,#16
FFFC2400 00112023		stt		$ra,[$sp]
FFFC2404 00912423		stt		$s1,8[$sp]          ; XON status
FFFC2408 01212623		stt   $s2,12[$sp]         ; interrupt state
FFFC240C FF0028B7		ldb		$s1,SerRcvXon				; skip sending XON if already sent
FFFC2410 C1088893
FFFC2414 000888B3
FFFC2418 00088483
FFFC241C 2D4000EF		call	SerialRcvCount			; check number of chars in receive buffer
FFFC2420 00852513		slt		$a0,$a0,#8					; less than 8?
FFFC2424 02050E63		beqz	$a0,.0002
FFFC2428 02049C63		bnez	$s1,.0002           ; XON already sent?
FFFC242C 01106513		ldi		$a0,#XON						; if <8 send an XON
FFFC2430 FF0028B7		stb		$x0,SerRcvXoff			; clear XOFF status
FFFC2434 C1188893
FFFC2438 000888B3
FFFC243C 00088023
FFFC2440 FF0028B7		stb		$a0,SerRcvXon				; flag so we don't send it multiple times
FFFC2444 C1088893
FFFC2448 000888B3
FFFC244C 00A88023
FFFC2450 FFDC18B7		stb		$a0,UART+UART_TRB
FFFC2454 A0088893
FFFC2458 000888B3
FFFC245C 00A88023
                        	.0002:
FFFC2460 42010013		di		2	
FFFC2464 FF0028B7		ldbu	$a1,SerHeadRcv			; check if anything is in buffer
FFFC2468 C0088893
FFFC246C 000888B3
FFFC2470 0008C583
FFFC2474 FF0028B7		ldbu	$a0,SerTailRcv
FFFC2478 C0488893
FFFC247C 000888B3
FFFC2480 0008C503
FFFC2484 02B50863		beq		$a0,$a1,.noChars		; no?
FFFC2488 FF0018B7		ldb		$a0,SerRcvBuf[$a1]	; get byte from buffer
FFFC248C 40088893
FFFC2490 00B888B3
FFFC2494 00088503
FFFC2498 00158593		add		$a1,$a1,#1					; update head index
FFFC249C 0FF5F593		and   $a1,$a1,#255        ; ring buffer wrapping
FFFC24A0 FF0028B7		stb		$a1,SerHeadRcv
FFFC24A4 C0088893
FFFC24A8 000888B3
FFFC24AC 00B88023
FFFC24B0 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC24B4 FFF06513		ldi		$a0,#-1
                        	.xit:
FFFC24B8 000565B3	  mov   $a1,$a0
FFFC24BC 00006513	  ldi   $a0,#E_Ok
                        	;	csrrc $x0,#$004,#1
FFFC24C0 00012083		ldt		$ra,[$sp]
FFFC24C4 00812483		ldt		$s1,8[$sp]
FFFC24C8 00C12903		ldt   $s2,12[$sp]
FFFC24CC 01010113		add		$sp,$sp,#16
FFFC24D0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. But don't update the buffer indexes. No need
                        	; to send an XON here.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;		$a1 = character or -1
                        	;------------------------------------------------------------------------------
FFFC24D4 00000000		align	1
FFFC24D8 00000000
FFFC24DC 00000000
                        	
                        	SerialPeekChar:
FFFC24E0 FF810113		sub		$sp,$sp,#8
FFFC24E4 00112023		stt		$ra,[$sp]
FFFC24E8 00912223		stt		$s1,4[$sp]
FFFC24EC 275000EF		call	LockOS
FFFC24F0 FF0028B7		ldbu	$a1,SerHeadRcv			; check if anything is in buffer
FFFC24F4 C0088893
FFFC24F8 000888B3
FFFC24FC 0008C583
FFFC2500 FF0028B7		ldbu	$a0,SerTailRcv
FFFC2504 C0488893
FFFC2508 000888B3
FFFC250C 0008C503
FFFC2510 00B50C63		beq		$a0,$a1,.noChars		; no?
FFFC2514 FF0018B7		ldb		$a0,SerRcvBuf[$a1]	; get byte from buffer
FFFC2518 40088893
FFFC251C 00B888B3
FFFC2520 00088503
FFFC2524 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC2528 FFF06513		ldi		$a0,#-1
                        	.xit
FFFC252C 275000EF	  call	UnlockOS
FFFC2530 000565B3	  mov   $a1,$a0
FFFC2534 00006513	  ldi   $a0,#E_Ok
FFFC2538 00012083		ldt		$ra,[$sp]
FFFC253C 00412483		ldt		$s1,4[$sp]
FFFC2540 00810113		add		$sp,$sp,#8
FFFC2544 00008067		ret
                        	
                        	SerialPeekCharEx:
FFFC2548 FF810113		sub		$sp,$sp,#8
FFFC254C 00112023		stt		$ra,[$sp]
FFFC2550 00912223		stt		$s1,4[$sp]
FFFC2554 42010013		di		2
FFFC2558 FF0028B7		ldbu	$a1,SerHeadRcv			; check if anything is in buffer
FFFC255C C0088893
FFFC2560 000888B3
FFFC2564 0008C583
FFFC2568 FF0028B7		ldbu	$a0,SerTailRcv
FFFC256C C0488893
FFFC2570 000888B3
FFFC2574 0008C503
FFFC2578 00B50C63		beq		$a0,$a1,.noChars		; no?
FFFC257C FF0018B7		ldb		$a0,SerRcvBuf[$a1]	; get byte from buffer
FFFC2580 40088893
FFFC2584 00B888B3
FFFC2588 00088503
FFFC258C 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC2590 FFF06513		ldi		$a0,#-1
                        	.xit
FFFC2594 000565B3	  mov   $a1,$a0
FFFC2598 00006513	  ldi   $a0,#E_Ok
FFFC259C 00012083		ldt		$ra,[$sp]
FFFC25A0 00412483		ldt		$s1,4[$sp]
FFFC25A4 00810113		add		$sp,$sp,#8
FFFC25A8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;		Get a character directly from the I/O port. This bypasses the input
                        	; buffer.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   $v0 = E_Ok
                        	;		$v1 = character or -1
                        	;------------------------------------------------------------------------------
FFFC25AC 00000000		align	1
                        	
                        	SerialPeekCharDirect:
FFFC25B0 FF810113		sub		$sp,$sp,#8
FFFC25B4 00112023		stt		$ra,[$sp]
FFFC25B8 00912223		stt		$s1,4[$sp]
FFFC25BC 7C40F4F3		csrrc	$s1,#$7C4,#1				; disable interrupts
FFFC25C0 FFDC18B7		ldb		$a0,UART+UART_STAT
FFFC25C4 A0488893
FFFC25C8 000888B3
FFFC25CC 00088503
FFFC25D0 00857513		and		$a0,$a0,#8					; look for Rx not empty
FFFC25D4 00050C63		beqz	$a0,.0001
FFFC25D8 FFDC18B7		ldb		$a1,UART+UART_TRB
FFFC25DC A0088893
FFFC25E0 000888B3
FFFC25E4 00088583
FFFC25E8 00000463		bra		.xit
                        	.0001:
FFFC25EC FFF06593		ldi		$a1,#-1
                        	.xit:
FFFC25F0 00006513	  ldi   $a0,#E_Ok
FFFC25F4 7C449073		csrrw	$x0,#$7C4,$s1				; restore interrupts
FFFC25F8 0040E073		csrrs $x0,#$004,#1
FFFC25FC 00012083		ldt		$ra,[$sp]
FFFC2600 00412483		ldt		$s1,4[$sp]
FFFC2604 00810113		add		$sp,$sp,#8
FFFC2608 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty. The routine will attempt to transmit the char up to 
                        	; 10 times. If it still can't transmit the char then sleep is called and the
                        	; task is put to sleep for a tick. When it wakes up the routine continues to
                        	; try and send a character up to 10 times. If sleep has been called 10 times
                        	; and the character still has not made it to the transmit fifo, then an
                        	; error is flagged.
                        	;
                        	; Stack Space
                        	;		5 words
                        	; Parameters:
                        	;		$a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$a0 = character put
                        	; Side Effects:
                        	;		LastErc in DCB set to E_NoDev (no device) if transmit times out
                        	;------------------------------------------------------------------------------
FFFC260C 00000000		align	1
                        	
                        	SerialPutChar:
FFFC2610 FEC10113		sub		$sp,$sp,#20
FFFC2614 00112223		stt		$ra,4[$sp]
FFFC2618 00B12423		stt		$a1,8[$sp]
FFFC261C 00912623		stt		$s1,12[$sp]
FFFC2620 00D12823		stt		$a3,16[$sp]
FFFC2624 00A06493		ldi		$s1,#10
                        	.0003:
FFFC2628 FFDC1337		ldi		$t1,#UART
FFFC262C A0030313
FFFC2630 FFF48493		sub		$s1,$s1,#1
FFFC2634 04048E63		beqz	$s1,.noFunc
FFFC2638 00A06593		ldi		$a1,#10
FFFC263C 125000EF		call	LockOS
                        	.0001:
FFFC2640 FFF58593		sub		$a1,$a1,#1
FFFC2644 02058A63		beqz	$a1,.goSleep
                        	;	pfi												; poll for an interrupt here
FFFC2648 00430503		ldb		$a0,UART_STAT[$t1]	; wait until the uart indicates tx empty
FFFC264C 01057513		and		$a0,$a0,#16					; bit #4 of the status reg
FFFC2650 FE0508E3		beqz	$a0,.0001				    ; branch if transmitter is not empty
FFFC2654 00D30023		stb		$a3,UART_TRB[$t1]		; send the byte
FFFC2658 149000EF		call	UnlockOS
                        	.xit:
FFFC265C 00412083		ldt		$ra,4[$sp]
FFFC2660 00812583		ldt		$a1,8[$sp]
FFFC2664 00C12483		ldt		$s1,12[$sp]
FFFC2668 01012683		ldt		$a3,16[$sp]
FFFC266C 0006E533		mov		$a0,$a3
FFFC2670 01410113		add		$sp,$sp,#20
FFFC2674 00008067		ret
                        	.goSleep:
FFFC2678 129000EF		call	UnlockOS
FFFC267C 00306513		ldi		$a0,#3							; ISleep function
FFFC2680 00106593		ldi		$a1,#1							; 1 tick
FFFC2684 47D000EF		call  OSOCall							; this may trash registers
FFFC2688 01012683		ldt		$a3,16[$sp]
FFFC268C F8000EE3		bra		.0003
                        	.noFunc:
FFFC2690 FF810113		sub		$sp,$sp,#8
FFFC2694 00C12023		stt		$a2,[$sp]
FFFC2698 00E12223		stt		$a4,4[$sp]
FFFC269C 00406513		ldi		$a0,#4							; Set DCB field
FFFC26A0 00506593		ldi		$a1,#5							; $a1 = I/O channel
FFFC26A4 01806613		ldi		$a2,#$18						; LastErc
FFFC26A8 00006693		ldi		$a3,#0							; 0 = set word
FFFC26AC 02106713		ldi		$a4,#E_NoDev				; error code to set
FFFC26B0 451000EF		call	OSOCall
FFFC26B4 00012603		ldt		$a2,[$sp]
FFFC26B8 00412703		ldt		$a4,4[$sp]
FFFC26BC 00810113		add		$sp,$sp,#8
FFFC26C0 FFF06693		ldi		$a3,#-1							; flag EOF on error
FFFC26C4 F8000CE3		bra		.xit
                        	
FFFC26C8 00000000		align	1
FFFC26CC 00000000
                        	
                        	SerialPutCharEx:
FFFC26D0 FFDC12B7		ldi		$t0,#UART
FFFC26D4 A0028293
                        	.0001:
                        	;	pfi												; poll for an interrupt here
FFFC26D8 00428503		ldb		$a0,UART_STAT[$t0]	; wait until the uart indicates tx empty
FFFC26DC 01057513		and		$a0,$a0,#16					; bit #4 of the status reg
FFFC26E0 FE050CE3		beqz	$a0,.0001				    ; branch if transmitter is not empty
FFFC26E4 00D28023		stb		$a3,UART_TRB[$t0]		; send the byte
FFFC26E8 0006E533		mov		$a0,$a3
FFFC26EC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Calculate number of character in input buffer
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	SerialRcvCount:
FFFC26F0 42010013		di		2
FFFC26F4 FF0028B7		ldbu	$a0,SerTailRcv	; v0 = tail index
FFFC26F8 C0488893
FFFC26FC 000888B3
FFFC2700 0008C503
FFFC2704 FF0028B7		ldbu	$a1,SerHeadRcv	; v1 = head index
FFFC2708 C0088893
FFFC270C 000888B3
FFFC2710 0008C583
FFFC2714 40B502B3		sub		$t0,$a0,$a1
FFFC2718 0002D863		bge		$t0,$x0,.xit
FFFC271C 10006293		ldi		$t0,#256
FFFC2720 40B282B3		sub		$t0,$t0,$a1
FFFC2724 00A282B3		add		$t0,$t0,$a0
                        	.xit:
FFFC2728 0002E533		mov		$a0,$t0
FFFC272C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	SerialIRQ:
FFFC2730 FFC10113		sub		$sp,$sp,#4
FFFC2734 00112023		stt		$ra,[$sp]
FFFC2738 FFDC1337		ldi		$t1,#UART
FFFC273C A0030313
                        	.nxtByte:
FFFC2740 00432503		ldt		$a0,UART_STAT[$t1]	; check the status
FFFC2744 00857293		and		$t0,$a0,#$08				; bit 3 = rx full
FFFC2748 0A028C63		beqz	$t0,.notRxInt
FFFC274C 00032583		ldt		$a1,UART_TRB[$t1]		; get data from Rx buffer to clear interrupt
FFFC2750 0145C393		xor   $t2,$a1,#CTRLT
FFFC2754 00039863		bnez  $t2,.0001
FFFC2758 0005E4B3		mov   $s1,$a1
FFFC275C 0005E6B3		mov		$a3,$a1
                        	;	call	SerialPutcharEx
                        	;	call  DumpTraceQueue
FFFC2760 0004E5B3		mov   $a1,$s1
                        	.0001:
FFFC2764 FF0028B7		ldbu	$t2,SerHeadRcv			; get buffer indexes
FFFC2768 C0088893
FFFC276C 000888B3
FFFC2770 0008C383
FFFC2774 FF0028B7		ldbu	$t3,SerTailRcv
FFFC2778 C0488893
FFFC277C 000888B3
FFFC2780 0008CE03
FFFC2784 000E6EB3		mov   $t4,$t3
FFFC2788 001E0E13		add		$t3,$t3,#1					; see if buffer full
FFFC278C 0FFE7E13		and		$t3,$t3,#255
FFFC2790 07C38863		beq		$t2,$t3,.rxFull
FFFC2794 FF0028B7		stb		$t3,SerTailRcv			; update tail pointer
FFFC2798 C0488893
FFFC279C 000888B3
FFFC27A0 01C88023
FFFC27A4 FF0018B7		stb		$a1,SerRcvBuf[$t4]	; store recieved byte in buffer
FFFC27A8 40088893
FFFC27AC 01D888B3
FFFC27B0 00B88023
FFFC27B4 FF0028B7		ldb		$a0,SerRcvXoff			; check if xoff already sent
FFFC27B8 C1188893
FFFC27BC 000888B3
FFFC27C0 00088503
FFFC27C4 F6051EE3		bnez	$a0,.nxtByte
FFFC27C8 F29FF0EF		call	SerialRcvCount			; if more than 240 chars in buffer
FFFC27CC 0F052513		slt		$a0,$a0,#240				; send an XOFF
FFFC27D0 F60518E3		bnez	$a0,.nxtByte
FFFC27D4 01306513		ldi		$a0,#XOFF
FFFC27D8 FF0028B7		stb		$x0,SerRcvXon				; clear XON status
FFFC27DC C1088893
FFFC27E0 000888B3
FFFC27E4 00088023
FFFC27E8 FF0028B7		stb		$a0,SerRcvXoff			; set XOFF status
FFFC27EC C1188893
FFFC27F0 000888B3
FFFC27F4 00A88023
FFFC27F8 00A30023		stb		$a0,UART_TRB[$t1]
FFFC27FC F40002E3		bra		.nxtByte            ; check the status for another byte
                        	;	ldi		$a0,#$0B						; dtr,rts active, rxint disabled, no parity
                        	;	sw		$a0,UART+UART_CMD
                        	.rxFull:
                        	.notRxInt:
FFFC2800 00012083		ldt		$ra,[$sp]
FFFC2804 00410113		add		$sp,$sp,#4
FFFC2808 96DFE06F		jmp		IRQExit
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC280C 00000000		align	1
                        	
                        	SerialGetUI:
FFFC2810 00006513	  ldi   $a0,#E_Ok           ; no errors
FFFC2814 00106593	  ldi   $a1,#1              ; yes this is a UI device
FFFC2818 00008067	  ret
                        	
                        	nmeSerial:
FFFC281C 69726553		db		"Serial",0
FFFC2820 00006C61
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC2823 00000000		align	
FFFC2827 FC294400
                        	
                        	ViaFuncTbl:
FFFC2828 FFFC2944		dw		ViaNOP				; no operation
FFFC282C FFFC2910		dw		ViaSetup			; setup
FFFC2830 00000000		dw		0							; initialize
FFFC2834 00000000		dw		0							; status
FFFC2838 00000000		dw		0							; media check
FFFC283C 00000000		dw		0							; build BPB
FFFC2840 00000000		dw		0							; open
FFFC2844 00000000		dw		0							; close
FFFC2848 00000000		dw		0							; get char
FFFC284C 00000000		dw		0							; Peek char
FFFC2850 00000000		dw		0							; get char direct
FFFC2854 00000000		dw		0							; peek char direct
FFFC2858 00000000		dw		0							; input status
FFFC285C 00000000		dw		0							; Put char
FFFC2860 00000000		dw		0							; reserved
FFFC2864 00000000		dw		0							; set position
FFFC2868 00000000		dw		0							; read block
FFFC286C 00000000		dw		0							; write block
FFFC2870 00000000		dw		0							; verify block
FFFC2874 00000000		dw		0							; output status
FFFC2878 00000000		dw		0							; flush input
FFFC287C 00000000		dw		0							; flush output
FFFC2880 FFFC29B0		dw		ViaIRQ				; IRQ routine
FFFC2884 00000000		dw		0							; Is removable
FFFC2888 00000000		dw		0							; ioctrl read
FFFC288C 00000000		dw		0							; ioctrl write
FFFC2890 00000000		dw		0							; output until busy
FFFC2894 00000000		dw		0							; 27
FFFC2898 00000000		dw		0
FFFC289C 00000000		dw		0
FFFC28A0 00000000		dw		0
FFFC28A4 00000000		dw		0							; 31
                        	
                        	  align 8                        	
                        	ViaDCB:
FFFC28A8 41495603	  db    3,"VIA        "
FFFC28AC 20202020
FFFC28B0 20202020
FFFC28B4 00000000	  dw    0     ; type
FFFC28B8 00000000	  dw    0     ; nBPB
FFFC28BC 00000000	  dw    0
FFFC28C0 00000000	  dw    0     ; last error code
FFFC28C4 00000000	  dw    0
FFFC28C8 00000000	  dw    0     ; starting block number
FFFC28CC 00000000	  dw    0
FFFC28D0 00000000	  dw    0     ; number of blocks
FFFC28D4 00000000	  dw    0
FFFC28D8 00000000	  dw    0     ; command processing routine
FFFC28DC 00000000	  dw    0
FFFC28E0 00000000	  db    0     ; reentrancy count
FFFC28E1 00000000	  db    0     ; single user flag
FFFC28E2 00000000	  db    0     ; user interface device flag
FFFC28E3 00000000	  db    0
FFFC28E4 00000000	  dw    0
FFFC28E8 00000000	  dw    0     ; hJob
FFFC28EC 00000000	  dw    0
FFFC28F0 00000000	  dw    0     ; Mailbox handle
FFFC28F4 00000000	  dw    0
FFFC28F8 00000000	  dw    0     ; pointer to device semaphore
FFFC28FC 00000000	  dw    0
FFFC2900 00000000	  dw    0     ; reserved
FFFC2904 00000000	  dw    0
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
FFFC2908 00000000		align	1
FFFC290C 00000000
                        	
                        	ViaSetup:
FFFC2910 FFC10113		sub		$sp,$sp,#4
FFFC2914 00112023		stt		$ra,[$sp]
FFFC2918 00F06513		ldi		$a0,#15							; VIA device
FFFC291C FFFC35B7		ldi		$a1,#ViaFuncTbl
FFFC2920 82858593
FFFC2924 07D020EF		call	CopyDevFuncTbl
FFFC2928 00F06513		ldi		$a0,#15							; VIA device
FFFC292C FFFC35B7		ldi		$a1,#ViaDCB
FFFC2930 8A858593
FFFC2934 09D020EF		call	CopyDevDCB
FFFC2938 018000EF		call  ViaInit
FFFC293C 00012083		ldt		$ra,[$sp]
FFFC2940 00410113		add		$sp,$sp,#4
                        	ViaNOP:
FFFC2944 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; ViaInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	; Initialize port A low order eight bits as output, the remaining bits as
                        	; input. Setup timer #3 as the system time slice (30ms).
                        	;------------------------------------------------------------------------------
                        	
FFFC2948 00000000		align	1
FFFC294C 00000000
                        	
                        	ViaInit:
FFFC2950 FFC10113		sub		$sp,$sp,#4
FFFC2954 00112023		stt		$ra,[$sp]
FFFC2958 FFDC0337		ldi		$t1,#VIA
FFFC295C 60030313
FFFC2960 0FF06293		ldi		$t0,#$000000FF      ; low eight bits output
FFFC2964 00532623		stt		$t0,VIA_DDRA[$t1]
FFFC2968 00106293		ldi		$t0,#1							; select timer 3 access
FFFC296C 025308A3		stb		$t0,VIA_PCR+1[$t1]
FFFC2970 000022B7		ldi		$t0,#$1F00
FFFC2974 F0028293
FFFC2978 02531623		stw		$t0,VIA_ACR[$t1]		; set timer 3 mode, timer 1/2 = 64 bit
FFFC297C 001252B7		ldi		$t0,#$00124F80			;	divider value for 33.333Hz (30 ms)
FFFC2980 F8028293
FFFC2984 00532823		stt		$t0,VIA_T1CL[$t1]
FFFC2988 00032A23		stt		$x0,VIA_T1CH[$t1]		; trigger transfer to count registers
FFFC298C 003D12B7		ldi   $t0,#$003D0900      ; divider value for 10 Hz (100 ms)
FFFC2990 90028293
FFFC2994 02532023		stt   $t0,VIA_T2CL[$t1]
FFFC2998 02032223		stt   $x0,VIA_T2CH[$t1]
FFFC299C 1C006293		ldi		$t0,#$1C0						; emable timer3/timer2 interrupts
FFFC29A0 02532C23		stt		$t0,VIA_IER[$t1]
FFFC29A4 00012083		ldt		$ra,[$sp]
FFFC29A8 00410113		add		$sp,$sp,#4
FFFC29AC 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        		align	16                        	
                        	ViaIRQ:
FFFC29B0 FFC10113		sub		$sp,$sp,#4
FFFC29B4 00112023		stt		$ra,[$sp]
FFFC29B8 FFDC0337		ldi		$t1,#VIA
FFFC29BC 60030313
FFFC29C0 03431283		ldw		$t0,VIA_IFR[$t1]    ; get the flag register
FFFC29C4 0402F513		and   $a0,$t0,#$40        ; timer 2? (bit 6)
FFFC29C8 06051663		bnez  $a0,.timer2irq
                        	.0001:
FFFC29CC 1002F513		and   $a0,$t0,#$100       ; timer 3? (bit 8)
FFFC29D0 00051863		bnez  $a0,.timer3irq
FFFC29D4 00012083		ldt		$ra,[$sp]
FFFC29D8 00410113		add		$sp,$sp,#4
FFFC29DC F98FE06F		jmp		IRQExit
                        	.timer3irq:
FFFC29E0 00106393		ldi		$t2,#1							; assume timer3, select timer 3 access
FFFC29E4 027308A3		stb		$t2,VIA_PCR+1[$t1]
FFFC29E8 01032383		ldt		$t2,VIA_T1CL[$t1]		; yes, clear interrupt
FFFC29EC FF0008B7		ldt		$t2,milliseconds
FFFC29F0 20888893
FFFC29F4 000888B3
FFFC29F8 0008A383
FFFC29FC 01E38393		add		$t2,$t2,#30
FFFC2A00 FF0008B7		stt		$t2,milliseconds
FFFC2A04 20888893
FFFC2A08 000888B3
FFFC2A0C 0078A023
FFFC2A10 FF0008B7		stt		$t2,switchflag
FFFC2A14 20088893
FFFC2A18 000888B3
FFFC2A1C 0078A023
FFFC2A20 00006513		ldi   $a0,#0							; invoke SchedulerIRQ()
FFFC2A24 0DD000EF		call  OSOCall
FFFC2A28 00012083		ldt		$ra,[$sp]
FFFC2A2C 00410113		add		$sp,$sp,#4
FFFC2A30 F44FE06F		jmp		IRQExit
                        		; reset countdown to clear interrupt
                        	.timer2irq:
FFFC2A34 003D13B7		ldi   $t2,#$003D0900      ; divider value for 10 Hz (100 ms)
FFFC2A38 90038393
FFFC2A3C 02732023		stt   $t2,VIA_T2CL[$t1]
FFFC2A40 02032223		stt   $x0,VIA_T2CH[$t1]
FFFC2A44 0440E073		csrrs $x0,#$044,#1        ; set GC interrupt pending bit
FFFC2A48 F80002E3		bra   .0001               ; there might be a timer 3 irq too
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
FFFC2A4C 00000000		align	1
                        	
                        	ViaTime:
FFFC2A50 FFDC0337		ldi		$t1,#VIA
FFFC2A54 60030313
FFFC2A58 00106293		ldi		$t0,#1							; select timer 3 access
FFFC2A5C 025308A3		stb		$t0,VIA_PCR+1[$t1]
FFFC2A60 01032283		ldt		$t0,VIA_T1CL[$t1]
FFFC2A64 00125E37		ldi		$t3,#1200000				; timer counts down from here
FFFC2A68 F80E0E13
FFFC2A6C 405E02B3		sub		$t0,$t3,$t0					; calc elapsed clocks
FFFC2A70 0000AE37		ldi		$t3,#40000					; 40,000 clocks per millisecond
FFFC2A74 C40E0E13
FFFC2A78 03C2C2B3		div		$t0,$t0,$t3
FFFC2A7C FF0008B7		ldt		$t2,milliseconds
FFFC2A80 20888893
FFFC2A84 000888B3
FFFC2A88 0008A383
FFFC2A8C 00538533		add		$a0,$t2,$t0
FFFC2A90 00008067		ret
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/task.r5a",25
                        		code
                        		align	4                        	
                        	OSCallTbl:
FFFC2A94 C389C367	  dh    SchedulerIRQ >> 4
FFFC2A96 C402C389	  dh    IStartTask >> 4
FFFC2A98 C359C402	  dh    ISendMsg >> 4
FFFC2A9A C514C359	  dh    ISleep >> 4
FFFC2A9C C433C514	  dh		ISetDCBField >> 4
FFFC2A9E C2D8C433	  dh		IStartApp >> 4							; 5
                        	
                        	OSEcallTbl:
FFFC2AA0 C389C2D8		dh		FMTK_Initialize	>> 4				; 0
FFFC2AA2 C3B8C389		dh		FMTK_StartTask >> 4					; 1
FFFC2AA4 C3B9C3B8		dh		FMTK_ExitTask >> 4
FFFC2AA6 C2EAC3B9		dh		FMTK_KillTask >> 4
FFFC2AA8 C366C2EA		dh		FMTK_SetTaskPriority >> 4
FFFC2AAA C3C9C366		dh		FMTK_Sleep >> 4							; 5
FFFC2AAC C3DCC3C9		dh		FMTK_AllocMbx >> 4
FFFC2AAE 0031C3DC		dh		FMTK_FreeMbx >> 4
FFFC2AB0 C4100031		dh		FMTK_PostMsg >> 4
FFFC2AB2 C41EC410		dh		FMTK_SendMsg >> 4
FFFC2AB4 C41DC41E		dh		FMTK_WaitMsg >> 4					; 10
FFFC2AB6 C433C41D		dh		FMTK_PeekMsg >> 4
FFFC2AB8 C452C433		dh		FMTK_StartApp >> 4          ; 12
FFFC2ABA C2DAC452		dh		FMTK_ExitApp >> 4           ; 13
FFFC2ABC C534C2DA		dh		FMTK_GetCurrentTid >> 4
FFFC2ABE C453C534		dh		FMTK_TCBFinalizerExit >> 4  ; 15
FFFC2AC0 C2EFC453		dh		FMTK_KillApp >> 4
FFFC2AC2 C2E0C2EF		dh		FMTK_RunAsOS >> 4            ; 17
FFFC2AC4 C2E9C2E0		dh		FMTK_GetTaskAppId >> 4      ; 18
FFFC2AC6 C4D3C2E9		dh		FMTK_SetTaskId >> 4         ; 19
FFFC2AC8 C4E4C4D3		dh		FMTK_HasIOFocus	>> 4				; 20
FFFC2ACA C4F0C4E4		dh		FMTK_SwitchIOFocus >> 4			; 21
FFFC2ACC C4F1C4F0		dh		FMTK_ReleaseIOFocus	>> 4		; 22
FFFC2ACE C4E5C4F1		dh		FMTK_ForceReleaseIOFocus >> 4	; 23
FFFC2AD0 C2F0C4E5		dh		FMTK_RequestIOFocus	>> 4		; 24
FFFC2AD2 C508C2F0		dh		FMTK_MapOSVars >> 4         ; 25
FFFC2AD4 C50FC508		dh		FMTK_IO	>> 4								; 26
FFFC2AD6 C519C50F		dh    FMTK_GetDCBField >> 4       ; 27
FFFC2AD8 C2E6C519		dh    FMTK_SetDCBField >> 4       ; 28
FFFC2ADA C2E3C2E6		dh    FMTK_GetAppTaskId >> 4      ; 29
FFFC2ADC 0000C2E3		dh    FMTK_SetTaskAppId >> 4      ; 30
FFFC2ADE C2020000		dh    0
FFFC2AE0 C1C3C202		dh    GetPamBit >> 4              ; 32
FFFC2AE2 C05FC1C3		dh    FetchMemoryWord >> 4        ; 33
FFFC2AE4 C2DBC05F		dh    Monitor >> 4                ; 34
FFFC2AE6 C2DDC2DB		dh    GetIRQFlag >> 4             ; 35
FFFC2AE8 C1C4C2DD		dh    SetIRQFlag >> 4             ; 36
FFFC2AEA C2DFC1C4		dh    FMTK_Alloc >> 4							; 37
FFFC2AEC C4A3C2DF		dh    FMTK_GetCurrentAppId >> 4		; 38
FFFC2AEE 0000C4A3		dh    FMTK_DumpReadyQueue >> 4		; 39
FFFC2AF0 00000000		dh    0                       ; 40
FFFC2AF2 00000000		dh    0                       ; 41
FFFC2AF4 00000000		dh    0                       ; 42
FFFC2AF6 00000000		dh    0                       ; 43
FFFC2AF8 00000000		dh    0                       ; 44
FFFC2AFA 00000000		dh    0                       ; 45
FFFC2AFC 00000000		dh    0                       ; 46
FFFC2AFE 00000000		dh    0                       ; 47
                        	
                        	qToChk:
FFFC2B00 01000000		db	0,0,0,1,0,0,2,1
FFFC2B04 01020000
FFFC2B08 01030000		db	0,0,3,1,0,0,2,1
FFFC2B0C 01020000
FFFC2B10 01040000		db	0,0,4,1,0,0,2,1
FFFC2B14 01020000
FFFC2B18 01030000		db	0,0,3,1,0,0,2,1
FFFC2B1C 01020000
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	FMTKInit:
FFFC2B20 FF0008B7		stt		$x0,QNDX
FFFC2B24 30488893
FFFC2B28 000888B3
FFFC2B2C 0008A023
FFFC2B30 FF0008B7		stt   $x0,APPID_POOL
FFFC2B34 2F088893
FFFC2B38 000888B3
FFFC2B3C 0008A023
FFFC2B40 FF0008B7		stt   $x0,CHAINA0
FFFC2B44 37888893
FFFC2B48 000888B3
FFFC2B4C 0008A023
FFFC2B50 FF0008B7		stt		$x0,missed_ticks
FFFC2B54 32088893
FFFC2B58 000888B3
FFFC2B5C 0008A023
FFFC2B60 00006293		ldi   $t0,#0
FFFC2B64 7C229073		csrrw $x0,#CSR_TASKID,$t0   ; task id = 0
FFFC2B68 FF0008B7		stt   $x0,TaskNum
FFFC2B6C 22088893
FFFC2B70 000888B3
FFFC2B74 0008A023
FFFC2B78 FF0008B7		stt		$x0,TimeoutList
FFFC2B7C 32888893
FFFC2B80 000888B3
FFFC2B84 0008A023
FFFC2B88 FF0008B7		stt		$x0,HEADRDY0
FFFC2B8C 40088893
FFFC2B90 000888B3
FFFC2B94 0008A023
FFFC2B98 FF0008B7		stt		$x0,HEADRDY1
FFFC2B9C 40488893
FFFC2BA0 000888B3
FFFC2BA4 0008A023
FFFC2BA8 FF0008B7		stt		$x0,HEADRDY2
FFFC2BAC 40888893
FFFC2BB0 000888B3
FFFC2BB4 0008A023
FFFC2BB8 FF0008B7		stt		$x0,HEADRDY3
FFFC2BBC 40C88893
FFFC2BC0 000888B3
FFFC2BC4 0008A023
FFFC2BC8 FF0008B7		stt		$x0,HEADRDY4
FFFC2BCC 41088893
FFFC2BD0 000888B3
FFFC2BD4 0008A023
FFFC2BD8 FF0008B7		stt		$x0,TAILRDY0
FFFC2BDC 42088893
FFFC2BE0 000888B3
FFFC2BE4 0008A023
FFFC2BE8 FF0008B7		stt		$x0,TAILRDY1
FFFC2BEC 42488893
FFFC2BF0 000888B3
FFFC2BF4 0008A023
FFFC2BF8 FF0008B7		stt		$x0,TAILRDY2
FFFC2BFC 42888893
FFFC2C00 000888B3
FFFC2C04 0008A023
FFFC2C08 FF0008B7		stt		$x0,TAILRDY3
FFFC2C0C 42C88893
FFFC2C10 000888B3
FFFC2C14 0008A023
FFFC2C18 FF0008B7		stt		$x0,TAILRDY4
FFFC2C1C 43088893
FFFC2C20 000888B3
FFFC2C24 0008A023
                        	
FFFC2C28 FF0018B7		stt		$x0,IOFocusNdx
FFFC2C2C 08088893
FFFC2C30 000888B3
FFFC2C34 0008A023
                        	
                        	  ; one out the register set last tid
FFFC2C38 000002B7	  ldi   $t0,#$FFFFFFFF
FFFC2C3C FFF28293
FFFC2C40 FF0018B7	  stt   $t0,RegsetTid
FFFC2C44 0F088893
FFFC2C48 000888B3
FFFC2C4C 0058A023
FFFC2C50 FF0018B7	  stt   $t0,RegsetTid+4
FFFC2C54 0F488893
FFFC2C58 000888B3
FFFC2C5C 0058A023
FFFC2C60 FF0018B7	  stt   $t0,RegsetTid+8
FFFC2C64 0F888893
FFFC2C68 000888B3
FFFC2C6C 0058A023
FFFC2C70 FF0018B7	  stt   $t0,RegsetTid+12
FFFC2C74 0FC88893
FFFC2C78 000888B3
FFFC2C7C 0058A023
                        	
                        		; zero out device function table
FFFC2C80 FF0022B7		ldi		$t0,#DVF_Base
FFFC2C84 00028293
FFFC2C88 40006313		ldi		$t1,#32*32
                        	.0003:
FFFC2C8C 0002A023		stt		$x0,[$t0]
FFFC2C90 00428293		add		$t0,$t0,#4
FFFC2C94 FFF30313		sub		$t1,$t1,#1
FFFC2C98 FE604AE3		bgtz	$t1,.0003
                        	
                        		; Initialize free message list
FFFC2C9C FF0018B7		stt		$x0,FreeMsg
FFFC2CA0 C0088893
FFFC2CA4 000888B3
FFFC2CA8 0008A023
                        	
                        		; Initialize mailboxes
FFFC2CAC FF0018B7		stt   $x0,FreeMbx
FFFC2CB0 C0888893
FFFC2CB4 000888B3
FFFC2CB8 0008A023
FFFC2CBC FF0018B7		stw   $x0,IdleTaskMbx
FFFC2CC0 C1088893
FFFC2CC4 000888B3
FFFC2CC8 00089023
FFFC2CCC FF0018B7		stw   $x0,IdleTaskId
FFFC2CD0 C2A88893
FFFC2CD4 000888B3
FFFC2CD8 00089023
FFFC2CDC FF0018B7		stb   $x0,MbxBlockCounter
FFFC2CE0 0E088893
FFFC2CE4 000888B3
FFFC2CE8 00088023
FFFC2CEC 00806293		ldi   $t0,#MBX_BLOCKPTR_BUFSZ
FFFC2CF0 FF001337		ldi   $t1,#MbxBlockPtr
FFFC2CF4 0A030313
                        	.0001:
FFFC2CF8 00032023		stt   $x0,[$t1]
FFFC2CFC 00430313		add   $t1,$t1,#4
FFFC2D00 FFF28293		sub   $t0,$t0,#1
FFFC2D04 FE029AE3		bnez  $t0,.0001
                        	
                        		; Initialize ACB pointers
FFFC2D08 07C06293		ldi		$t0,#31*4
                        	.0002:
FFFC2D0C FF0008B7		stt		$x0,ACBPtrs[$t0]
FFFC2D10 60088893
FFFC2D14 005888B3
FFFC2D18 0008A023
FFFC2D1C FFC28293		sub		$t0,$t0,#4
FFFC2D20 FE02D6E3		bge		$t0,$x0,.0002
                        	
                        		; Initialize TCB pointers
FFFC2D24 FF0008B7		stt		$x0,TCBID_POOL
FFFC2D28 2F888893
FFFC2D2C 000888B3
FFFC2D30 0008A023
FFFC2D34 FF0008B7		stt		$x0,TCBID_POOL+4
FFFC2D38 2FC88893
FFFC2D3C 000888B3
FFFC2D40 0008A023
FFFC2D44 0FC06293		ldi		$t0,#63*4
                        	.0004:
FFFC2D48 FF0008B7		stt		$x0,TCBPtrs[$t0]
FFFC2D4C 50088893
FFFC2D50 005888B3
FFFC2D54 0008A023
FFFC2D58 FFC28293		sub		$t0,$t0,#4
FFFC2D5C FE02D6E3		bge		$t0,$x0,.0004
                        	
                        		; unlock the system semaphore	
                        		
FFFC2D60 FFF06513			ldi				a0,#-1
FFFC2D64 FF0008B7			stt				a0,SysSema
FFFC2D68 34088893
FFFC2D6C 000888B3
FFFC2D70 00A8A023
                        	
FFFC2D74 00008067		ret
                        	
FFFC2D78 00000000		align	1
FFFC2D7C 00000000
                        	
                        	FMTK_Initialize:
                        	  
FFFC2D80 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2D84 D9DFF06F	jmp  FMTKInit
                        	 
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
FFFC2D88 00000000		align	1
FFFC2D8C 00000000
                        	
                        	GetCurrentTid:
                        		
FFFC2D90 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2D94 00008067	ret
                        	
FFFC2D98 00000000		align	1
FFFC2D9C 00000000
                        	
                        	FMTK_GetCurrentTid:
                        		
FFFC2DA0 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2DA4 000565B3	mov		$a1,$a0
FFFC2DA8 00006513		ldi		$a0,#E_Ok
FFFC2DAC 00008067		ret
                        	
                        		align	16                        	
                        	GetIRQFlag:
FFFC2DB0 FF0018B7	  ldt   $a1,IRQFlag
FFFC2DB4 09088893
FFFC2DB8 000888B3
FFFC2DBC 0008A583
FFFC2DC0 00006513	  ldi   $a0,#E_Ok
FFFC2DC4 00008067	  ret
                        	
FFFC2DC8 00000000		align	1
FFFC2DCC 00000000
                        	
                        	SetIRQFlag:
FFFC2DD0 FF0018B7	  stt   $a1,IRQFlag
FFFC2DD4 09088893
FFFC2DD8 000888B3
FFFC2DDC 00B8A023
FFFC2DE0 00006513	  ldi   $a0,#E_Ok
FFFC2DE4 00008067	  ret
                        	
                        	; Accessors
                        	
FFFC2DE8 00000000		align	1
FFFC2DEC 00000000
                        	
                        	FMTK_GetCurrentAppId:
                        		
FFFC2DF0 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2DF4 000565B3	mov		$a1,$a0
FFFC2DF8 0080006F		jmp		FMTK_GetTaskAppId
                        	
FFFC2DFC 00000000		align	1
                        	
                        	FMTK_GetTaskAppId:
FFFC2E00 00259293		sll		$t0,$a1,#2
FFFC2E04 FF0008B7		ldt		$t0,TCBPtrs[$t0]
FFFC2E08 50088893
FFFC2E0C 005888B3
FFFC2E10 0008A283
FFFC2E14 001008B7		and		$t0,$t0,#$FFC00
FFFC2E18 C0088893
FFFC2E1C 0112F2B3
FFFC2E20 3422D583	  ldwu  $a1,TCBappid[$t0]
FFFC2E24 00006513	  ldi   $a0,#E_Ok
FFFC2E28 00008067	  ret
                        	
FFFC2E2C 00000000		align	1
                        	
                        	FMTK_SetTaskAppId:
FFFC2E30 00259293	  sll		$t0,$a1,#2
FFFC2E34 FF0008B7	  ldt		$t0,TCBPtrs[$t0]
FFFC2E38 50088893
FFFC2E3C 005888B3
FFFC2E40 0008A283
FFFC2E44 001008B7		and		$t0,$t0,#$FFC00
FFFC2E48 C0088893
FFFC2E4C 0112F2B3
FFFC2E50 34C29123	  stw   $a2,TCBappid[$t0]
FFFC2E54 00006513	  ldi   $a0,#E_Ok
FFFC2E58 00008067	  ret
                        	
FFFC2E5C 00000000		align	1
                        	
                        	FMTK_GetAppTaskId:
FFFC2E60 00259593		sll		$a1,$a1,#2
FFFC2E64 FF0008B7		ldt		$a1,ACBPtrs[$a1]
FFFC2E68 60088893
FFFC2E6C 00B888B3
FFFC2E70 0008A583
FFFC2E74 001008B7		and		$a1,$a1,#$FFC00
FFFC2E78 C0088893
FFFC2E7C 0115F5B3
FFFC2E80 3C05D583	  ldwu  $a1,ACBTask[$a1]
FFFC2E84 00006513	  ldi   $a0,#E_Ok
FFFC2E88 00008067	  ret
                        	
                        	; The following only really needed by startup code, otherwise the task id
                        	; is completely managed by the OS.
FFFC2E8C 00000000		align	1
                        	
                        	FMTK_SetTaskId:
                        	  ; Should get the id and see if it's currently zero (unset).
                        	  ; but this would be more code bloat.
FFFC2E90 7C259073	  csrrw $x0,#CSR_TASKID,$a1
FFFC2E94 00006513	  ldi   $a0,#E_Ok
FFFC2E98 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Setting the task priority will take effect the next time the task is
                        	; scheduled.
                        	;
                        	; Parameters:
                        	;   $a1 = new priority to set
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;------------------------------------------------------------------------------
FFFC2E9C 00000000		align	1
                        	
                        	FMTK_SetTaskPriority:
                        	  
FFFC2EA0 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2EA4 00251293	sll		$t0,$a0,#2
FFFC2EA8 FF0008B7	  ldt		$t0,TCBPtrs[$t0]
FFFC2EAC 50088893
FFFC2EB0 005888B3
FFFC2EB4 0008A283
FFFC2EB8 001008B7		and		$t0,$t0,#$FFC00
FFFC2EBC C0088893
FFFC2EC0 0112F2B3
FFFC2EC4 2CB284A3	  stb   $a1,TCBPriority[$t0]
FFFC2EC8 00006513	  ldi   $a0,#E_Ok
FFFC2ECC 00008067	  ret
                        	.badTid:
FFFC2ED0 02806513	  ldi   $a0,#E_BadTid
FFFC2ED4 00008067	  ret
                        	.badPtr:
FFFC2ED8 000008B7	  call  FreeTID
FFFC2EDC 33C880E7
FFFC2EE0 02706513	  ldi   $a0,#E_BadTcbPointer
FFFC2EE4 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; RunAsOS
                        	;   Runs a piece of code as part of the OS.
                        	; Only certain tasks are allowed to run code this way.
                        	;
                        	; Parameters:
                        	;   $a1 = pointer to code to run
                        	;------------------------------------------------------------------------------
FFFC2EE8 00000000		align	1
FFFC2EEC 00000000
                        	
                        	FMTK_RunAsOS:
FFFC2EF0 0005E2B3	  mov   $t0,$a1
FFFC2EF4 00028067	  jmp   [$t0]
                        	.badFunc:
FFFC2EF8 00206513	  ldi   $a0,#E_Func
FFFC2EFC 00008067	  ret
                        	 
                        	;------------------------------------------------------------------------------
                        	; Map operating system variables into the app's address space.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;   $a0 = E_Ok if successful
                        	;   $a1 = virtual address space location of vars., -1 if unsuccessful
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	FMTK_MapOSVars:
FFFC2F00 00006513	  ldi   $a0,#0          ; OS app
FFFC2F04 03006593	  ldi   $a1,#OSPAGES
FFFC2F08 FFC10113	  sub		$sp,$sp,#4
FFFC2F0C 00112023	  stt		$ra,[$sp]
FFFC2F10 A41FE0EF	  call  FindRun
FFFC2F14 02054C63	  bltz  $a0,.noMem
FFFC2F18 00006293	  ldi   $t0,#0
FFFC2F1C 000565B3	  mov   $a1,$a0
                        	.mapMore:
FFFC2F20 02A2800D	  mvmap $x0,$t0,$a0
FFFC2F24 00128293	  add   $t0,$t0,#1
FFFC2F28 00150513	  add   $a0,$a0,#1
FFFC2F2C 0102A313	  slt   $t1,$t0,#16
FFFC2F30 FE0318E3	  bnez  $t1,.mapMore
FFFC2F34 1FF5F593	  and   $a1,$a1,#$1FF
FFFC2F38 00A59593	  sll   $a1,$a1,#LOG_PGSZ
FFFC2F3C 00006513	  ldi   $a0,#E_Ok
                        	.retx:
FFFC2F40 00012083	  ldt		$ra,[$sp]
FFFC2F44 00410113	  add		$sp,$sp,#4
FFFC2F48 00008067	  ret
                        	.noMem:
FFFC2F4C FFF06593	  ldi   $a1,#-1
FFFC2F50 04706513	  ldi   $a0,#E_NoMem
FFFC2F54 FE0006E3	  bra		.retx
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
FFFC2F58 00000000		align	1
FFFC2F5C 00000000
                        	
                        	LockOSSemaphore:
                        	LockOS:
FFFC2F60 7C401DF3		csrrw	$s11,#CSR_PMSTACK,$x0		; Get current interrupt enable setting
                        	.spin:
                        		
FFFC2F64 010002B7			ldi				$t0,#$000180|(1<<24)				; enable timer3 interrupts after tm cycles
		stt				$t0,VIA_IER+VIA
FFFC2F68 18028293
FFFC2F6C FFDC08B7
FFFC2F70 63888893
FFFC2F74 000888B3
FFFC2F78 0058A023
                        	
FFFC2F7C 7C40E073		csrrs	$x0,#CSR_PMSTACK,#1			; ensure interrupts are enabled
FFFC2F80 FFDB08B7		ldt		$t0,OS_SEMA+4						; try and lock semaphore
FFFC2F84 00488893
FFFC2F88 000888B3
FFFC2F8C 0008A283
FFFC2F90 FC028AE3		beqz	$t0,.spin
FFFC2F94 00008067		ret
                        	
FFFC2F98 00000000		align	1
FFFC2F9C 00000000
                        	
                        	UnlockOSSemaphore:
                        	UnlockOS:
FFFC2FA0 7C4D9073		csrrw	$x0,#CSR_PMSTACK,$s11		; restore interrupts
FFFC2FA4 00106D93		ldi		$s11,#1
FFFC2FA8 FFDB48B7		stt		$s11,OS_SEMA+$4000			; unlock semaphore
FFFC2FAC 00088893
FFFC2FB0 000888B3
FFFC2FB4 01B8A023
FFFC2FB8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready lists are searched in a circular
                        	; fashion beginning with the list identified indirectly by QNDX. There are
                        	; five ready lists to hold tasks of five different priorities.
                        	; Cannot wait for an interrupt in this routine because it is called by
                        	; the SchedulerIRQ() routine. 
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		$a1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		$a0 = TCB pointer of task to run. 0 if no task is ready to run.
                        	;------------------------------------------------------------------------------
FFFC2FBC 00000000	  align 1
                        	
                        	SelectTaskToRun:
FFFC2FC0 FF410113	  sub   $sp,$sp,#12
FFFC2FC4 00112023	  stt   $ra,[$sp]
FFFC2FC8 00912223	  stt		$s1,4[$sp]
FFFC2FCC 01212423	  stt		$s2,8[$sp]
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
                        	
FFFC2FD0 F91FF0EF		call	LockOS
FFFC2FD4 FF0008B7		ldbu	$a1,QNDX						; get index into que check table
FFFC2FD8 30488893
FFFC2FDC 000888B3
FFFC2FE0 0008C583
FFFC2FE4 00158593		add		$a1,$a1,#1					; increment it, and limit
FFFC2FE8 01F5F593		and		$a1,$a1,#31
FFFC2FEC FF0008B7		stb		$a1,QNDX						; store back
FFFC2FF0 30488893
FFFC2FF4 000888B3
FFFC2FF8 00B88023
FFFC2FFC FFFC38B7		ldbu	$a1,qToChk[$a1]			; assume this will be valid
FFFC3000 B0088893
FFFC3004 00B888B3
FFFC3008 0008C583
FFFC300C 00259593		sll		$a1,$a1,#2					; turn $a1 into index
FFFC3010 00506393		ldi		$t2,#5							; 5 queues to check
                        	.nxtQ:
FFFC3014 FF0008B7	  ldt		$a0,HEADRDY[$a1]
FFFC3018 40088893
FFFC301C 00B888B3
FFFC3020 0008A503
FFFC3024 02051463	  bnez  $a0,.dq      				;
FFFC3028 00458593		add		$a1,$a1,#4					; no, advance to next queue
FFFC302C 0145A513		slt   $a0,$a1,#20
FFFC3030 00051463		bnez  $a0,.mod
FFFC3034 00006593		ldi   $a1,#0
                        	.mod:
FFFC3038 FFF38393		sub		$t2,$t2,#1					;
FFFC303C FC704CE3		bgtz	$t2,.nxtQ				    ; go back to check next queue
                        		; Here, nothing else is actually ready to run?
                        		; This should not be possible as the IdleTask should always
                        		; be present. Return NULL.
FFFC3040 00006513		ldi		$a0,#0
FFFC3044 F5DFF0EF		call	UnlockOS
FFFC3048 06000463		bra		.xit
                        	.dq:
                        		; TCBs should be 1kB aligned and within the RAM memory range.
FFFC304C 000808B7		and		$a0,$a0,#$0007FC00
FFFC3050 C0088893
FFFC3054 01157533
FFFC3058 00052283		ldt		$t0,[$a0]
FFFC305C 205448B7		xor		$t0,$t0,#TCB_MAGIC
FFFC3060 34288893
FFFC3064 0112C2B3
FFFC3068 04029E63		bnez	$t0,.listCorrupt
                        	  ; Rotate ready list
                        	;  call	LockOS
FFFC306C 000564B3		mov		$s1,$a0
FFFC3070 0005E933		mov		$s2,$a1
FFFC3074 DADFD0EF		call	PutHexWord
FFFC3078 02006513		ldi		$a0,#' '
FFFC307C C64FD0EF		call	Putch
FFFC3080 0004E533		mov		$a0,$s1
FFFC3084 000965B3		mov		$a1,$s2
FFFC3088 31052303	  ldt   $t1,TCBNext[$a0]
FFFC308C FF0008B7	  stt		$t1,HEADRDY[$a1]
FFFC3090 40088893
FFFC3094 00B888B3
FFFC3098 0068A023
FFFC309C FF0008B7	  stt		$a0,TAILRDY[$a1]
FFFC30A0 42088893
FFFC30A4 00B888B3
FFFC30A8 00A8A023
FFFC30AC EF5FF0EF		call	UnlockOS
                        	  ; Return $a0 equal selected task
                        	.xit:
FFFC30B0 00012083	  ldt   $ra,[$sp]
FFFC30B4 00412483	  ldt		$s1,4[$sp]
FFFC30B8 00812903	  ldt		$s2,8[$sp]
FFFC30BC 00C10113	  add   $sp,$sp,#12
FFFC30C0 00008067		ret
                        	.listCorrupt:
FFFC30C4 FFFC3537		ldi		$a0,#msgReadyQueueCorrupt
FFFC30C8 0D450513
FFFC30CC E35FD0EF		call	PutString
                        	.0001:
FFFC30D0 00000063		bra		.0001
                        	
                        	msgReadyQueueCorrupt:
FFFC30D4 64616552		db	"Ready Queue corrupt",CR,LNFD,0
FFFC30D8 75512079
FFFC30DC 20657565
FFFC30E0 72726F63
FFFC30E4 0D747075
FFFC30E8 0000000A
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	;
                        	; Parameters:
                        	;		$s1 = pointer to TCB of outgoing context
                        	;		$s2 = pointer to TCB of incoming context
                        	; Must not modify:
                        	;   $t2
                        	; Modifies:
                        	;   $t0,$t1,$t3,$t4,$t5
                        	;------------------------------------------------------------------------------
FFFC30EA 00000000	  align 1
FFFC30EE 01130000
                        	
                        	SwapContext:
FFFC30F0 FF810113		sub		$sp,$sp,#8
FFFC30F4 00112023		stt		$ra,[$sp]
FFFC30F8 00712223		stt		$t2,4[$sp]
                        	/*
	ldbu	$a0,TCBRegset[$s1]
	mov		$a0,$s1
	call	PutHexByte
	ldi		$a0,#' '
	call 	Putch
	ldbu	$a0,TCBRegset[$s2]
	call	PutHexByte
	ldi		$a0,#CR
	call	Putch
*/
                        		; Save outgoing register set in TCB
FFFC30FC E65FF0EF		call	LockOS
FFFC3100 7C026073		csrrs	$x0,#CSR_REGSET,#4	  ; select prior register set for Rs2, epc
FFFC3104 0414A423		stt		$x1,TCBxRA[$s1]
FFFC3108 0424A823		stt		$x2,TCBxSP[$s1]
FFFC310C 0434AC23		stt		$x3,TCBxGP[$s1]
FFFC3110 0644A023		stt		$x4,TCBxTP[$s1]
FFFC3114 0654A423		stt		$x5,TCBxT0[$s1]
FFFC3118 0664A823		stt		$x6,TCBxT1[$s1]
FFFC311C 0674AC23		stt		$x7,TCBxT2[$s1]
FFFC3120 0884A023		stt		$x8,TCBxFP[$s1]
FFFC3124 0894A423		stt		$x9,TCBxS1[$s1]
FFFC3128 08A4A823		stt		$x10,TCBxA0[$s1]
FFFC312C 08B4AC23		stt		$x11,TCBxA1[$s1]
FFFC3130 0AC4A023		stt		$x12,TCBxA2[$s1]
FFFC3134 0AD4A423		stt		$x13,TCBxA3[$s1]
FFFC3138 0AE4A823		stt		$x14,TCBxA4[$s1]
FFFC313C 0AF4AC23		stt		$x15,TCBxA5[$s1]
FFFC3140 0D04A023		stt		$x16,TCBxA6[$s1]
FFFC3144 7C0FF073		csrrc	$x0,#CSR_REGSET,#31   ; restore register set selections
FFFC3148 E59FF0EF		call	UnlockOS
FFFC314C E15FF0EF		call	LockOS
FFFC3150 7C026073		csrrs	$x0,#CSR_REGSET,#4	  ; select prior register set for Rs2, epc
FFFC3154 0D14A423		stt		$x17,TCBxA7[$s1]
FFFC3158 0D24A823		stt		$x18,TCBxS2[$s1]
FFFC315C 0D34AC23		stt		$x19,TCBxS3[$s1]
FFFC3160 0F44A023		stt		$x20,TCBxS4[$s1]
FFFC3164 0F54A423		stt		$x21,TCBxS5[$s1]
FFFC3168 0F64A823		stt		$x22,TCBxS6[$s1]
FFFC316C 0F74AC23		stt		$x23,TCBxS7[$s1]
FFFC3170 1184A023		stt		$x24,TCBxS8[$s1]
FFFC3174 1194A423		stt		$x25,TCBxS9[$s1]
FFFC3178 11A4A823		stt		$x26,TCBxS10[$s1]
FFFC317C 11B4AC23		stt		$x27,TCBxS11[$s1]
FFFC3180 13C4A023		stt		$x28,TCBxT3[$s1]
FFFC3184 13D4A423		stt		$x29,TCBxT4[$s1]
FFFC3188 13E4A823		stt		$x30,TCBxT5[$s1]
FFFC318C 13F4AC23		stt		$x31,TCBxT6[$s1]
FFFC3190 7C0FF073		csrrc	$x0,#CSR_REGSET,#31   ; restore register set selections
FFFC3194 E0DFF0EF		call	UnlockOS
                        	
                        		; Save MEPC
FFFC3198 34101E73		csrrw $t3,#CSR_MEPC,$x0
FFFC319C 2DC4A023		stt   $t3,TCBepc[$s1]
                        	
                        		; Save the operating mode
FFFC31A0 7C401E73		csrrw $t3,#CSR_PMSTACK,$x0
FFFC31A4 038E7E13		and   $t3,$t3,#$38
FFFC31A8 35C48223		stb   $t3,TCBOpMode[$s1]
                        	
                        		; Save interrupt mask
FFFC31AC 7C501E73		csrrw	$t3,#CSR_IMSTACK,$x0
FFFC31B0 00FE7E13		and		$t3,$t3,#15
FFFC31B4 35C482A3		stb		$t3,TCBImMask[$s1]
                        	
                        		; set task id
FFFC31B8 DA9FF0EF		call	LockOS
FFFC31BC 00A95513	  srl   $a0,$s2,#LOG_PGSZ
FFFC31C0 7C251073		csrrw $x0,#CSR_TASKID,$a0			
                        	
                        		; Switch to destination memory map
FFFC31C4 2CC94503	  ldbu  $a0,TCBRegset[$s2]
                        	;  ldbu  $a0,TCBmid[$s2]
FFFC31C8 01651513	  sll		$a0,$a0,#22							; shift into position
FFFC31CC 18001373	  csrrw	$t1,#CSR_SATP,$x0				; get satp
FFFC31D0 F04008B7	  and		$t1,$t1,#$f03fffff			; mask off asid
FFFC31D4 FFF88893
FFFC31D8 01137333
FFFC31DC 00A36333	  or		$t1,$t1,$a0							; set new asid
FFFC31E0 18031073		csrrw	$x0,#CSR_SATP,$t1				; set satp
                        		; User map has now been switched
                        	
                        		; Select register set to return to
FFFC31E4 2CC94503	  ldbu  $a0,TCBRegset[$s2]
FFFC31E8 7C301373		csrrw $t1,#CSR_RSSTACK,$x0
FFFC31EC FFFFF8B7		and   $t1,$t1,#$FFFFF03F
FFFC31F0 03F88893
FFFC31F4 01137333
FFFC31F8 00551293		sll   $t0,$a0,#5
FFFC31FC 00536333		or    $t1,$t1,$t0
FFFC3200 7C331073		csrrw $x0,#CSR_RSSTACK,$t1
FFFC3204 D9DFF0EF		call	UnlockOS
                        	
FFFC3208 D59FF0EF		call	LockOS
FFFC320C 7C00E073		csrrs $x0,#CSR_REGSET,#1      ; select task's register set
                        		; These two registers always need to be loaded so that the OS return values
                        		; can be transferred.
FFFC3210 05092103		ldt		$x2,TCBxSP[$s2]         ; manipulated by StartTask
FFFC3214 05892183		ldt		$x3,TCBxGP[$s2]         ; manipulated by StartApp
FFFC3218 09092503		ldt		$x10,TCBxA0[$s2]
FFFC321C 09892583		ldt		$x11,TCBxA1[$s2]
                        	;	beqz  $t1,.skipCtxLoad
FFFC3220 04892083		ldt		$x1,TCBxRA[$s2]
FFFC3224 06092203		ldt		$x4,TCBxTP[$s2]
FFFC3228 06892283		ldt		$x5,TCBxT0[$s2]
FFFC322C 07092303		ldt		$x6,TCBxT1[$s2]
FFFC3230 07892383		ldt		$x7,TCBxT2[$s2]
FFFC3234 08092403		ldt		$x8,TCBxFP[$s2]
FFFC3238 08892483		ldt		$x9,TCBxS1[$s2]
FFFC323C 0A092603		ldt		$x12,TCBxA2[$s2]
FFFC3240 0A892683		ldt		$x13,TCBxA3[$s2]
FFFC3244 0B092703		ldt		$x14,TCBxA4[$s2]
FFFC3248 0B892783		ldt		$x15,TCBxA5[$s2]
FFFC324C 0C092803		ldt		$x16,TCBxA6[$s2]
FFFC3250 7C0FF073		csrrc	$x0,#CSR_REGSET,#31   ; restore register set selections
FFFC3254 D4DFF0EF		call	UnlockOS
FFFC3258 D09FF0EF		call	LockOS
FFFC325C 7C00E073		csrrs $x0,#CSR_REGSET,#1      ; select task's register set
FFFC3260 0C892883		ldt		$x17,TCBxA7[$s2]
FFFC3264 0D092903		ldt		$x18,TCBxS2[$s2]
FFFC3268 0D892983		ldt		$x19,TCBxS3[$s2]
FFFC326C 0E092A03		ldt		$x20,TCBxS4[$s2]
FFFC3270 0E892A83		ldt		$x21,TCBxS5[$s2]
FFFC3274 0F092B03		ldt		$x22,TCBxS6[$s2]
FFFC3278 0F892B83		ldt		$x23,TCBxS7[$s2]
FFFC327C 10092C03		ldt		$x24,TCBxS8[$s2]
FFFC3280 10892C83		ldt		$x25,TCBxS9[$s2]
FFFC3284 11092D03		ldt		$x26,TCBxS10[$s2]
FFFC3288 11892D83		ldt		$x27,TCBxS11[$s2]
FFFC328C 12092E03		ldt		$x28,TCBxT3[$s2]
FFFC3290 12892E83		ldt		$x29,TCBxT4[$s2]
FFFC3294 13092F03		ldt		$x30,TCBxT5[$s2]
FFFC3298 13892F83		ldt		$x31,TCBxT6[$s2]
FFFC329C 7C0FF073		csrrc	$x0,#CSR_REGSET,#31   ; restore register set selections
FFFC32A0 D01FF0EF		call	UnlockOS
                        	
FFFC32A4 CBDFF0EF		call	LockOS
                        	  ; Setup return privilege mode
FFFC32A8 34494E03	  ldbu  $t3,TCBOpMode[$s2]
FFFC32AC 7C4012F3	  csrrw $t0,#CSR_PMSTACK,$x0
FFFC32B0 FC72F293	  and   $t0,$t0,#$FFFFFFC7
FFFC32B4 038E7E13	  and   $t3,$t3,#$38          ; four operating modes max
FFFC32B8 01C2E2B3	  or    $t0,$t0,$t3
FFFC32BC 7C429073	  csrrw $x0,#CSR_PMSTACK,$t0
                        	
                        		; Setup interrupt mask
FFFC32C0 34594E03		ldbu	$t3,TCBImMask[$s2]
FFFC32C4 7C5012F3		csrrw	$t0,#CSR_IMSTACK,$x0
FFFC32C8 FF02F293		and		$t0,$t0,#$FFFFFFF0
FFFC32CC 00FE7E13		and		$t3,$t3,#15
FFFC32D0 01C2E2B3		or		$t0,$t0,$t3
FFFC32D4 7C529073		csrrw	$x0,#CSR_IMSTACK,$t0
                        	
                        		; Setup EPC to return to task
FFFC32D8 2C092E03	  ldt   $t3,TCBepc[$s2]
FFFC32DC 341E1073	  csrrw $x0,#CSR_MEPC,$t3
FFFC32E0 CC1FF0EF		call	UnlockOS
                        	
FFFC32E4 00012083	  ldt		$ra,[$sp]
FFFC32E8 00412383	  ldt		$t2,4[$sp]
FFFC32EC 00810113	  add		$sp,$sp,#8
                        	
FFFC32F0 00008067		ret
                        	/*
	; Now save off segment registers
	ldi		$t1,#0
.svseg:
	mvseg	$t0,$x0,$t1
	sll		$t3,$t1,#2
	add		$t3,$t3,$s1
	stt		$t0,TCBbases[$t3]
	add		$t1,$t1,#1
	and		$t1,$t1,#15
	bnez	$t1,.svseg

	; Switch memory maps
;	srl		$v0,$a1,#10					; convert pointer to tid
;	and		$v0,$v0,#$F					; mask to 16 task
  ldbu  $a0,TCBmid[$s2]
  sll		$a0,$a0,#22					; shift into position
  csrrw	$t1,#$180,$x0				; get satp
  and		$t1,$t1,#$f83fffff	; mask off asid
  or		$t1,$t1,$a0					; set new asid
	csrrw	$x0,#$180,$t1				; set satp
  srl   $a0,$s2,#LOG_PGSZ
	csrrw $x0,#CSR_TASKID,$a0
	; User map has now been switched

	; Restore segment register set
	ldi		$t1,#0
.rsseg:
	sll		$t3,$t1,#2
	add		$t3,$t3,$s2
	ldt		$t0,TCBbases[$t3]
	mvseg	$x0,$t0,$t1
	add		$t1,$t1,#1
	and		$t1,$t1,#15
	bnez	$t1,.rsseg

.0005:
	; We can skip over a bunch of load operations if the last task to use the
	; register set is the same task that wants it. In that event there are no
	; registers to reload other than the return value ones.
	srl   $t0,$t0,#4              ; position $t0 as index
	ldbu  $t1,RegsetTid[$t0]
	beq   $t1,$t0,.0001:
	stb   $t0,RegsetTid[$t0]      ; flag as the last user
	ldi   $t1,#1
	jmp   .0002
.0001:
  ldi   $t1,#0
.0002:
*/
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system ordinary call dispatcher.
                        	;------------------------------------------------------------------------------
FFFC32F4 00000000	  align 
                        	
FFFC32F8 434F534F	  db  "OSOCall",0
FFFC32FC 006C6C61
                        	  align 16                        	
                        	OSOCall:
FFFC3300 00852293	  slt   $t0,$a0,#8
FFFC3304 08028463		beqz  $t0,.badFunc
FFFC3308 7C10E2F3	  csrrs $t0,#$7C1,#1    		; set OS running semaphore
FFFC330C 0012F293	  and		$t0,$t0,#1
FFFC3310 08029263	  bnez	$t0,.busy
FFFC3314 FFC10113	  sub		$sp,$sp,#4
FFFC3318 00112023	  stt		$ra,[$sp]
                        		
FFFC331C 10006293		ldi		$t0,#$100						; disable timer3 (time slice) interrupts
FFFC3320 FFDC08B7		stt		$t0,VIA_IER+VIA
FFFC3324 63888893
FFFC3328 000888B3
FFFC332C 0058A023
FFFC3330 00000013		nop                   ; make sure disable has time for effect
FFFC3334 00000013		nop
                        	; The function address table is compressed by assuming all the code is
                        		; located within the same 64kB block of memory. We're really saving bytes
                        		; here.
FFFC3338 00A50533		add		$a0,$a0,$a0         ; shift left one bit, assume add might be faster
FFFC333C FFFC38B7		ldwu  $t0,OSCallTbl[$a0]  ; get the low order 16 bits of the address
FFFC3340 A9488893
FFFC3344 00A888B3
FFFC3348 0008D283
FFFC334C 04028063		beqz  $t0,.badFunc
FFFC3350 00429293		sll		$t0,$t0,#4
FFFC3354 FFFC08B7		or    $t0,$t0,#$FFFC0000  ; add in the high order address bits
FFFC3358 00088893
FFFC335C 0112E2B3
FFFC3360 000280E7		call	[$t0]
FFFC3364 00012083		ldt		$ra,[$sp]
FFFC3368 00410113		add		$sp,$sp,#4
                        		
FFFC336C 0A0002B7			ldi				$t0,#$000180|(10<<24)				; enable timer3 interrupts after tm cycles
		stt				$t0,VIA_IER+VIA
FFFC3370 18028293
FFFC3374 FFDC08B7
FFFC3378 63888893
FFFC337C 000888B3
FFFC3380 0058A023
                        	
FFFC3384 7C10F073		csrrc $x0,#$7C1,#1        ; clear OS running semaphore
FFFC3388 00008067		ret
                        	.badFunc:
FFFC338C 00206513	  ldi   $a0,#E_Func
FFFC3390 00008067	  ret
                        	.busy:
FFFC3394 01B06513		ldi		$a0,#E_Busy
FFFC3398 00008067		ret
                        	  
                        	;------------------------------------------------------------------------------
                        	; Operating system ecall dispatcher.
                        	; On entry machine registers are selected.
                        	;------------------------------------------------------------------------------
FFFC339C 00000000	  align 1
                        	
                        	OSECALL:
                        		; Switch to map 61
FFFC33A0 42080013		di		16
FFFC33A4 18001373	  csrrw	$t1,#CSR_SATP,$x0
FFFC33A8 F04008B7	  and		$t1,$t1,#$f03fffff			; mask off asid
FFFC33AC FFF88893
FFFC33B0 01137333
FFFC33B4 0F4008B7	  or		$t1,$t1,#$0f400000			; set new asid
FFFC33B8 00088893
FFFC33BC 01136333
FFFC33C0 18031073		csrrw	$x0,#CSR_SATP,$t1				; set satp
FFFC33C4 7C10E2F3	  csrrs $t0,#$7C1,#1    ; set OS running semaphore
FFFC33C8 0012F293	  and		$t0,$t0,#1
FFFC33CC 08029863	  bnez	$t0,.busy
                        	  ; We reset the stack pointer at each call to the OS in case an error causes
                        	  ; it to be messed up.
FFFC33D0 F607F137		ldi		$sp,#$F607F000-4	; setup machine mode stack pointer
FFFC33D4 FFC10113
FFFC33D8 B89FF0EF	  call	LockOS
                        	  
FFFC33DC 10006293		ldi		$t0,#$100						; disable timer3 (time slice) interrupts
FFFC33E0 FFDC08B7		stt		$t0,VIA_IER+VIA
FFFC33E4 63888893
FFFC33E8 000888B3
FFFC33EC 0058A023
FFFC33F0 00000013		nop                   ; make sure disable has time for effect
FFFC33F4 00000013		nop
FFFC33F8 7C016073	csrrs	$x0,#CSR_REGSET,#2  ; get register sets
FFFC33FC 00056533		mov		$a0,$a0					; move user to machine
FFFC3400 0005E5B3		mov		$a1,$a1
FFFC3404 00066633		mov		$a2,$a2
FFFC3408 0006E6B3		mov		$a3,$a3
FFFC340C 00076733		mov		$a4,$a4
FFFC3410 0007E7B3		mov		$a5,$a5
FFFC3414 7C07F073		csrrc	$x0,#CSR_REGSET,#15 ; get back current registers for all
                        	  ; Enable other kinds of interrupts. While accessing the previous register set
                        	  ; we cannot be interrupted because the regset would be in flux.
FFFC3418 B89FF0EF	  call	UnlockOS
FFFC341C 02F52293	  slt   $t0,$a0,#47     
FFFC3420 02028A63		beqz  $t0,.badFunc
                        		; The function address table is compressed by assuming all the code is
                        		; located within the same 64kB block of memory. We're really saving bytes
                        		; here.
FFFC3424 00A50533		add		$a0,$a0,$a0     ; shift left one bit, assume add might be faster
FFFC3428 FFFC38B7		ldwu  $t0,OSEcallTbl[$a0] ; get the low order 16 bits of the address
FFFC342C AA088893
FFFC3430 00A888B3
FFFC3434 0008D283
FFFC3438 00028E63		beqz  $t0,.badFunc
FFFC343C 00429293		sll		$t0,$t0,#4
FFFC3440 FFFC08B7		or    $t0,$t0,#$FFFC0000  ; add in the high order address bits
FFFC3444 00088893
FFFC3448 0112E2B3
FFFC344C 000280E7		call	[$t0]
FFFC3450 0200006F		jmp		OSExit
                        	.badFunc:
FFFC3454 00206513	  ldi   $a0,#E_Func
FFFC3458 0180006F	  jmp   OSExit
                        	.busy:
FFFC345C 01B06513		ldi		$a0,#E_Busy
FFFC3460 0100006F		jmp		OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit from the operating system. All operating system routines use this
                        	; fragment of code to return. Return values are transferred to the previously
                        	; active register set.
                        	;------------------------------------------------------------------------------
FFFC3464 00000000	  align 1
FFFC3468 00000000
FFFC346C 00000000
                        	
                        	OSExit:
FFFC3470 AF1FF0EF	  call	LockOS
FFFC3474 00000013	  nop                       ; landing zone for interrupts
FFFC3478 00000013	  nop
                        		; Switch back to app map
FFFC347C 42080013		di		16
FFFC3480 18001373	  csrrw	$t1,#CSR_SATP,$x0
FFFC3484 F04008B7	  and		$t1,$t1,#$f03fffff		; mask off asid
FFFC3488 FFF88893
FFFC348C 01137333
FFFC3490 7C3013F3	  csrrw	$t2,#CSR_RSSTACK,$x0
FFFC3494 0063D393	  srl		$t2,$t2,#6
FFFC3498 03F3F393	  and		$t2,$t2,#$3f
FFFC349C 01639393	  sll		$t2,$t2,#22
FFFC34A0 00736333	  or		$t1,$t1,t2						; restore asid
FFFC34A4 18031073		csrrw	$x0,#CSR_SATP,$t1			; set satp
FFFC34A8 7C00E073		csrrs	$x0,#CSR_REGSET,#1		; get register sets
FFFC34AC 0005E5B3		mov		$a1,$a1							; move return values to user registers
FFFC34B0 00056533		mov		$a0,$a0
FFFC34B4 7C07F073		csrrc $x0,#CSR_REGSET,#15 ; restore register set selection
FFFC34B8 AE9FF0EF		call	UnlockOS
FFFC34BC 7C10F073		csrrc $x0,#$7C1,#1        ; clear OS running semaphore
                        		
FFFC34C0 1A0002B7		ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
FFFC34C4 18028293
FFFC34C8 FFDC08B7		stt		$t0,VIA_IER+VIA
FFFC34CC 63888893
FFFC34D0 000888B3
FFFC34D4 0058A023
FFFC34D8 30200073	mret
                        	
                        	;------------------------------------------------------------------------------
                        	; Time accounting.
                        	; Update the length of time the task has been running.
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB
                        	; Modifies:
                        	;		t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	AccountTime:
                        	;	csrrw	$t3,#$741,$x0					; get high time
                        	;	csrrw	$t2,#$701,$x0					; get low time
                        	;	csrrw	$t4,#$741,$x0
                        	;	bne		$t3,$t4,.again
FFFC34DC FFC10113		sub		$sp,$sp,#4
FFFC34E0 00112023		stt		$ra,[$sp]
FFFC34E4 D6CFF0EF		call	ViaTime
FFFC34E8 2CA4AC23		stt		$a0,TCBEndTick[$s1]
FFFC34EC 2D04AE03		ldt		$t3,TCBStartTick[$s1]
FFFC34F0 41C38EB3		sub		$t4,$t2,$t3						; end - start
FFFC34F4 3004AF03		ldt		$t5,TCBTicks[$s1]
FFFC34F8 01DF0F33		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC34FC 31E4A023		stt		$t5,TCBTicks[$s1]
FFFC3500 00012083		ldt		$ra,[$sp]
FFFC3504 00410113		add		$sp,$sp,#4
FFFC3508 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; UpdateMsgFields
                        	;    Place message data in target address by calling PeekMsg().
                        	;
                        	; Parameters:
                        	;   $a0 = target tid
                        	;   $t2 = TCB status (updated)
                        	;   $s2 = target TCB to update
                        	; Modifies:
                        	;   $a1,$a2,$a3,$a4,$a5,$t3,$t4
                        	;------------------------------------------------------------------------------
FFFC350C 00000000	  align 1
                        	
                        	UpdateMsgFields:
FFFC3510 FF810113	  sub 	$sp,$sp,#8
FFFC3514 00112023	  stt   $ra,[$sp]
FFFC3518 00912223	  stt		$s1,4[$sp]
FFFC351C 2C894383	  ldbu	$t2,TCBStatus[$s2]
FFFC3520 0083FE13	  and   $t3,$t2,#TS_WAITMSG
FFFC3524 040E0863	  beqz  $t3,.notWaiting
                        	;  call	DumpReadyQueue
                        	;  call	DumpTimeoutList
                        	;.0001:
                        	;	bra		.0001
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC3528 00B06E13		ldi		$t3,#E_NoMsg						; setup to return E_NoMsg
FFFC352C 09C92823		stt		$t3,TCBxA0[$s2]					; in a0
FFFC3530 0043FE13		and		$t3,$t2,#TS_MSGRDY
FFFC3534 020E0663		beqz	$t3,.noMsg
FFFC3538 0005EEB3		mov   $t4,$a1                 ; save $a1
FFFC353C 09892583		ldt		$a1,TCBxA1[$s2]					; user a1 (x20)
FFFC3540 0A092603		ldt		$a2,TCBxA2[$s2]					; user a2 (x20)
FFFC3544 0A892683		ldt		$a3,TCBxA3[$s2]					; user a3 (x20)
FFFC3548 0B092703		ldt		$a4,TCBxA4[$s2]					; user a4 (x20)
FFFC354C 0B892783		ldt		$a5,TCBxA5[$s2]					; user a5 (x20)
FFFC3550 3C1000EF		call  PeekMsg
FFFC3554 000EE5B3		mov   $a1,$t4                 ; restore $a1
FFFC3558 00006E13		ldi		$t3,#E_Ok						    ; setup to return E_Ok
FFFC355C 09C92823		stt		$t3,TCBxA0[$s2]					; in a0
                        	.noMsg:
FFFC3560 A01FF0EF		call	LockOS
FFFC3564 2C894383	  ldbu	$t2,TCBStatus[$s2]
FFFC3568 FF33F393		and		$t2,$t2,#~(TS_WAITMSG|TS_MSGRDY)  ; mask out message ready status
	stb		$t2,TCBStatus[$s2]
FFFC356C 2C790423
FFFC3570 A31FF0EF		call	UnlockOS
                        	.notWaiting:
FFFC3574 00012083	  ldt   $ra,[$sp]
FFFC3578 00412483	  ldt		$s1,4[$sp]
FFFC357C 00810113	  add   $sp,$sp,#8
FFFC3580 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
                        	; Passing a time of zero or less causes the function to return right away.
                        	;
                        	; Parameters:
                        	;		$a1 = length of time to sleep (must be >= 0)
                        	; Returns:
                        	;		$v0 = E_Ok
                        	;   $v1 = 1 = context switched, 0 = same context
                        	;------------------------------------------------------------------------------
FFFC3584 00000000	  align 1
FFFC3588 00000000
FFFC358C 00000000
                        	
                        	ISleep:
FFFC3590 FF010113	  sub 	$sp,$sp,#16
FFFC3594 00112023	  stt   $ra,[$sp]
FFFC3598 00912223	  stt   $s1,4[$sp]
FFFC359C 01212423	  stt   $s2,8[$sp]
FFFC35A0 01312623	  stt		$s3,12[$sp]
FFFC35A4 0A05C063		bltz	$a1,.xit
                        		
FFFC35A8 7C201573	  csrrw $a0,#CSR_TASKID,$x0
                        	;	beqz  $a0,.xit
FFFC35AC 00251493		sll		$s1,$a0,#2
FFFC35B0 FF0008B7		ldt		$s1,TCBPtrs[$s1]
FFFC35B4 50088893
FFFC35B8 009888B3
FFFC35BC 0008A483
FFFC35C0 001008B7		and		$s1,$s1,#$FFC00
FFFC35C4 C0088893
FFFC35C8 0114F4B3
FFFC35CC 0004E933		mov   $s2,$s1               ; for bad pointer processing
FFFC35D0 00058863		beqz	$a1,.0001             ; zero timeout?
FFFC35D4 0004E533		mov		$a0,$s1
FFFC35D8 238010EF		call	RemoveFromReadyQueue
FFFC35DC 3A4010EF		call	InsertIntoTimeoutList	; a1 = timeout
                        	.0001:
FFFC35E0 981FF0EF		call	LockOS
FFFC35E4 2C84C503		ldbu	$a0,TCBStatus[$s1]		; flag task as no longer running
FFFC35E8 F7F57513		and		$a0,$a0,#~TS_RUNNING
FFFC35EC 2CA48423		stb		$a0,TCBStatus[$s1]
FFFC35F0 9B1FF0EF		call	UnlockOS
                        	
FFFC35F4 EE9FF0EF		call	AccountTime						; uses s1
FFFC35F8 9C9FF0EF		call	SelectTaskToRun
FFFC35FC 00056933	  mov   $s2,$a0    						; $s2 = $a0 = TCB pointer
FFFC3600 961FF0EF	  call	LockOS
FFFC3604 2C894383		ldbu	$t2,TCBStatus[$s2]		; x2 = incoming status
FFFC3608 0803E393		or		$t2,$t2,#TS_RUNNING	  ; set status = running
FFFC360C 2C790423		stb   $t2,TCBStatus[$s2]
FFFC3610 991FF0EF		call	UnlockOS
FFFC3614 30892E03		ldt		$t3,TCBException[$s2]	;
FFFC3618 000E0A63		beqz	$t3,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC361C 09C92823		stt		$t3,TCBxA0[$s2]						; r1 = exception
FFFC3620 30092423		stt		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC3624 02D06E13		ldi		$t3,#45
FFFC3628 09C92C23		stt		$t3,TCBxA1[$s2]						; r2 = 45
                        	.noException:
FFFC362C 00006593		ldi   $a1,#0
FFFC3630 01248663		beq		$s1,$s2,.noCtxSwitch	; incoming and outgoing contexts the same?
FFFC3634 ABDFF0EF		call	SwapContext
FFFC3638 00106593		ldi   $a1,#1
                        	.noCtxSwitch:
                        	;	call  UpdateMsgFields       ; must be after context is set
FFFC363C C14FF0EF		call	ViaTime
FFFC3640 2CA4A823		stt		$a0,TCBStartTick[$s1]
                        	.xit:
                        	;	mov		$a0,$s1
                        	;	call	PutHexWord
                        	;	ldi		$a0,#' '
                        	;	call	Putch
FFFC3644 00006513		ldi   $a0,#E_Ok
FFFC3648 00012083	  ldt   $ra,[$sp]
FFFC364C 00412483	  ldt   $s1,4[$sp]
FFFC3650 00812903	  ldt   $s2,8[$sp]
FFFC3654 00C12983	  ldt		$s3,12[$sp]
FFFC3658 01010113	  add   $sp,$sp,#16
FFFC365C 00008067		ret
                        	
                        		align	16                        	
                        	FMTK_Sleep:
FFFC3660 F31FF06F	  jmp  	ISleep
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR. This routine will not
                        	; be invoked if the operating system is active.
                        	; Does not return anything.
                        	; The user mode task may be switched to the highest priority task.
                        	;------------------------------------------------------------------------------
FFFC3664 00000000	  align 1
FFFC3668 00000000
FFFC366C 00000000
                        	
                        	SchedulerIRQ:
                        		; See if the OS was interrupted.
FFFC3670 7C101573		csrrw $a0,#$7C1,$x0   ; Is the OS running?
FFFC3674 00157513		and   $a0,$a0,#1
FFFC3678 00050463		beqz  $a0,.noOS
FFFC367C 00008067		ret                   ; refuse to continue this function
                        	.noOS:
FFFC3680 FEC10113		sub		$sp,$sp,#20
FFFC3684 00112023		stt		$ra,[$sp]
FFFC3688 00912223		stt   $s1,4[$sp]
FFFC368C 01212423		stt   $s2,8[$sp]
FFFC3690 01312623		stt		$s3,12[$sp]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
FFFC3694 8CDFF0EF		call	LockOS
                        	
                        	.0001:
FFFC3698 FFDC08B7		ldt		$s1,TMOQ+$200
FFFC369C 60088893
FFFC36A0 000888B3
FFFC36A4 0008A483
FFFC36A8 FFDC08B7		stt		$x0,TMOQ+$200
FFFC36AC 60088893
FFFC36B0 000888B3
FFFC36B4 0008A023
FFFC36B8 08048463		beqz	$s1,.0002
FFFC36BC 00006513		ldi		$a0,#0
                        	.0004:
FFFC36C0 0014F993		and		$s3,$s1,#1
FFFC36C4 06098463		beqz	$s3,.0003
FFFC36C8 FF0008B7		ldt		$t0,TCBPtrs[$a0]									; $t0 = TCB pointer
FFFC36CC 50088893
FFFC36D0 00A888B3
FFFC36D4 0008A283
FFFC36D8 000808B7		and		$t0,$t0,#$7FC00										; help ensure valid pointer
FFFC36DC C0088893
FFFC36E0 0112F2B3
FFFC36E4 0002A383		ldt		$t2,[$t0]													; check magic number
FFFC36E8 205448B7		xor		$t2,$t2,#TCB_MAGIC
FFFC36EC 34288893
FFFC36F0 0113C3B3
FFFC36F4 02039C63		bnez	$t2,.0003													; not pointing to a TCB? Go to next
FFFC36F8 2C82C383		ldbu	$t2,TCBStatus[$t0]
FFFC36FC FE73F393		and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG) ; no longer timing out or waiting
	stb		$t2,TCBStatus[$t0]
FFFC3700 2C728423
FFFC3704 2DC010EF		call	RemoveFromTimeoutList
                        		; Remove task from task queue of mailbox
FFFC3708 00A12823		stt		$a0,16[$sp]
FFFC370C 0002E533		mov		$a0,$t0
FFFC3710 891FF0EF		call	UnlockOS
FFFC3714 4DC000EF		call  MbxRemoveTask
FFFC3718 849FF0EF		call	LockOS
FFFC371C 885FF0EF		call	UnlockOS
FFFC3720 010010EF		call	InsertIntoReadyQueue
FFFC3724 83DFF0EF		call	LockOS
FFFC3728 01012503		ldt		$a0,16[$sp]
                        	.0003:
FFFC372C 0014D493		srl		$s1,$s1,#1
FFFC3730 00048863		beqz	$s1,.0002
FFFC3734 00450513		add		$a0,$a0,#4
FFFC3738 08006993		ldi		$s3,#128
FFFC373C F93562E3		bltu	$a0,$s3,.0004
                        	
                        	.0002:
FFFC3740 FFDC08B7		ldt		$s1,TMOQ+$204
FFFC3744 60488893
FFFC3748 000888B3
FFFC374C 0008A483
FFFC3750 FFDC08B7		stt		$x0,TMOQ+$204
FFFC3754 60488893
FFFC3758 000888B3
FFFC375C 0008A023
FFFC3760 08048463		beqz	$s1,.0007
FFFC3764 02006513		ldi		$a0,#32
                        	.0005:
FFFC3768 0014F993		and		$s3,$s1,#1
FFFC376C 06098463		beqz	$s3,.0006
FFFC3770 FF0008B7		ldt		$t0,TCBPtrs[$a0]									; $t0 = TCB pointer
FFFC3774 50088893
FFFC3778 00A888B3
FFFC377C 0008A283
FFFC3780 000808B7		and		$t0,$t0,#$7FC00										; help ensure valid pointer
FFFC3784 C0088893
FFFC3788 0112F2B3
FFFC378C 0002A383		ldt		$t2,[$t0]													; check magic number
FFFC3790 205448B7		xor		$t2,$t2,#TCB_MAGIC
FFFC3794 34288893
FFFC3798 0113C3B3
FFFC379C 02039C63		bnez	$t2,.0006													; not pointing to a TCB? Go to next
FFFC37A0 2C82C383		ldbu	$t2,TCBStatus[$t0]
FFFC37A4 FE73F393		and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG) ; no longer timing out or waiting
	stb		$t2,TCBStatus[$t0]
FFFC37A8 2C728423
FFFC37AC 234010EF		call	RemoveFromTimeoutList
                        		; Remove task from task queue of mailbox
FFFC37B0 00A12823		stt		$a0,16[$sp]
FFFC37B4 0002E533		mov		$a0,$t0
FFFC37B8 FE8FF0EF		call	UnlockOS
FFFC37BC 434000EF		call  MbxRemoveTask
FFFC37C0 FA0FF0EF		call	LockOS
FFFC37C4 FDCFF0EF		call	UnlockOS
FFFC37C8 769000EF		call	InsertIntoReadyQueue
FFFC37CC F94FF0EF		call	LockOS
FFFC37D0 01012503		ldt		$a0,16[$sp]
                        	.0006:
FFFC37D4 0014D493		srl		$s1,$s1,#1
FFFC37D8 00048863		beqz	$s1,.0007
FFFC37DC 00450513		add		$a0,$a0,#4
FFFC37E0 10006993		ldi		$s3,#256
FFFC37E4 F93562E3		bltu	$a0,$s3,.0005
                        	.0007:
                        		; Clear timeout flags
FFFC37E8 FFDC08B7		stt		$x0,TMOQ+$200
FFFC37EC 60088893
FFFC37F0 000888B3
FFFC37F4 0008A023
FFFC37F8 FFDC08B7		stt		$x0,TMOQ+$200
FFFC37FC 60088893
FFFC3800 000888B3
FFFC3804 0008A023
                        	/*
	ldt		$a0,TimeoutList
	beqz	$a0,.toDone
	ldi		$t1,#512<<LOG_PGSZ			; valid tid?
	bgeu	$a0,$t1,.toDone
	ldt		$t1,TCBTimeout[$a0]
	beqz	$t1,.rmvFromTol
	sub		$t1,$t1,#1			; decrement timeouts for tasks on timeout list
	stt		$t1,TCBTimeout[$a0]
	bra		.toDone
.rmvFromTol:
	ldbu	$t2,TCBStatus[$a0]
	and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG) ; no longer timing out or waiting
	stb		$t2,TCBStatus[$a0]
	; Remove task from task queue of mailbox
	call	UnlockOS
	call  MbxRemoveTask
	call	LockOS
	; Remove task from timeout list
	ldt		$s3,TCBNext[$a0]
	stt		$s3,TimeoutList
	stt		$x0,TCBNext[$a0]
	call	UnlockOS
	call	InsertIntoReadyQueue
	call	LockOS
	beqz	$s3,.toDone						; list empty?
	bra		.0001
*/
                        	.toDone:
FFFC3808 F98FF0EF		call	UnlockOS
                        		
FFFC380C 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC3810 00A51493	sll   $s1,$a0,#LOG_PGSZ
                        	; Might need the following if the external timer isn't used.
                        	;	csrrw	$v0,#$701,$x0					; get the time
                        	;	add		$v0,$v0,#600000				; wait 600,000 cycles @20MHz (30ms)
                        	;	csrrw	$x0,#$321,$v0					; set next interrupt time
FFFC3814 CC9FF0EF		call	AccountTime
FFFC3818 F48FF0EF		call	LockOS
FFFC381C 2C84CF03		ldbu	$t5,TCBStatus[$s1]
FFFC3820 020F6F13		or		$t5,$t5,#TS_PREEMPT
FFFC3824 F7FF7F13		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC3828 2DE48423		stb		$t5,TCBStatus[$s1]
FFFC382C F74FF0EF		call	UnlockOS
                        		; The ready queue was just updated, there could be new tasks
                        		; ready to run.
FFFC3830 F90FF0EF		call	SelectTaskToRun
FFFC3834 02050863		beqz	$a0,.noCtxSwitch
FFFC3838 00056933	  mov   $s2,$a0
FFFC383C F24FF0EF		call	LockOS
FFFC3840 2C894E03		lbu		$t3,TCBStatus[$s2]	; t3 = incoming status
FFFC3844 081E6393		or		$t2,$t3,#TS_RUNNING|TS_READY	; status = running
FFFC3848 FDF3F393		and   $t2,$t2,#~TS_PREEMPT
FFFC384C 2C792423		stt		$t2,TCBStatus[$s2]
FFFC3850 F50FF0EF		call	UnlockOS
FFFC3854 30892E03		ldt		$t3,TCBException[$s2]	;
FFFC3858 000E0263		beqz	$t3,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
FFFC385C 01248463		beq		$s1,$s2,.noCtxSwitch
FFFC3860 891FF0EF		call	SwapContext
                        	.noCtxSwitch:
                        	;	call  UpdateMsgFields       ; must be after context set
FFFC3864 9ECFF0EF		call	ViaTime
FFFC3868 2CA4A823		stt		$a0,TCBStartTick[$s1]
FFFC386C 00012083		ldt		$ra,[$sp]
FFFC3870 00412483		ldt   $s1,4[$sp]
FFFC3874 00812903		ldt   $s2,8[$sp]
FFFC3878 00C12983		ldt		$s3,12[$sp]
FFFC387C 01010113		add		$sp,$sp,#16
FFFC3880 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready queue. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;   $a1 = app id
                        	;		$a2 = memory required (task's local memory)
                        	;		$a3 = start pc (usually $400)
                        	;   $a4 = register set, operating mode
                        	;	Modifies:
                        	;	Returns:
                        	;		$a0 = E_Ok if successful
                        	;		$a1 = tid of started task if successful
                        	;------------------------------------------------------------------------------
FFFC3884 00000000	  align 1
FFFC3888 00000000
FFFC388C 00000000
                        	
                        	FMTK_StartTask:
                        	IStartTask:
FFFC3890 FE810113	  sub 	$sp,$sp,#24
FFFC3894 00112023	  stt   $ra,[$sp]
FFFC3898 00912223	  stt   $s1,4[$sp]
FFFC389C 01212423	  stt   $s2,8[$sp]
FFFC38A0 01312623	  stt   $s3,12[$sp]
FFFC38A4 01412823	  stt   $s4,16[$sp]
FFFC38A8 01512A23	  stt   $s5,20[$sp]
FFFC38AC 0005E9B3	  mov   $s3,$a1       ; $s3 = app id
FFFC38B0 00066933	  mov   $s2,$a2       ; $s2 = memory required
FFFC38B4 0006EAB3	  mov   $s5,$a3       ; $s5 = start address
FFFC38B8 40006513	  ldi   $a0,#1024     ; TCB is 1kB
FFFC38BC C74FE0EF	  call  PAMAlloc      ; allocate storage for the TCB
FFFC38C0 1E054E63		bltz	$a0,.err
FFFC38C4 250000EF		call	MapTCBStorage
                        	
                        		; Initialize OBJECT fields
                        		; More todo here yet.
FFFC38C8 205442B7		ldi		$t0,#TCB_MAGIC
FFFC38CC 34228293
FFFC38D0 00552023		stt		$t0,[$a0]
FFFC38D4 40006293		ldi		$t0,#1024
FFFC38D8 00552423		stt		$t0,OBJSize[$a0]
FFFC38DC 00006293		ldi		$t0,#OST_WHITE
FFFC38E0 00550C23		stb		$t0,OBJState[$a0]
FFFC38E4 00050CA3		stb		$x0,OBJScavcnt[$a0]
FFFC38E8 02052823		stt		$x0,OBJFinalizer[$a0]
                        	
FFFC38EC 00056A33		mov   $s4,$a0
FFFC38F0 E70FF0EF		call	LockOS
FFFC38F4 4FD000EF		call	AllocTCBId
FFFC38F8 20054263		bltz	$a0,.noTcbId
FFFC38FC 32AA1C23	  stw   $a0,TCBtid[$s4]
FFFC3900 00251513	  sll		$a0,$a0,#2
FFFC3904 FF0008B7	  stt		$s4,TCBPtrs[$a0]
FFFC3908 50088893
FFFC390C 00A888B3
FFFC3910 0148A023
FFFC3914 001008B7		and		$s4,$s4,#$FFC00
FFFC3918 C0088893
FFFC391C 011A7A33
FFFC3920 E80FF0EF	  call	UnlockOS
FFFC3924 000A64B3	  mov   $s1,$s4         ; $s1 = pointer to TCB
                        	;	call	FreeAll
                        	;	call	MapOSPages			; Map OS pages into address space
FFFC3928 0009E533	  mov   $a0,$s3         ; $a0 = app id
FFFC392C 34AA1123	  stw   $a0,TCBappid[$s4]
FFFC3930 451000EF	  call	DumpACBPtrs
                        	  
FFFC3934 00251513	  sll   $a0,$a0,#2
FFFC3938 FF0008B7	  ldt		$a0,ACBPtrs[$a0]
FFFC393C 60088893
FFFC3940 00A888B3
FFFC3944 0008A503
FFFC3948 001008B7	  and		$a0,$a0,#$FFC00
FFFC394C C0088893
FFFC3950 01157533
FFFC3954 3C450503	  ldb   $a0,ACBmid[$a0]
FFFC3958 34AA1023	stw   $a0,TCBmid[$s4] ; record the mid
FFFC395C 954FE0EF		call	AllocStack
FFFC3960 16050263		beqz  $a0,.AllocStackErr
FFFC3964 200008B7		or		$t0,$a0,#$200003FC	; set stack pointer
FFFC3968 3FC88893
FFFC396C 011562B3
FFFC3970 0454A823		stt		$t0,TCBxSP[$s1]
FFFC3974 2D54A023		stt		$s5,TCBepc[$s1]	; address task will begin at
FFFC3978 00106293		ldi		$t0,#TS_READY
FFFC397C 2C548423		stb		$t0,TCBStatus[$s1]
FFFC3980 00206293		ldi		$t0,#2					; normal execution priority
FFFC3984 2C5484A3		stb		$t0,TCBPriority[$s1]
FFFC3988 3204A023		stt   $x0,TCBTimeout[$s1]
                        	
                        		; leave segment base at $0, flat memory model
FFFC398C 00606293		ldi		$t0,#6							; read,write
FFFC3990 00299513		sll		$a0,$s3,#2					; $a0 = appid shifted into place
FFFC3994 0055000D		mvseg	$x0,$a0,$t0
FFFC3998 00150513		add		$a0,$a0,#1
FFFC399C 0055000D		mvseg	$x0,$a0,$t0
FFFC39A0 00150513		add		$a0,$a0,#1
FFFC39A4 0055000D		mvseg	$x0,$a0,$t0
FFFC39A8 00150513		add		$a0,$a0,#1
FFFC39AC 0055000D		mvseg	$x0,$a0,$t0
                        		; Set bounds registers
FFFC39B0 FFF06293		ldi		$t0,#-1
FFFC39B4 08056513		or		$a0,$a0,#128
FFFC39B8 0FC57513		and		$a0,$a0,#$FC
FFFC39BC 0055000D		mvseg	$x0,$a0,$t0
FFFC39C0 00150513		add		$a0,$a0,#1
FFFC39C4 0055000D		mvseg	$x0,$a0,$t0
FFFC39C8 00150513		add		$a0,$a0,#1
FFFC39CC 0055000D		mvseg	$x0,$a0,$t0
FFFC39D0 00150513		add		$a0,$a0,#1
FFFC39D4 0055000D		mvseg	$x0,$a0,$t0
                        	
                        		; Clear time accounting fields
FFFC39D8 3004A023		stt		$x0,TCBTicks[$s1]
FFFC39DC 2C04A823		stt		$x0,TCBStartTick[$s1]
FFFC39E0 2C04AC23		stt		$x0,TCBEndTick[$s1]
                        	
                        	;	srl		$a0,$s1,#LOG_TCBSZ	; need the tid again
FFFC39E4 3404A423	  stt   $x0,TCBMbxNext[$s1]
FFFC39E8 3404A823	  stt   $x0,TCBMbxPrev[$s1]
FFFC39EC 0004E533	  mov   $a0,$s1							; a0 = tid
FFFC39F0 03F77293	  and   $t0,$a4,#63
FFFC39F4 2C548623	  stb   $t0,TCBRegset[$s1]
FFFC39F8 30077293	  and   $t0,$a4,#$300
FFFC39FC 30006313	  ldi		$t1,#$300
FFFC3A00 00628C63	  beq		$t0,$t1,.mm
FFFC3A04 2CC48283	  ldb		$t0,TCBRegset[$s1]
FFFC3A08 03406313	  ldi		$t1,#52
FFFC3A0C 0062F663	  bgeu	$t0,$t1,.mm
FFFC3A10 00806293	  ldi		$t0,#$08						; enable interrupts, user mode
FFFC3A14 00000463	  bra		.mm1
                        	.mm:
FFFC3A18 03806293		ldi		$t0,#$38						; enable interrupts, machine mode
                        	.mm1:
FFFC3A1C 34548223	  stb   $t0,TCBOpMode[$s1]
FFFC3A20 340482A3	  stb		$x0,TCBImMask[$s1]
FFFC3A24 2C0486A3	  stb   $x0,TCBHasFocus[$s1]
FFFC3A28 000008B7	  stt   $x0,IOF_NEXT[$s1]
FFFC3A2C 37188893
FFFC3A30 009888B3
FFFC3A34 0008A023
FFFC3A38 000008B7	  stt   $x0,IOF_PREV[$s1]
FFFC3A3C 37288893
FFFC3A40 009888B3
FFFC3A44 0008A023
FFFC3A48 FF0008B7	  ldt   $t0,TaskNum
FFFC3A4C 22088893
FFFC3A50 000888B3
FFFC3A54 0008A283
FFFC3A58 3454AC23	  stt   $t0,TCBTaskNum[$s1]
FFFC3A5C 00128293	  add   $t0,$t0,#1
FFFC3A60 FF0008B7	  stt   $t0,TaskNum
FFFC3A64 22088893
FFFC3A68 000888B3
FFFC3A6C 0058A023
FFFC3A70 FFF28293	  sub   $t0,$t0,#1
FFFC3A74 00029E63	  bnez  $t0,.notIdleTask
FFFC3A78 00A55513	  srl		$a0,$a0,#LOG_PGSZ
FFFC3A7C FF0018B7	  stw   $a0,IdleTaskId
FFFC3A80 C2A88893
FFFC3A84 000888B3
FFFC3A88 00A89023
FFFC3A8C 00A51513	  sll		$a0,$a0,#LOG_PGSZ
                        	.notIdleTask:
FFFC3A90 4A1000EF		call	InsertIntoReadyQueue
FFFC3A94 3384D583		ldwu	$a1,TCBtid[$s1]
FFFC3A98 00006513		ldi   $a0,#E_Ok
                        	.xit:
FFFC3A9C 00012083		ldt   $ra,[$sp]
FFFC3AA0 00412483	  ldt   $s1,4[$sp]
FFFC3AA4 00812903	  ldt   $s2,8[$sp]
FFFC3AA8 00C12983	  ldt   $s3,12[$sp]
FFFC3AAC 01012A03	  ldt   $s4,16[$sp]
FFFC3AB0 01412A83	  ldt   $s5,20[$sp]
FFFC3AB4 01810113		add   $sp,$sp,#24
FFFC3AB8 00008067	  ret
                        	.err:
FFFC3ABC 04706513	  ldi   $a0,#E_NoMem
FFFC3AC0 FC000EE3	  bra   .xit
                        	.AllocStackErr:
FFFC3AC4 C9CFF0EF		call	LockOS
FFFC3AC8 338A5503		ldwu	$a0,TCBtid[$s4]
FFFC3ACC 00251293		sll		$t0,$a0,#2
FFFC3AD0 FF0008B7		stt		$x0,TCBPtrs[$t0]
FFFC3AD4 50088893
FFFC3AD8 005888B3
FFFC3ADC 0008A023
FFFC3AE0 371000EF		call	FreeTCBId
FFFC3AE4 CBCFF0EF		call	UnlockOS
FFFC3AE8 000A6533		mov		$a0,$s4
FFFC3AEC B14FE0EF		call	PAMFree
FFFC3AF0 054000EF		call	UnmapTCBStorage
FFFC3AF4 04706513		ldi		$a0,#E_NoMem
FFFC3AF8 FA0002E3		bra		.xit
                        	.noTcbId:
FFFC3AFC CA4FF0EF		call	UnlockOS
FFFC3B00 000A6533		mov		$a0,$s4
FFFC3B04 AFCFE0EF		call	PAMFree
FFFC3B08 03C000EF		call	UnmapTCBStorage
FFFC3B0C 04506513		ldi		$a0,#E_NoMoreTcbs
FFFC3B10 F80006E3		bra		.xit
                        	
                        	; Map the TCB storage into maps 60 to 63
                        	MapTCBStorage:
FFFC3B14 00A55293		srl		$t0,$a0,#LOG_PGSZ
FFFC3B18 003C0337		ldi		$t1,#60<<16
FFFC3B1C 00030313
FFFC3B20 00536333		or		$t1,$t1,$t0
FFFC3B24 0262800D		mvmap	$x0,$t0,$t1
FFFC3B28 00130313		add		$t1,$t1,#1
FFFC3B2C 0262800D		mvmap	$x0,$t0,$t1
FFFC3B30 00130313		add		$t1,$t1,#1
FFFC3B34 0262800D		mvmap	$x0,$t0,$t1
FFFC3B38 00130313		add		$t1,$t1,#1
FFFC3B3C 0262800D		mvmap	$x0,$t0,$t1
FFFC3B40 00008067		ret
                        	
                        	; Remove TCB storage from maps 60 to 63
                        	UnmapTCBStorage:
FFFC3B44 00AA5293		srl		$t0,$s4,#LOG_PGSZ
FFFC3B48 003C0337		ldi		$t1,#60<<16
FFFC3B4C 00030313
FFFC3B50 00536333		or		$t1,$t1,$t0
FFFC3B54 00006293		ldi		$t0,#0
FFFC3B58 0262800D		mvmap	$x0,$t0,$t1
FFFC3B5C 00130313		add		$t1,$t1,#1
FFFC3B60 0262800D		mvmap	$x0,$t0,$t1
FFFC3B64 00130313		add		$t1,$t1,#1
FFFC3B68 0262800D		mvmap	$x0,$t0,$t1
FFFC3B6C 00130313		add		$t1,$t1,#1
FFFC3B70 0262800D		mvmap	$x0,$t0,$t1
FFFC3B74 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
FFFC3B78 00000000		align	1
FFFC3B7C 00000000
                        	
                        	FMTK_ExitTask:
                        		
FFFC3B80 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC3B84 00A51593	sll		$a1,$a0,#LOG_PGSZ
                        		; fall through to KillTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
FFFC3B88 00000000	  align 1
FFFC3B8C 00000000
                        	
                        	FMTK_KillTask:
FFFC3B90 00259593		sll		$a1,$a1,#2
FFFC3B94 FF0008B7		ldt		$a1,TCBPtrs[$a1]
FFFC3B98 50088893
FFFC3B9C 00B888B3
FFFC3BA0 0008A583
FFFC3BA4 001008B7		and		$a1,$a1,#$FFC00
FFFC3BA8 C0088893
FFFC3BAC 0115F5B3
FFFC3BB0 3585A283		ldt   $t0,TCBTaskNum[$a1]
FFFC3BB4 02028863		beqz	$t0,.immortal		    ; tid #0 is immortal (the system)
FFFC3BB8 04006293		ldi		$t0,#TS_UNDEAD			; flag task as undead
FFFC3BBC 2C558423		stb		$t0,TCBStatus[$a1]
                        		; Move the task to the undead queue, it will no longer be selected by the
                        		; scheduler.
FFFC3BC0 0005E533		mov		$a0,$a1
FFFC3BC4 FFC10113		sub		$sp,$sp,#4
FFFC3BC8 00112023		stt		$ra,[$sp]
FFFC3BCC 445000EF		call	RemoveFromReadyQueue
FFFC3BD0 00706293		ldi   $t0,#UNDEADQ
FFFC3BD4 2C5584A3		stb   $t0,TCBPriority[$a1]
FFFC3BD8 359000EF		call	InsertIntoReadyQueue
FFFC3BDC 00012083		ldt		$ra,[$sp]
FFFC3BE0 00410113		add		$sp,$sp,#4
                        	;	ldbu  $a0,TCBmid[$a1]
                        	;	call	FreeAll							; free all the memory associated with the task
                        	.immortal:
FFFC3BE4 00006513		ldi		$a0,#E_Ok
FFFC3BE8 00008067		ret
                        	
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.r5a",34
                        		code  18 bits
                        	;------------------------------------------------------------------------------
                        	; Remove the task from the list of tasks waiting at the mailbox.
                        	;
                        	; Parameters:
                        	;		$a0 = task id (TCB pointer)
                        	;------------------------------------------------------------------------------
FFFC3BEC 00000000	  align  1
                        	
                        	MbxRemoveTask:
FFFC3BF0 FE810113		sub		$sp,$sp,#24
FFFC3BF4 00912023		stt		$s1,[$sp]
FFFC3BF8 00512223		stt		$t0,4[$sp]
FFFC3BFC 00612423		stt		$t1,8[$sp]
FFFC3C00 00712623		stt		$t2,12[$sp]
FFFC3C04 00A12823		stt   $a0,16[$sp]
FFFC3C08 00112A23		stt		$ra,20[$sp]
FFFC3C0C B54FF0EF		call	LockOS
FFFC3C10 35052283		ldt   $t0,TCBMbxPrev[$a0]
FFFC3C14 34852303		ldt   $t1,TCBMbxNext[$a0]
FFFC3C18 00028863		beqz  $t0,.atHead
FFFC3C1C 3462A423		stt   $t1,TCBMbxNext[$t0]
FFFC3C20 34532823	  stt   $t0,TCBMbxPrev[$t1]
FFFC3C24 04000863	  bra   .xit
                        	.atHead:
FFFC3C28 2CA51283		ldw		$t0,TCBWaitMbx[$a0]		; get mailbox handle
FFFC3C2C 04505463		ble	  $t0,$x0,.xit  		    ; handle good?
                        		
FFFC3C30 0082D393	    srl   $t2,$t0,#8        ; extract collection index
FFFC3C34 00239393	    sll   $t2,$t2,#2
FFFC3C38 FF0018B7	    ldt   $t2,MbxBlockPtr[$t2]
FFFC3C3C 0A088893
FFFC3C40 007888B3
FFFC3C44 0008A383
FFFC3C48 0FF2F293	    and   $t0,$t0,#$FF
FFFC3C4C 00229293	    sll   $t0,$t0,#2
FFFC3C50 0072E2B3	    or    $t0,$t0,$t2
                        	
FFFC3C54 0042A303		ldt		$t1,MBX_TQHEAD[$t0]		; get waiting task list
FFFC3C58 00030A63		beqz  $t1,.tqEmpty
FFFC3C5C 00A31863		bne		$t1,$a0,.tqEmpty
FFFC3C60 34852303		ldt		$t1,TCBMbxNext[$a0]
FFFC3C64 0062A223		stt		$t1,MBX_TQHEAD[$t0]
FFFC3C68 34032823		stt		$x0,TCBMbxPrev[$t1]
                        	.tqEmpty:
FFFC3C6C 34052823		stt   $x0,TCBMbxPrev[$a0]
FFFC3C70 34052423		stt   $x0,TCBMbxNext[$a0]
                        	.xit:
FFFC3C74 B2CFF0EF	  call	UnlockOS
FFFC3C78 00012483		ldt		$s1,[$sp]
FFFC3C7C 00412283		ldt		$t0,4[$sp]
FFFC3C80 00812303		ldt		$t1,8[$sp]
FFFC3C84 00C12383		ldt		$t2,12[$sp]
FFFC3C88 01012503		ldt   $a0,16[$sp]
FFFC3C8C 01412083		ldt		$ra,20[$sp]
FFFC3C90 01810113		add		$sp,$sp,#24
FFFC3C94 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; FMTK_AllocMbx
                        	;   Allocate a mailbox. Get the mailbox off the free list. If there are no
                        	; free mailboxes then allocate a block of new mailboxes.
                        	;
                        	; Parameters:
                        	;		$a1 = app id of owner
                        	; Returns:
                        	;		$a0 = E_Ok
                        	;   $a1 = mailbox handle
                        	;------------------------------------------------------------------------------
                        	FMTK_AllocMbx:
FFFC3C98 FF0018B7	  ldt   $a0,FreeMbx
FFFC3C9C C0888893
FFFC3CA0 000888B3
FFFC3CA4 0008A503
FFFC3CA8 0A051A63	  bnez  $a0,.gotMbx
                        	  ; no free mailboxes?
FFFC3CAC 40006513	  ldi   $a0,#1024         ; 1 page
FFFC3CB0 880FE0EF	  call  PAMAlloc
FFFC3CB4 0E054C63	  bltz  $a0,.outOfMem
FFFC3CB8 FF0018B7	  ldbu  $t0,MbxBlockCounter
FFFC3CBC 0E088893
FFFC3CC0 000888B3
FFFC3CC4 0008C283
FFFC3CC8 00550E23	  stb   $t0,OBJCollectionIndex[$a0] ; store which index of the collection we are
FFFC3CCC 00229293	  sll   $t0,$t0,#2
FFFC3CD0 FF0018B7	  stt   $a0,MbxBlockPtr[$t0]
FFFC3CD4 0A088893
FFFC3CD8 005888B3
FFFC3CDC 00A8A023
FFFC3CE0 0022D293	  srl   $t0,$t0,#2
FFFC3CE4 00128293	  add   $t0,$t0,#1
FFFC3CE8 FF0018B7	  stb   $t0,MbxBlockCounter
FFFC3CEC 0E088893
FFFC3CF0 000888B3
FFFC3CF4 00588023
FFFC3CF8 02F06293	  ldi   $t0,#47           ; 48 mailboxes in block
                        	  ; Initialize object fields
FFFC3CFC 204D4337	  ldi   $t1,#MBX_MAGIC
FFFC3D00 25830313
FFFC3D04 00652023	  stt   $t1,OBJMagic[$a0]
FFFC3D08 3C006313	  ldi   $t1,#960
FFFC3D0C 00652423	  stt   $t1,OBJSize[$a0]
FFFC3D10 00050C23	  stb   $x0,OBJState[$a0]
FFFC3D14 00050CA3	  stb   $x0,OBJScavcnt[$a0]
FFFC3D18 00050D23	  stb   $x0,OBJOwningMap[$a0]
FFFC3D1C 00000337	  ldi   $t1,#MbxFinalizer
FFFC3D20 37D30313
FFFC3D24 02652823	  stt   $t1,OBJFinalizer[$a0]
                        	  
FFFC3D28 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC3D2C 04050313	add   $t1,$a0,#64       ; point to first mailbox
FFFC3D30 FF0018B7	  stt   $t1,FreeMbx
FFFC3D34 C0888893
FFFC3D38 000888B3
FFFC3D3C 0068A023
FFFC3D40 00036533	  mov   $a0,$t1
                        	.0001:
FFFC3D44 01430393	  add   $t2,$t1,#MBX_SIZE
FFFC3D48 00732223	  stt   $t2,MBX_LINK[$t1]
FFFC3D4C 0003E333	  mov   $t1,$t2
FFFC3D50 FFF28293	  sub   $t0,$t0,#1
FFFC3D54 FE5048E3	  bgtz  $t0,.0001
FFFC3D58 00032223	  stt   $x0,MBX_LINK[$t1]
                        	.gotMbx:
FFFC3D5C 00452283	  ldt   $t0,MBX_LINK[$a0]
FFFC3D60 FF0018B7	  stt   $t0,FreeMbx
FFFC3D64 C0888893
FFFC3D68 000888B3
FFFC3D6C 0058A023
FFFC3D70 00052223	  stt   $x0,MBX_LINK[$a0]
FFFC3D74 00B50023		stb		$a1,MBX_OWNER[$a0]
FFFC3D78 00052223		stt   $x0,MBX_TQHEAD[$a0]
FFFC3D7C 00052423		stt   $x0,MBX_TQTAIL[$a0]
FFFC3D80 00052623		stt   $x0,MBX_MQHEAD[$a0]
FFFC3D84 00052823		stt   $x0,MBX_MQTAIL[$a0]
                        		; Create an id that is a hash code representing the location of the mailbox.
                        		; Given the hash code the mailbox pointer can be recreated easily.
FFFC3D88 C0057293		and   $t0,$a0,#$FFFFFC00    ; get pointer to block object
FFFC3D8C 01C2C303		ldbu  $t1,OBJCollectionIndex[$t0]
                        		
FFFC3D90 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC3D94 3FF57393	and   $t2,$a0,#$3FF         ; get offset of mailbox in block
FFFC3D98 00A31313		sll   $t1,$t1,#10           ; make an id hash
FFFC3D9C 007365B3		or    $a1,$t1,$t2
FFFC3DA0 0025D593		srl   $a1,$a1,#2            ; 2 LSB's will be zero
FFFC3DA4 00006513	  ldi   $a0,#E_Ok
FFFC3DA8 00008067	  ret
                        	.outOfMem:
FFFC3DAC 04706513	  ldi   $a0,#E_NoMem
FFFC3DB0 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Dequeue any waiting tasks returning to them a E_NoMsg status and removing
                        	; them from the timeout list as well. Then move any messages that are queued
                        	; back to the free message list.
                        	;------------------------------------------------------------------------------
                        	/*
  align 16
FMTK_FreeMbx_Old:
  csrrs $x0,#$300,#1        ; enable interrupts
	slt		$s1,$a1,#32
	beq		$s1,$x0,.badMbx
	sll		$s1,$a1,#4					; convert handle to pointer
	add		$s1,$s1,#mbxs
	bra   FreeMbx1
*/
FFFC3DB4 00000000	  align 1
FFFC3DB8 00000000
FFFC3DBC 00000000
                        	
                        	FMTK_FreeMbx:
FFFC3DC0 FF010113		sub		$sp,$sp,#16
FFFC3DC4 00112023		stt		$ra,[$sp]
FFFC3DC8 00912223		stt		$s1,4[$sp]
FFFC3DCC 01512423		stt		$s5,8[$sp]
FFFC3DD0 01612623		stt		$s6,12[$sp]
FFFC3DD4 0005E533	  mov   $a0,$a1
                        	  
FFFC3DD8 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC3DDC 00229293	  sll   $t0,$t0,#2
FFFC3DE0 FF0018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC3DE4 0A088893
FFFC3DE8 005888B3
FFFC3DEC 0008A283
FFFC3DF0 0FF57513	  and   $a0,$a0,#$FF
FFFC3DF4 00251513	  sll   $a0,$a0,#2
FFFC3DF8 00556533	  or    $a0,$a0,$t0
FFFC3DFC 964FF0EF	call	LockOS
FFFC3E00 FF0018B7	  ldt   $t0,FreeMbx
FFFC3E04 C0888893
FFFC3E08 000888B3
FFFC3E0C 0008A283
FFFC3E10 00552223	  stt   $t0,MBX_LINK[$a0]
FFFC3E14 FF0018B7	  stt   $a0,FreeMbx
FFFC3E18 C0888893
FFFC3E1C 000888B3
FFFC3E20 00A8A023
                        	
FFFC3E24 000564B3	  mov   $s1,$a0
                        	FreeMbx1:
FFFC3E28 0044AB03		ldt		$s6,MBX_TQHEAD[$s1]
                        	.0002:
FFFC3E2C 040B0A63		beqz	$s6,.0001
FFFC3E30 2C8B4383		ldbu	$t2,TCBStatus[$s6]
FFFC3E34 FF73F393		and		$t2,$t2,#~TS_WAITMSG	; no longer waiting
FFFC3E38 2C7B0423		stb		$t2,TCBStatus[$s6]
FFFC3E3C 0103F393		and		$t2,$t2,#TS_TIMEOUT   ; Is the task timing out?
FFFC3E40 00038A63		beqz	$t2,.0003
FFFC3E44 000B6533		mov		$a0,$s6
FFFC3E48 958FF0EF		call	UnlockOS
FFFC3E4C 395000EF		call	RemoveFromTimeoutList
FFFC3E50 910FF0EF		call	LockOS
                        	.0003:
FFFC3E54 000B6533	  mov		$a0,$s6
FFFC3E58 948FF0EF	  call	UnlockOS
FFFC3E5C 0D5000EF		call	InsertIntoReadyQueue
FFFC3E60 900FF0EF		call	LockOS
FFFC3E64 00B06393		ldi		$t2,#E_NoMsg					; but no message
FFFC3E68 087B2823		stt		$t2,TCBxA0[$s6]	; a0 = E_NoMsg
FFFC3E6C 348B2A83		ldt   $s5,TCBMbxNext[$s6]
FFFC3E70 340B2423		stt   $x0,TCBMbxNext[$s6]
FFFC3E74 340B2823		stt   $x0,TCBMbxPrev[$s6]
FFFC3E78 000AEB33		mov   $s6,$s5
FFFC3E7C FA0008E3		bra   .0002
                        	.0001:
FFFC3E80 0004A223	  stt   $x0,MBX_TQHEAD[$s1]
FFFC3E84 0004A423	  stt   $x0,MBX_TQTAIL[$s1]
                        	  ; Now free any messages queued at the mailbox. We are crafty here and
                        	  ; don't follow any links. Instead the entire chain of messages queued
                        	  ; is transferred to the free message list.
FFFC3E88 0104AB03	  ldt   $s6,MBX_MQTAIL[$s1] ; get pointer to last message
FFFC3E8C FF0018B7	  ldt   $s5,FreeMsg
FFFC3E90 C0088893
FFFC3E94 000888B3
FFFC3E98 0008AA83
FFFC3E9C 015B2023	  stt   $s5,MSG_LINK[$s6]   ; link current free list onto it
FFFC3EA0 00C4AB03	  ldt   $s6,MBX_MQHEAD[$s1]
FFFC3EA4 FF0018B7	  stt   $s6,FreeMsg         ; set new head of free list
FFFC3EA8 C0088893
FFFC3EAC 000888B3
FFFC3EB0 0168A023
FFFC3EB4 8ECFF0EF	  call	UnlockOS
FFFC3EB8 00012083	  ldt		$ra,[$sp]
FFFC3EBC 00412483	  ldt		$s1,4[$sp]
FFFC3EC0 00812A83	  ldt		$s5,8[$sp]
FFFC3EC4 00C12B03	  ldt		$s6,12[$sp]
FFFC3EC8 01010113	  add		$sp,$sp,#16
FFFC3ECC 00006513		ldi		$a0,#E_Ok
FFFC3ED0 00008067		ret
                        	.badMbx:
FFFC3ED4 00012083	  ldt		$ra,[$sp]
FFFC3ED8 00412483	  ldt		$s1,4[$sp]
FFFC3EDC 00812A83	  ldt		$s5,8[$sp]
FFFC3EE0 00C12B03	  ldt		$s6,12[$sp]
FFFC3EE4 01010113	  add		$sp,$sp,#16
FFFC3EE8 00406513		ldi		$a0,#E_BadMbx				; return null pointer if bad mailbox
FFFC3EEC 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; AllocMsg
                        	;
                        	; This internally used routine to provide message space to store data in.
                        	; First the free list is checked to see if any messages are available.
                        	; If there are no message available then a block of 48 messages is allocated
                        	; and added to the free list. 48 messages fit nicely into a 1kB memory page.
                        	;
                        	; Parameters:
                        	;   none
                        	; Returns:
                        	;   $a0 = status (E_Ok)
                        	;   $a1 = pointer to message
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	AllocMsg:
FFFC3EF0 FFC10113		sub		$sp,$sp,#4
FFFC3EF4 00112023		stt		$ra,[$sp]
FFFC3EF8 868FF0EF	  call	LockOS
FFFC3EFC FF0018B7	  ldt   $a0,FreeMsg
FFFC3F00 C0088893
FFFC3F04 000888B3
FFFC3F08 0008A503
FFFC3F0C 06051C63	  bnez  $a0,.gotMsg
                        	  ; no free messages?
FFFC3F10 40006513	  ldi   $a0,#1024         ; 1 page
FFFC3F14 88CFF0EF	  call	UnlockOS
FFFC3F18 E19FD0EF	  call  PAMAlloc
FFFC3F1C 844FF0EF	  call	LockOS
FFFC3F20 08054A63	  bltz  $a0,.outOfMem
FFFC3F24 02F06293	  ldi   $t0,#47           ; 48 messages in block
                        	  ; Initialize object fields
FFFC3F28 204D5337	  ldi   $t1,#MSG_MAGIC
FFFC3F2C 34730313
FFFC3F30 00652023	  stt   $t1,OBJMagic[$a0]
FFFC3F34 3C006313	  ldi   $t1,#960
FFFC3F38 00652423	  stt   $t1,OBJSize[$a0]
FFFC3F3C 00050C23	  stb   $x0,OBJState[$a0]
FFFC3F40 00050CA3	  stb   $x0,OBJScavcnt[$a0]
FFFC3F44 00050D23	  stb   $x0,OBJOwningMap[$a0]
FFFC3F48 FFFC4337	  ldi   $t1,#MsgFinalizer
FFFC3F4C 2D030313
FFFC3F50 02652823	  stt   $t1,OBJFinalizer[$a0]
                        	 
FFFC3F54 04050313	  add   $t1,$a0,#64       ; point to first message
FFFC3F58 FF0018B7	  stt   $t1,FreeMsg
FFFC3F5C C0088893
FFFC3F60 000888B3
FFFC3F64 0068A023
FFFC3F68 00036533	  mov   $a0,$t1
                        	.0001:
FFFC3F6C 01430393	  add   $t2,$t1,#MSG_SIZE
FFFC3F70 00732023	  stt   $t2,MSG_LINK[$t1]
FFFC3F74 0003E333	  mov   $t1,$t2
FFFC3F78 FFF28293	  sub   $t0,$t0,#1
FFFC3F7C FE5048E3	  bgtz  $t0,.0001
FFFC3F80 00032023	  stt   $x0,MSG_LINK[$t1]
                        	.gotMsg:
FFFC3F84 00052283	  ldt   $t0,MSG_LINK[$a0]
FFFC3F88 FF0018B7	  stt   $t0,FreeMsg
FFFC3F8C C0088893
FFFC3F90 000888B3
FFFC3F94 0058A023
FFFC3F98 00052023	  stt   $x0,MSG_LINK[$a0]
FFFC3F9C 804FF0EF	  call	UnlockOS
FFFC3FA0 000565B3	  mov   $a1,$a0
FFFC3FA4 00006513	  ldi   $a0,#E_Ok
FFFC3FA8 00012083	  ldt		$ra,[$sp]
FFFC3FAC 00410113	  add		$sp,$sp,#4
FFFC3FB0 00008067	  ret
                        	.outOfMem:
FFFC3FB4 FEDFE0EF	  call	UnlockOS
FFFC3FB8 04706513	  ldi   $a0,#E_NoMem
FFFC3FBC 00012083	  ldt		$ra,[$sp]
FFFC3FC0 00410113	  add		$sp,$sp,#4
FFFC3FC4 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; FreeMsg
                        	;
                        	; This internally used routine frees a message previously allocated with
                        	; AllocMsg. The message is added to the free list.
                        	;
                        	; Parameters:
                        	;   $a0 = pointer to message.
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;------------------------------------------------------------------------------
FFFC3FC8 00000000	  align 1
FFFC3FCC 00000000
                        	
                        	FreeMsgRout:
FFFC3FD0 FFC10113		sub		$sp,$sp,#4
FFFC3FD4 00112023		stt		$ra,[$sp]
FFFC3FD8 F89FE0EF	  call	LockOS
FFFC3FDC FF0018B7	  ldt   $t0,FreeMsg
FFFC3FE0 C0088893
FFFC3FE4 000888B3
FFFC3FE8 0008A283
FFFC3FEC 00552023	  stt   $t0,MSG_LINK[$a0]
FFFC3FF0 FF0018B7	  stt   $a0,FreeMsg
FFFC3FF4 C0088893
FFFC3FF8 000888B3
FFFC3FFC 00A8A023
FFFC4000 FA1FE0EF	  call	UnlockOS
FFFC4004 00006513	  ldi   $a0,#E_Ok
FFFC4008 00012083	  ldt		$ra,[$sp]
FFFC400C 00410113	  add		$sp,$sp,#4
FFFC4010 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		$t0 = mailbox pointer
                        	;		$t1 = message pointer
                        	;		$s1 = task id of waiting task
                        	; Modifies:
                        	;		$a0
                        	; Parameters:
                        	;		$a1 = mailbox handle
                        	;		$a2 = message d1
                        	;		$a3 = message d2
                        	;		$a4 = message d3
                        	;------------------------------------------------------------------------------
FFFC4014 00000000	  align 1
FFFC4018 00000000
FFFC401C 00000000
                        	
                        	ISendMsg:
FFFC4020 FFC10113	  sub   $sp,$sp,#4
FFFC4024 00112023	  stt   $ra,[$sp]
                        	;  mEI
                        	;	slt		$t0,$a1,#32
                        	;	beq		$t0,$x0,.badMbx
                        	;	sll		$t0,$a1,#4					; convert handle to pointer
                        	;	add		$t0,$t0,#mbxs
FFFC4028 0005E533	  mov   $a0,$a1
                        	  
FFFC402C 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC4030 00229293	  sll   $t0,$t0,#2
FFFC4034 FF0018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC4038 0A088893
FFFC403C 005888B3
FFFC4040 0008A283
FFFC4044 0FF57513	  and   $a0,$a0,#$FF
FFFC4048 00251513	  sll   $a0,$a0,#2
FFFC404C 00556533	  or    $a0,$a0,$t0
FFFC4050 000562B3	mov   $t0,$a0
FFFC4054 0042A983		ldt		$s3,MBX_TQHEAD[$t0]
FFFC4058 04098663		beq		$s3,$x0,.noWaiters
FFFC405C 2CC9AC23		stt		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC4060 2ED9A023		stt		$a3,TCBMsgD2[$s3]
FFFC4064 2EE9A423		stt		$a4,TCBMsgD3[$s3]
FFFC4068 2C89C383		ldbu	$t2,TCBStatus[$s3]
FFFC406C 0043E393		or		$t2,$t2,#TS_MSGRDY
FFFC4070 2C798423		stb		$t2,TCBStatus[$s3]
FFFC4074 3389D503		ldwu  $a0,TCBtid[$s3]
FFFC4078 FFC10113		sub		$sp,$sp,#4
FFFC407C 00512023		stt		$t0,[$sp]						; push t0
FFFC4080 6B0000EF		call	InsertIntoReadyQueue
FFFC4084 00012283		ldt		$t0,[$sp]						; pop t0
FFFC4088 00410113		add		$sp,$sp,#4
FFFC408C 3489AA83		ldt   $s5,TCBMbxNext[$s3]
FFFC4090 3409A423		stt   $x0,TCBMbxNext[$s3]
FFFC4094 3409A823		stt   $x0,TCBMbxPrev[$s3]
FFFC4098 0152A223		stt   $s5,MBX_TQHEAD[$t0]
FFFC409C 00006513		ldi		$a0,#E_Ok
FFFC40A0 04000663		bra   .xit
                        	.noWaiters:
FFFC40A4 E4DFF0EF	  call  AllocMsg
FFFC40A8 02051C63		bnez	$a0,.noMsg			    ; message available?
FFFC40AC 00C5A423		stt		$a2,MSG_D1[$a1]
FFFC40B0 00D5A623		stt		$a3,MSG_D2[$a1]
FFFC40B4 00E5A823		stt		$a4,MSG_D3[$a1]
FFFC40B8 0102AE03		ldt		$t3,MBX_MQTAIL[$t0]
FFFC40BC 000E0A63		beqz	$t3,.mbxEmpty
FFFC40C0 00BE2023		stt		$a1,MSG_LINK[$t3]
FFFC40C4 00B2A823		stt		$a1,MBX_MQTAIL[$t0]
FFFC40C8 00006513		ldi		$a0,#E_Ok
FFFC40CC 02000063		bra   .xit
                        	.mbxEmpty:
FFFC40D0 00B2A623		stt		$a1,MBX_MQHEAD[$t0]
FFFC40D4 00B2A823		stt		$a1,MBX_MQTAIL[$t0]
FFFC40D8 00006513		ldi		$a0,#E_Ok
FFFC40DC 00000863		bra   .xit
                        	.noMsg:
FFFC40E0 00B06513		ldi		$a0,#E_NoMsg
FFFC40E4 00000463		bra   .xit
                        	.badMbx:
FFFC40E8 00406513		ldi		$a0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit
FFFC40EC 00012083		ldt   $ra,[$sp]
FFFC40F0 00410113		add   $sp,$sp,#4
FFFC40F4 00008067		ret
                        	
FFFC40F8 00000000	  align 1
FFFC40FC 00000000
                        	
                        	FMTK_SendMsg:
FFFC4100 F21FF06F	  jmp  ISendMsg
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a1 = mailbox handle
                        	;		$a2 = pointer where to put message D1
                        	;		$a3 = pointer where to put message D2
                        	;		$a4 = pointer where to put message D3
                        	;		$a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
FFFC4104 00000000	  align 1
FFFC4108 00000000
FFFC410C 00000000
                        	
                        	PeekMsg:
FFFC4110 FFC10113		sub		$sp,$sp,#4
FFFC4114 00112023		stt		$ra,[$sp]
                        	;	slt		$t0,$a1,#32
                        	;	beq		$t0,$x0,.badMbx
                        	;	sll		$t2,$a1,#4					; convert handle to pointer
                        	;	add		$t2,$t2,#mbxs
FFFC4118 0005E533		mov   $a0,$a1
                        		
FFFC411C 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC4120 00229293	  sll   $t0,$t0,#2
FFFC4124 FF0018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC4128 0A088893
FFFC412C 005888B3
FFFC4130 0008A283
FFFC4134 0FF57513	  and   $a0,$a0,#$FF
FFFC4138 00251513	  sll   $a0,$a0,#2
FFFC413C 00556533	  or    $a0,$a0,$t0
FFFC4140 000563B3	mov   $t2,$a0
FFFC4144 E1DFE0EF		call	LockOS
FFFC4148 00C3A303		ldt		$t1,MBX_MQHEAD[$t2]
FFFC414C 06030463		beqz	$t1,.noMsg
FFFC4150 00078A63		beqz	$a5,.nodq
FFFC4154 00032E03		ldt		$t3,MSG_LINK[$t1]
FFFC4158 01C3A623		stt		$t3,MBX_MQHEAD[$t2]
                        		; This is done here only because interrupts are disabled
FFFC415C 000E6533		mov   $a0,$t3
FFFC4160 E71FF0EF		call  FreeMsgRout
                        	.nodq:
                        	  ; Makes use of the MPRV feature. PeekMsg() or WaitMsg() will be running in
                        	  ; the task context expecting to receive a message. That means the base
                        	  ; registers and ASID should be set appropriately.
FFFC4164 000205B7		ldi   $a1,#$20000       ; bit 17 = mprv
FFFC4168 00058593
FFFC416C 34030503	  ldb   $a0,TCBmid[$t1]   ; $a0 = mid
FFFC4170 00060A63		beqz  $a2,.nod1
FFFC4174 00832E03		ldt		$t3,MSG_D1[$t1]
FFFC4178 3005A073		csrrs $x0,#CSR_MSTATUS,$a1
FFFC417C 01C62023		stt		$t3,[$a2]
FFFC4180 3005B073		csrrc $x0,#CSR_MSTATUS,$a1
                        	.nod1:
FFFC4184 00068A63		beqz	$a3,.nod2
FFFC4188 00C32E03		ldt		$t3,MSG_D2[$t1]
FFFC418C 3005A073		csrrs $x0,#CSR_MSTATUS,$a1
FFFC4190 01C6A023		stt		$t3,[$a3]
FFFC4194 3005B073		csrrc $x0,#CSR_MSTATUS,$a1
                        	.nod2:
FFFC4198 00070A63		beqz	$a4,.nod3
FFFC419C 01032E03		ldt		$t3,MSG_D3[$t1]
FFFC41A0 3005A073		csrrs $x0,#CSR_MSTATUS,$a1
FFFC41A4 01C72023		stt		$t3,[$a4]
FFFC41A8 3005B073		csrrc $x0,#CSR_MSTATUS,$a1
                        	.nod3:
FFFC41AC 00006513		ldi		$a0,#E_Ok
FFFC41B0 00000863		bra		.ret
                        	.noMsg:
FFFC41B4 00B06513		ldi		$a0,#E_NoMsg
FFFC41B8 00000463		bra		.ret
                        	.badMbx:
FFFC41BC 00406513		ldi		$a0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
FFFC41C0 DE1FE0EF	  call	UnlockOS
FFFC41C4 00012083		ldt		$ra,[$sp]
FFFC41C8 00410113		add		$sp,$sp,#4
FFFC41CC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC41D0 F41FF06F		jmp		PeekMsg
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
FFFC41D4 00000000	  align 1
FFFC41D8 00000000
FFFC41DC 00000000
                        	
                        	FMTK_WaitMsg:
FFFC41E0 FF810113		sub		$sp,$sp,#8
FFFC41E4 00112023		stt		$ra,[$sp]
FFFC41E8 01512223		stt		$s5,4[$sp]
FFFC41EC 0007EAB3		mov		$s5,$a5
FFFC41F0 00106793		ldi		$a5,#1              ; dequeue messages
FFFC41F4 F1DFF0EF		call	PeekMsg							; check for a message, return if available
FFFC41F8 00B06313		ldi		$t1,#E_NoMsg
FFFC41FC 00650A63		beq		$a0,$t1,.qt					; no message? Then go queue task
FFFC4200 00012083		ldt		$ra,[$sp]
FFFC4204 00412A83		ldt		$s5,4[$sp]
FFFC4208 00810113		add		$sp,$sp,#8
FFFC420C 00008067		ret
                        	.qt:
FFFC4210 000AE7B3		mov		$a5,$s5
FFFC4214 0005E533	  mov   $a0,$a1
                        	  
FFFC4218 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC421C 00229293	  sll   $t0,$t0,#2
FFFC4220 FF0018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC4224 0A088893
FFFC4228 005888B3
FFFC422C 0008A283
FFFC4230 0FF57513	  and   $a0,$a0,#$FF
FFFC4234 00251513	  sll   $a0,$a0,#2
FFFC4238 00556533	  or    $a0,$a0,$t0
FFFC423C 00056E33	mov   $t3,$a0
                        		
FFFC4240 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC4244 00251313	sll		$t1,$a0,#2
FFFC4248 FF0008B7		ldt		$t1,TCBPtrs[$t1]		; $t1 = tcb pointer
FFFC424C 50088893
FFFC4250 006888B3
FFFC4254 0008A303
FFFC4258 001008B7		and		$t1,$t1,#$FFC00
FFFC425C C0088893
FFFC4260 01137333
FFFC4264 CFDFE0EF	  call	LockOS
FFFC4268 008E2E83		ldt		$t4,MBX_TQTAIL[$t3]	; get waiting task list tail
FFFC426C 000E8A63		beqz  $t4,.qempty
FFFC4270 35D32823	  stt   $t4,TCBMbxPrev[$t1] ; add task onto tail of waiting list
FFFC4274 346EA423	  stt   $t1,TCBMbxNext[$t4] ; tail->next = tid tcb pointer
FFFC4278 006E2423	  stt   $t1,MBX_TQTAIL[$t3]
FFFC427C 00000663	  bra   .setA
                        	.qempty:
FFFC4280 006E2223	  stt   $t1,MBX_TQHEAD[$t3]
FFFC4284 006E2423	  stt   $t1,MBX_TQTAIL[$t3]
                        	.setA:
FFFC4288 08B32C23		stt		$a1,TCBxA1[$t1]
FFFC428C 0AC32023	  stt   $a2,TCBxA2[$t1]   ; save pointers for data in task regs
FFFC4290 0AD32423	  stt   $a3,TCBxA3[$t1]
FFFC4294 0AE32823	  stt   $a4,TCBxA4[$t1]
FFFC4298 0AF32C23	  stt   $a5,TCBxA5[$t1]
FFFC429C 2C834E03		ldbu	$t3,TCBStatus[$t1]
FFFC42A0 008E6E13		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC42A4 FFEE7E13		and		$t3,$t3,#~TS_READY	; not ready
FFFC42A8 2DC30423		stb		$t3,TCBStatus[$t1]
FFFC42AC 2CB31523		stw		$a1,TCBWaitMbx[$t1]	; set mailbox task is waiting for
FFFC42B0 CF1FE0EF		call	UnlockOS
FFFC42B4 00036533		mov		$a0,$t1
FFFC42B8 0007E5B3		mov		$a1,$a5
FFFC42BC 6C4000EF		call	InsertIntoTimeoutList
FFFC42C0 00012083		ldt		$ra,[$sp]
FFFC42C4 00412A83		ldt		$s5,4[$sp]
FFFC42C8 00810113		add		$sp,$sp,#8
FFFC42CC B94FF06F		jmp		FMTK_Sleep          ; Continue by switching tasks
                        	
                        		align	16                        	
                        	MsgFinalizer:
FFFC42D0 00008067	  ret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/app.r5a",1
                        	.file "../fmtk/app.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/app.r5a",25
                        		code
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   none
                        	; Returns:
                        	;   $a0 = app id (0 to 31), -1 if none available
                        	;------------------------------------------------------------------------------
FFFC42D4 00000000	  align 1
FFFC42D8 00000000
FFFC42DC 00000000
                        	
                        	AllocAppId:
FFFC42E0 FF0008B7	  ldt   $a1,APPID_POOL
FFFC42E4 2F088893
FFFC42E8 000888B3
FFFC42EC 0008A583
FFFC42F0 01F06513	  ldi   $a0,#31
                        	.0002:
FFFC42F4 0205C263	  bltz  $a1,.0001
FFFC42F8 00106293	  ldi   $t0,#1
FFFC42FC 00A292B3	  sll   $t0,$t0,$a0
FFFC4300 0055E5B3	  or    $a1,$a1,$t0
FFFC4304 FF0008B7	  stt   $a1,APPID_POOL
FFFC4308 2F088893
FFFC430C 000888B3
FFFC4310 00B8A023
FFFC4314 00008067	  ret
                        	.0001:
FFFC4318 00159593	  sll   $a1,$a1,#1
FFFC431C FFF50513	  sub   $a0,$a0,#1
FFFC4320 FC055AE3	  bge   $a0,$x0,.0002
FFFC4324 FFF06513	  ldi   $a0,#-1
FFFC4328 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a1 = pointer to application start record
                        	; Modifies:
                        	;		$s1 = pointer to application start record
                        	;		$s3 = pointer to ACB
                        	;------------------------------------------------------------------------------
FFFC432C 00000000	  align 1
                        	
                        	FMTK_StartApp:
                        	IStartApp:
FFFC4330 FFC10113		sub		$sp,$sp,#4
FFFC4334 00112023		stt		$ra,[$sp]
FFFC4338 0005E4B3	  mov   $s1,$a1
FFFC433C 00006533	  mov   $a0,$x0           ; OS owns the ACB
FFFC4340 FA1FF0EF	  call	AllocAppId
FFFC4344 1C054263	  bltz	$a0,.noMoreApps
FFFC4348 00251913	  sll		$s2,$a0,#2
FFFC434C 00001537	  ldi   $a0,#4096         ; size of application control block
FFFC4350 00050513
FFFC4354 9DDFD0EF	  call  PAMAlloc          ; allocate ACB
FFFC4358 1A054C63	  bltz	$a0,.noMem
FFFC435C FF0008B7	  stt		$a0,ACBPtrs[$s2]	; store pointer to ACB in list
FFFC4360 60088893
FFFC4364 012888B3
FFFC4368 00A8A023
FFFC436C 000569B3	  mov   $s3,$a0           ; $s3 = pointer to ACB
FFFC4370 00295913	  srl		$s2,$s2,#2
FFFC4374 3D298223	  stb   $s2,ACBmid[$s3]
FFFC4378 204142B7	  ldi   $t0,#ACB_MAGIC
FFFC437C 34228293
FFFC4380 0059A023	  stt   $t0,OBJMagic[$s3]
FFFC4384 0809AC23	  stt   $x0,ACBGarbageList[$s3]
FFFC4388 3209AC23	  stt   $x0,ACBiofNext[$s3]
FFFC438C 3409A023	  stt   $x0,ACBiofPrev[$s3]
                        	;  ldb   $t0,ASRmid[$s1]
FFFC4390 0024C283	  ldbu	$t0,ASRRegset[$s1]
                        	  ; Allocate a virtual screen and set pointers to it.
                        	;  srl   $a0,$s3,#LOG_PGSZ ; App owns the screen
FFFC4394 00002537	  ldi   $a0,#8192         ; size of virtual screen
FFFC4398 00050513
FFFC439C 995FD0EF	  call  PAMAlloc
FFFC43A0 16054863	  bltz  $a0,.noMem
FFFC43A4 34A9A823	  stt   $a0,ACBpVidMem[$s3]
FFFC43A8 34A9AC23	  stt   $a0,ACBpVirtVidMem[$s3]
                        	  ; Setup screen attributes
FFFC43AC 03806293	  ldi   $t0,#56
FFFC43B0 365980A3	  stb   $t0,ACBVideoCols[$s3]
FFFC43B4 01F06293	  ldi   $t0,#31
FFFC43B8 36598023	  stb   $t0,ACBVideoRows[$s3]
FFFC43BC 36098123	  stb   $x0,ACBCursorRow[$s3]
FFFC43C0 360981A3	  stb   $x0,ACBCursorCol[$s3]
FFFC43C4 008802B7	  ldi   $t0,#$0087FC00
FFFC43C8 C0028293
FFFC43CC 3659A223	  stt   $t0,ACBNormAttr[$s3]
                        	
                        	  ; Allocate memory for application code and copy code into position
FFFC43D0 3C49C503	  ldbu	$a0,ACBmid[$s3]
FFFC43D4 0084A583	  ldt   $a1,ASRCodeSize[$s1]
FFFC43D8 02058C63	  beqz  $a1,.0004         ; 0 size code = in ROM
FFFC43DC DD4FD0EF	  call  Alloc
FFFC43E0 12054863	  bltz  $a0,.noMem
FFFC43E4 08B9A323	  stt   $a1,ACBpCode[$s3] ; save pointer to code area in ACB
FFFC43E8 0005EA33	  mov   $s4,$a1           ; $s4 = pointer to application code
FFFC43EC 0084A283	  ldt   $t0,ASRCodeSize[$s1]  ; $t0 = code size
FFFC43F0 0304AA83	  ldt   $s5,ASRpCode[$s1] ; $s5 = pointer to application code
                        	.0001:
FFFC43F4 000AA303	  ldt   $t1,[$s5]
FFFC43F8 006A2023	  stt   $t1,[$s4]
FFFC43FC 004A8A93	  add   $s5,$s5,#4
FFFC4400 004A0A13	  add   $s4,$s4,#4
FFFC4404 FFC28293	  sub   $t0,$t0,#4
FFFC4408 FE5046E3	  bgtz  $t0,.0001
FFFC440C 00000663	  bra   .0003
                        	.0004:
FFFC4410 0304AA83	  ldt   $s5,ASRpCode[$s1] ; $s5 = pointer to application code
FFFC4414 0959A323	  stt   $s5,ACBpCode[$s3] ; save pointer to code area in ACB
                        	
                        	.0003:
                        	  ; Allocate memory for application data and copy data into position
                        	  ; The memory requirements for both initialized and uninitialized data are
                        	  ; summed and a single block of memory allocated for both.
                        	  ; Vars will then be accessed via a global pointer offset from the start
                        	  ; of the data area.
FFFC4418 0409A023	  stt   $x0,ACBpData[$s3]
FFFC441C 0409A823	  stt   $x0,ACBpUIData[$s3]
FFFC4420 3C49C503	  ldbu	$a0,ACBmid[$s3]
FFFC4424 0104A583	  ldt   $a1,ASRDataSize[$s1]
FFFC4428 0184A603	  ldt   $a2,ASRUIDataSize[$s1]
FFFC442C 00C585B3	  add   $a1,$a1,$a2
FFFC4430 02058E63	  beqz  $a1,.0005         ; no data?
FFFC4434 D7CFD0EF	  call  Alloc
FFFC4438 0C054C63	  bltz  $a0,.noMem
FFFC443C 04B9A023	  stt   $a1,ACBpData[$s3]
                        	
                        	  ; Copy pre-initialized data to data area.
FFFC4440 0005EA33	  mov   $s4,$a1           ; $s4 = pointer to application data
FFFC4444 0104A283	  ldt   $t0,ASRDataSize[$s1]  ; $t0 = data size
FFFC4448 00328293	  add   $t0,$t0,#3        ; round to whole words
FFFC444C FFC2F293	  and   $t0,$t0,#$FFFFFFFC
FFFC4450 0384AA83	  ldt   $s5,ASRpData[$s1] ; $s5 = pointer to application data
                        	.0002:
FFFC4454 000AA303	  ldt   $t1,[$s5]
FFFC4458 006A2023	  stt   $t1,[$s4]
FFFC445C 004A8A93	  add   $s5,$s5,#4
FFFC4460 004A0A13	  add   $s4,$s4,#4
FFFC4464 FFC28293	  sub   $t0,$t0,#4
FFFC4468 FE5046E3	  bgtz  $t0,.0002
                        	
                        	.0005:
                        	  ; Record pointer to uninitialized data
FFFC446C 0104A503	  ldt   $a0,ASRDataSize[$s1]
FFFC4470 0404A583	  ldt   $a1,ACBpData[$s1]
FFFC4474 00B505B3	  add   $a1,$a0,$a1
FFFC4478 00358593	  add   $a1,$a1,#3
FFFC447C FFC5F593	  and   $a1,$a1,#$FFFFFFFC
FFFC4480 04B9A823	  stt   $a1,ACBpUIData[$s3]
                        	
                        	.0006:
                        	  ; Allocate memory for heap
FFFC4484 3C49C503	  ldbu	$a0,ACBmid[$s3]
FFFC4488 0204A583	  ldt   $a1,ASRHeapSize[$s1]
FFFC448C 00058863	  beqz  $a1,.0007         ; no heap?
FFFC4490 D20FD0EF	  call  Alloc
FFFC4494 06054E63	  bltz  $a0,.noMem
FFFC4498 0AB9A023	  stt   $a1,ACBHeap[$s3]
                        	
                        	.0007:
FFFC449C 3C49D583	  ldwu	$a1,ACBmid[$s3]		; $a1 = app id
FFFC44A0 40006613	  ldi   $a2,#1024         ; task local memory
FFFC44A4 0304A683	  ldt   $a3,ASRpCode[$s1] ; get pointer to code area
FFFC44A8 0024C703	  ldbu	$a4,ASRRegset[$s1]
FFFC44AC 03406293	  ldi		$t0,#52						; register set 52 and above are Machine
FFFC44B0 00574463	  blt		$a4,$t0,.norm
FFFC44B4 30076713	  or		$a4,$a4,#$300			; set Machine Mode
                        	.norm:
FFFC44B8 BD8FF0EF	  call  IStartTask        ; start the initial app task
FFFC44BC 04051063	  bnez  $a0,.tskErr       ; error?
FFFC44C0 3CB99023	  stw   $a1,ACBTask[$s3]
FFFC44C4 00259293	  sll   $t0,$a1,#2
FFFC44C8 FF0008B7	  ldt		$t0,TCBPtrs[$t0]
FFFC44CC 50088893
FFFC44D0 005888B3
FFFC44D4 0008A283
FFFC44D8 0409A303	  ldt   $t1,ACBpData[$s3]
FFFC44DC 0462AC23	  stt   $t1,TCBxGP[$t0]   ; set global pointer to data area
FFFC44E0 00106313	  ldi   $t1,#AS_LIVE
FFFC44E4 3C698323	  stb   $t1,ACBStatus[$s3]
FFFC44E8 3C49D583	  ldwu	$a1,ACBmid[$s3]		; return app id
FFFC44EC 00006513	  ldi   $a0,#E_Ok
                        	.retx:
FFFC44F0 00012083	  ldt		$ra,[$sp]
FFFC44F4 00410113	  add		$sp,$sp,#4
FFFC44F8 00008067	  ret
                        	.tskErr:
FFFC44FC 00406313	  ldi   $t1,#AS_UNDEAD
FFFC4500 3C698323	  stb   $t1,ACBStatus[$s3]
FFFC4504 FE0006E3	  bra		.retx
                        	
                        	.noMoreApps:
FFFC4508 04606513	  ldi   $a0,#E_NoMoreAppIds
FFFC450C FE0002E3	  bra		.retx
                        	.noMem
FFFC4510 04706513		ldi		$a0,#E_NoMem
FFFC4514 FC000EE3	  bra		.retx
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
FFFC4518 00000000		align	1
FFFC451C 00000000
                        	
                        	FMTK_ExitApp:
                        		
FFFC4520 7C201573	  csrrw $a0,#CSR_TASKID,$x0
                        	;	sll		$a1,$a0,#LOG_TCBSZ  ; convert TID to TCB address
FFFC4524 34058583		ldb   $a1,TCBmid[$a1]     ; get the mid
FFFC4528 00000463		bra		FMTK_KillApp
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = mid of task to kill
                        	;------------------------------------------------------------------------------
FFFC452C 00000000	  align 1
                        	
                        	FMTK_KillApp:
FFFC4530 00058C63		beqz	$a1,.immortal		    ; app #0 is immortal (the system)
FFFC4534 00206293		ldi		$t0,#TS_DEAD				; flag app as dead (prevents it from being re-queued)
FFFC4538 00259593		sll		$a1,$a1,#2	        
                        	;	ldt   $a1,TidTcbMap[$a1]  ; convert TID to TCB address
FFFC453C 3C05A583		ldt		$a1,ACBTask[$a1]
FFFC4540 2C558423		stb		$t0,TCBStatus[$a1]
                        	;	ldbu  $a0,TCBmid[$a1]
                        	;	call	FreeAll							; free all the memory associated with the task
                        		; Now make task ID available for reuse
FFFC4544 3385C503		ldbu  $a0,TCBtid[$a1]
                        	.immortal:
FFFC4548 00006513		ldi		$a0,#E_Ok
FFFC454C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	PickACB:
FFFC4550 07C06293		ldi		$t0,#31*4
                        	.0001:
FFFC4554 FF0008B7		ldt		$a0,ACBPtrs[$t0]
FFFC4558 60088893
FFFC455C 005888B3
FFFC4560 0008A503
FFFC4564 000808B7		and		$a0,$a0,#$07FC00
FFFC4568 C0088893
FFFC456C 01157533
FFFC4570 00051663		bnez	$a0,.xit
FFFC4574 FFC28293		sub		$t0,$t0,#4
FFFC4578 FC02DEE3		bge		$t0,$x0,.0001
                        	.xit:
FFFC457C 00008067		ret
                        	
                        	DumpACBPtrs:
FFFC4580 FF810113		sub		$sp,$sp,#8
FFFC4584 00112023		stt		$ra,[$sp]
FFFC4588 00006293		ldi		$t0,#0
FFFC458C 00512223		stt		$t0,4[$sp]
FFFC4590 FFFC4537		ldi		$a0,#msgACBPtrs
FFFC4594 5E050513
FFFC4598 969FC0EF		call	PutString
FFFC459C 00412283		ldt		$t0,4[$sp]
                        	.0001:
FFFC45A0 00512223		stt		$t0,4[$sp]
FFFC45A4 FF0008B7		ldt		$a0,ACBPtrs[$t0]
FFFC45A8 60088893
FFFC45AC 005888B3
FFFC45B0 0008A503
FFFC45B4 86DFC0EF		call	PutHexWord
FFFC45B8 00D06513		ldi		$a0,#CR
FFFC45BC F25FB0EF		call	Putch
FFFC45C0 00412283		ldt		$t0,4[$sp]
FFFC45C4 00428293		add		$t0,$t0,#4
FFFC45C8 08006313		ldi		$t1,#128
FFFC45CC FC62CAE3		blt		$t0,$t1,.0001
FFFC45D0 00012083		ldt		$ra,[$sp]
FFFC45D4 00810113		add		$sp,$sp,#8
FFFC45D8 00008067		ret
                        	
                        	DumpACB:
FFFC45DC 00008067		ret
                        	
                        	msgACBPtrs:
FFFC45E0 20424341		db		"ACB Pointers",CR,LNFD,0
FFFC45E4 6E696F50
FFFC45E8 73726574
FFFC45EC 00000A0D
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/tcb.r5a",25
                        		code
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   none
                        	; Returns:
                        	;   $a0 = tcb id (0 to 63), -1 if none available
                        	;------------------------------------------------------------------------------
FFFC45EF C1011300	  align 1
                        	
                        	AllocTCBId:
FFFC45F0 FFC10113		sub		$sp,$sp,#4
FFFC45F4 00112023		stt		$ra,[$sp]
FFFC45F8 04006413	  ldi   $s0,#64					; bit count
FFFC45FC 00006593	  ldi		$a1,#0
                        	.0002:
FFFC4600 FF000537		ldi		$a0,#TCBID_POOL
FFFC4604 2F850513
FFFC4608 0A8000EF		call	Getbit
FFFC460C 02050063		beqz	$a0,.0001
FFFC4610 00158593		add		$a1,$a1,#1
FFFC4614 FFF40413		sub		$s0,$s0,#1
FFFC4618 FE0414E3		bnez	$s0,.0002
FFFC461C FFF06513		ldi		$a0,#-1
FFFC4620 00012083		ldt		$ra,[$sp]
FFFC4624 00410113		add		$sp,$sp,#4
FFFC4628 00008067		ret
                        	.0001:
FFFC462C FF000537		ldi		$a0,#TCBID_POOL
FFFC4630 2F850513
FFFC4634 09C000EF		call	Setbit
FFFC4638 0005E533		mov		$a0,$a1
FFFC463C 00012083		ldt		$ra,[$sp]
FFFC4640 00410113		add		$sp,$sp,#4
FFFC4644 00008067		ret
                        	
FFFC4648 00000000	  align 1
FFFC464C 00000000
                        	
                        	FreeTCBId:
FFFC4650 FFC10113		sub		$sp,$sp,#4
FFFC4654 00112023		stt		$ra,[$sp]
FFFC4658 000565B3		mov		$a1,$a0
FFFC465C 03F5F593		and		$a1,$a1,#63
FFFC4660 FF000537		ldi		$a0,#TCBID_POOL
FFFC4664 2F850513
FFFC4668 098000EF		call	Clrbit
FFFC466C 00012083		ldt		$ra,[$sp]
FFFC4670 00410113		add		$sp,$sp,#4
FFFC4674 00008067		ret
                        	
FFFC4678 00000000	  align 1
FFFC467C 00000000
                        	
                        	FreeAllTCBId:
FFFC4680 FF0008B7		stt		$x0,TCBID_POOL
FFFC4684 2F888893
FFFC4688 000888B3
FFFC468C 0008A023
FFFC4690 FF0008B7		stt		$x0,TCBID_POOL+4
FFFC4694 2FC88893
FFFC4698 000888B3
FFFC469C 0008A023
FFFC46A0 00008067		ret
                        	
                        	; Parameters:
                        	;		$a0 start address of bit field
                        	;		$a1 bit number to get
                        	;
FFFC46A4 00000000	  align 1
FFFC46A8 00000000
FFFC46AC 00000000
                        	
                        	Getbit:
FFFC46B0 0055D293		srl		$t0,$a1,#5	; $t0 = word index
FFFC46B4 00229293		sll		$t0,$t0,#2	; *4 bytes per word
FFFC46B8 01F5F313		and		$t1,$a1,#31	; $t1 = bit index
FFFC46BC 00550E33		add		$t3,$a0,$t0
FFFC46C0 000E2383		ldt		$t2,[$t3]
FFFC46C4 0063D3B3		srl		$t2,$t2,$t1
FFFC46C8 0013F513		and		$a0,$t2,#1
FFFC46CC 00008067		ret
                        	
                        	  align 16                        	
                        	Setbit:
FFFC46D0 0055D293		srl		$t0,$a1,#5	; $t0 = word index
FFFC46D4 00229293		sll		$t0,$t0,#2	; *4 bytes per word
FFFC46D8 01F5F313		and		$t1,$a1,#31	; $t1 = bit index
FFFC46DC 00550EB3		add		$t4,$a0,$t0
FFFC46E0 000EA383		ldt		$t2,[$t4]
FFFC46E4 00106E13		ldi		$t3,#1
FFFC46E8 006E1E33		sll		$t3,$t3,$t1
FFFC46EC 01C3E3B3		or		$t2,$t2,$t3
FFFC46F0 007EA023		stt		$t2,[$t4]
FFFC46F4 00008067		ret
                        	
FFFC46F8 00000000	  align 1
FFFC46FC 00000000
                        	
                        	Clrbit:
FFFC4700 0055D293		srl		$t0,$a1,#5	; $t0 = word index
FFFC4704 00229293		sll		$t0,$t0,#2	; *4 bytes per word
FFFC4708 01F5F313		and		$t1,$a1,#31	; $t1 = bit index
FFFC470C 00550EB3		add		$t4,$a0,$t0
FFFC4710 000EA383		ldt		$t2,[$t4]
FFFC4714 00106E13		ldi		$t3,#1
FFFC4718 006E1E33		sll		$t3,$t3,$t1
FFFC471C FFFE4E13		xor		$t3,$t3,#-1
FFFC4720 01C3F3B3		and		$t2,$t2,$t3
FFFC4724 007EA023		stt		$t2,[$t4]
FFFC4728 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready queue.
                        	; The ready queue is a circular doubley-linked list. 
                        	; Inserting into the ready queue is done by both OS ecall functions and
                        	; interrupt driven scheduling. It's important to have interrupts disabled
                        	; so that there is no contention for the ready queue.
                        	;
                        	; Parameters:
                        	;		$a0 = tid to insert (TCB pointer)
                        	; Modifies:
                        	;	  $t0,$t1
                        	; Stack Space:
                        	;		1 word
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
FFFC472C 00000000		align	1
                        	
                        	InsertIntoReadyQueue:
FFFC4730 08050C63		beqz	$a0,.retx
FFFC4734 FFC10113		sub		$sp,$sp,#4
FFFC4738 00112023		stt		$ra,[$sp]
FFFC473C 000808B7		and		$a0,$a0,#$007FC00
FFFC4740 C0088893
FFFC4744 01157533
FFFC4748 819FE0EF		call	LockOS
FFFC474C 00052283		ldt		$t0,[$a0]
FFFC4750 205448B7		xor		$t0,$t0,#TCB_MAGIC
FFFC4754 34288893
FFFC4758 0112C2B3
FFFC475C 06029063		bnez	$t0,.badTcb
FFFC4760 2C854283		ldbu	$t0,TCBStatus[$a0]		; set status to ready
FFFC4764 0012E293		or		$t0,$t0,#TS_READY
FFFC4768 2C550423		stb		$t0,TCBStatus[$a0]
FFFC476C 2C950283		ldb		$t0,TCBPriority[$a0]	; $t0 = priority
FFFC4770 0072F293		and		$t0,$t0,#7
FFFC4774 00229293		sll		$t0,$t0,#2						; $t0 = index to priority list
FFFC4778 FF0008B7		ldt		$t1,TAILRDY[$t0]			; $t1 = tail
FFFC477C 42088893
FFFC4780 005888B3
FFFC4784 0008A303
FFFC4788 04030263		beqz	$t1,.qempty
FFFC478C 30A32823		stt		$a0,TCBNext[$t1]			; tail->next = new
FFFC4790 FF0008B7		stt		$a0,TAILRDY[$t0]			; tail = new
FFFC4794 42088893
FFFC4798 005888B3
FFFC479C 00A8A023
FFFC47A0 30652C23		stt		$t1,TCBPrev[$a0]			; new->prev = $t1
FFFC47A4 FF0008B7		ldt		$t1,HEADRDY[$t0]
FFFC47A8 40088893
FFFC47AC 005888B3
FFFC47B0 0008A303
FFFC47B4 30652823		stt		$t1,TCBNext[$a0]			; new->next = head
FFFC47B8 30A32C23		stt		$a0,TCBPrev[$t1]			; head->prev = new
                        	.badTcb:
FFFC47BC FE4FE0EF		call	UnlockOS
FFFC47C0 00012083		ldt		$ra,[$sp]
FFFC47C4 00410113		add		$sp,$sp,#4
                        	.retx:
FFFC47C8 00008067		ret
                        	.qempty:
FFFC47CC FF0008B7		stt		$a0,HEADRDY[$t0]
FFFC47D0 40088893
FFFC47D4 005888B3
FFFC47D8 00A8A023
FFFC47DC FF0008B7		stt		$a0,TAILRDY[$t0]
FFFC47E0 42088893
FFFC47E4 005888B3
FFFC47E8 00A8A023
FFFC47EC 30A52823		stt		$a0,TCBNext[$a0]
FFFC47F0 30A52C23		stt		$a0,TCBPrev[$a0]
FFFC47F4 FACFE0EF		call	UnlockOS
FFFC47F8 00012083		ldt		$ra,[$sp]
FFFC47FC 00410113		add		$sp,$sp,#4
FFFC4800 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove from ready queue.
                        	;
                        	; Parameters:
                        	;		$a0 = tid to remove (TCB pointer)
                        	; Modifies:
                        	;		$t0,$t1
                        	; Stack Space:
                        	;		1 word
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
FFFC4804 00000000		align	1
FFFC4808 00000000
FFFC480C 00000000
                        	
                        	RemoveFromReadyQueue:
FFFC4810 06050263		beqz	$a0,.retx
FFFC4814 FFC10113		sub		$sp,$sp,#4
FFFC4818 00112023		stt		$ra,[$sp]
FFFC481C 000808B7		and		$a0,$a0,#$007FC00
FFFC4820 C0088893
FFFC4824 01157533
FFFC4828 F38FE0EF		call	LockOS
FFFC482C 00052283		ldt		$t0,[$a0]
FFFC4830 205448B7		xor		$t0,$t0,#TCB_MAGIC
FFFC4834 34288893
FFFC4838 0112C2B3
FFFC483C 02029663		bnez	$t0,.badTcb
FFFC4840 2C850283		ldb		$t0,TCBStatus[$a0]		; set status no longer ready or running
FFFC4844 F7E2F293		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$a0]
FFFC4848 2C550423
FFFC484C 31052283		ldt		$t0,TCBNext[$a0]
FFFC4850 02A28463		beq		$t0,$a0,.emptyList
FFFC4854 31852303		ldt		$t1,TCBPrev[$a0]
FFFC4858 3062AC23		stt		$t1,TCBPrev[$t0]
FFFC485C 30532823		stt		$t0,TCBNext[$t1]
                        	.xit:
FFFC4860 30052C23		stt		$x0,TCBPrev[$a0]
FFFC4864 30052823		stt		$x0,TCBNext[$a0]
                        	.badTcb:
FFFC4868 F38FE0EF		call	UnlockOS
FFFC486C 00012083		ldt		$ra,[$sp]
FFFC4870 00410113		add		$sp,$sp,#4
                        	.retx:
FFFC4874 00008067		ret
                        	
                        	; Removing the last task from a ready list.
                        	; Find the task in the ready lists
                        	.emptyList:
FFFC4878 FF0008B7		ldt		$t0,HEADRDY0
FFFC487C 40088893
FFFC4880 000888B3
FFFC4884 0008A283
FFFC4888 02A29263		bne		$t0,$a0,.hr1
FFFC488C FF0008B7		stt		$x0,HEADRDY0
FFFC4890 40088893
FFFC4894 000888B3
FFFC4898 0008A023
FFFC489C FF0008B7		stt		$x0,TAILRDY0
FFFC48A0 42088893
FFFC48A4 000888B3
FFFC48A8 0008A023
                        	.hr1:
FFFC48AC FF0008B7		ldt		$t0,HEADRDY1
FFFC48B0 40488893
FFFC48B4 000888B3
FFFC48B8 0008A283
FFFC48BC 02A29263		bne		$t0,$a0,.hr2
FFFC48C0 FF0008B7		stt		$x0,HEADRDY1
FFFC48C4 40488893
FFFC48C8 000888B3
FFFC48CC 0008A023
FFFC48D0 FF0008B7		stt		$x0,TAILRDY1
FFFC48D4 42488893
FFFC48D8 000888B3
FFFC48DC 0008A023
                        	.hr2:
FFFC48E0 FF0008B7		ldt		$t0,HEADRDY2
FFFC48E4 40888893
FFFC48E8 000888B3
FFFC48EC 0008A283
FFFC48F0 02A29263		bne		$t0,$a0,.hr3
FFFC48F4 FF0008B7		stt		$x0,HEADRDY2
FFFC48F8 40888893
FFFC48FC 000888B3
FFFC4900 0008A023
FFFC4904 FF0008B7		stt		$x0,TAILRDY2
FFFC4908 42888893
FFFC490C 000888B3
FFFC4910 0008A023
                        	.hr3:
FFFC4914 FF0008B7		ldt		$t0,HEADRDY3
FFFC4918 40C88893
FFFC491C 000888B3
FFFC4920 0008A283
FFFC4924 02A29263		bne		$t0,$a0,.hr4
FFFC4928 FF0008B7		stt		$x0,HEADRDY3
FFFC492C 40C88893
FFFC4930 000888B3
FFFC4934 0008A023
FFFC4938 FF0008B7		stt		$x0,TAILRDY3
FFFC493C 42C88893
FFFC4940 000888B3
FFFC4944 0008A023
                        	.hr4:
FFFC4948 FF0008B7		ldt		$t0,HEADRDY4
FFFC494C 41088893
FFFC4950 000888B3
FFFC4954 0008A283
FFFC4958 F0A294E3		bne		$t0,$a0,.xit
FFFC495C FF0008B7		stt		$x0,HEADRDY4
FFFC4960 41088893
FFFC4964 000888B3
FFFC4968 0008A023
FFFC496C FF0008B7		stt		$x0,TAILRDY4
FFFC4970 43088893
FFFC4974 000888B3
FFFC4978 0008A023
FFFC497C EE0002E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = task id to insert (TCB pointer)
                        	;		$a1 = timeout value
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4
                        	;------------------------------------------------------------------------------
                        	
                        		align	16                        	
                        	InsertIntoTimeoutList:
FFFC4980 04050063		beqz	$a0,.retx
FFFC4984 000808B7		and		$a0,$a0,#$07FC00
FFFC4988 C0088893
FFFC498C 01157533
FFFC4990 00052283		ldt		$t0,[$a0]
FFFC4994 205448B7		xor		$t0,$t0,#TCB_MAGIC
FFFC4998 34288893
FFFC499C 0112C2B3
FFFC49A0 02029063		bnez	$t0,.retx
FFFC49A4 FFDC02B7		ldi		$t0,#TMOQ
FFFC49A8 40028293
FFFC49AC 33854303		ldbu	$t1,TCBtid[$a0]
FFFC49B0 00231313		sll		$t1,$t1,#2
FFFC49B4 0FF37313		and		$t1,$t1,#$FF
FFFC49B8 00530333		add		$t1,$t1,$t0
FFFC49BC 00B32023		stt		$a1,[$t1]
                        	.retx:
FFFC49C0 00008067		ret
                        	/*
	sub		$sp,$sp,#20
	stt		$ra,[$sp]
	stt		$x0,TCBID_TL
	stt		$x0,TCBID_TL+4
	call	LockOS
	ldbu	$t2,TCBStatus[$a0]		; set status to timing out
	or		$t2,$t2,#TS_TIMEOUT
	stb		$t2,TCBStatus[$a0]
	ldt		$t0,TimeoutList
	beqz	$t0,.listEmpty
.loop:
	beq		$t0,$a0,.xit				; task already on TimeoutList
	ldt		$t1,TCBTimeout[$t0]
	sltu	$t2,$a1,$t1
	bnez	$t2,.lessThan
	; Here timeout was >=
	sub		$a1,$a1,$t1
	ldt		$t0,TCBNext[$t0]
	stt		$t0,4[$sp]
	stt		$t3,8[$sp]
	stt		$a0,12[$sp]
	stt		$a1,16[$sp]
	; Is a task on the list twice? List corrupt?
	ldi		$a0,#TCBID_TL
	ldbu	$a1,TCBtid[$t0]
	call	Getbit
	bnez	$a0,.tolCorrupt
	ldi		$a0,#TCBID_TL
	ldbu	$a1,TCBtid[$t0]
	call	Setbit
	ldt		$t0,4[$sp]
	ldt		$t3,8[$sp]
	ldt		$a0,12[$sp]
	ldt		$a1,16[$sp]
	bnez	$t0,.loop
.hitAlready:
	; Add at end
	ldt		$t0,4[$sp]
	ldt		$a0,12[$sp]
	stt		$a0,TCBNext[$t0]
	stt		$x0,TCBNext[$a0]
	stt		$a1,TCBTimeout[$a0]
	bra		.xit
.listEmpty:
	stt		$a1,TCBTimeout[$a0]
	stt		$a0,TimeoutList
	stt		$x0,TCBNext[$a0]
	stt		$x0,TCBPrev[$a0]
	bra		.xit
.lessThan:
	beq		$t0,$a0,.xit
	sub		$t1,$t1,$a1
	stt		$t1,TCBTimeout[$t0]
	stt		$t0,TCBNext[$a0]
	ldt		$t1,TCBPrev[$t0]
	stt		$a0,TCBPrev[$t0]
	stt		$t1,TCBPrev[$a0]
	beqz	$t1,.atHead
	stt		$a0,TCBNext[$t1]
	bra		.xit
.atHead:
	stt		$a0,TimeoutList
	stt		$x0,TCBPrev[$a0]
.xit:
	call	UnlockOS
	ldi		$a0,#E_Ok
	ldt		$ra,[$sp]
	add		$sp,$sp,#20
.retx:
	ret
.tolCorrupt:
	ldi		$a0,#msgTOLCorrupt
	call	PutString
	bra		.hitAlready
*/
                        	msgTOLCorrupt:
FFFC49C4 204C4F54		db	"TOL Corrupt",CR,LNFD,0
FFFC49C8 72726F43
FFFC49CC 0D747075
FFFC49D0 0000000A
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove a task from the timeout list.
                        	; Called when a mailbox is freed and a task is waiting at the
                        	; mailbox.
                        	;
                        	; Parameters:
                        	;		$a0 = task id to remove
                        	; Modifies:
                        	;		$t0,$t1,$t2
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
FFFC49D2 00000000		align	1
FFFC49D6 00000000
FFFC49DA 00000000
FFFC49DE 02630000
                        	
                        	RemoveFromTimeoutList:
FFFC49E0 04050263		beqz	$a0,.retx
FFFC49E4 000808B7		and		$a0,$a0,#$07FC00
FFFC49E8 C0088893
FFFC49EC 01157533
FFFC49F0 00052283		ldt		$t0,[$a0]
FFFC49F4 205448B7		xor		$t0,$t0,#TCB_MAGIC
FFFC49F8 34288893
FFFC49FC 0112C2B3
FFFC4A00 02029263		bnez	$t0,.retx
FFFC4A04 FFDC02B7		ldi		$t0,#TMOQ
FFFC4A08 40028293
FFFC4A0C 33854303		ldbu	$t1,TCBtid[$a0]
FFFC4A10 00231313		sll		$t1,$t1,#2
FFFC4A14 0FF37313		and		$t1,$t1,#$FF
FFFC4A18 00530333		add		$t1,$t1,$t0
FFFC4A1C FFF06393		ldi		$t2,#-1					; max timeout
FFFC4A20 00732023		stt		$t2,[$t1]
                        	.retx:
FFFC4A24 00008067		ret
                        	/*
	sub		$sp,$sp,#4
	stt		$ra,[$sp]
	call	LockOS
	ldt		$t0,TimeoutList
	beq		$t0,$a0,.atHead				; quick test for head of list
	ldt		$t0,TCBNext[$a0]
	beqz	$t0,.atTail2
	ldt		$t1,TCBTimeout[$t0]
	ldt		$t2,TCBTimeout[$a0]
	sub		$t1,$t1,$t2
	stt		$t1,TCBTimeout[$t0]
	ldt		$t3,TCBPrev[$a0]
	stt		$t0,TCBNext[$t3]			; this->prev->next = this->next
	stt		$t3,TCBPrev[$t0]			; this->next->prev = this->prev
	stt		$x0,TCBNext[$a0]			; this->next = null
	stt		$x0,TCBPrev[$a0]			; this->prev = null
	stt		$x0,TCBTimeout[$a0]		; this->timeout = 0
	bra		.xit
.atHead:
	ldt		$t0,TCBNext[$a0]
	stt		$x0,TCBPrev[$t0]
	ldt		$t1,TCBTimeout[$t0]
	ldt		$t2,TCBTimeout[$a0]
	sub		$t1,$t1,$t2
	stt		$t1,TCBTimeout[$t0]
	stt		$t0,TimeoutList
	stt		$x0,TCBNext[$a0]
	stt		$x0,TCBPrev[$a0]
	stt		$x0,TCBTimeout[$a0]
	bra		.xit
.atTail2:
	ldt		$t0,TCBPrev[$a0]
	stt		$x0,TCBNext[$t0]
	stt		$x0,TCBNext[$a0]
	stt		$x0,TCBPrev[$a0]
	stt		$x0,TCBTimeout[$a0]
.xit:
	call	UnlockOS
	ldt		$ra,[$sp]
	add		$sp,$sp,#4
.retx:
	ret
*/
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
FFFC4A28 00000000		align	1
FFFC4A2C 00000000
                        	
                        	FMTK_DumpReadyQueue:
                        	DumpReadyQueue:
FFFC4A30 FE010113		sub		$sp,$sp,#32
FFFC4A34 00112023		stt		$ra,[$sp]
FFFC4A38 00A12223		stt		$a0,4[$sp]
FFFC4A3C 00C12423		stt		$a2,8[$sp]
FFFC4A40 00D12623		stt		$a3,12[$sp]
FFFC4A44 00612823		stt		$t1,16[$sp]
FFFC4A48 00712A23		stt		$t2,20[$sp]
FFFC4A4C 01C12C23		stt		$t3,24[$sp]
FFFC4A50 00912E23		stt		$s1,28[$sp]
FFFC4A54 00D06513	  ldi   $a0,#CR
FFFC4A58 A89FB0EF	  call  Putch
FFFC4A5C 00006513	  ldi   $a0,#LF
  call  Putch
FFFC4A60 A81FB0EF
                        	  ; Display PAM
FFFC4A64 00006313	  ldi   $t1,#0        ; $a1 = bit number
                        	.0006:
FFFC4A68 02006513	  ldi   $a0,#32       ; Get PAM bit pair
FFFC4A6C 000365B3	  mov   $a1,$t1
                        	;  csrrw	$t0,#CSR_RSSTACK,$x0
                        	;  stt		$t0,$10000
FFFC4A70 00000073	  ecall
                        	;  csrrw	$t0,#CSR_RSSTACK,$x0
                        	;  stt		$t0,$10004
FFFC4A74 03058513	  add   $a0,$a1,#'0'
FFFC4A78 A69FB0EF	  call  Putch
FFFC4A7C 00130313	  add   $t1,$t1,#1
FFFC4A80 20032513	  slt   $a0,$t1,#MEMSZ
FFFC4A84 FE0512E3	  bnez  $a0,.0006
                        	
FFFC4A88 FFFC5537		ldi		$a0,#msgReadyQueue
FFFC4A8C C9850513
FFFC4A90 C70FC0EF		call	PutString
FFFC4A94 00006913		ldi		$s2,#0
                        	;	csrrc	$s1,#CSR_PMSTACK,#1
FFFC4A98 04006A93		ldi		$s5,#64
                        	.0002:
                        	;	call	SerialPeekCharDirect
                        	;	xor		$v0,$v0,#CTRLC
                        	;	beqz	$v0,.brk
FFFC4A9C 00D06513		ldi		$a0,#CR
FFFC4AA0 A41FB0EF		call	Putch
FFFC4AA4 05106513		ldi		$a0,#'Q'
FFFC4AA8 A39FB0EF		call	Putch
                        		;srl		$a0,$t1,#1
FFFC4AAC 00096533		mov   $a0,$s2
FFFC4AB0 C00FC0EF		call	PutHexNybble
FFFC4AB4 03A06513		ldi		$a0,#':'
FFFC4AB8 A29FB0EF		call	Putch
FFFC4ABC 00291313		sll		$t1,$s2,#2
FFFC4AC0 FF0008B7		ldt		$s3,HEADRDY[$t1]
FFFC4AC4 40088893
FFFC4AC8 006888B3
FFFC4ACC 0008A983
FFFC4AD0 0009EA33		mov		$s4,$s3							; record head of list
                        	.0007:
FFFC4AD4 02098463		beqz	$s3,.0008
FFFC4AD8 00A9D513		srl		$a0,$s3,#LOG_PGSZ
FFFC4ADC B74FC0EF		call	PutHexHalf
FFFC4AE0 00D06513		ldi		$a0,#CR
FFFC4AE4 9FDFB0EF		call	Putch
FFFC4AE8 FFFA8A93		sub		$s5,$s5,#1
FFFC4AEC 000A8E63		beqz	$s5,.0005
FFFC4AF0 3109A983		ldt		$s3,TCBNext[$s3]
FFFC4AF4 00098463		beqz	$s3,.0008
FFFC4AF8 FD499EE3		bne		$s3,$s4,.0007
                        	.0008:
FFFC4AFC 00190913		add		$s2,$s2,#1
FFFC4B00 00506313		ldi		$t1,#5
FFFC4B04 F8694CE3		blt		$s2,$t1,.0002
                        	.0005:
                        	;	bra   .0001
                        	;	sll		$a3,$a3,#LOG_TCBSZ
                        	;	ldw		$a0,TCBNext[$a3]
                        	;	call	PutHexHalf
                        	;	ldi		$a0,#' '
                        	;	call	Putch
                        	;	ldw		$a0,TCBPrev[$a3]
                        	;	call	PutHexHalf
                        	.brk:
FFFC4B08 FFFC5537		ldi		$a0,#msgTaskInfo
FFFC4B0C CC250513
FFFC4B10 BF0FC0EF		call	PutString
FFFC4B14 00001437	  ldi   $s0,#$1000
FFFC4B18 00040413
                        	.0004:
FFFC4B1C 00046533		mov		$a0,$s0
FFFC4B20 00042503	  ldt   $a0,[$s0]
FFFC4B24 205448B7	  xor   $a0,$a0,#TCB_MAGIC
FFFC4B28 34288893
FFFC4B2C 01154533
FFFC4B30 06051C63	  bnez  $a0,.nxtT
FFFC4B34 000463B3	  mov   $t2,$s0
FFFC4B38 00046533	  mov		$a0,$s0
FFFC4B3C AE4FC0EF	  call  PutHexWord
FFFC4B40 02006513	  ldi   $a0,' '
FFFC4B44 99DFB0EF	  call  Putch
FFFC4B48 3383D503	  ldwu  $a0,TCBtid[$t2]
FFFC4B4C B04FC0EF	  call  PutHexHalf
FFFC4B50 02006513	  ldi   $a0,' '
FFFC4B54 98DFB0EF	  call  Putch
FFFC4B58 2C93C503	  ldbu  $a0,TCBPriority[$t2]
FFFC4B5C B24FC0EF	  call  PutHexByte
FFFC4B60 02006513	  ldi   $a0,' '
FFFC4B64 97DFB0EF	  call  Putch
FFFC4B68 3443C503	  ldbu  $a0,TCBOpMode[$t2]
FFFC4B6C B14FC0EF	  call  PutHexByte
FFFC4B70 02006513	  ldi   $a0,' '
FFFC4B74 96DFB0EF	  call  Putch
FFFC4B78 2C83C503	  ldbu  $a0,TCBStatus[$t2]
FFFC4B7C B04FC0EF	  call  PutHexByte
FFFC4B80 02006513	  ldi   $a0,' '
FFFC4B84 95DFB0EF	  call  Putch
FFFC4B88 3203A503	  ldt   $a0,TCBTimeout[$t2]
FFFC4B8C A94FC0EF	  call  PutHexWord
FFFC4B90 02006513	  ldi   $a0,' '
FFFC4B94 94DFB0EF	  call  Putch
FFFC4B98 0503A503	  ldt   $a0,TCBxSP[$t2]
FFFC4B9C A84FC0EF	  call  PutHexWord
FFFC4BA0 00D06513		ldi		$a0,#CR
FFFC4BA4 93DFB0EF		call	Putch
                        	.nxtT:
FFFC4BA8 40040413	  add   $s0,$s0,#$400
                        	;  ldi		$t1,#$7D000
FFFC4BAC 0007D8B7	  sltu  $t1,$s0,#$7D000
FFFC4BB0 00088893
FFFC4BB4 01143333
FFFC4BB8 F60312E3	  bnez  $t1,.0004
                        	;	csrrw	$x0,#CSR_PMSTACK,$s1
FFFC4BBC 00012083		ldt		$ra,[$sp]
FFFC4BC0 00412503		ldt		$a0,4[$sp]
FFFC4BC4 00812603		ldt		$a2,8[$sp]
FFFC4BC8 00C12683		ldt		$a3,12[$sp]
FFFC4BCC 01012303		ldt		$t1,16[$sp]
FFFC4BD0 01412383		ldt		$t2,20[$sp]
FFFC4BD4 01812E03		ldt		$t3,24[$sp]
FFFC4BD8 01C12483		ldt		$s1,28[$sp]
FFFC4BDC 02010113		add		$sp,$sp,#32
FFFC4BE0 00008067		ret
                        	
FFFC4BE4 00000000		align	1
FFFC4BE8 00000000
FFFC4BEC 00000000
                        	
                        	DumpTimeoutList:
FFFC4BF0 FE010113		sub		$sp,$sp,#32
FFFC4BF4 00112023		stt		$ra,[$sp]
FFFC4BF8 00A12223		stt		$a0,4[$sp]
FFFC4BFC 00C12423		stt		$a2,8[$sp]
FFFC4C00 00D12623		stt		$a3,12[$sp]
FFFC4C04 00612823		stt		$t1,16[$sp]
FFFC4C08 00712A23		stt		$t2,20[$sp]
FFFC4C0C 01C12C23		stt		$t3,24[$sp]
FFFC4C10 00912E23		stt		$s1,28[$sp]
FFFC4C14 FFFC5537		ldi		$a0,#msgTimeoutList
FFFC4C18 CF450513
FFFC4C1C AE4FC0EF		call	PutString
FFFC4C20 FF0008B7		ldt		$a2,TimeoutList
FFFC4C24 32888893
FFFC4C28 000888B3
FFFC4C2C 0008A603
                        	.0002:
FFFC4C30 981FD0EF		call	SerialPeekCharDirect
FFFC4C34 00354513		xor		$a0,$a0,#CTRLC
FFFC4C38 02050C63		beqz	$a0,.brk
FFFC4C3C 00D06513		ldi		$a0,#CR
FFFC4C40 8A1FB0EF		call	Putch
FFFC4C44 02060663		beqz	$a2,.brk
FFFC4C48 00A65513		srl		$a0,$a2,#LOG_PGSZ
FFFC4C4C A04FC0EF		call	PutHexHalf
FFFC4C50 02D06513		ldi		$a0,#'-'
FFFC4C54 88DFB0EF		call	Putch
FFFC4C58 32062503		ldt		$a0,TCBTimeout[$a2]
FFFC4C5C 9C4FC0EF		call	PutHexWord
FFFC4C60 00D06513		ldi		$a0,#CR
FFFC4C64 87DFB0EF		call	Putch
FFFC4C68 31062603		ldt		$a2,TCBNext[$a2]
FFFC4C6C FC0612E3		bnez	$a2,.0002
                        	.brk:
FFFC4C70 00012083		ldt		$ra,[$sp]
FFFC4C74 00412503		ldt		$a0,4[$sp]
FFFC4C78 00812603		ldt		$a2,8[$sp]
FFFC4C7C 00C12683		ldt		$a3,12[$sp]
FFFC4C80 01012303		ldt		$t1,16[$sp]
FFFC4C84 01412383		ldt		$t2,20[$sp]
FFFC4C88 01812E03		ldt		$t3,24[$sp]
FFFC4C8C 01C12483		ldt		$s1,28[$sp]
FFFC4C90 02010113		add		$sp,$sp,#32
FFFC4C94 00008067		ret
                        	
                        	msgReadyQueue:
FFFC4C98 6165520D		db	CR,"Ready Queue",CR
FFFC4C9C 51207964
FFFC4CA0 65756575
FFFC4CA4 6575510D
FFFC4CA5 3A657551		db	"Que: Tid List",CR
FFFC4CA9 64695420
FFFC4CAD 73694C20
FFFC4CB1 2D2D0D74
FFFC4CB3 2D2D2D2D		db	"-------------",CR,0
FFFC4CB7 2D2D2D2D
FFFC4CBB 2D2D2D2D
FFFC4CBF 0D000D2D
                        	msgTaskInfo:
FFFC4CC2 7361540D	  db  CR,"Task Info",CR
FFFC4CC6 6E49206B
FFFC4CCA 540D6F66
FFFC4CCD 20424354	  db  "TCB Ptr   Tid  Pr Om St Timeout    SP",CR
FFFC4CD1 20727450
FFFC4CD5 69542020
FFFC4CD9 50202064
FFFC4CDD 6D4F2072
FFFC4CE1 20745320
FFFC4CE5 656D6954
FFFC4CE9 2074756F
FFFC4CED 53202020
FFFC4CF1 0D000D50
FFFC4CF3 69540D00	  db  0
                        	msgTimeoutList:
FFFC4CF4 6D69540D		db	CR,"Timeout List",CR
FFFC4CF8 74756F65
FFFC4CFC 73694C20
FFFC4D00 54200D74
FFFC4D02 64695420		db	" Tid - Timeout",CR
FFFC4D06 54202D20
FFFC4D0A 6F656D69
FFFC4D0E 2D0D7475
FFFC4D11 2D2D2D2D		db	"--------------",CR,0
FFFC4D15 2D2D2D2D
FFFC4D19 2D2D2D2D
FFFC4D1D 000D2D2D
                        	
FFFC4D21 00000000		align 
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;-----------------------------------------------------------------------------
                        	;-----------------------------------------------------------------------------
                        	
                        	.file "../fmtk/iofocus.r5a",28
                        		code
                        	
                        	;-----------------------------------------------------------------------------
                        	; Determine if the currently running app has the I/O focus.
                        	;
                        	; Stack Space:
                        	;		none
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$a0 = E_Ok
                        	;		$a1 = 1 if task has IO focus, 0 otherwise
                        	;-----------------------------------------------------------------------------
FFFC4D24 00000000		align	1
FFFC4D28 00000000
FFFC4D2C 00000000
                        	
                        	FMTK_HasIOFocus:
                        		
FFFC4D30 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC4D34 00251513	sll   $a0,$a0,#2
FFFC4D38 FF0008B7		ldt		$a0,TCBPtrs[$a0]
FFFC4D3C 50088893
FFFC4D40 00A888B3
FFFC4D44 0008A503
FFFC4D48 001008B7		and		$a0,$a0,#$FFC00
FFFC4D4C C0088893
FFFC4D50 01157533
FFFC4D54 34255503		ldwu  $a0,TCBappid[$a0]
FFFC4D58 02050C63		beqz  $a0,.hasFocus       ; startup appid = zero
FFFC4D5C 00251513		sll		$a0,$a0,#2
FFFC4D60 FF0008B7		ldt		$a0,ACBPtrs[$a0]		; $a0 = ACB pointer
FFFC4D64 60088893
FFFC4D68 00A888B3
FFFC4D6C 0008A503
FFFC4D70 001008B7		and		$a0,$a0,#$FFC00
FFFC4D74 C0088893
FFFC4D78 01157533
FFFC4D7C FF0018B7		ldt   $a1,IOFocusNdx
FFFC4D80 08088893
FFFC4D84 000888B3
FFFC4D88 0008A583
FFFC4D8C 00A59863		bne   $a1,$a0,.notEqual
                        	.hasFocus:
FFFC4D90 00106593		ldi   $a1,#1
FFFC4D94 00006513		ldi		$a0,#E_Ok
FFFC4D98 00008067		ret
                        	.notEqual:
FFFC4D9C 00006593	  ldi   $a1,#0
FFFC4DA0 00006513		ldi		$a0,#E_Ok
FFFC4DA4 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; First check if it's even possible to switch the focus to another
                        	; app. The I/O focus list could be empty or there may be only a
                        	; single task in the list. In either case it's not possible to
                        	; switch.
                        	;
                        	;	Parameters:
                        	;		none
                        	;	Modifies:
                        	;		none
                        	;	Returns:
                        	;		a0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
FFFC4DA8 00000000		align	1
FFFC4DAC 00000000
                        	
                        	SwitchIOFocusHelper:
FFFC4DB0 FFC10113		sub		$sp,$sp,#4
FFFC4DB4 00112023		stt		$ra,[$sp]
                        		; Ensure the focus index is valid
FFFC4DB8 FF0018B7	  ldt   $t0,IOFocusNdx
FFFC4DBC 08088893
FFFC4DC0 000888B3
FFFC4DC4 0008A283
FFFC4DC8 0002A303	  ldt		$t1,OBJMagic[$t0]
FFFC4DCC 204148B7	  xor		$t1,$t1,#ACB_MAGIC
FFFC4DD0 34288893
FFFC4DD4 01134333
FFFC4DD8 04031463	  bnez	$t1,.pickACB
FFFC4DDC 3382A303	  ldt   $t1,ACBiofNext[$t0]
                        	  ; Ensure new choice is valid
FFFC4DE0 02030663	  beqz  $t1,.zeroAppId
FFFC4DE4 00032383	  ldt		$t2,OBJMagic[$t1]
FFFC4DE8 204148B7	  xor		$t2,$t2,#ACB_MAGIC
FFFC4DEC 34288893
FFFC4DF0 0113C3B3
FFFC4DF4 00039C63	  bnez	$t2,.zeroAppId
FFFC4DF8 FF0018B7	  stt   $t1,IOFocusNdx
FFFC4DFC 08088893
FFFC4E00 000888B3
FFFC4E04 0068A023
FFFC4E08 00629A63	  bne   $t0,$t1,.notSame
                        	.zeroAppId:
FFFC4E0C 00006513		ldi		$a0,E_Ok
FFFC4E10 00012083		ldt		$ra,[$sp]
FFFC4E14 00410113		add		$sp,$sp,#4
FFFC4E18 00008067		ret
                        	.notSame:
                        		; swap virtual screens
                        		; set vidmem pointer
FFFC4E1C FE0008E3		bra		.zeroAppId
                        	.pickACB:
FFFC4E20 F30FF0EF		call	PickACB
FFFC4E24 FF0018B7		stt		$a0,IOFocusNdx
FFFC4E28 08088893
FFFC4E2C 000888B3
FFFC4E30 00A8A023
FFFC4E34 FC000CE3		bra		.zeroAppId
                        	    
FFFC4E38 00000000		align	1
FFFC4E3C 00000000
                        	
                        	FMTK_SwitchIOFocus:
FFFC4E40 F71FF06F		jmp		SwitchIOFocusHelper
                        	
                        	;-----------------------------------------------------------------------------
                        	; RequestIOFocus requests that the task receive the I/O focus. It does not
                        	; mean the task will receive the focus immediately. Instead it is placed
                        	; on a list of requesters. Which task has the I/O focus is determined from
                        	; user input.
                        	; The I/O focus list is an array indicating which apps are requesting the
                        	; I/O focus. The I/O focus is user controlled by pressing CNTRL-T on the
                        	; keyboard.
                        	;
                        	; Parameters:
                        	;		$a1 = app id requesting focus for
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;   $a1 (unmodified)
                        	;-----------------------------------------------------------------------------
                        	
FFFC4E44 00000000		align	1
FFFC4E48 00000000
FFFC4E4C 00000000
                        	
                        	FMTK_RequestIOFocus:
FFFC4E50 01F06613		ldi		$a2,#31
FFFC4E54 08C5FE63		bgeu	$a1,$a2,.badAppId
FFFC4E58 FFC10113		sub		$sp,$sp,#4
FFFC4E5C 00112023		stt		$ra,[$sp]
FFFC4E60 00106613		ldi   $a2,#1
FFFC4E64 00259393		sll		$t2,$a1,#2
FFFC4E68 FF0008B7		ldt		$t2,ACBPtrs[$t2]
FFFC4E6C 60088893
FFFC4E70 007888B3
FFFC4E74 0008A383
FFFC4E78 001008B7		and		$t2,$t2,#$FFC00
FFFC4E7C C0088893
FFFC4E80 0113F3B3
FFFC4E84 06038663		beqz	$t2,.badAppId
FFFC4E88 8D8FE0EF		call	LockOS
FFFC4E8C 3C238303		ldb		$t1,ACBHasFocus[$t2]  ; Is the task already included in the IO focus?
FFFC4E90 04031463		bnez	$t1,.ret				      ; If so, don't add again
FFFC4E94 FF0018B7		ldt	  $t0,IOFocusNdx			  ; get current index
FFFC4E98 08088893
FFFC4E9C 000888B3
FFFC4EA0 0008A283
FFFC4EA4 02029063		bnez	$t0,.notEmpty		      ; is there one? (!= 0)
FFFC4EA8 FF0018B7		stt   $t2,IOFocusNdx
FFFC4EAC 08088893
FFFC4EB0 000888B3
FFFC4EB4 0078A023
FFFC4EB8 3273AC23		stt   $t2,ACBiofNext[$t2]
FFFC4EBC 3473A023		stt   $t2,ACBiofPrev[$t2]
FFFC4EC0 0180006F		jmp   .ret
                        	.notEmpty:
                        	  ; Insert just before head which is end of queue
FFFC4EC4 3402A303	  ldt   $t1,ACBiofPrev[$t0]
FFFC4EC8 3472A023	  stt   $t2,ACBiofPrev[$t0]     ; head->prev = new
FFFC4ECC 32732C23	  stt   $t2,ACBiofNext[$t1]     ; head->prev->next = new
FFFC4ED0 3253AC23	  stt   $t0,ACBiofNext[$t2]     ; new->next = head
FFFC4ED4 3463A023	  stt   $t1,ACBiofPrev[$t2]     ; new->prev = head->prev
                        	.ret:
FFFC4ED8 3CC38123		stb   $a2,ACBHasFocus[$t2]  ; set has focus flag
FFFC4EDC 8C4FE0EF		call	UnlockOS
FFFC4EE0 00012083		ldt		$ra,[$sp]
FFFC4EE4 00410113		add		$sp,$sp,#4
FFFC4EE8 00006513		ldi		$a0,#E_Ok
FFFC4EEC 00008067		ret
                        	.badAppId:
FFFC4EF0 01C06513		ldi		$a0,#E_BadAppId
FFFC4EF4 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; ReleaseIOFocus called when the app no longer desires to be on the I/O
                        	; focus list.
                        	;-----------------------------------------------------------------------------
                        	
FFFC4EF8 00000000		align	1
FFFC4EFC 00000000
                        	
                        	FMTK_ReleaseIOFocus:
                        		
FFFC4F00 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC4F04 00A51593	sll   $a1,$a0,#LOG_TCBSZ
FFFC4F08 3425D583		ldwu  $a1,TCBappid[$a1]
FFFC4F0C 0040006F		jmp		FMTK_ForceReleaseIOFocus
                        	
                        	;-----------------------------------------------------------------------------
                        	; Releasing the I/O focus causes the focus to switch if the running app
                        	; had the I/O focus.
                        	; ForceReleaseIOFocus forces the release of the IO focus for a app
                        	; different than the one currently running.
                        	; 
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		$a1 = app id to release
                        	; Returns:
                        	;		$a0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        		align	16                        	
                        	FMTK_ForceReleaseIOFocus:
FFFC4F10 FFC10113		sub		$sp,$sp,#4
FFFC4F14 00112023		stt		$ra,[$sp]
FFFC4F18 848FE0EF		call	LockOS
FFFC4F1C 00259293		sll		$t0,$a1,#2
FFFC4F20 FF0008B7		ldt		$t0,ACBPtrs[$t0]
FFFC4F24 60088893
FFFC4F28 005888B3
FFFC4F2C 0008A283
FFFC4F30 001008B7		and		$t0,$t0,#$FFC00
FFFC4F34 C0088893
FFFC4F38 0112F2B3
FFFC4F3C 3C228303		ldb		$t1,ACBHasFocus[$t0]
FFFC4F40 06030463		beqz	$t1,.noFocus	    ; does it even have the focus?
FFFC4F44 3C028123		stb   $x0,ACBHasFocus[$t0]
FFFC4F48 FF0018B7		ldt   $t1,IOFocusNdx
FFFC4F4C 08088893
FFFC4F50 000888B3
FFFC4F54 0008A303
FFFC4F58 02629C63		bne   $t0,$t1,.notAtTop
FFFC4F5C 3382A303		ldt   $t1,ACBiofNext[$t0]
FFFC4F60 02531063		bne   $t1,$t0,.0001
                        		; removing last entry
FFFC4F64 FF0018B7		stt   $x0,IOFocusNdx
FFFC4F68 08088893
FFFC4F6C 000888B3
FFFC4F70 0008A023
FFFC4F74 3202AC23		stt   $x0,ACBiofNext[$t0]
FFFC4F78 3402A023		stt   $x0,ACBiofPrev[$t0]
FFFC4F7C 02000663		bra		.noFocus
                        	.0001:	
FFFC4F80 FF0018B7		stt   $t1,IOFocusNdx
FFFC4F84 08088893
FFFC4F88 000888B3
FFFC4F8C 0068A023
                        	.notAtTop:
FFFC4F90 3382A303		ldt   $t1,ACBiofNext[$t0]
FFFC4F94 3402A383		ldt   $t2,ACBiofPrev[$t0]
FFFC4F98 34732023		stt   $t2,ACBiofPrev[$t1]
FFFC4F9C 3263AC23		stt   $t1,ACBiofNext[$t2]
FFFC4FA0 3202AC23		stt   $x0,ACBiofNext[$t0]
FFFC4FA4 3402A023		stt   $x0,ACBiofPrev[$t0]
                        	.noFocus:
FFFC4FA8 FF9FD0EF		call	UnlockOS
FFFC4FAC 00012083		ldt		$ra,[$sp]
FFFC4FB0 00410113		add		$sp,$sp,#4
FFFC4FB4 00006513		ldi		$a0,#E_Ok
FFFC4FB8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;     Wait for the IO Focus. Returns only when focus is present. This function
                        	; calls PeekChar() to see if there's a CTRL-T in the buffer which means to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;   a1 = device # to check, 5 = COM1 serial port, 1 = KBD keyboard
                        	;------------------------------------------------------------------------------
                        	
FFFC4FBC 00000000		align	1
                        	
                        	_WaitForIOFocus:
                        	WaitForIOFocus:
FFFC4FC0 FF410113	  sub 	$sp,$sp,#12
FFFC4FC4 00A12023	  stt   $a0,[$sp]
FFFC4FC8 00B12223	  stt   $a1,4[$sp]
FFFC4FCC 00C12423	  stt   $a2,8[$sp]
                        	.WFF1:
FFFC4FD0 01406513		ldi		$a0,#20           ; FMTK Has Focus
FFFC4FD4 00000073		ecall
FFFC4FD8 04059663		bnez	$a1,.HasFocus
FFFC4FDC 01A06513		ldi   $a0,#26           ; FMTK_IO
FFFC4FE0 00506593		ldi   $a1,#5            ; hardcoded to serial port for now
FFFC4FE4 00906613		ldi   $a2,#9            ; peekchar function
FFFC4FE8 00000073		ecall
                        	;	call	SerialPeekChar
FFFC4FEC 0005C263		bltz  $a1,.0001
                        	.0001:
FFFC4FF0 01406513		ldi		$a0,#$14					; CTRL-T
FFFC4FF4 02A59063		bne		$a1,$a0,.WFF2
                        	;	call	SerialGetChar
                        		; eat up the CTRL-T
FFFC4FF8 01A06513		ldi		$a0,#26						; FMTK_IO
FFFC4FFC 00506593		ldi   $a1,#5  ;4[$sp]        ; get back device #
FFFC5000 00806613		ldi		$a2,#8						; getchar function
FFFC5004 00000073		ecall
FFFC5008 01506513		ldi		$a0,#21						; switch IO Focus
FFFC500C 00000073		ecall
FFFC5010 FC0000E3		bra		.WFF1
                        	.WFF2:
FFFC5014 00506513		ldi		$a0,#5            ; FMTK Sleep() function
FFFC5018 00106593		ldi		$a1,#1
FFFC501C 00000073		ecall
FFFC5020 FA0008E3		bra		.WFF1
                        	.HasFocus:
FFFC5024 00012503	  ldt   $a0,[$sp]
FFFC5028 00412583	  ldt   $a1,4[$sp]
FFFC502C 00812603	  ldt   $a2,8[$sp]
FFFC5030 00C10113	  add   $sp,$sp,#12
FFFC5034 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	
FFFC5038 00000000		align	1
FFFC503C 00000000
                        	
                        	GetUIFlag:
FFFC5040 FF410113	  sub 	$sp,$sp,#12
FFFC5044 00112023	  stt		$ra,[$sp]
FFFC5048 00C12223	  stt   $a2,4[$sp]
FFFC504C 00D12423	  stt   $a3,8[$sp]
FFFC5050 01B06513	  ldi   $a0,#27           ; Get DCB Field
FFFC5054 04206613	  ldi   $a2,#DCB_fUI      ; Get UI Flag
FFFC5058 00106693	  ldi   $a3,#1            ; 1 byte
FFFC505C 00000073	  ecall
FFFC5060 00012083	  ldt		$ra,[$sp]
FFFC5064 00412603	  ldt   $a2,4[$sp]
FFFC5068 00812683	  ldt   $a3,8[$sp]
FFFC506C 00C10113	  add   $sp,$sp,#12
FFFC5070 00008067	  ret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15   VIA							VIA1
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	.file "../fmtk/io.r5a",62
                        		code
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = function
                        	;		a3 = data
                        	;------------------------------------------------------------------------------
FFFC5074 00000000		align	1
FFFC5078 00000000
FFFC507C 00000000
                        	
                        	FMTK_IO:
                        	;  mEI
FFFC5080 FFC10113		sub		$sp,$sp,#4
FFFC5084 00112023		stt		$ra,[$sp]
FFFC5088 7C10F073		csrrc	$x0,#$7C1,#1				; clear OS running semaphore
FFFC508C 02006513		ldi		$a0,#32
FFFC5090 04A5F663		bgeu	$a1,$a0,.badDev
FFFC5094 02006393		ldi		$t2,#32
FFFC5098 02767A63		bgeu	$a2,$t2,.badFunc
FFFC509C 00759E13		sll		$t3,$a1,#7					; each device allowed 32 functions (*128)
FFFC50A0 00261393		sll		$t2,$a2,#2					; function number *4
FFFC50A4 FF0028B7		add		$t3,$t3,#DVF_Base		; base address of function table
FFFC50A8 00088893
FFFC50AC 011E0E33
FFFC50B0 007E0E33		add		$t3,$t3,$t2
FFFC50B4 000E2E03		ldt		$t3,[$t3]
FFFC50B8 000E0A63		beqz	$t3,.badFunc
FFFC50BC 000E00E7		call	[$t3]
FFFC50C0 00012083		ldt		$ra,[$sp]
FFFC50C4 00410113		add		$sp,$sp,#4
                        	.xit:
FFFC50C8 00008067		ret
                        	.badFunc:
FFFC50CC 02206513		ldi		$a0,#E_BadDevOp
FFFC50D0 00012083		ldt		$ra,[$sp]
FFFC50D4 00410113		add		$sp,$sp,#4
FFFC50D8 00008067		ret
                        	.badDev:
FFFC50DC 02006513		ldi		$a0,#E_BadDevNum
FFFC50E0 00012083		ldt		$ra,[$sp]
FFFC50E4 00410113		add		$sp,$sp,#4
FFFC50E8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = field offset
                        	;   a3 = 0 = get word, 1 = get byte
                        	;------------------------------------------------------------------------------
FFFC50EC 00000000		align 1
                        	
                        	FMTK_GetDCBField:
FFFC50F0 02006393		ldi		$t2,#32
FFFC50F4 0475F063		bgeu	$a1,$t2,.badDev
FFFC50F8 06006E13		ldi		$t3,#DCB_Size
FFFC50FC 03C67863		bgeu	$a2,$t3,.badFunc
FFFC5100 03C583B3		mul		$t2,$a1,$t3		      ; each device allowed (96 bytes)
FFFC5104 FF0038B7		add		$t2,$t2,#DCB_Base		; base address of function table
FFFC5108 00088893
FFFC510C 011383B3
FFFC5110 00C383B3		add   $t2,$t2,$a2         ; add field offset
FFFC5114 00068663		beqz  $a3,.ldWord
FFFC5118 00038583		ldb   $a1,[$t2]
FFFC511C 00000463		bra   .ok
                        	.ldWord:
FFFC5120 0003A583	  ldt   $a1,[$t2]
                        	.ok:
FFFC5124 00006513	  ldi   $a0,#E_Ok
                        	.xit:
FFFC5128 00008067		ret
                        	.badFunc:
FFFC512C 01A06513		ldi		$a0,#E_BadDCBOffset
FFFC5130 00008067		ret
                        	.badDev:
FFFC5134 02006513		ldi		$a0,#E_BadDevNum
FFFC5138 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = field offset
                        	;   a3 = 0 = get word, 1 = get byte
                        	;   a4 = value to set
                        	;------------------------------------------------------------------------------
FFFC513C 00000000		align	1
                        	
                        	ISetDCBField:
FFFC5140 02006393		ldi		$t2,#32
FFFC5144 0475F063		bgeu	$a1,$t2,.badDev
FFFC5148 06006E13		ldi		$t3,#DCB_Size
FFFC514C 03C67863		bgeu	$a2,$t3,.badFunc
FFFC5150 03C583B3		mul		$t2,$a1,$t3		      ; each device allowed (96 bytes)
FFFC5154 FF0038B7		add		$t2,$t2,#DCB_Base		; base address of function table
FFFC5158 00088893
FFFC515C 011383B3
FFFC5160 00C383B3		add   $t2,$t2,$a2         ; add field offset
FFFC5164 00068663		beqz  $a3,.stWord
FFFC5168 00E38023		stb   $a4,[$t2]
FFFC516C 00000463		bra   .ok
                        	.stWord:
FFFC5170 00E3A023	  stt   $a4,[$t2]
                        	.ok:
FFFC5174 00006513	  ldi   $a0,#E_Ok
                        	.xit:
FFFC5178 00008067		ret
                        	.badFunc:
FFFC517C 01A06513		ldi		$a0,#E_BadDCBOffset
FFFC5180 00008067		ret
                        	.badDev:
FFFC5184 02006513		ldi		$a0,#E_BadDevNum
FFFC5188 00008067		ret
                        	
FFFC518C 00000000		align	1
                        	
                        	FMTK_SetDCBField:
FFFC5190 FB1FF0EF		call	ISetDCBField
FFFC5194 ADCFE06F		jmp		OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = I/O channel
                        	;		a1 = points to function table
                        	;------------------------------------------------------------------------------
FFFC5198 00000000		align	1
FFFC519C 00000000
                        	
                        	CopyDevFuncTbl:
FFFC51A0 00751393		sll		$t2,$a0,#7					; each device allowed 32 functions (*128)
FFFC51A4 FF0028B7		add		$t2,$t2,#DVF_Base		; base address of function table
FFFC51A8 00088893
FFFC51AC 011383B3
FFFC51B0 02006293		ldi		$t0,#32							; 32 functions to copy
                        	.again:
FFFC51B4 0005A683		ldt		$a3,[$a1]
FFFC51B8 00D3A023		stt		$a3,[$t2]
FFFC51BC 00458593		add		$a1,$a1,#4
FFFC51C0 00438393		add		$t2,$t2,#4
FFFC51C4 FFF28293		sub		$t0,$t0,#1
FFFC51C8 FE5046E3		bgtz	$t0,.again
FFFC51CC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        		align	16                        	
                        	CopyDevDCB:
FFFC51D0 06006393	  ldi   $t2,#DCB_Size
FFFC51D4 027503B3	  mul   $t2,$a0,$t2
FFFC51D8 FF0038B7	  add   $t2,$t2,#DCB_Base
FFFC51DC 00088893
FFFC51E0 011383B3
FFFC51E4 01806293		ldi		$t0,#24							; 24 words to copy
                        	.again:
FFFC51E8 0005A683		ldt		$a3,[$a1]
FFFC51EC 00D3A023		stt		$a3,[$t2]
FFFC51F0 00458593		add		$a1,$a1,#4
FFFC51F4 00438393		add		$t2,$t2,#4
FFFC51F8 FFF28293		sub		$t0,$t0,#1
FFFC51FC FE5046E3		bgtz	$t0,.again
FFFC5200 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;    Compare the current APPID against the device owner to see if the device
                        	; is owned.
                        	;------------------------------------------------------------------------------
FFFC5204 00000000		align	1
FFFC5208 00000000
FFFC520C 00000000
                        	
                        	CheckDevOwner:
FFFC5210 FFC10113	  sub   $sp,$sp,#4
FFFC5214 00912023	  stt   $s1,[$sp]
FFFC5218 0040E073		csrrs $x0,#$004,#1        ; enable gc interrupt
FFFC521C 00E06513	  ldi   $a0,#14             ; FMTK: GetCurrentTid
FFFC5220 00000073	  ecall
FFFC5224 0005E4B3	  mov   $s1,$a1
FFFC5228 01B06513	  ldi   $a0,#27             ; FMTK Get DCB Field
FFFC522C 04806613	  ldi   $a2,#DCB_hJob
FFFC5230 00006693	  ldi   $a3,#0              ; get word
FFFC5234 00000073	  ecall
FFFC5238 0FF5F593	  and   $a1,$a1,#$FF
FFFC523C 0095C5B3	  xor   $a1,$a1,$s1
FFFC5240 00059A63	  bnez  $a1,.notOwner
FFFC5244 00006513	  ldi   $a0,#E_Ok
                        	.xit:
FFFC5248 00012483	  ldt   $s1,[$sp]
FFFC524C 00410113	  add   $sp,$sp,#4
FFFC5250 00008067	  ret
                        	.notOwner:
FFFC5254 01C06513	  ldi   $a0,#28             ; FMTK Set DCB field
FFFC5258 0004E5B3	  mov   $a1,$s1
FFFC525C 01806613	  ldi   $a2,#DCB_LastErc
FFFC5260 00006693	  ldi   $a3,#0              ; word
FFFC5264 01206713	  ldi   $a4,#E_NotOwner
FFFC5268 00000073	  ecall                     
FFFC526C 00076533	  mov   $a0,$a4
FFFC5270 FC000CE3	  bra   .xit
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/finalizer.r5a",1
                        	.file "../fmtk/finalizer.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; The Finalizer task examines the undead queue looking for tasks that haven't
                        	; been finalized yet. If there is no finalizer the task is marked dead, 
                        	; otherwise the task's execution point is changed to the task finalizer and
                        	; the task is placed back into the ready queue. The task finalizer should
                        	; exit by invoking the FinalizerExit routine of the OS.
                        	
                        	.file "../fmtk/finalizer.r5a",31
                        	  code  18 bits
FFFC5274 00000000	  align 1
FFFC5278 00000000
FFFC527C 00000000
                        	
                        	Finalizer:
FFFC5280 01806513	  ldi   $a0,#24               ; request I/O focus
FFFC5284 00000073	  ecall
FFFC5288 FFFC5537	  ldi   $a0,#msgFinalizerRunning
FFFC528C 37C50513
FFFC5290 C71FB0EF	  call  PutString
FFFC5294 01606513	  ldi   $a0,#22               ; release I/O focus
FFFC5298 00000073	  ecall
FFFC529C 00406513	  ldi   $a0,#4                ; set task priority
FFFC52A0 00306593	  ldi   $a1,#PRI_LOW
FFFC52A4 00000073	  ecall
                        	.yield:
FFFC52A8 00506513	  ldi   $a0,#5                ; Sleep
FFFC52AC 00006593	  ldi   $a1,#0                ; 0 to yeild
FFFC52B0 00000073	  ecall
                        	.nxt2:
FFFC52B4 01106513	  ldi   $a0,#17               ; RunAsOS
FFFC52B8 FFFC55B7	  ldi   $a1,.oscode
FFFC52BC 2C858593
FFFC52C0 00000073	  ecall
FFFC52C4 FE0008E3	  bra   .nxt2
                        	.oscode:
FFFC52C8 00706293	  ldi   $t0,#UNDEADQ
FFFC52CC 1A02850D	  popq  $a0,$t0
  bge   $a0,$x0,.nxt2         ; valid entry?
FFFC52D0 FE0552E3
FFFC52D4 000048B7	  and   $t1,$a0,#$4000        ; queue empty?
FFFC52D8 00088893
FFFC52DC 01157333
FFFC52E0 FC0314E3	  bnez  $t1,.yield            ; go back to yield
FFFC52E4 0FF57313	  and   $t1,$a0,#$FF
FFFC52E8 000008B7	  ldt   $a1,TidTcbMap[$t1]    ; get pointer to task
FFFC52EC 3F788893
FFFC52F0 006888B3
FFFC52F4 0008A583
FFFC52F8 FFF808B7	  and   $t1,$t1,#$FFF803FF    ; valid task pointer
FFFC52FC 3FF88893
FFFC5300 01137333
FFFC5304 FA0318E3	  bnez  $t1,.nxt2
FFFC5308 0305A303	  ldt   $t1,OBJFinalizer[$a1] ; Finalizer code?
FFFC530C 00030C63	  beqz  $t1,.noFinalizer
                        	  ; If there is finalizer code to run, the task is placed back into the ready
                        	  ; queue with the operating address set to the finalizer code.
FFFC5310 2C65A023	  stt   $t1,TCBepc[$a1]       ; Cause task to return to finalizer
FFFC5314 00306313	  ldi   $t1,#PRI_LOW
FFFC5318 2C6584A3	  stb		$t1,TCBPriority[$a1]
FFFC531C 0005E533	  mov		$a0,$a1
FFFC5320 C10FF0EF	  call	InsertIntoReadyQueue
                        	;  pushq $a0,$t1
                        	.noFinalizer:
FFFC5324 00206313	  ldi   $t1,#TS_DEAD
FFFC5328 2C658423	  stb   $t1,TCBStatus[$a1]
FFFC532C 08006313	  ldi   $t1,#OST_DEAD
FFFC5330 00658C23	  stb   $t1,OBJState[$a1]
FFFC5334 00006513	  ldi   $a0,#E_Ok
FFFC5338 00008067	  ret
FFFC533C F6000CE3	  bra   .nxt2
                        	
                        	FMTK_TCBFinalizerExit:
                        	  
FFFC5340 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC5344 0FF57313	and   $t1,$a0,#$FF
FFFC5348 000008B7	  ldt   $a1,TidTcbMap[$t1]    ; get pointer to task
FFFC534C 3F788893
FFFC5350 006888B3
FFFC5354 0008A583
FFFC5358 FFF808B7	  and   $t1,$t1,#$FFF803FF    ; valid task pointer
FFFC535C 3FF88893
FFFC5360 01137333
FFFC5364 00031A63	  bnez  $t1,.0001
FFFC5368 00206313	  ldi   $t1,#TS_DEAD
FFFC536C 2C658423	  stb   $t1,TCBStatus[$a1]
FFFC5370 08006313	  ldi   $t1,#OST_DEAD
FFFC5374 00658C23	  stb   $t1,OBJState[$a1]
                        	.0001:
FFFC5378 00008067	  ret
                        	
                        	msgFinalizerRunning:
FFFC537C 616E6946	  db  "Finalizer task running",CR,0
FFFC5380 657A696C
FFFC5384 61742072
FFFC5388 72206B73
FFFC538C 696E6E75
FFFC5390 000D676E
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/gcIncremental.r5a",1
                        	.file "../fmtk/gcIncremental.r5a",1
                        	; Garbage Collector
                        	
                        	gcIncrement:
FFFC5394 00008067	  ret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "TinyBasic.r5a",1
                        	.file "TinyBasic.r5a",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x6C0
                        	FILEBUF		EQU		0x07F600
                        	OSSP		EQU		0x700
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	SRCHLN    EQU   CURRNT+4
                        	; Reserved four byte area before BUFFER in case line number stuffed into it
                        	; is less than four digits.
                        	BUFFER		EQU		SRCHLN+8
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x001800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x00F000	; end of available memory
                        	STACKOFFS	EQU		0x00FFFC	; stack offset
                        	
                        	
                        	.file "TinyBasic.r5a",86
                        			code
FFFC5398 00000000			align	25
FFFC539C 00000000
FFFC53A0 00000000
FFFC53A4 00000000
FFFC53A8 00000000
FFFC53AC 00000000
FFFC53B0 00000000
FFFC53B4 00000000
FFFC53B8 00000000
FFFC53BC 00000000
FFFC53C0 00000000
FFFC53C4 00000000
FFFC53C8 00000000
FFFC53CC 00000000
FFFC53D0 00000000
FFFC53D4 00000000
FFFC53D8 00000000
FFFC53DC 00000000
FFFC53E0 00000000
FFFC53E4 00000000
FFFC53E8 00000000
FFFC53EC 00000000
FFFC53F0 00000000
FFFC53F4 00000000
FFFC53F8 00000000
FFFC53FC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC5400 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC5404 0EC0006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC5408 5B50106F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC540C 5B50106F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC5410 000008B7			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC5414 42788067
                        	GOAUXI:	
FFFC5418 000008B7			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC541C 42988067
                        	GOBYE:	
FFFC5420 5D10106F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC5424 00000000		align	1
FFFC5428 00000000
FFFC542C 00000000
                        	
                        	//message "CSTART"
                        	public CSTART:
	; First save off the link register and OS sp value
FFFC5430 00E06513		ldi		$a0,#14							; Get current tid
FFFC5434 00000073		ecall                     ; $a1 = task id
FFFC5438 01206513		ldi   $a0,#18             ; Get task app id
FFFC543C 00000073		ecall
FFFC5440 01806513		ldi		$a0,#24							; RequestIOFocus
FFFC5444 00000073		ecall
FFFC5448 02506513		ldi		$a0,#37							; Allocate memory
FFFC544C 00010637		ldi		$a2,#$10000					; request 64k
FFFC5450 00060613
FFFC5454 00000073		ecall
FFFC5458 0005E1B3		mov		$gp,$a1
FFFC545C 7021A023		stt		$sp,OSSP[$gp]
FFFC5460 000108B7		add		$sp,$gp,#STACKOFFS	; initialize stack pointer
FFFC5464 FFC88893
FFFC5468 01118133
                        	;	call	_DBGHomeCursor[pc]
FFFC546C 00006533		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC5470 FFFC7537		ldi		$a0,#msgInit  ;	tell who we are
FFFC5474 20450513
FFFC5478 34D010EF		call	PRMESG
FFFC547C 000028B7		add		$a0,$gp,#TXTBGN	;	init. end-of-program pointer
FFFC5480 80088893
FFFC5484 01118533
FFFC5488 70A1A223		stt		$a0,TXTUNF[$gp]
FFFC548C 0000F8B7		add		$a0,$gp,#ENDMEM	;	get address of end of memory
FFFC5490 00088893
FFFC5494 01118533
FFFC5498 0001E533		mov		$a0,$gp
FFFC549C 000108B7		add		$a0,$a0,#$F800	; 2k stack
FFFC54A0 80088893
FFFC54A4 01150533
                        	;	ldi		$a0,#$7F800 ; 2k stack
FFFC54A8 7AA1A223		stt		$a0,STKBOT[$gp]
FFFC54AC 0000F8B7		add		$a0,$gp,#ENDMEM
FFFC54B0 00088893
FFFC54B4 01118533
FFFC54B8 70A1A623		stt		$a0,VAREND[$gp]
FFFC54BC CE050513		sub		$a0,$a0,#800  ;   100 vars
FFFC54C0 70A1A423		stt   $a0,VARBGN[$gp]
FFFC54C4 4AC000EF		call  clearVars   ; clear the variable area
FFFC54C8 7A01A623		stt		$x0,IRQROUT[$gp]
FFFC54CC 7081A503		ldt   $a0,VARBGN[$gp]  ; calculate number of bytes free
FFFC54D0 7041A583		ldt		$a1,TXTUNF[$gp]
FFFC54D4 40B50533		sub   $a0,$a0,$a1
FFFC54D8 00606593		ldi		$a1,#6		; max 6 digits
FFFC54DC 00A06613		ldi		$a2,#10	  ; base 10
FFFC54E0 011010EF		call  PRTNUM
FFFC54E4 FFFC7537		ldi		$a0,#msgBytesFree
FFFC54E8 2A550513
FFFC54EC 2D9010EF		call	PRMESG
                        	WSTART:
FFFC54F0 7001A823		stt		$x0,LOPVAR[$gp]  ; initialize internal variables
FFFC54F4 7001AA23		stt		$x0,STKGOS[$gp]
FFFC54F8 7001AC23		stt		$x0,CURRNT[$gp]	;	current line number pointer = 0
FFFC54FC 000108B7		add		$sp,$gp,#STACKOFFS	;	init S.P. again, just in case
FFFC5500 FFC88893
FFFC5504 01118133
FFFC5508 FFFC7537		ldi		$a0,#msgReady	;	display "Ready"
FFFC550C 2B250513
FFFC5510 2B5010EF		call	PRMESG
                        	BASPRMPT:
FFFC5514 00E06513		ldi		$a0,#14		; get current tid
FFFC5518 00000073		ecall
FFFC551C 0005E533		mov		$a0,$a1   ;
FFFC5520 961FB0EF		call	PutHexByte
FFFC5524 03E06513		ldi		$a0,#'>'	; Prompt with a '>' and
FFFC5528 4BC010EF		call	GETLN		  ; read a line.
FFFC552C 1E9010EF		call	TOUPBUF 	; convert to upper case
FFFC5530 72418393		add		$t2,$gp,#BUFFER	; point to the beginning of line
FFFC5534 139010EF		call	TSTNUM		; is there a number there?
FFFC5538 1A5010EF		call	IGNBLK		; skip trailing blanks
FFFC553C 0003CB03		ldbu	$s6,[$t2]
FFFC5540 00DB4B13		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC5544 260C8E63		beqz	$s9,DIRECT		; if not, it's a direct statement ($s9 = num digits)
FFFC5548 00100337		ldi		$t1,#$FFFFF
FFFC554C FFF30313
FFFC5550 01837863		bleu	$s8,$t1,ST2	; see if line no. is <= 20 bits
FFFC5554 FFFC7537		ldi		$a0,#msgLineRange	; if not, we've overflowed
FFFC5558 2CD50513
FFFC555C 4440106F		jmp		ERROR
                        	ST2:
FFFC5560 000C6533	  mov		$a0,$s8		; a0 = line number
FFFC5564 0003EAB3	  mov		$s5,$t2			; save line buffer pointer
FFFC5568 FFB38393		sub		$t2,$t2,#5
FFFC556C 00A3A0A3	  stt		$a0,1[$t2]  ;	This will end up in buffer (requires unaligned store capability)
FFFC5570 568010EF		call	FNDLN		; find this line in save area
FFFC5574 000E6BB3		mov		$s7,$t3		; $s7 = save possible line pointer
FFFC5578 000C0663		beqz	$s8,INSLINE	; if not found, insert
FFFC557C 000E6533		mov		$a0,$t3
FFFC5580 050000EF		call	DeleteLine
                        	INSLINE:
FFFC5584 F80B08E3		beqz	$s6,BASPRMPT	; line was empty
FFFC5588 000AE533		mov		$a0,$s5			; a0 = buffer pointer
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC558C 094000EF		call	GetBuflen
FFFC5590 005C0A13		add		$s4,$s8,#5  ; update length, needed later
FFFC5594 FF4A8DA3		stb   $s4,-5[$s5] ; put length into buffer
FFFC5598 000BE533		mov		$a0,$s7
FFFC559C 000A65B3		mov		$a1,$s4
FFFC55A0 0AC000EF		call	OpenSpace
FFFC55A4 000C1863		bnez	$s8,.0001	  ; space available?
FFFC55A8 FFFC7537		ldi		$a0,#msgTooBig  ; no space available
FFFC55AC 39F50513
FFFC55B0 3F00106F		jmp		ERROR
                        	.0001:
FFFC55B4 000AE533	  mov   $a0,$s5
FFFC55B8 949FB0EF		call  PutString	
FFFC55BC 000BE533		mov		$a0,$s7			; target
FFFC55C0 FFBA8593		sub		$a1,$s5,#5	; source (incl lineno)
FFFC55C4 000A6633		mov		$a2,$s4			; length
FFFC55C8 038000EF		call	InsertLine
FFFC55CC F40004E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
FFFC55D0 00054283		ldbu  $t0,[$a0]     ; $t0 = length
FFFC55D4 00A282B3		add		$t0,$t0,$a0		; t0 = pointer to line past line number and length
FFFC55D8 70402E03		ldt		$t3,TXTUNF		; last text address
                        		; pull text after eol overtop
                        	.0003:
FFFC55DC 0002CE83		ldbu	$t4,[$t0]			; copy from next line
FFFC55E0 01D50023		stb		$t4,[$a0]			; overtop deleted line
FFFC55E4 00128293		add		$t0,$t0,#1		; increment pointers
FFFC55E8 00150513		add		$a0,$a0,#1
FFFC55EC FE5E78E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC55F0 40A28533		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC55F4 40AE0E33		sub		$t3,$t3,$a0		
FFFC55F8 71C02223		stt		$t3,TXTUNF
FFFC55FC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC5600 00060E63		beqz	$a2,.done		    ; zero length? Probably a SW error
                        	.0001:
FFFC5604 0005C303		ldbu	$t1,[$a1]				; get from source text
FFFC5608 00650023		stb		$t1,[$a0]				; store to insertion point
FFFC560C 00158593		add		$a1,$a1,#1			; increment pointers
FFFC5610 00150513		add		$a0,$a0,#1
FFFC5614 FFF60613		sub		$a2,$a2,#1			; decrement length
FFFC5618 FEC046E3		bgtz	$a2,.0001
                        	.done:
FFFC561C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		s8 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC5620 00006C13		ldi		$s8,#0
FFFC5624 00D06E13		ldi		$t3,#CR
FFFC5628 00056F33		mov		$t5,$a0
                        	.0002:
FFFC562C 000F4383		ldbu	$t2,[$t5]
FFFC5630 001F0F13		add		$t5,$t5,#1
FFFC5634 00038A63		beqz	$t2,.0001
FFFC5638 01C38663		beq		$t2,$t3,.0004
FFFC563C 001C0C13		add		$s8,$s8,#1
FFFC5640 FE0006E3		bra		.0002
                        	.0004:
FFFC5644 001C0C13		add		$s8,$s8,#1
                        	.0001:
FFFC5648 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		s8 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC564C 7041A383		ldt		$t2,TXTUNF[$gp]
FFFC5650 0003EE33		mov		$t3,$t2				; t3 = old end of text
FFFC5654 00B383B3		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC5658 7081A303		ldt		$t1,VARBGN[$gp]		; compare to start of variables
FFFC565C 0263F263		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC5660 70702223		stt		$t2,TXTUNF		; yes, set new end of text
                        	.0003:
FFFC5664 000E4F03		ldbu	$t5,[$t3]			; copy old text
FFFC5668 01E38023		stb		$t5,[$t2]			; to new text loc
FFFC566C FFFE0E13		sub		$t3,$t3,#1		; decrement pointers
FFFC5670 FFF38393		sub		$t2,$t2,#1
FFFC5674 FEAE78E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC5678 00106C13		ldi		$s8,#1				; return success
FFFC567C 00008067		ret
                        	.noSpace:
FFFC5680 00006C13		ldi		$s8,#0
FFFC5684 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC5688 D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC568C C4414F4C		db	"LOA",'D'+0x80
FFFC5690 52D7454E		db	"NE",'W'+0x80
FFFC5693 53CE5552		db	"RU",'N'+0x80
FFFC5696 C5564153		db	"SAV",'E'+0x80
FFFC569A 45454C53		db  "SLEE",'P'+0x80
FFFC569E 58454ED0
                        	TAB2:
FFFC569F D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC56A3 49D4454C		db	"LE",'T'+0x80
FFFC56A6 4F47C649		db	"I",'F'+0x80
FFFC56A8 CF544F47		db	"GOT",'O'+0x80
FFFC56AC 55534F47		db	"GOSU",'B'+0x80
FFFC56B0 544552C2
FFFC56B1 55544552		db	"RETUR",'N'+0x80
FFFC56B5 4552CE52
FFFC56B7 46CD4552		db	"RE",'M'+0x80
FFFC56BA 49D24F46		db	"FO",'R'+0x80
FFFC56BD 55504E49		db	"INPU",'T'+0x80
FFFC56C1 495250D4
FFFC56C2 4E495250		db	"PRIN",'T'+0x80
FFFC56C6 4B4F50D4
FFFC56C7 C54B4F50		db	"POK",'E'+0x80
FFFC56CB 454B4F50		db	"POKE",'W'+0x80
FFFC56CF 4B4F50D7
FFFC56D0 454B4F50		db	"POKE",'H'+0x80
FFFC56D4 454959C8
FFFC56D5 4C454959		db	"YIEL",'D'+0x80
FFFC56D9 4F5453C4
FFFC56DA D04F5453		db	"STO",'P'+0x80
FFFC56DE 53C55942		db	"BY",'E'+0x80
FFFC56E1 43D35953		db	"SY",'S'+0x80
FFFC56E4 43D34C43		db	"CL",'S'+0x80
FFFC56E7 52D24C43	    db  "CL",'R'+0x80
FFFC56EA C6434452	    db	"RDC",'F'+0x80
FFFC56EE 52494E4F	    db	"ONIR",'Q'+0x80
FFFC56F2 494157D1
FFFC56F3 D4494157	    db	"WAI",'T'+0x80
FFFC56F7 45455000		db	0
                        	TAB4:
FFFC56F8 CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC56FC 4B454550		db	"PEEK",'W'+0x80
FFFC5700 454550D7
FFFC5701 4B454550		db	"PEEK",'H'+0x80
FFFC5705 C44E52C8
FFFC5706 41C44E52		db	"RN",'D'+0x80
FFFC5709 53D34241		db	"AB",'S'+0x80
FFFC570C 54CE4753		db  "SG",'N'+0x80
FFFC570F CB434954		db	"TIC",'K'+0x80
FFFC5713 C55A4953		db	"SIZ",'E'+0x80
FFFC5717 41D25355		db  "US",'R'+0x80
FFFC571A 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC571E D8424D43
FFFC5722 444E4553	  db	"SENDMS",'G'+0x80
FFFC5726 57C7534D
FFFC5729 54494157	  db	"WAITMS",'G'+0x80
FFFC572D 00C7534D
FFFC5730 00CF5400		db	0
                        	TAB5:
FFFC5731 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC5733 45545300		db	0
                        	TAB6:
FFFC5734 D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC5738 3CBD3E00		db	0
                        	TAB8:
FFFC5739 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC573B BDBEBE3C		db	'<','>'+0x80
FFFC573D BD3CBDBE		db	'>'+0x80
FFFC573E BCBD3CBD		db	'='+0x80
FFFC573F 00BCBD3C		db	'<','='+0x80
FFFC5741 4E4100BC		db	'<'+0x80
FFFC5742 C44E4100		db	0
                        	TAB9:
FFFC5743 00C44E41	    db  "AN",'D'+0x80
FFFC5746 00D24F00	    db  0
                        	TAB10:
FFFC5747 E400D24F	    db  "O",'R'+0x80
FFFC5749 C459E400	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
                        		align	2                        	
                        	TAB1_1:
FFFC574A 5EC459E4		dh	LISTX			;Direct commands
FFFC574C 58405EC4		dh	LOAD3
FFFC574E 58985840		dh	NEW
FFFC5750 5F2C5898		dh	RUN
FFFC5752 585C5F2C		dh	SAVE3
FFFC5754 5BE4585C		dh  SLEEP
                        	TAB2_1:
FFFC5756 5D7C5BE4		dh	NEXT		;	Direct / statement
FFFC5758 5C5C5D7C		dh	LET
FFFC575A 59445C5C		dh	IF0
FFFC575C 5AD05944		dh	GOTO
FFFC575E 5B145AD0		dh	GOSUB
FFFC5760 5C685B14		dh	RETURN
FFFC5762 5B585C68		dh	IF2			; REM
FFFC5764 5CB05B58		dh	FOR
FFFC5766 5A305CB0		dh	INPUT
FFFC5768 608C5A30		dh	PRINT
FFFC576A 60B8608C		dh	POKE
FFFC576C 60E460B8		dh	POKEW
FFFC576E 589060E4		dh	POKEH
FFFC5770 58545890		dh	YIELD0
FFFC5772 54205854		dh	STOP
FFFC5774 611C5420		dh	GOBYE
FFFC5776 046B611C		dh	SYSX
FFFC5778 5968046B		dh	_cls
FFFC577A 046D5968		dh  _clr
FFFC577C 59A8046D		dh	_rdcf
FFFC577E 59D059A8		dh  ONIRQ
FFFC5780 5D7059D0		dh	WAITIRQ
FFFC5782 67385D70		dh	DEFLT
                        	TAB4_1:
FFFC5784 67506738		dh	PEEK			;Functions
FFFC5786 67686750		dh	PEEKW
FFFC5788 67C06768		dh	PEEKH
FFFC578A 000067C0		dh	RND
FFFC578C 68540000		dh	ABS
FFFC578E 68406854		dh  SGN
FFFC5790 68906840		dh	TICKX
FFFC5792 67806890		dh	SIZEX
FFFC5794 6FDC6780		dh  USRX
FFFC5796 70486FDC		dh	ALLOCMBX
FFFC5798 70E47048		dh	SENDMSG
FFFC579A 651470E4		dh	WAITMSG
FFFC579C 5B786514		dh	XP40
                        	TAB5_1
FFFC579E 69985B78		dh	FR1			;"TO" in "FOR"
FFFC57A0 5B946998		dh	QWHAT
                        	TAB6_1
FFFC57A2 5B9C5B94		dh	FR2			;"STEP" in "FOR"
FFFC57A4 62CC5B9C		dh	FR3
                        	TAB8_1
FFFC57A6 62E462CC		dh	XP11	;>=		Relational operators
FFFC57A8 62FC62E4		dh	XP12	;<>
FFFC57AA 632C62FC		dh	XP13	;>
FFFC57AC 6314632C		dh	XP15	;=
FFFC57AE 63446314		dh	XP14	;<=
FFFC57B0 63846344		dh	XP16	;<
FFFC57B2 61DC6384		dh	XP17
                        	TAB9_1
FFFC57B4 61F061DC	    dh  XP_AND
FFFC57B6 617C61F0	    dh  XP_ANDX
                        	TAB10_1
FFFC57B8 6190617C	    dh  XP_OR
FFFC57BA 00006190	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC57BC 00000000		align	1
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC57C0 FFFC5E37		ldi		$t3,#TAB1
FFFC57C4 688E0E13
FFFC57C8 FFFC5EB7		ldi		$t4,#TAB1_1
FFFC57CC 74AE8E93
                        	EXEC:
FFFC57D0 70C010EF		call	IGNBLK		; ignore leading blanks
FFFC57D4 0003EF33		mov		$t5,$t2		; save the pointer
FFFC57D8 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC57DC 0003C503		ldbu	$a0,[$t2]		; get the program character
FFFC57E0 00138393		add		$t2,$t2,#1
FFFC57E4 000E4583		ldbu	$a1,[$t3]		; get the table character
FFFC57E8 00059663		bnez	$a1,EXNGO		; If end of table,
FFFC57EC 000F63B3		mov		$t2,$t5		;	restore the text pointer and...
FFFC57F0 02000E63		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC57F4 02350C63		beq		$a0,r3,EXGO	; Else check for period... if so, execute
FFFC57F8 07F5F593		and		$a1,$a1,#$7f  ; ignore the table's high bit
FFFC57FC 02A58063		beq		$a1,$a0,EXMAT	;		is there a match?
FFFC5800 002E8E93		add		$t4,$t4,#2	;if not, try the next entry
FFFC5804 000F63B3		mov		$t2,$t5		; reset the program pointer
FFFC5808 000061B3		mov		r3,$x0		; sorry, no match
                        	EX1:
FFFC580C 000E0503		ldb	  $a0,[$t3]		; get to the end of the entry
FFFC5810 001E0E13		add		$t3,$t3,#1
FFFC5814 FE055CE3		bge   $a0,$x0,EX1
                        	;	and		$t1,$a0,#$80
                        	;	beq		$t1,$r0,EX1	; test for bit 7 set
FFFC5818 FC0002E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC581C 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC5820 000E0503		ldb	  $a0,[$t3]		; end of table entry?
FFFC5824 001E0E13		add		$t3,$t3,#1
FFFC5828 FA055AE3		bge   $a0,$x0,EXLP
                        	;	and		$t1,$a0,#$80
                        	;	beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC582C 000ED503		ldwu	$a0,[$t4]	; get the low mid order byte
FFFC5830 FFFC08B7		or		$a0,$a0,#$FFFC0000  ; add in ROM base
FFFC5834 00088893
FFFC5838 01156533
FFFC583C 00050067		jmp		[$a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC5840 110010EF		call	ENDCHK
FFFC5844 00002C37		ldi		$s8,#TXTBGN
FFFC5848 800C0C13
FFFC584C 7181A223		stt		$s8,TXTUNF[$gp]	;	set the end pointer
FFFC5850 120000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC5854 0FC010EF		call	ENDCHK
FFFC5858 C99FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SLEEP:
FFFC585C 0ED000EF		call	OREXPR		;evaluate the following expression
FFFC5860 000C64B3		mov   $s1,$s8
FFFC5864 0EC010EF	  call  ENDCHK
                        	SLEEP1:
FFFC5868 01606513	  ldi   $a0,#22   ; FMTK release I/O focus
FFFC586C 00000073	  ecall
FFFC5870 00506513	  ldi   $a0,#5    ; FMTK sleep function
FFFC5874 0004E5B3	  mov   $a1,$s1
FFFC5878 00000073	  ecall
FFFC587C 00E06513	  ldi   $a0,#14   ; FMTK get current tid
FFFC5880 00000073	  ecall
FFFC5884 01806513	  ldi   $a0,#24   ; FMTK request I/O focus
FFFC5888 00000073	  ecall
FFFC588C 23C0006F	  jmp   FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC5890 00006493	  ldi   $s1,#0
FFFC5894 FC000AE3	  bra   SLEEP1
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC5898 0B8010EF		call	ENDCHK
FFFC589C 000023B7		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC58A0 80038393
FFFC58A4 7071AC23		stt		$t2,CURRNT[$gp]
FFFC58A8 0C8000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC58AC 7181A383		ldt		$t2,CURRNT[$gp]	; executing a program?
FFFC58B0 00039463		bnez	$t2,RUN3	  ; if not, we've finished a direct stat.
                        	RUN2:
FFFC58B4 C3DFF06F		jmp		WSTART
                        	RUN3:
FFFC58B8 7071AE23	  stt   $t2,SRCHLN[$gp]
FFFC58BC 0003CE03	  ldbu  $t3,[$t2]
FFFC58C0 01C383B3	  add   $t2,$t2,$t3
FFFC58C4 7AC1A503		ldt		$a0,IRQROUT[$gp]	; are we handling IRQ's ?
FFFC58C8 04050463		beqz  $a0,RUN1
FFFC58CC 02306513		ldi   $a0,#35       ; Get IRQ flag, was there an IRQ?
FFFC58D0 00000073		ecall
FFFC58D4 020C0E63		beqz	$s8,RUN1
FFFC58D8 02406513		ldi   $a0,#36       ; Set IRQ flag
FFFC58DC 00006593		ldi   $a1,#0        ; set the flag to zero
FFFC58E0 00000073		ecall
FFFC58E4 2C8010EF		call	PUSHA_		; the same code as a GOSUB
FFFC58E8 FF410113		sub		$sp,$sp,#12
FFFC58EC 7141A503		ldt		$a0,STKGOS[$gp]
FFFC58F0 00A12023		stt		$a0,[$sp]
FFFC58F4 7181A503		ldt		$a0,CURRNT[$gp]
FFFC58F8 00A12223		stt		$a0,4[$sp]
FFFC58FC 00712423		stt		$t2,8[$sp]
FFFC5900 7001A823		stt		$x0,LOPVAR[$gp]		; load new values
FFFC5904 7021AA23		stt		$sp,STKGOS[$gp]
FFFC5908 7AC1AE03		ldt		$t3,IRQROUT[$gp]
FFFC590C 00000C63		bra		RUNTSL
                        	RUN1:
FFFC5910 0003EE33		mov		$t3,$t2
FFFC5914 00006533		mov		$a0,$x0
FFFC5918 218010EF		call	FNDNXT  		; else find the next line number
FFFC591C 7041A303		ldt		$t1,TXTUNF[$gp]	; if we've fallen off the end, stop
FFFC5920 F86E7AE3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC5924 71C1AC23		stt		$t3,CURRNT[$gp]	; set CURRNT to point to the line no.
FFFC5928 005E0393		add		$t2,$t3,#5	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC592C 668010EF		call	CHKIO		; see if a control-C was pressed
FFFC5930 FFFC5E37		ldi		$t3,#TAB2		; find command in TAB2
FFFC5934 69FE0E13
FFFC5938 FFFC5EB7		ldi		$t4,#TAB2_1
FFFC593C 756E8E93
FFFC5940 E91FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC5944 005000EF		call	OREXPR		;evaluate the following expression
FFFC5948 000C62B3		mov   $t0,$s8
FFFC594C 004010EF		call 	ENDCHK		;must find end of line
FFFC5950 0002E533		mov   $a0,$t0
FFFC5954 184010EF		call 	FNDLN		; find the target line
FFFC5958 FC0C16E3		bnez	$s8,RUNTSL  ; go do it
FFFC595C FFFC7537		ldi		$a0,#msgBadGotoGosub
FFFC5960 36D50513
FFFC5964 03C0106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC5968 008000EF	    call    clearVars
FFFC596C 15C0006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC5970 FF810113		sub		$sp,$sp,#8
FFFC5974 00612023		stt		r6,[$sp]
FFFC5978 00112223		stt		$ra,4[$sp]
FFFC597C 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC5980 7081AC03	  ldt   $s8,VARBGN[$gp]
                        	.cv1:
FFFC5984 000C2023	  stt		x0,[$s8]		; variable name
FFFC5988 000C2223	  stt		x0,4[$s8]		; and value
FFFC598C 008C0C13	  add		s8,s8,#8
FFFC5990 FFF30313	  sub		r6,r6,#1
FFFC5994 FE6048E3		bgt		r6,x0,.cv1
FFFC5998 00012303	  ldt		r6,[$sp]
FFFC599C 00412083	  ldt		$ra,4[$sp]
FFFC59A0 00810113	  add		$sp,$sp,#8
FFFC59A4 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC59A8 7A0000EF		call	OREXPR		;evaluate the following expression
FFFC59AC 000C62B3		mov   $t0,$s8
FFFC59B0 7A1000EF		call 	ENDCHK		;must find end of line
FFFC59B4 0002E533		mov   $a0,$t0
FFFC59B8 120010EF		call 	FNDLN		; find the target line
FFFC59BC 000C1663		bnez	$s8,ONIRQ1
FFFC59C0 7A01A623		stt		$x0,IRQROUT[$gp]
FFFC59C4 1040006F		jmp		FINISH
                        	ONIRQ1:
FFFC59C8 7BC1A623		stt		$t3,IRQROUT[$gp]
FFFC59CC 0FC0006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC59D0 5C4010EF		call	CHKIO		; see if a control-C was pressed
FFFC59D4 02306513		ldi   $a0,#35
FFFC59D8 00000073		ecall
FFFC59DC FE050AE3		beqz	$a0,WAITIRQ
FFFC59E0 0E80006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC59E4 488010EF		call		TSTNUM		; see if there's a line no.
FFFC59E8 000C62B3		mov      r5,$s8
FFFC59EC 765000EF		call		ENDCHK		; if not, we get a zero
FFFC59F0 0002E533		mov      $a0,r5
FFFC59F4 0E4010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC59F8 000C1663		bnez		$s8,LS4
                        	LS5:
FFFC59FC 7041A303		ldt		$t1,TXTUNF[$gp]
FFFC5A00 AE6E78E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC5A04 000E6533		mov		$a0,$t3
FFFC5A08 3BC010EF		call	PRTLN		; print the line
FFFC5A0C 00054E03		ldbu  $t3,[$a0]
FFFC5A10 00AE0E33		add   $t3,$t3,$a0 ; set pointer for next
                        	;	mov		$t3,$s8		
FFFC5A14 580010EF		call	CHKIO		; check for listing halt request
FFFC5A18 00050A63		beqz	$a0,LS3
FFFC5A1C 01306313		ldi		$t1,#CTRLS
FFFC5A20 00651663		bne		$a0,$t1,LS3 ; pause the listing?
                        	LS2:
FFFC5A24 570010EF		call 	CHKIO		; if so, wait for another keypress
FFFC5A28 FE050EE3		beqz	$a0,LS2
                        	LS3:
                        	;	mov		$s8,$x0
FFFC5A2C FC0008E3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC5A30 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC5A34 3EC010EF		call	TSTC		; if null list and ":"
FFFC5A38 0000003A		dw		':'
FFFC5A3C 00000663		bra		PR2
FFFC5A40 57C010EF		call	CRLF		; give CR-LF and continue
FFFC5A44 EE9FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC5A48 3D8010EF		call	TSTC		;if null list and <CR>
FFFC5A4C 0000000D		dw		CR
FFFC5A50 00000663		bra		PR0
FFFC5A54 568010EF		call	CRLF		;also give CR-LF and
FFFC5A58 E55FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC5A5C 3C4010EF		call	TSTC		;else is it a format?
FFFC5A60 00000023		dw		'#'
FFFC5A64 00000863		bra		PR1
FFFC5A68 6E0000EF		call	OREXPR		; yes, evaluate expression
FFFC5A6C 000C62B3		mov		r5,s8	; and save it as print width
FFFC5A70 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC5A74 3AC010EF		call	TSTC	;	is character expression? (MRL)
FFFC5A78 00000024		dw		'$'
FFFC5A7C 00000863		bra		PR4
FFFC5A80 6C8000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC5A84 985FF0EF		call	GOOUT	;	print low byte (MRL)
FFFC5A88 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC5A8C 1CC010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC5A90 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC5A94 38C010EF		call		TSTC	;	if ",", go find next
FFFC5A98 0000002C		dw		','
FFFC5A9C 00000663		bra		PR6
FFFC5AA0 675000EF		call		FIN		;in the list.
FFFC5AA4 FA000CE3		bra		PR0
                        	PR6:
FFFC5AA8 514010EF		call		CRLF		;list ends here
FFFC5AAC 01C0006F		jmp		FINISH
                        	PR8:
FFFC5AB0 698000EF		call	OREXPR		; evaluate the expression
FFFC5AB4 000C6533		mov		$a0,$s8
FFFC5AB8 00506593		ldi		$a1,#5		; set the width
FFFC5ABC 00A06613		ldi		$a2,#10
FFFC5AC0 230010EF		call	PRTNUM		; print its value
FFFC5AC4 FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC5AC8 64D000EF		call	FIN		; Check end of command
FFFC5ACC 6CD0006F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC5AD0 0DC010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC5AD4 674000EF		call	OREXPR		; get line number
FFFC5AD8 000C6533		mov		$a0,$s8
FFFC5ADC 7FD000EF		call	FNDLN		; find the target line
FFFC5AE0 000C1863		bnez	$s8,gosub1
FFFC5AE4 FFFC7537		ldi		a0,#msgBadGotoGosub
FFFC5AE8 36D50513
FFFC5AEC 6B50006F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC5AF0 FF410113		sub		$sp,$sp,#12
FFFC5AF4 71402503		lw		a0,STKGOS	; 'STKGOS'
FFFC5AF8 00A12023		sw		a0,[$sp]
FFFC5AFC 7181A503		lw		a0,CURRNT[$gp]	; found it, save old 'CURRNT'...
FFFC5B00 00A12223		sw		a0,4[$sp]
FFFC5B04 00712423		sw		$t2,8[$sp]
FFFC5B08 7001A823		sw		$x0,LOPVAR[$gp]		; load new values
FFFC5B0C 7021AA23		sw		$sp,STKGOS[$gp]
FFFC5B10 E15FF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC5B14 63D000EF		call	ENDCHK		; there should be just a <CR>
FFFC5B18 7141A583		ldt		$a1,STKGOS[$gp]		; get old stack pointer
FFFC5B1C 00059863		bne		a1,x0,return1
FFFC5B20 FFFC7537		ldi		a0,#msgRetWoGosub
FFFC5B24 38950513
FFFC5B28 6790006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC5B2C 0005E133		mov		$sp,a1		; else restore it
FFFC5B30 00012503		lw		a0,[$sp]
FFFC5B34 00410113		add		$sp,$sp,#4
FFFC5B38 70A1AA23		sw		a0,STKGOS[$gp]	; and the old 'STKGOS'
FFFC5B3C 00012503		lw		a0,[$sp]
FFFC5B40 00410113		add		$sp,$sp,#4
FFFC5B44 70A1AC23		stt		$a0,CURRNT[$gp]	; and the old 'CURRNT'
FFFC5B48 00012383		lw		$t2,[$sp]	; and the old text pointer
FFFC5B4C 00410113		add		$sp,$sp,#4
FFFC5B50 024010EF		call	POPA_		;and the old 'FOR' parameters
FFFC5B54 F75FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC5B58 054010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC5B5C 551000EF		call	SETVAL		; set the control variable
FFFC5B60 7181A823		stt		$s8,LOPVAR[$gp]		; save its address
FFFC5B64 FFFC5E37		ldi		$t3,#TAB5
FFFC5B68 731E0E13
FFFC5B6C FFFC5EB7		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC5B70 79EE8E93
FFFC5B74 C5DFF06F		jmp		EXEC
                        	FR1:
FFFC5B78 5D0000EF		call	OREXPR		; evaluate the limit
FFFC5B7C 7981A223		stt		$s8,LOPLMT[$gp]	; save that
FFFC5B80 FFFC5E37		ldi		$t3,#TAB6
FFFC5B84 734E0E13
FFFC5B88 FFFC5EB7		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC5B8C 7A2E8E93
FFFC5B90 C41FF06F		jmp		EXEC
                        	FR2:
FFFC5B94 5B4000EF		call	OREXPR		; found it, get the step value
FFFC5B98 00000463		bra		FR4
                        	FR3:
FFFC5B9C 00106C13		ldi		s8,#1		; not found, step defaults to 1
                        	FR4:
FFFC5BA0 7981A023		sw		s8,LOPINC[$gp]	; save that too
                        	FR5:
FFFC5BA4 7181A583		lw		a1,CURRNT[$gp]
FFFC5BA8 76B1AE23		sw		a1,LOPLN[$gp]	; save address of current line number
FFFC5BAC 7671AC23		sw		$t2,LOPPT[$gp]	; and text pointer
FFFC5BB0 000161B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC5BB4 7101A303		lw		r6,LOPVAR[$gp]
FFFC5BB8 00000463		bra		FR7
                        	FR6:
FFFC5BBC 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC5BC0 0001A583		lw		a1,[r3]		; is it zero?
FFFC5BC4 00058E63		beq		a1,x0,FR8	; if so, we're done
FFFC5BC8 FE659AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC5BCC 0001E533	  mov		a0,r3	   ; Else remove 5 words from...
FFFC5BD0 000165B3		mov		a1,$sp
FFFC5BD4 01418613		add		a2,r3,#20  ; inside the stack.
FFFC5BD8 795000EF		call	MVDOWN
FFFC5BDC 01410113		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC5BE0 EE9FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC5BE4 00006533		mov		a0,x0		; don't allocate it
FFFC5BE8 1A1000EF		call	TSTV		; get address of variable
FFFC5BEC 000C1863		bne		s8,x0,NX4
FFFC5BF0 FFFC7537		ldi		a0,#msgNextVar
FFFC5BF4 34A50513
FFFC5BF8 5A0004E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC5BFC 000C6E33		mov		$t3,s8	; save variable's address
                        	NX0:
FFFC5C00 7101A503		lw		a0,LOPVAR[$gp]	; If 'LOPVAR' is zero, we never...
FFFC5C04 00051863		bne		a0,x0,NX5	; had a FOR loop
FFFC5C08 FFFC7537		ldi		a0,#msgNextFor
FFFC5C0C 33850513
FFFC5C10 580008E3		bra		ERROR
                        	NX5:
FFFC5C14 01C50663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC5C18 75D000EF		call	POPA_		; nope, let's see the next frame
FFFC5C1C FE0002E3		bra		NX0
                        	NX2:
FFFC5C20 000E2503		lw		a0,[$t3]		; get control variable's value
FFFC5C24 7801A583		lw		a1,LOPINC[$gp]
FFFC5C28 00B50533		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC5C2C 00AE2023		sw		a0,[$t3]		; save control variable's new value
FFFC5C30 7841A183		lw		r3,LOPLMT[$gp]	; get loop's limit value
FFFC5C34 0005D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC5C38 00354E63		blt		a0,r3,NXPurge	; test against limit
FFFC5C3C 00000463		bra     NX3
                        	NX1:
FFFC5C40 00A1CA63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC5C44 77C1A383		lw		$t2,LOPLN[$gp]	; Within limit, go back to the...
FFFC5C48 7071AC23		sw		$t2,CURRNT[$gp]
FFFC5C4C 7781A383		lw		$t2,LOPPT[$gp]	; saved 'CURRNT' and text pointer.
FFFC5C50 E79FF06F		jmp		FINISH
                        	NXPurge:
FFFC5C54 721000EF	  call    POPA_        ; purge this loop
FFFC5C58 E71FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC5C5C 4EC000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC5C60 000C0463	  beqz	$s8,IF2	; is it zero? if not, continue
FFFC5C64 CC9FF06F	  jmp		RUNSML
                        	IF2:
FFFC5C68 0003EE33	  mov		$t3,$t2	; set lookup pointer
FFFC5C6C 00006533		mov		$a0,$x0		; find line #0 (impossible)
FFFC5C70 7181A503		ldt   $a0,CURRNT[$gp]  ; move to the next line
FFFC5C74 00054583		ldbu  $a1,[$a0]
FFFC5C78 00A585B3		add   $a1,$a1,$a0
FFFC5C7C 70B1AC23		stt   $a1,CURRNT[$gp]
FFFC5C80 7041A503		ldt   $a0,TXTUNF[$gp]  ; do a warm start if past end
FFFC5C84 00A5E463		bltu  $a1,$a0,IF3
FFFC5C88 869FF06F		jmp		WSTART
                        	IF3:
FFFC5C8C 0005EE33	  mov   $t3,$a1
FFFC5C90 C95FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC5C94 7A002103		ldt		$sp,STKINP		; restore the old stack pointer
FFFC5C98 00012503		ldt		$a0,[$sp]
FFFC5C9C 00410113		add		$sp,$sp,#4
FFFC5CA0 70A1AC23		stt		$a0,CURRNT[$gp]		; and old 'CURRNT'
FFFC5CA4 00012383		ldt		$t2,[$sp]		; and old text pointer
FFFC5CA8 00410113		add		$sp,$sp,#4
FFFC5CAC 01410113		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC5CB0 FEC10113		sub		$sp,$sp,#20	; allocate five words on stack
FFFC5CB4 00512823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC5CB8 00712023		sw		$t2,[$sp]	; save in case of error
FFFC5CBC 79D000EF		call	QTSTG		; is next item a string?
FFFC5CC0 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC5CC4 00106513		ldi		a0,#1		; allocate var
FFFC5CC8 0C1000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC5CCC 08050463		beq    a0,r0,IP4   ; if not, brnch
FFFC5CD0 00056EB3		mov		$t4,a0		; put away the variable's address
FFFC5CD4 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC5CD8 00712223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC5CDC 00106513		ldi		a0,#1
FFFC5CE0 0A9000EF		call	TSTV		; must be a variable now
FFFC5CE4 00051A63		bne		a0,r0,IP7
FFFC5CE8 FFFC7537		ldi		a0,#msgInputVar
FFFC5CEC 31C50513
FFFC5CF0 01410113		add		$sp,$sp,#20	; cleanup stack
FFFC5CF4 4A0006E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC5CF8 00056EB3		mov		$t4,a0		; put away the variable's address
FFFC5CFC 0003C283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC5D00 00038023		sb		x0,[$t2]
FFFC5D04 000065B3		mov		a1,x0
FFFC5D08 00412503		lw		a0,4[$sp]	; get back text pointer
FFFC5D0C 6E5000EF		call	PRTSTG		; print string as prompt
FFFC5D10 00538023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC5D14 00712223		sw		$t2,4[$sp]	; save in case of error
FFFC5D18 7181A503		lw		a0,CURRNT[$gp]
FFFC5D1C 00A12423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC5D20 FFF06513		ldi		a0,#-1
FFFC5D24 70A1AC23		sw		a0,CURRNT[$gp]	; flag that we are in INPUT
FFFC5D28 7A21A023		sw		$sp,STKINP[$gp]	; save the stack pointer too
FFFC5D2C 01D12623		sw		$t4,12[$sp]	; save the variable address
FFFC5D30 03A06513		ldi		a0,#':'		; print a colon first
FFFC5D34 4B1000EF		call	GETLN		; then get an input line
FFFC5D38 72418393		add		$t2,$gp,#BUFFER	; point to the buffer
FFFC5D3C 40C000EF		call	OREXPR		; evaluate the input
FFFC5D40 00C12E83		lw		$t4,12[$sp]	; restore the variable address
FFFC5D44 00AEA023		sw		a0,[$t4]	; save value in variable
FFFC5D48 00812503		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC5D4C 70A1AC23		sw		a0,CURRNT[$gp]
FFFC5D50 00412383		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC5D54 0CC010EF		call	TSTC
FFFC5D58 0000002C		dw		','
FFFC5D5C 00000463		bra		IP5
FFFC5D60 F4000CE3		bra		IP6			; yes, more items
                        	IP5:
FFFC5D64 01012283		lw		r5,16[$sp]
FFFC5D68 01410113		add		$sp,$sp,#20	; cleanup stack
FFFC5D6C D5DFF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC5D70 0003C503	  lbu    	a0,[$t2]
FFFC5D74 00D06313	  ldi			$t1,#CR
FFFC5D78 D46508E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC5D7C 331000EF	  call	SETVAL		; do the assignment
FFFC5D80 0A0010EF		call	TSTC		; check for more 'LET' items
FFFC5D84 0000002C		dw		','
FFFC5D88 D41FF06F		jmp		FINISH
FFFC5D8C FE0008E3		bra	    LET
                        	LT1:
FFFC5D90 D39FF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC5D94 000023B7		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC5D98 80038393
FFFC5D9C 00D06513		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC5DA0 E70FF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC5DA4 E74FF0EF		call	GOAUXI		; look for start of line
FFFC5DA8 FEA05EE3		ble		a0,r0,LOD1
FFFC5DAC 04006313		ldi		$t1,#'@'
FFFC5DB0 02650E63		beq		a0,$t1,LODEND	; end of program?
FFFC5DB4 01A06313		ldi		$t1,#$1A
FFFC5DB8 02650A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC5DBC 03A06313		ldi		$t1,#':'
FFFC5DC0 FE6512E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC5DC4 030000EF		call	GCHAR		; get line number
FFFC5DC8 00A3A023		sw		a0,[$t2]		; store it
FFFC5DCC 00438393		add		$t2,$t2,#4
                        	LOD2:
FFFC5DD0 E48FF0EF		call	GOAUXI		; get another text char.
FFFC5DD4 FEA05EE3		ble		a0,r0,LOD2
FFFC5DD8 00A38023		sb		a0,[$t2]		; store it
FFFC5DDC 00138393		add		$t2,$t2,#1
FFFC5DE0 00D06313		ldi		$t1,#CR
FFFC5DE4 FE6516E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC5DE8 FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC5DEC 70702223		sw		$t2,TXTUNF	; set end-of program pointer
FFFC5DF0 F00FF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC5DF4 FF410113		sub		$sp,$sp,#12
FFFC5DF8 00512023		sw		r5,[$sp]
FFFC5DFC 00612223		sw		r6,4[$sp]
FFFC5E00 00112423		sw		$ra,8[$sp]
FFFC5E04 00806313		ldi		r6,#8       ; repeat ten times
FFFC5E08 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC5E0C E0CFF0EF		call	GOAUXI		; get a char
FFFC5E10 FEA05EE3		ble		a0,r0,GCHAR1
FFFC5E14 02C000EF		call	asciiToHex
FFFC5E18 00429293		sll		r5,r5,#4
FFFC5E1C 00A2E2B3		or		r5,r5,a0
FFFC5E20 FFF30313		sub		r6,r6,#1
FFFC5E24 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC5E28 0002E533		mov		a0,r5
FFFC5E2C 00012283		lw		r5,[$sp]
FFFC5E30 00412303		lw		r6,4[$sp]
FFFC5E34 00812083		lw		$ra,8[$sp]
FFFC5E38 00C10113		add		$sp,$sp,#12
FFFC5E3C 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC5E40 03906313		ldi		$t1,#'9'
FFFC5E44 00A37463		bleu	a0,$t1,a2h1; less than '9'
FFFC5E48 FF950513		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC5E4C FD050513		sub		a0,a0,#'0'
FFFC5E50 00F57513		and		a0,a0,#15	; make sure a nybble
FFFC5E54 00008067		ret
                        	
                        	GetFilename:
FFFC5E58 FFC10113		sub		$sp,$sp,#4
FFFC5E5C 00112023		sw		$ra,[$sp]
FFFC5E60 7C1000EF		call	TSTC
FFFC5E64 00000022		dw		'"'
FFFC5E68 04000C63		bra		gfn1
FFFC5E6C 000061B3		mov		r3,r0
                        	gfn2:
FFFC5E70 0003C503		lbu		a0,[$t2]		; get text character
FFFC5E74 00138393		add		$t2,$t2,#1
FFFC5E78 02206313		ldi		$t1,#'"'
FFFC5E7C 02650263		beq		a0,$t1,gfn3
FFFC5E80 02050063		beq		a0,r0,gfn3
FFFC5E84 6CA18023		sb		a0,FILENAME[r3]
FFFC5E88 00118193		add		r3,r3,#1
FFFC5E8C 04006313		ldi		$t1,#64
FFFC5E90 FE61E0E3		bltu	r3,$t1,gfn2
FFFC5E94 00012083		lw		$ra,[$sp]
FFFC5E98 00410113		add		$sp,$sp,#4
FFFC5E9C 00008067		ret
                        	gfn3:
FFFC5EA0 02006513		ldi		a0,#' '
FFFC5EA4 6CA18023		sb		a0,FILENAME[r3]
FFFC5EA8 00118193		add		r3,r3,#1
FFFC5EAC 04006313		ldi		$t1,#64
FFFC5EB0 FE61E8E3		bltu	r3,$t1,gfn3
FFFC5EB4 00012083		lw		$ra,[$sp]
FFFC5EB8 00410113		add		$sp,$sp,#4
FFFC5EBC 00008067		ret
                        	gfn1:
FFFC5EC0 E30FF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC5EC4 F95FF0EF		call	GetFilename
FFFC5EC8 000008B7		call	AUXIN_INIT
FFFC5ECC 4E6880E7
FFFC5ED0 EC5FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC5ED4 000015B7		ldi		a1,#$E00
FFFC5ED8 E0058593
FFFC5EDC 000008B7		call	SDReadSector
FFFC5EE0 4E7880E7
FFFC5EE4 00150513		add		a0,a0,#1
FFFC5EE8 000025B7		ldi		a1,#TXTBGN
FFFC5EEC 80058593
                        	LOAD4:
FFFC5EF0 FFC10113		sub		$sp,$sp,#4
FFFC5EF4 00A12023		sw		a0,[$sp]
FFFC5EF8 000008B7		call	SDReadSector
FFFC5EFC 4E7880E7
FFFC5F00 20058593		add		a1,a1,#512
FFFC5F04 00012503		lw		a0,[$sp]
FFFC5F08 00410113		add		$sp,$sp,#4
FFFC5F0C 00150513		add		a0,a0,#1
FFFC5F10 00002237		ldi		r4,#TXTBGN
FFFC5F14 80020213
FFFC5F18 000108B7		add		r4,r4,#65536
FFFC5F1C 00088893
FFFC5F20 01120233
FFFC5F24 FC45C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC5F28 DC000463		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC5F2C F2DFF0EF		call	GetFilename
FFFC5F30 000008B7		call	AUXOUT_INIT
FFFC5F34 4EA880E7
FFFC5F38 0600006F		jmp		SAVE
                        	
FFFC5F3C 20C000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC5F40 000015B7		ldi		a1,#$E00	; starting address to write
FFFC5F44 E0058593
FFFC5F48 000008B7		call	SDWriteSector
FFFC5F4C 4EC880E7
FFFC5F50 00150513		add		a0,a0,#1
FFFC5F54 000025B7		ldi		a1,#TXTBGN
FFFC5F58 80058593
                        	SAVE4:
FFFC5F5C FFC10113		sub		$sp,$sp,#4
FFFC5F60 00A12023		sw		a0,[$sp]
FFFC5F64 000008B7		call	SDWriteSector
FFFC5F68 4EC880E7
FFFC5F6C 20058593		add		a1,a1,#512
FFFC5F70 00012503		lw		a0,[$sp]
FFFC5F74 00410113		add		$sp,$sp,#4
FFFC5F78 00150513		add		a0,a0,#1
FFFC5F7C 00002237		ldi		r4,#TXTBGN
FFFC5F80 80020213
FFFC5F84 000108B7		add		r4,r4,#65536
FFFC5F88 00088893
FFFC5F8C 01120233
FFFC5F90 FC45C6E3		blt		a1,r4,SAVE4
FFFC5F94 D4000E63		bra		WSTART
                        	
                        	SAVE:
FFFC5F98 000028B7		add		$t2,$gp,#TXTBGN	;set pointer to start of prog. area
FFFC5F9C 80088893
FFFC5FA0 011183B3
FFFC5FA4 7041AE03		lw		$t3,TXTUNF[$gp]	;set pointer to end of prog. area
                        	SAVE1:
FFFC5FA8 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC5FAC 027E4863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC5FB0 03A06513		ldi		a0,#':'		; if not, start a line
FFFC5FB4 C5CFF0EF		call	GOAUXO
FFFC5FB8 0003A503		lw		a0,[$t2]		; get line number
FFFC5FBC 00438393		add		$t2,$t2,#4
FFFC5FC0 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC5FC4 0003C503		lbu		a0,[$t2]		; get a text char.
FFFC5FC8 00138393		add		$t2,$t2,#1
FFFC5FCC 00D06313		ldi		$t1,#CR
FFFC5FD0 FC650CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC5FD4 C3CFF0EF		call	GOAUXO		; send it out
FFFC5FD8 FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC5FDC 04006513		ldi		a0,#'@'		; send end-of-program indicator
FFFC5FE0 C30FF0EF		call	GOAUXO
FFFC5FE4 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC5FE8 01A06513		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC5FEC C24FF0EF		call	GOAUXO
FFFC5FF0 000008B7		call	AUXOUT_FLUSH
FFFC5FF4 4F3880E7
FFFC5FF8 CE000C63		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC5FFC FFC10113		sub		$sp,$sp,#4
FFFC6000 00112023		sw		$ra,[$sp]
FFFC6004 00D06513	  ldi		a0,#CR
FFFC6008 C08FF0EF	  call	GOAUXO
FFFC600C 00A06513	  ldi		a0,#LINEFD
FFFC6010 C00FF0EF	  call	GOAUXO
FFFC6014 00012083	  lw		$ra,[$sp]
FFFC6018 00410113	  add		$sp,$sp,#4
FFFC601C 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC6020 FF810113		sub		$sp,$sp,#8
FFFC6024 00512023		sw		r5,[$sp]
FFFC6028 00112223		sw		$ra,4[$sp]
FFFC602C 7AA18293		add		r5,$gp,#NUMWKA+14
FFFC6030 00056233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC6034 00026533	  mov   a0,r4	    ; a0 = value
FFFC6038 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC603C 038000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC6040 00A28023	  sb    a0,[r5]		; save in work area
FFFC6044 FFF28293	  sub		r5,r5,#1
FFFC6048 79C18313	  add		$t1,$gp,#NUMWKA
FFFC604C FE62D4E3		bge		r5,$t1,pword1
                        	pword2:
FFFC6050 00128293	  add		r5,r5,#1
FFFC6054 0002C503	  lbu   a0,[r5]     ; get char to output
FFFC6058 BB8FF0EF		call	GOAUXO		; send it
FFFC605C 7AA18313		add		$t1,$gp,#NUMWKA+14
FFFC6060 FE62C8E3		blt		r5,$t1,pword2
FFFC6064 00012283		lw		r5,[$sp]
FFFC6068 00412083		lw		$ra,4[$sp]
FFFC606C 00810113		add		$sp,$sp,#8
FFFC6070 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC6074 00F57513		and		a0,a0,#15	; make sure it's a nybble
FFFC6078 00A06313		ldi		$t1,#10
FFFC607C 00654463		blt		a0,$t1,tah1	; > 10 ?
FFFC6080 00750513		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC6084 03050513		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC6088 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC608C 0BC000EF		call	OREXPR		; get the memory address
FFFC6090 591000EF		call	TSTC		; it must be followed by a comma
FFFC6094 0000002C		dw		','
FFFC6098 06000C63		bra		PKER
FFFC609C FFC10113		sub		$sp,$sp,#4
FFFC60A0 00A12023		sw		a0,[$sp]	; save the address
FFFC60A4 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC60A8 00012583		lw		a1,[$sp]	; get the address back
FFFC60AC 00410113		add		$sp,$sp,#4
FFFC60B0 00A58023		sb		a0,[a1]		; store the byte in memory
FFFC60B4 A15FF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC60B8 090000EF		call	OREXPR		; get the memory address
FFFC60BC 565000EF		call	TSTC		; it must be followed by a comma
FFFC60C0 0000002C		dw		','
FFFC60C4 04000663		bra		PKER
FFFC60C8 FFC10113		sub		$sp,$sp,#4
FFFC60CC 00A12023		sw		a0,[$sp]	; save the address
FFFC60D0 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC60D4 00012583		lw		a1,[$sp]	; get the address back
FFFC60D8 00410113		add		$sp,$sp,#4
FFFC60DC 00A5A023		sw		a0,[a1]		; store the byte in memory
FFFC60E0 9E9FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC60E4 064000EF		call	OREXPR		; get the memory address
FFFC60E8 539000EF		call	TSTC		; it must be followed by a comma
FFFC60EC 0000002C		dw		','
FFFC60F0 02000063		bra		PKER
FFFC60F4 FFC10113		sub		$sp,$sp,#4
FFFC60F8 00A12023		sw		a0,[$sp]	; save the address
FFFC60FC 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC6100 00012583		lw		a1,[$sp]	; get the address back
FFFC6104 00410113		add		$sp,$sp,#4
FFFC6108 00A59023		sh		a0,[a1]		; store the byte in memory
FFFC610C 9BDFF06F		jmp		FINISH
                        	
                        	PKER:
FFFC6110 FFFC7537		ldi		a0,#msgComma
FFFC6114 2BA50513
FFFC6118 0890006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC611C 02C000EF		call	OREXPR		; get the subroutine's address
FFFC6120 000C1863		bne		s8,r0,sysx1; make sure we got a valid address
FFFC6124 FFFC7537		ldi		a0,#msgSYSBad
FFFC6128 30B50513
FFFC612C 0750006F		jmp		ERROR
                        	sysx1:
FFFC6130 FFC10113		sub		$sp,$sp,#4
FFFC6134 00712023		stt		$t2,[$sp]	; save the text pointer
FFFC6138 000C00E7		call	[s8]			; jump to the subroutine
FFFC613C 00012383		ldt		$t2,[$sp]	; restore the text pointer
FFFC6140 00410113		add		$sp,$sp,#4
FFFC6144 985FF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC6148 FF41310D		gcsub	$sp,$sp,#12
FFFC614C 00112023		sw		$ra,[$sp]
FFFC6150 00312223		sw		r3,4[$sp]
FFFC6154 00412423		sw		r4,8[$sp]
FFFC6158 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC615C FF810113		sub		$sp,$sp,#8
FFFC6160 01812023		sw		$s8,[$sp]		; save <ANDEXPR> value
FFFC6164 01912223		sw		$s9,4[$sp]	; save type
FFFC6168 FFFC5E37		ldi		$t3,#TAB10	; look up a logical operator
FFFC616C 747E0E13
FFFC6170 FFFC5EB7		ldi		$t4,#TAB10_1
FFFC6174 7B8E8E93
FFFC6178 E58FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC617C 034000EF	  call	ANDEXPR
FFFC6180 00012503	  lw		$a0,[$sp]
FFFC6184 00810113	  add		$sp,$sp,#8
FFFC6188 00AC6C33	  or    s8,s8,a0
FFFC618C FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC6190 00012C03	  lw		$s8,[$sp]
FFFC6194 00412C83	  lw		$s9,4[$sp]
FFFC6198 00810113	  add		$sp,$sp,#8
FFFC619C 00012083		lw		$ra,[$sp]
FFFC61A0 00412183		lw		r3,4[$sp]
FFFC61A4 00812203		lw		r4,8[$sp]
FFFC61A8 00C10113		add		$sp,$sp,#12
FFFC61AC 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC61B0 FFC10113		sub		$sp,$sp,#4
FFFC61B4 00112023		sw		$ra,[$sp]
FFFC61B8 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC61BC FF810113		sub		$sp,$sp,#8
FFFC61C0 01812023		sw		$s8,[$sp]		; save <EXPR> value
FFFC61C4 01912223		sw		$s9,4[$sp]	; save type
FFFC61C8 FFFC5E37		ldi		$t3,#TAB9		; look up a logical operator
FFFC61CC 743E0E13
FFFC61D0 FFFC5EB7		ldi		$t4,#TAB9_1
FFFC61D4 7B4E8E93
FFFC61D8 DF8FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC61DC 0C4000EF	  call	EXPR
FFFC61E0 00012503	  lw		$a0,[$sp]
FFFC61E4 00810113	  add		$sp,$sp,#8
FFFC61E8 00AC7C33	  and   s8,s8,a0
FFFC61EC FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC61F0 00012C03	  lw		$s8,[$sp]
FFFC61F4 00412C83	  lw		$s9,4[$sp]
FFFC61F8 00810113	  add		$sp,$sp,#8
FFFC61FC 00012083		lw		$ra,[$sp]
FFFC6200 00410113		add		$sp,$sp,#4
FFFC6204 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC6208 03006313		ldi		$t1,#'0'
FFFC620C 00654A63		blt		$a0,$t1,isDigitFalse
FFFC6210 03906313		ldi		$t1,#'9'
FFFC6214 00A34663		bgt		$a0,$t1,isDigitFalse
FFFC6218 00106C13		ldi		$s8,#1
FFFC621C 00008067	  ret
                        	isDigitFalse:
FFFC6220 00006C33	  mov		$s8,$x0
FFFC6224 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC6228 04106313		ldi		$t1,#'A'
FFFC622C 02654263		blt		$a0,$t1,isAlphaFalse
FFFC6230 05A06313		ldi		$t1,#'Z'
FFFC6234 00A35A63		ble		$a0,$t1,isAlphaTrue
FFFC6238 06106313		ldi		$t1,#'a'
FFFC623C 00654A63		blt		$a0,$t1,isAlphaFalse
FFFC6240 07A06313		ldi		$t1,#'z'
FFFC6244 00A34663		bgt		$a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC6248 00106C13	  ldi		$s8,#1
FFFC624C 00008067	  ret
                        	isAlphaFalse:
FFFC6250 00006C33	  mov		$s8,$x0
FFFC6254 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC6258 FFC10113		sub		$sp,$sp,#4
FFFC625C 00112023		sw		$ra,[$sp]
FFFC6260 FA9FF0EF	  call	isDigit
FFFC6264 000C1463		bne		s8,r0,isDigitx	; if it is a digit
FFFC6268 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC626C 00012083		lw		$ra,[$sp]
FFFC6270 00410113		add		$sp,$sp,#4
FFFC6274 00008067	  ret
                        	
                        	FORCEFIT:
FFFC6278 03958263		beq		a1,s9,.0001				; types match
FFFC627C 00006293		ldi		$t0,#0
FFFC6280 00558663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$s8
FFFC6284 00106513		ldi		a0,#1
FFFC6288 00008067		ret
                        	.intAnd:
FFFC628C 00106293		ldi		$t0,#1
FFFC6290 005C9663		bne		$s9,$t0,.0001
                        	;	itof	$f2,$a1
FFFC6294 00106593		ldi		$a1,#1
FFFC6298 00008067		ret
                        	.0001:
FFFC629C 00008067		ret
                        	
                        	EXPR:
FFFC62A0 FFC10113		sub		$sp,$sp,#4
FFFC62A4 00112023		sw		$ra,[$sp]
FFFC62A8 11C000EF		call	ADDEXPR
FFFC62AC FF810113		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC62B0 01812023		sw		s8,[$sp]
FFFC62B4 01912223		sw		s9,4[$sp]					; save type
FFFC62B8 FFFC5E37		ldi		$t3,#TAB8		; look up a relational operator
FFFC62BC 739E0E13
FFFC62C0 FFFC5EB7		ldi		$t4,#TAB8_1
FFFC62C4 7A6E8E93
FFFC62C8 D08FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC62CC 00012503		lw		a0,[$sp]
FFFC62D0 00412583		lw		a1,4[$sp]
FFFC62D4 00810113		add		$sp,$sp,#8
FFFC62D8 0C4000EF		call	XP18	; is it ">="?
FFFC62DC 09855A63		bge		a0,s8,XPRT1	; no, return s8=1
FFFC62E0 06000E63		bra		XPRT0	; else return s8=0
                        	XP12:
FFFC62E4 00012503		lw		a0,[$sp]
FFFC62E8 00412583		lw		a1,4[$sp]
FFFC62EC 00810113		add		$sp,$sp,#8
FFFC62F0 0AC000EF		call	XP18	; is it "<>"?
FFFC62F4 07851E63		bne		a0,s8,XPRT1	; no, return a1=1
FFFC62F8 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC62FC 00012503		lw		a0,[$sp]
FFFC6300 00412583		lw		a1,4[$sp]
FFFC6304 00810113		add		$sp,$sp,#8
FFFC6308 094000EF		call	XP18	; is it ">"?
FFFC630C 06AC4263		bgt		a0,s8,XPRT1	; no, return a1=1
FFFC6310 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC6314 00012503		lw		a0,[$sp]
FFFC6318 00412583		lw		a1,4[$sp]
FFFC631C 00810113		add		$sp,$sp,#8
FFFC6320 07C000EF		call	XP18	; is it "<="?
FFFC6324 04AC5663		ble		a0,s8,XPRT1	; no, return a1=1
FFFC6328 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC632C 00012503		lw		a0,[$sp]
FFFC6330 00412583		lw		a1,4[$sp]
FFFC6334 00810113		add		$sp,$sp,#8
FFFC6338 064000EF		call	XP18	; is it "="?
FFFC633C 03850A63		beq		a0,s8,XPRT1	; if not, return a1=1
FFFC6340 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC6344 00012503		lw		a0,[$sp]
FFFC6348 00412583		lw		a1,4[$sp]
FFFC634C 00810113		add		$sp,$sp,#8
FFFC6350 04C000EF		call	XP18	; is it "<"?
FFFC6354 01854E63		blt		a0,s8,XPRT1	; if not, return a1=1
FFFC6358 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC635C 00006C33		mov		s8,x0   ; return a0=0 (false)
FFFC6360 00006CB3		mov		s9,x0		; type = int
FFFC6364 00012083		lw		$ra,[$sp]
FFFC6368 00410113		add		$sp,$sp,#4
FFFC636C 00008067		ret
                        	XPRT1:
FFFC6370 00106C13		ldi		s8,#1	; return a0=1 (true)
FFFC6374 00006C93		ldi		s9,#0	; type = int
FFFC6378 00012083		lw		$ra,[$sp]
FFFC637C 00410113		add		$sp,$sp,#4
FFFC6380 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC6384 00012C03		lw		s8,[$sp]; return a1=<ADDEXPR>
FFFC6388 00412C83		lw		s9,4[$sp]
FFFC638C 00810113		add		$sp,$sp,#8
FFFC6390 00012083		lw		$ra,[$sp]
FFFC6394 00410113		add		$sp,$sp,#4
FFFC6398 00008067		ret
                        	
                        	XP18:
FFFC639C FF410113		sub		$sp,$sp,#12
FFFC63A0 00112023		sw		$ra,[$sp]
FFFC63A4 01812223		sw		s8,4[$sp]
FFFC63A8 01912423		sw		s9,8[$sp]
FFFC63AC 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC63B0 00412503		lw		a0,4[$sp]
FFFC63B4 00812583		lw		a1,8[$sp]
FFFC63B8 00012083		lw		$ra,[$sp]
FFFC63BC 00C10113		add		$sp,$sp,#12
FFFC63C0 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC63C4 FFC10113		sub		$sp,$sp,#4
FFFC63C8 00112023		sw		$ra,[$sp]
FFFC63CC 255000EF		call	TSTC		; negative sign?
FFFC63D0 0000002D		dw		'-'
FFFC63D4 00000C63		bra		XP21
FFFC63D8 00006C33		mov		s8,r0		; yes, fake '0-'
FFFC63DC FF810113		sub		$sp,$sp,#8
FFFC63E0 01812023		sw		s8,[$sp]
FFFC63E4 01912223		sw		s9,4[$sp]
FFFC63E8 04000863		bra		XP26
                        	XP21:
FFFC63EC 235000EF		call	TSTC		; positive sign? ignore it
FFFC63F0 0000002B		dw		'+'
FFFC63F4 00000263		bra		XP22
                        	XP22:
FFFC63F8 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC63FC FF810113		sub		$sp,$sp,#8; yes, save the value
FFFC6400 01812023		sw		s8,[$sp]
FFFC6404 01912223		sw		s9,4[$sp]	; and type
FFFC6408 219000EF		call	TSTC		; add?
FFFC640C 0000002B		dw		'+'
FFFC6410 00000E63		bra		XP25
FFFC6414 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC6418 00012503		lw		a0,[$sp]
FFFC641C 00412583		lw		a1,4[$sp]
FFFC6420 00810113		add		$sp,$sp,#8
FFFC6424 00AC0C33		add		s8,s8,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC6428 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC642C 1F5000EF		call	TSTC		; subtract?
FFFC6430 0000002D		dw		'-'
FFFC6434 00000863		bra		XP45
                        	XP26:
FFFC6438 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC643C 41800C33		sub		s8,r0,s8	; change its sign
FFFC6440 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC6444 00012C03		lw		s8,[$sp]
FFFC6448 00412C83		lw		s9,4[$sp]
FFFC644C 00810113		add		$sp,$sp,#8
FFFC6450 00012083		lw		$ra,[$sp]
FFFC6454 00410113		add		$sp,$sp,#4
FFFC6458 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC645C FFC10113		sub		$sp,$sp,#4
FFFC6460 00112023		sw		$ra,[$sp]
FFFC6464 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC6468 FF810113		sub		$sp,$sp,#8
FFFC646C 01812023		sw		s8,[$sp]; yes, save that first result
FFFC6470 01912223		sw		s9,4[$sp]
FFFC6474 1AD000EF		call	TSTC		; multiply?
FFFC6478 0000002A		dw		'*'
FFFC647C 00000E63		bra		XP34
FFFC6480 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC6484 00012503		lw		a0,[$sp]
FFFC6488 00412583		lw		a1,4[$sp]
FFFC648C 00810113		add		$sp,$sp,#8
FFFC6490 02AC0C33		mul		s8,s8,a0	; multiply the two
FFFC6494 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC6498 189000EF		call	TSTC		; divide?
FFFC649C 0000002F		dw		'/'
FFFC64A0 00000E63		bra		XP35
FFFC64A4 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC64A8 00012503		lw		a0,[$sp]
FFFC64AC 00412583		lw		a1,4[$sp]
FFFC64B0 00810113		add		$sp,$sp,#8
FFFC64B4 02AC4C33		div		s8,s8,a0	; do the division
FFFC64B8 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC64BC 165000EF		call	TSTC
FFFC64C0 00000025		dw		'%'
FFFC64C4 00000E63		bra		XP47
FFFC64C8 030000EF		call	FUNCEXPR
FFFC64CC 00012503		lw		a0,[$sp]
FFFC64D0 00412583		lw		a1,4[$sp]
FFFC64D4 00810113		add		$sp,$sp,#8
FFFC64D8 02AC6C33		rem		s8,s8,a0
FFFC64DC F80006E3		bra		XP31
                        	XP47:
FFFC64E0 00012C03		lw		s8,[$sp]
FFFC64E4 00412C83		lw		s9,4[$sp]
FFFC64E8 00810113		add		$sp,$sp,#8
FFFC64EC 00012083		lw		$ra,[$sp]
FFFC64F0 00410113		add		$sp,$sp,#4
FFFC64F4 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC64F8 FFC1310D		gcsub	$sp,$sp,#4
FFFC64FC 00112023		stt		$ra,[$sp]
FFFC6500 FFFC5E37	  ldi		$t3,#TAB4		; find possible function
FFFC6504 6F8E0E13
FFFC6508 FFFC5EB7	  ldi		$t4,#TAB4_1
FFFC650C 784E8E93
FFFC6510 AC0FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC6514 00006533		mov		$a0,$x0
FFFC6518 070000EF		call	TSTV
FFFC651C 000C0A63		beqz  $s8,XP41	  ; not a variable
FFFC6520 000C2C03		ldt		$s8,[$s8]		; if a variable, return its value in s8
FFFC6524 00012083		ldt		$ra,[$sp]
FFFC6528 00410113		add		$sp,$sp,#4
FFFC652C 00008067		ret
                        	XP41:
FFFC6530 13D000EF		call	TSTNUM		; or is it a number?
FFFC6534 000C9463		bnez	$s9,XP46	; (if not, # of digits will be zero) if so, return it in s8
FFFC6538 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC653C 00012083		ldt		$ra,[$sp]
FFFC6540 00410113		add		$sp,$sp,#4
FFFC6544 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC6548 FFC1310D		gcsub	$sp,$sp,#4
FFFC654C 00112023		stt		$ra,[$sp]	
FFFC6550 0D1000EF		call	TSTC		; else look for ( OREXPR )
FFFC6554 00000028		dw		'('
FFFC6558 02000063		bra		XP43
FFFC655C BEDFF0EF		call	OREXPR
FFFC6560 0C1000EF		call	TSTC
FFFC6564 00000029		dw		')'
FFFC6568 00000863		bra		XP43
                        	XP42:
FFFC656C 00012083		ldt		$ra,[$sp]
FFFC6570 00410113		add		$sp,$sp,#4
FFFC6574 00008067		ret
                        	XP43:
FFFC6578 00410113		add		$sp,$sp,#4		; get rid of return address
FFFC657C FFFC7537		ldi		$a0,#msgWhat
FFFC6580 24050513
FFFC6584 41C0006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		s8 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC6588 FF810113		sub		$sp,$sp,#8
FFFC658C 00512023		sw		r5,[$sp]
FFFC6590 00112223		sw		$ra,4[$sp]
FFFC6594 000562B3		mov		r5,a0		; r5=allocate flag
FFFC6598 145000EF		call	IGNBLK
FFFC659C 0003C503		lbu		a0,[$t2]		; look at the program text
FFFC65A0 04006313		ldi		$t1,#'@'
FFFC65A4 06654263		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC65A8 02651E63		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC65AC 00138393		add		$t2,$t2,#1	; If it is, it should be
FFFC65B0 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC65B4 00000263		bra		TV3
                        	TV3:
FFFC65B8 FFC10113		sub		$sp,$sp,#4	; save the index
FFFC65BC 01812023		sw		s8,[$sp]
FFFC65C0 2D0000EF		call	SIZEX		; get amount of free memory
FFFC65C4 00012583		lw		a1,[$sp]
FFFC65C8 00410113		add		$sp,$sp,#4	; get back the index
FFFC65CC 0185C663		blt		a1,s8,TV2		; see if there's enough memory
FFFC65D0 00810113		add		$sp,$sp,#8
FFFC65D4 3B80006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC65D8 7081A503		lw		a0,VARBGN[$gp]	; put address of array element...
FFFC65DC 40B50C33		sub   s8,a0,a1    ; into a0 (neg. offset is used)
FFFC65E0 00000C63		bra   TSTVRT
                        	TV1:	
FFFC65E4 038000EF	  call	getVarName      ; get variable name
FFFC65E8 000C0863	  beq   s8,x0,TSTVRT    ; if not, return s8=0
FFFC65EC 000C6533	  mov		a0,s8
FFFC65F0 0002E5B3	  mov		a1,r5
FFFC65F4 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC65F8 00012283		lw		r5,[$sp]
FFFC65FC 00412083		lw		$ra,4[$sp]
FFFC6600 00810113		add		$sp,$sp,#8
FFFC6604 00008067		ret								; s8<>0 (if found)
                        	tstv_notfound:
FFFC6608 00012283		lw		r5,[$sp]
FFFC660C 00412083		lw		$ra,4[$sp]
FFFC6610 00810113		add		$sp,$sp,#8
FFFC6614 00006C33		mov		s8,x0				; s8=0 if not found
FFFC6618 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   s8 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC661C FF41310D		gcsub	$sp,$sp,#12
FFFC6620 00512023		sw		r5,[$sp]
FFFC6624 00112223		sw		$ra,4[$sp]
FFFC6628 0003C503	  lbu   a0,[$t2]		; get first character
FFFC662C 00A12423	  sw		a0,8[$sp]		; save off current name
FFFC6630 BF9FF0EF	  call	isAlpha
FFFC6634 080C0063	  beq   s8,r0,gvn1
FFFC6638 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC663C 00138393		add		$t2,$t2,#1
FFFC6640 0003C503		lbu   a0,[$t2]		; do we have another char ?
FFFC6644 C15FF0EF		call	isAlnum
FFFC6648 020C0863		beq   s8,x0,gvn2	; nope
FFFC664C 00812503		lw		a0,8[$sp]		; get varname
FFFC6650 00851513		sll		a0,a0,#8
FFFC6654 0003C583		lbu   a1,[$t2]
FFFC6658 00B56533		or    a0,a0,a1   	; add in new char
FFFC665C 00A12423	  sw		a0,8[$sp]		; save off current name again
FFFC6660 FFF28293	  sub		r5,r5,#1
FFFC6664 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC6668 00138393		add		$t2,$t2,#1
FFFC666C 0003C503		lbu   a0,[$t2]		; do we have another char ?
FFFC6670 BE9FF0EF	  call  isAlnum
FFFC6674 FE0C1AE3	  bne   s8,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC6678 0003C583		lbu   a1,[$t2]
FFFC667C 02506313		ldi		$t1,#'%'
FFFC6680 00658A63		beq		a1,$t1,gvn3
FFFC6684 02406313		ldi		$t1,#'$'
FFFC6688 00658663		beq		a1,$t1,gvn3
FFFC668C FFF38393	  sub		$t2,$t2,#1
FFFC6690 02E06593	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC6694 00138393		add		$t2,$t2,#1
FFFC6698 00812503		lw		a0,8[$sp]		; get varname
FFFC669C 00851513		sll		a0,a0,#8
FFFC66A0 00B56C33	  or    s8,a0,a1    ; add in variable type
FFFC66A4 00012283	  lw		r5,[$sp]
FFFC66A8 00412083	  lw		$ra,4[$sp]
FFFC66AC 00C10113	  add		$sp,$sp,#12
FFFC66B0 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC66B4 00012283		lw		r5,[$sp]
FFFC66B8 00412083	  lw		$ra,4[$sp]
FFFC66BC 00C10113		add		$sp,$sp,#12
FFFC66C0 00006C33	  mov		s8,x0       ; return s8 = 0 if not a varname
FFFC66C4 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   s8 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC66C8 FF810113		sub		$sp,$sp,#8
FFFC66CC 00712023		sw		x7,[$sp]
FFFC66D0 00312223		sw		x3,4[$sp]
FFFC66D4 7081A183	  lw    x3,VARBGN[$gp]
                        	fv4:
FFFC66D8 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC66DC 02038663	  beq   x7,x0,fv3		; no more vars ?
FFFC66E0 02750863	  beq   a0,x7,fv1		; match ?
FFFC66E4 00818193		add		x3,x3,#8		; move to next var
FFFC66E8 70C1A383	  ldt   x7,VAREND[$gp]		; 
FFFC66EC FE71C6E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC66F0 00012383	  lw		x7,[$sp]
FFFC66F4 00412183	  lw		x3,4[$sp]
FFFC66F8 00810113	  add		$sp,$sp,#8
FFFC66FC FFFC7537	  ldi		a0,#msgVarSpace
FFFC6700 28E50513
FFFC6704 29C0006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC6708 00058E63		beq		a1,x0,fv2
FFFC670C 00A1A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC6710 00418C13	  add		s8,x3,#4
FFFC6714 00012383	  lw		x7,[$sp]
FFFC6718 00412183	  lw		x3,4[$sp]
FFFC671C 00810113	  add		$sp,$sp,#8
FFFC6720 00008067	  ret			    			; s8 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC6724 00012383	  lw		x7,[$sp]
FFFC6728 00412183	  lw		x3,4[$sp]
FFFC672C 00810113	  add		$sp,$sp,#8
FFFC6730 00006C33		mov		s8,x0				; s8 = nullptr
FFFC6734 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC6738 E11FF0EF		call	PARN		; get the memory address
FFFC673C 000C0C03		ldb		$s8,[$s8]	; get the addressed byte
FFFC6740 00006CB3		mov		$s9,$x0		; type = int
FFFC6744 00012083		ldt		$ra,[$sp]
FFFC6748 00410113		add		$sp,$sp,#4
FFFC674C 00008067		ret
                        	PEEKW:
FFFC6750 DF9FF0EF		call	PARN		; get the memory address
FFFC6754 000C2C03		ldt		$s8,[$s8]		; get the addressed word
FFFC6758 00006CB3		mov		$s9,$x0			; type = int
FFFC675C 00012083		ldt		$ra,[$sp]
FFFC6760 00410113		add		$sp,$sp,#4
FFFC6764 00008067		ret
                        	PEEKH:
FFFC6768 DE1FF0EF		call	PARN		; get the memory address
FFFC676C 000C1C03		ldw		$s8,[$s8]		; get the addressed byte
FFFC6770 00006CB3		mov		$s9,$x0			; type = int
FFFC6774 00012083		ldt		$ra,[$sp]
FFFC6778 00410113		add		$sp,$sp,#4
FFFC677C 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC6780 FFC1310D		gcsub	$sp,$sp,#4
FFFC6784 00512023		stt		$t0,[$sp]
FFFC6788 DC1FF0EF		call	PARN		; get expression value
FFFC678C 000C6533		mov		$a0,$s8
FFFC6790 000CE5B3		mov		$a1,$s9
FFFC6794 FFC1310D		gcsub	$sp,$sp,#4	; save the text pointer
FFFC6798 00712023		stt		$t2,[$sp]
FFFC679C 7A81A283		ldt		$t0,usrJmp[$gp]
FFFC67A0 000280E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC67A4 00012383		ldt		$t2,[$sp]	; restore the text pointer
FFFC67A8 00410113		add		$sp,$sp,#4
FFFC67AC 00012283		ldt		$t0,[$sp]
FFFC67B0 00410113		add		$sp,$sp,#4
FFFC67B4 00012083		ldt		$ra,[$sp]
FFFC67B8 00410113		add		$sp,$sp,#4
FFFC67BC 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC67C0 D89FF0EF		call	PARN		; get the upper limit
FFFC67C4 040C0063		beq		s8,r0,rnd2	; it must be positive and non-zero
FFFC67C8 020C4663		blt		s8,r0,rnd1
FFFC67CC 000C65B3		mov		a1,s8
FFFC67D0 000C6CB3		mov		s9,s8
FFFC67D4 000008B7		call	gen_rand	; generate a random number
FFFC67D8 535880E7
FFFC67DC 039C6C33		rem		s8,s8,s9
FFFC67E0 001C0C13		add		s8,s8,#1
FFFC67E4 00006CB3		mov		s9,x0
FFFC67E8 00012083		lw		$ra,[$sp]
FFFC67EC 00410113		add		$sp,$sp,#4
FFFC67F0 00008067		ret
                        	rnd1:
FFFC67F4 FFFC7537		ldi		a0,#msgRNDBad
FFFC67F8 2F850513
FFFC67FC 00410113		add		$sp,$sp,#4
FFFC6800 1A00006F		jmp		ERROR
                        	rnd2:
FFFC6804 000008B7		call	gen_rand	; generate a random number
FFFC6808 535880E7
FFFC680C 00006CB3		mov		s9,x0
FFFC6810 00012083		lw		$ra,[$sp]
FFFC6814 00410113		add		$sp,$sp,#4
FFFC6818 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC681C D2DFF0EF		call	PARN		; get the following expr.'s value
FFFC6820 000C4863		blt		s8,r0,ABS1
FFFC6824 00012083		lw		$ra,[$sp]
FFFC6828 00410113		add		$sp,$sp,#4
FFFC682C 00008067		ret
                        	ABS1:
FFFC6830 41800C33		sub		s8,x0,s8
FFFC6834 00012083		lw		$ra,[$sp]
FFFC6838 00410113		add		$sp,$sp,#4
FFFC683C 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC6840 C0001C73		csrrw	s8,#$C00,x0
FFFC6844 00006CB3		mov		s9,x0
FFFC6848 00012083		lw		$ra,[$sp]
FFFC684C 00410113		add		$sp,$sp,#4
FFFC6850 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC6854 CF5FF0EF		call	PARN		; get the following expr.'s value
FFFC6858 00006CB3		mov		s9,x0
FFFC685C 020C0463		beq		s8,r0,SGN1
FFFC6860 000C4A63		blt		s8,r0,SGN2
FFFC6864 00106C13		ldi		s8,#1
FFFC6868 00012083		lw		$ra,[$sp]
FFFC686C 00410113		add		$sp,$sp,#4
FFFC6870 00008067		ret
                        	SGN2:
FFFC6874 FFF06C13		ldi		s8,#-1
FFFC6878 00012083		lw		$ra,[$sp]
FFFC687C 00410113		add		$sp,$sp,#4
FFFC6880 00008067		ret
                        	SGN1:
FFFC6884 00012083		lw		$ra,[$sp]
FFFC6888 00410113		add		$sp,$sp,#4
FFFC688C 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in s8.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC6890 7081AC03		ldt		s8,VARBGN[$gp]	; get the number of free bytes...
FFFC6894 7041AC83		ldt		s9,TXTUNF[$gp]	; between 'TXTUNF' and 'VARBGN'
FFFC6898 419C0C33		sub		s8,s8,s9
FFFC689C 00006CB3		mov		s9,x0			; type = int
FFFC68A0 00012083		lw		$ra,[$sp]
FFFC68A4 00410113		add		$sp,$sp,#4
FFFC68A8 00008067		ret					; return the number in s8
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC68AC FFC10113		sub		$sp,$sp,#4
FFFC68B0 00112023		sw		$ra,[$sp]
FFFC68B4 00106513	  ldi		a0,#1		; allocate var
FFFC68B8 CD1FF0EF	  call	TSTV		; variable name?
FFFC68BC 000C1A63	  bne		s8,x0,.sv2
FFFC68C0 FFFC7537	 	ldi		a0,#msgVar
FFFC68C4 2E250513
FFFC68C8 00410113		add		$sp,$sp,#4
FFFC68CC 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC68D0 FFC10113		sub		$sp,$sp,#4
FFFC68D4 01812023		sw		s8,[$sp]	; save the variable's address
FFFC68D8 548000EF		call	TSTC			; get past the "=" sign
FFFC68DC 0000003D		dw		'='
FFFC68E0 02000663		bra		SV1
FFFC68E4 865FF0EF		call	OREXPR		; evaluate the expression
FFFC68E8 00012583		lw		a1,[$sp]	; get back the variable's address
FFFC68EC 00410113		add		$sp,$sp,#4
FFFC68F0 0185A023		sw    s8,[a1]   ; and save value in the variable
FFFC68F4 0005EC33		mov		s8,a1			; return s8 = variable address
FFFC68F8 FFC5AC83		lw		s9,-4[a1]
FFFC68FC 0FFCFC93		and		s9,s9,#$FF
FFFC6900 00012083		lw		$ra,[$sp]
FFFC6904 00410113		add		$sp,$sp,#4
FFFC6908 00008067		ret
                        	SV1:
FFFC690C 00410113		add		$sp,$sp,#4
FFFC6910 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC6914 FFC1310D		gcsub	$sp,$sp,#4
FFFC6918 00112023		stt		$ra,[$sp]
FFFC691C 504000EF		call	TSTC		; *** FIN ***
FFFC6920 0000003A		dw		':'
FFFC6924 00000663		bra		FI1
FFFC6928 00410113		add		$sp,$sp,#4	; if ":", discard return address
FFFC692C 800FF06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC6930 4F0000EF		call	TSTC		; not ":", is it a CR?
FFFC6934 0000000D		dw		CR
FFFC6938 00000663		bra		FI2
                        							; else return to the caller
FFFC693C 00410113		add		$sp,$sp,#4	; yes, purge return address
FFFC6940 F6DFE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC6944 00012083		ldt		$ra,[$sp]
FFFC6948 00410113		add		$sp,$sp,#4
FFFC694C 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC6950 FFC1310D		gcsub	$sp,$sp,#4
FFFC6954 00112023		stt		$ra,[$sp]
FFFC6958 584000EF		call	IGNBLK
FFFC695C 0003C503		ldbu	$a0,[$t2]
FFFC6960 00D06313		ldi		$t1,#CR
FFFC6964 00650863		beq		$a0,$t1,ec1	; does it end with a CR?
FFFC6968 FFFC7537		ldi		$a0,#msgExtraChars
FFFC696C 3B350513
FFFC6970 0300006F		jmp		ERROR
                        	ec1:
FFFC6974 00012083		ldt		$ra,[$sp]
FFFC6978 00410113		add		$sp,$sp,#4
FFFC697C 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC6980 FFFC7537		ldi		a0,#msgTooBig
FFFC6984 39F50513
FFFC6988 00000C63		bra		ERROR
                        	QSORRY:
FFFC698C FFFC7537	  ldi		a0,#SRYMSG
FFFC6990 24750513
FFFC6994 00000663		bra	    ERROR
                        	QWHAT:
FFFC6998 FFFC7537		ldi		a0,#msgWhat
FFFC699C 24050513
                        	ERROR:
FFFC69A0 624000EF		call	PRMESG		; display the error message
FFFC69A4 7181A503		ldt		$a0,CURRNT[$gp]	; get the current line pointer
FFFC69A8 02050C63		beqz	$a0,ERROR1	; if zero, do a warm start
FFFC69AC FFF06313		ldi		$t1,#-1
FFFC69B0 AE650263		beq		$a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC69B4 0003C283		ldbu	r5,[$t2]		; save the char. pointed to
FFFC69B8 00038023		stb		$x0,[$t2]		; put a zero where the error is
FFFC69BC 7181A503		ldt		$a0,CURRNT[$gp]	; point to start of current line
FFFC69C0 404000EF		call	PRTLN		; display the line in error up to the 0
FFFC69C4 00056333		mov     r6,$a0	    ; save off end pointer
FFFC69C8 00538023		sb		r5,[$t2]		; restore the character
FFFC69CC 03F06513		ldi		$a0,#'?'		; display a "?"
FFFC69D0 A39FE0EF		call	GOOUT
FFFC69D4 000065B3		mov		$a1,$x0		; stop char = 0
FFFC69D8 FFF30513		sub		$a0,r6,#1	; point back to the error char.
FFFC69DC 214000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC69E0 B11FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC69E4 FF81310D		gcsub	$sp,$sp,#8
FFFC69E8 00512023		stt		r5,[$sp]
FFFC69EC 00112223		stt		$ra,4[$sp]
FFFC69F0 A19FE0EF		call	GOOUT		; display the prompt
FFFC69F4 00106513		ldi		$a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC69F8 02006513		ldi		$a0,#' '		; and a space
FFFC69FC A0DFE0EF		call	GOOUT
FFFC6A00 72418393		add		$t2,$gp,#BUFFER	; $t2 is the buffer pointer
                        	.GL1:
FFFC6A04 590000EF		call	CHKIO		; check keyboard
FFFC6A08 FE050EE3		beqz	$a0,.GL1	; wait for a char. to come in
FFFC6A0C 00806313		ldi		$t1,#CTRLH
FFFC6A10 04650463		beq		$a0,$t1,.GL3	; delete last character? if so
FFFC6A14 01806313		ldi		$t1,#CTRLX
FFFC6A18 06650463		beq		$a0,$t1,.GL4	; delete the whole line?
FFFC6A1C 00D06313		ldi		$t1,#CR
FFFC6A20 00650663		beq		$a0,$t1,.GL2		; accept a CR
FFFC6A24 02006313		ldi		$t1,#' '
FFFC6A28 FC654EE3		blt		$a0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC6A2C 00A38023		stb		$a0,[$t2]		; save the char.
FFFC6A30 00138393		add		$t2,$t2,#1
FFFC6A34 FFC1310D		gcsub	$sp,$sp,#4
FFFC6A38 00A12023		stt		$a0,[$sp]
FFFC6A3C 9CDFE0EF		call	GOOUT		  ; echo the char back out
FFFC6A40 00012503		ldt		$a0,[$sp] ; get char back (GOOUT destroys a0)
FFFC6A44 00410113		add		$sp,$sp,#4
FFFC6A48 00D06313		ldi		$t1,#CR
FFFC6A4C 06650863		beq		$a0,$t1,.GL7			; if it's a CR, end the line
FFFC6A50 77718313		add		$t1,$gp,#BUFFER+BUFLEN-1
FFFC6A54 FA63C8E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC6A58 00806513		ldi		$a0,#CTRLH	; delete a char. if possible
FFFC6A5C 9ADFE0EF		call	GOOUT
FFFC6A60 02006513		ldi		$a0,#' '
FFFC6A64 9A5FE0EF		call	GOOUT
FFFC6A68 72418313		add		$t1,$gp,#BUFFER
FFFC6A6C F8735CE3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC6A70 00806513		ldi		$a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC6A74 995FE0EF		call	GOOUT
FFFC6A78 FFF38393		sub		$t2,$t2,#1	; decrement the text pointer
FFFC6A7C F80004E3		bra		.GL1		; back for more
                        	.GL4:
FFFC6A80 0003E533		mov		$a0,$t2		; delete the whole line
FFFC6A84 72418E13		add		$t3,$gp,#BUFFER	; figure out how many backspaces we need
FFFC6A88 41C502B3		sub		r5,$a0,$t3 
FFFC6A8C 02028463		beqz	r5,.GL6		  ; if none needed, branch
FFFC6A90 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC6A94 00806513		ldi		$a0,#CTRLH		; and display BS-space-BS sequences
FFFC6A98 971FE0EF		call	GOOUT
FFFC6A9C 02006513		ldi		$a0,#' '
FFFC6AA0 969FE0EF		call	GOOUT
FFFC6AA4 00806513		ldi		$a0,#CTRLH
FFFC6AA8 961FE0EF		call	GOOUT
FFFC6AAC FFF28293		sub		r5,r5,#1
FFFC6AB0 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC6AB4 72418393		add		$t2,$gp,#BUFFER	; reinitialize the text pointer
FFFC6AB8 F40006E3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC6ABC 00038023		stb		$x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC6AC0 00A06513		ldi		$a0,#LINEFD	; echo a LF for the CR
FFFC6AC4 945FE0EF		call	GOOUT
FFFC6AC8 00012283		ldt		r5,[$sp]
FFFC6ACC 00412083		ldt		$ra,4[$sp]
FFFC6AD0 00810113		add		$sp,$sp,#8
FFFC6AD4 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $s8 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $s8 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $s8 = 0.
                        	; $s8=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC6AD8 00100337		ldi		$t1,#$FFFFF
FFFC6ADC FFF30313
FFFC6AE0 00654863		blt		$a0,$t1,fl1	; line no. must be < 1048576
FFFC6AE4 FFFC7537		ldi		$a0,#msgLineRange
FFFC6AE8 2CD50513
FFFC6AEC EB5FF06F		jmp		ERROR
                        	fl1:
FFFC6AF0 000028B7		add		$t3,$gp,#TXTBGN	; init. the text save pointer
FFFC6AF4 80088893
FFFC6AF8 01118E33
FFFC6AFC 71C1AE23		stt   $t3,SRCHLN[$gp]
FFFC6B00 00000663	  bra   FNDLNP
                        	FNDLNT:
FFFC6B04 7181AE03	  ldt   $t3,CURRNT[$gp]
FFFC6B08 71C1AE23	  stt   $t3,SRCHLN[$gp]
                        	FNDLNP:
FFFC6B0C 7041AE83		ldt		$t4,TXTUNF[$gp]	; check if we passed the end
FFFC6B10 01DE7863		bgeu	$t3,$t4,FNDRET1 ; if so, return with r9=0,a0=0
                        		;call	LoadWord		; get line number
FFFC6B14 001E2C03		ldt   $s8,1[$t3]
                        	;	gcsub $sp,$sp,#8
                        	;	stt   $ra,[$sp]
                        	;	stt   $a0,4[$sp]
                        	;	mov   $a0,$s8
                        	;	call  PutHexWord
                        	;	ldt   $ra,[$sp]
                        	;	ldt   $a0,4[$sp]
                        	;	add   $sp,$sp,#8
FFFC6B18 00AC0863		beq		$s8,$a0,FNDRET2
FFFC6B1C 00AC6A63		bltu	$s8,$a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET1:
FFFC6B20 00006C33		mov		$s8,$x0	; line not found, but $t3=next line pointer
FFFC6B24 00008067		ret
                        	FNDRET2:
FFFC6B28 00106C13		ldi		$s8,#1	; line found
FFFC6B2C 00008067		ret
                        	
                        	; Move from the current line to the next one.
                        	FNDNXT:
FFFC6B30 71C1AC03	  ldt   $s8,SRCHLN[$gp]
FFFC6B34 000C4C83		ldbu	$s9,[$s8]
FFFC6B38 019C0E33		add		$t3,$s8,$s9
FFFC6B3C 71C1AE23		stt   $t3,SRCHLN[$gp]
FFFC6B40 FC0006E3		bra   FNDLNP
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC6B44 00050203		lb		r4,[a0]
FFFC6B48 00458023		sb		r4,[a1]
FFFC6B4C 00150513		add		a0,a0,#1
FFFC6B50 00158593		add		a1,a1,#1
                        	MVUP:
FFFC6B54 FEC518E3		bne		a0,a2,MVUP1
FFFC6B58 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC6B5C FFF50513		sub		a0,a0,#1
FFFC6B60 FFF58593		sub		a1,a1,#1
FFFC6B64 00050203		lb		r4,[a0]
FFFC6B68 00458023		sb		r4,[a1]
                        	MVDOWN:
FFFC6B6C FEC518E3		bne		a0,a2,MVDOWN1
FFFC6B70 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC6B74 00012503		ldt		$a0,[$sp]
FFFC6B78 00410113		add		$sp,$sp,#4
FFFC6B7C 70A1A823		stt		$a0,LOPVAR[$gp]	; restore LOPVAR, but zero means no more
FFFC6B80 02050463		beqz	$a0,PP1
FFFC6B84 00012503		ldt		$a0,[$sp]
FFFC6B88 76A1AC23		stt		$a0,LOPPT[$gp]
FFFC6B8C 00412503		ldt		$a0,4[$sp]
FFFC6B90 76A1AE23		stt		$a0,LOPLN[$gp]
FFFC6B94 00812503		ldt		$a0,8[$sp]
FFFC6B98 78A1A223		stt		$a0,LOPLMT[$gp]
FFFC6B9C 00C12503		ldt		$a0,12[$sp]
FFFC6BA0 78A1A023		stt		$a0,LOPINC[$gp]
FFFC6BA4 01010113		add		$sp,$sp,#16
                        	PP1:
FFFC6BA8 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC6BAC 7A41A503		ldt		$a0,STKBOT[$gp]	; Are we running out of stack room?
FFFC6BB0 01450513		add		$a0,$a0,#20	; we might need this many bytes
FFFC6BB4 DCA14CE3		blt		$sp,$a0,QSORRY	; out of stack space
FFFC6BB8 7101A583		ldt		$a1,LOPVAR[$gp]		; save loop variables
FFFC6BBC 02058463		beqz	$a1,PU1		; if LOPVAR is zero, that's all
FFFC6BC0 FF010113		sub		$sp,$sp,#16
FFFC6BC4 7781A503		ldt		$a0,LOPPT[$gp]
FFFC6BC8 00A12023		stt		$a0,[$sp]
FFFC6BCC 77C1A503		ldt		$a0,LOPLN[$gp]
FFFC6BD0 00A12223		stt		$a0,4[$sp]
FFFC6BD4 7841A503		ldt		$a0,LOPLMT[$gp]
FFFC6BD8 00A12423		stt		$a0,8[$sp]
FFFC6BDC 7801A503		ldt		$a0,LOPINC[$gp]
FFFC6BE0 00A12623		stt		$a0,12[$sp]
                        	PU1:
FFFC6BE4 FFC10113		sub		$sp,$sp,#4
FFFC6BE8 00B12023		stt		a1,[$sp]
FFFC6BEC 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return s8 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC6BF0 FEC10113		sub		$sp,$sp,#20
FFFC6BF4 00512023		stt		x5,[$sp]
FFFC6BF8 00612223		stt		x6,4[$sp]
FFFC6BFC 00712423		stt		x7,8[$sp]
FFFC6C00 00112623		stt		$ra,12[$sp]
FFFC6C04 00A12823		stt		$a0,16[$sp]
FFFC6C08 000562B3		mov   x5,a0	    ; r5 = pointer
FFFC6C0C 0005E333		mov   x6,a1	    ; r6 = stop char
                        	.PS1:
FFFC6C10 0002C383	  ldbu  x7,[x5]     ; get a text character
FFFC6C14 00128293		add		x5,x5,#1
FFFC6C18 00638E63		beq	  x7,x6,.PRTRET	; same as stop character? if so, return
FFFC6C1C 0003E533		mov   $a0,x7
FFFC6C20 FE8FE0EF		call	GOOUT		; display the char.
FFFC6C24 00D06313		ldi		$t1,#CR
FFFC6C28 FE6394E3		bne   x7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC6C2C 00A06513		ldi		$a0,#LINEFD  ; yes, add a L.F.
FFFC6C30 FD8FE0EF		call	GOOUT
                        	.PRTRET:
FFFC6C34 0003ECB3	  mov   $s9,x7	    ; return a1 = stop char
FFFC6C38 0002EC33		mov		$s8,x5		; return a0 = line pointer
FFFC6C3C 00012283		ldt		$x5,[$sp]
FFFC6C40 00412303		ldt		$x6,4[$sp]
FFFC6C44 00812383		ldt		$x7,8[$sp]
FFFC6C48 00C12083		ldt		$ra,12[$sp]
FFFC6C4C 01012503		ldt		$a0,16[$sp]
FFFC6C50 01410113		add		$sp,$sp,#20
FFFC6C54 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC6C58 FFC10113		sub		$sp,$sp,#4
FFFC6C5C 00112023		stt		$ra,[$sp]
FFFC6C60 1C0000EF		call	TSTC		; *** QTSTG ***
FFFC6C64 00000022		dw		'"'
FFFC6C68 02000063		bra		QT3
FFFC6C6C 02206593		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC6C70 0003E533		mov		a0,$t2
FFFC6C74 F7DFF0EF		call	PRTSTG		; print until another
FFFC6C78 000C63B3		mov		$t2,s8
FFFC6C7C 00D06313		ldi		$t1,#CR
FFFC6C80 026C9863		bne		s9,$t1,QT2	; was last one a CR?
FFFC6C84 C29FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC6C88 198000EF		call	TSTC		; is it a single quote?
FFFC6C8C 0000005C		dw		'\''
FFFC6C90 00000663		bra		QT4
FFFC6C94 02706593		ldi		a1,#'\''	; if so, do same as above
FFFC6C98 FC000CE3		bra		QT1
                        	QT4:
FFFC6C9C 184000EF		call	TSTC		; is it an underline?
FFFC6CA0 0000005F		dw		'_'
FFFC6CA4 00000C63		bra		QT5
FFFC6CA8 00D06513		ldi		a0,#CR		; if so, output a CR without LF
FFFC6CAC F5CFE0EF		call	GOOUT
                        	QT2:
FFFC6CB0 00012083		lw		$ra,[$sp]		; get return address
FFFC6CB4 00410113		add		$sp,$sp,#4
FFFC6CB8 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC6CBC 00012083		lw		$ra,[$sp]		; get return address
FFFC6CC0 00410113		add		$sp,$sp,#4
FFFC6CC4 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC6CC8 FFC10113		sub		$sp,$sp,#4
FFFC6CCC 00112023		stt		$ra,[$sp]
FFFC6CD0 00D06513		ldi		$a0,#CR
FFFC6CD4 F34FE0EF		call	GOOUT
FFFC6CD8 00A06513		ldi		$a0,#LINEFD
FFFC6CDC F2CFE0EF		call	GOOUT
FFFC6CE0 00012083		ldt		$ra,[$sp]
FFFC6CE4 00410113		add		$sp,$sp,#4
FFFC6CE8 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
FFFC6CEC 00000000		align	1
                        	
FFFC6CF0 FEC10113	public PRTNUM:
	sub		$sp,$sp,#20
FFFC6CF4 00912023		stt		$s1,[$sp]
FFFC6CF8 01212223		stt		$s2,4[$sp]
FFFC6CFC 01312423		stt		$s3,8[$sp]
FFFC6D00 01412623		stt		$s4,12[$sp]
FFFC6D04 00112823		stt		$ra,16[$sp]
FFFC6D08 79C18A13		add		$s4,$gp,#NUMWKA	; r7 = pointer to numeric work area
FFFC6D0C 000569B3		mov		$s3,$a0		; save number for later
FFFC6D10 0005E933		mov		$s2,$a1		; s2 = min number of chars
FFFC6D14 00055663		bge		$a0,$x0,.PN2	; is it negative? if not
FFFC6D18 40A00533		sub		$a0,$x0,$a0	; else make it positive
FFFC6D1C FFF90913		sub		$s2,$s2,#1	; one less for width count
                        	.PN2:
FFFC6D20 00A06313		ldi		$t1,#10
                        	.PN1:
FFFC6D24 02C565B3		rem		$a1,$a0,$a2	; a1 = a0 mod base
FFFC6D28 02C54533		div		$a0,$a0,$a2	; a0 /= divide by base
FFFC6D2C 00B67463		bleu	$a1,$a2,.PN7
FFFC6D30 00758593		add		$a1,$a1,#'A'-10-'0'
                        	.PN7:
FFFC6D34 03058593		add		$a1,$a1,#'0'	; convert remainder to ascii
FFFC6D38 00BA0023		stb		$a1,[$s4]		; and store in buffer
FFFC6D3C 001A0A13		add		$s4,$s4,#1
FFFC6D40 FFF90913		sub		$s2,$s2,#1	; decrement width
FFFC6D44 FE0510E3		bnez	$a0,.PN1
FFFC6D48 01205A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC6D4C 02006513		ldi		$a0,#' '		; display the required leading spaces
FFFC6D50 EB8FE0EF		call	GOOUT
FFFC6D54 FFF90913		sub		$s2,$s2,#1
FFFC6D58 FF204AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC6D5C 0009D663		bge		$s3,$x0,.PN5	; is number negative?
FFFC6D60 02D06513		ldi		$a0,#'-'		; if so, display the sign
FFFC6D64 EA4FE0EF		call	GOOUT
                        	.PN5:
FFFC6D68 79C18313		add		$t1,$gp,#NUMWKA
                        	.PN6:
FFFC6D6C FFFA0A13		sub		$s4,$s4,#1
FFFC6D70 000A4503		ldbu	$a0,[$s4]		; now unstack the digits and display
FFFC6D74 E94FE0EF		call	GOOUT
FFFC6D78 FF436AE3		bgtu	$s4,$t1,.PN6
                        	
FFFC6D7C 00012483		ldt		$s1,[$sp]
FFFC6D80 00412903		ldt		$s2,4[$sp]
FFFC6D84 00812983		ldt		$s3,8[$sp]
FFFC6D88 00C12A03		ldt		$s4,12[$sp]
FFFC6D8C 01012083		ldt		$ra,16[$sp]
FFFC6D90 01410113		add		$sp,$sp,#20
FFFC6D94 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		s8 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC6D98 00054C03	  lbu		$s8,[$a0]	
FFFC6D9C 00154C83	  lbu		$s9,1[$a0]
FFFC6DA0 008C9C93	  sll		$s9,$s9,#8
FFFC6DA4 019C6C33	  or		$s8,$s8,$s9
FFFC6DA8 00254C83	  lbu		$s9,2[$a0]
FFFC6DAC 010C9C93	  sll		$s9,$s9,#16
FFFC6DB0 019C6C33	  or		$s8,$s8,$s9
FFFC6DB4 00354C83	  lbu		$s9,3[$a0]
FFFC6DB8 018C9C93	  sll		$s9,$s9,#24
FFFC6DBC 019C6C33	  or		$s8,$s8,$s9
FFFC6DC0 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	$a0 = pointer to line
                        	; Returns:
                        	;		$s8 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC6DC4 FF01310D		gcsub	$sp,$sp,#16
FFFC6DC8 00512023		stt		$t0,[$sp]
FFFC6DCC 00112223		stt		$ra,4[$sp]
FFFC6DD0 00A12423		stt		$a0,8[$sp]
FFFC6DD4 00B12623		stt		$a1,12[$sp]
FFFC6DD8 000562B3	  mov		$t0,$a0		; $t0 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
                        	  ;call	LoadWord
FFFC6DDC 0012AC03	  ldt   $s8,1[$t0]    ; we can do unaligned loads
FFFC6DE0 00528293		add		$t0,$t0,#5
FFFC6DE4 000C6533	  mov		$a0,$s8
FFFC6DE8 00506593	  ldi		$a1,#5       ; display a 0 or more digit line no.
FFFC6DEC 00A06613	  ldi		$a2,#10
FFFC6DF0 F01FF0EF		call	PRTNUM
FFFC6DF4 02006513		ldi		$a0,#' '     ; followed by a blank
FFFC6DF8 E10FE0EF		call	GOOUT
FFFC6DFC 000065B3		mov		$a1,$x0     ; stop char. is a zero
FFFC6E00 0002E533		mov		$a0,$t0
FFFC6E04 DEDFF0EF		call  PRTSTG		  ; display the rest of the line
FFFC6E08 00012283		ldt		$t0,[$sp]
FFFC6E0C 00412083		ldt		$ra,4[$sp]
FFFC6E10 00812503		ldt		$a0,8[$sp]
FFFC6E14 00C12583		ldt		$a1,12[$sp]
FFFC6E18 01010113		add		$sp,$sp,#16
FFFC6E1C 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC6E20 FF41310D		gcsub	$sp,$sp,#12
FFFC6E24 00A12023		stt		$a0,[$sp]
FFFC6E28 00112223		stt		$ra,4[$sp]
FFFC6E2C 00B12423		stt		$a1,8[$sp]
FFFC6E30 0AC000EF		call	IGNBLK		; ignore leading blanks
FFFC6E34 00412083		ldt		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC6E38 0003C503		ldbu	$a0,[$t2]
FFFC6E3C 0000C583		ldbu	$a1,[$ra]
FFFC6E40 00A58A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC6E44 00012503		ldt		$a0,[$sp]		; restore a0
FFFC6E48 00812583		ldt		$a1,8[$sp]
FFFC6E4C 00C10113		add		$sp,$sp,#12	;
FFFC6E50 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC6E54 00138393		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC6E58 00012503		ldt		$a0,[$sp]
FFFC6E5C 00412083		ldt		$ra,4[$sp]
FFFC6E60 00812583		ldt		$a1,8[$sp]
FFFC6E64 00C10113		add		$sp,$sp,#12
FFFC6E68 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $s8 and the number of digits in $s9,
                        	;	else return zero in $s8 and $s9.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	s8 = number
                        	;		s9 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC6E6C FF81310D		gcsub	$sp,$sp,#8
FFFC6E70 00112223		stt		$ra,4[$sp]
FFFC6E74 00512023		stt		$t0,[$sp]
FFFC6E78 064000EF		call	IGNBLK		; skip over blanks
FFFC6E7C 00006C33		mov		$s8,$x0		; initialize return parameters
FFFC6E80 00006CB3		mov		$s9,$x0
                        	TN1:
FFFC6E84 0003C283		ldbu	$t0,[$t2]
FFFC6E88 03006313		ldi		$t1,#'0'
FFFC6E8C 0462C063		blt		$t0,$t1,TSNMRET; is it less than zero?
FFFC6E90 03906313		ldi		$t1,#'9'
FFFC6E94 02534C63		bgt		$t0,$t1,TSNMRET; is it greater than nine?
FFFC6E98 08000337		ldi		$t1,#$7FFFFFF
FFFC6E9C FFF30313
FFFC6EA0 01837863		bleu	$s8,$t1,TN2; see if there's room for new digit
FFFC6EA4 FFFC7537		ldi		$a0,#msgNumTooBig
FFFC6EA8 26950513
FFFC6EAC AF5FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC6EB0 00138393		add		$t2,$t2,#1	; adjust text pointer
FFFC6EB4 00A06E13		ldi   $t3,#10
FFFC6EB8 03CC0C33		mul   $s8,$s8,$t3 ; quickly multiply result by 10
FFFC6EBC FD028293		sub   $t0,$t0,#'0'  ; convert ascii to binary
FFFC6EC0 005C0C33		add		$s8,$s8,$t0 ; add in the new digit
FFFC6EC4 001C8C93		add		$s9,$s9,#1	; increment the no. of digits
FFFC6EC8 FA000EE3		bra		TN1
                        	TSNMRET:
FFFC6ECC 00012283		ldt		$t0,[$sp]
FFFC6ED0 00412083		ldt		$ra,4[$sp]
FFFC6ED4 00810113		add		$sp,$sp,#8
FFFC6ED8 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC6EDC FF81310D		gcsub	$sp,$sp,#8
FFFC6EE0 00A12023		stt		$a0,[$sp]
FFFC6EE4 00612223		stt   $t1,4[$sp]
                        	IGB2:
FFFC6EE8 0003C503		ldbu	$a0,[$t2]			; get char
FFFC6EEC 02006313		ldi		$t1,#' '
FFFC6EF0 00650663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC6EF4 00906313		ldi		$t1,#'\t'
FFFC6EF8 00651663		bne		$a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC6EFC 00138393		add		$t2,$t2,#1		; increment the text pointer
FFFC6F00 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC6F04 00012503		ldt		$a0,[$sp]
FFFC6F08 00412303		ldt   $t1,4[$sp]
FFFC6F0C 00810113		add		$sp,$sp,#8
FFFC6F10 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC6F14 FFC10113		sub		$sp,$sp,#4
FFFC6F18 00112023		stt		$ra,[$sp]
FFFC6F1C 72418393		add		$t2,$gp,#BUFFER	; set up text pointer
FFFC6F20 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC6F24 0003C503		lbu		$a0,[$t2]		; get the next text char.
FFFC6F28 00138393		add		$t2,$t2,#1
FFFC6F2C 00D06313		ldi		$t1,#CR
FFFC6F30 02650E63		beq		$a0,$t1,TOUPBRT		; is it end of line?
FFFC6F34 02206313		ldi		$t1,#'"'
FFFC6F38 00650E63		beq		$a0,$t1,DOQUO	; a double quote?
FFFC6F3C 02706313		ldi		$t1,#'\''     ; '
FFFC6F40 00650A63		beq		$a0,$t1,DOQUO	; or a single quote?
FFFC6F44 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC6F48 030000EF		call	toUpper 	; convert to upper case
FFFC6F4C FEA38FA3		stb		$a0,-1[$t2]	; store it
FFFC6F50 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC6F54 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC6F58 000561B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC6F5C FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC6F60 FCA192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC6F64 000061B3		mov		r3,r0		; else clear quote flag
FFFC6F68 FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC6F6C 00012083		ldt		$ra,[$sp]
FFFC6F70 00410113		add		$sp,$sp,#4
FFFC6F74 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	;toUpper:
                        	;  sge     $cr0,$a0,#'a'
                        	;  sle.and $cr0,$a0,#'z'
                        	;  asl     $t1,$cr0.C,#5
                        	;  sub     $a0,$a0,$t1
                        	;  ret
                        	
                        	toUpper:
FFFC6F78 06152313		slt		$t1,$a0,#'a'
FFFC6F7C 00031A63		bnez  $t1,TOUPRET	    ; is it < 'a'?
FFFC6F80 07B06313		ldi		$t1,#'z'+1
FFFC6F84 00652333		slt   $t1,$a0,$t1     ; >= 'a' and <= 'z'?
FFFC6F88 00531313		sll   $t1,$t1,#5
FFFC6F8C 40650533		sub		$a0,$a0,$t1	    ; if not, make it upper case
                        	TOUPRET:
FFFC6F90 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC6F94 FFC10113		sub		$sp,$sp,#4
FFFC6F98 00112023		stt		$ra,[$sp]
FFFC6F9C 224000EF		call	INCH		    ; get input if possible
FFFC6FA0 00050863		beqz	$a0,CHKRET  ; if Zero, no input
FFFC6FA4 00354C93		xor		$s9,$a0,#CTRLC
FFFC6FA8 000C9463		bnez	$s9,CHKRET  ; is it control-C?
FFFC6FAC D44FE06F		jmp		WSTART		  ; if so, do a warm start
                        	CHKRET:
FFFC6FB0 00012083		ldt		$ra,[$sp]
FFFC6FB4 00410113		add		$sp,$sp,#4
FFFC6FB8 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC6FBC FFFC7537		ldi		a0,#CLMSG
FFFC6FC0 24D50513
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC6FC4 FFC10113		sub	  $sp,$sp,#4
FFFC6FC8 00112023		stt		$ra,[$sp]
FFFC6FCC F35F90EF		call	PutString
FFFC6FD0 00012083		ldt		$ra,[$sp]
FFFC6FD4 00410113		add		$sp,$sp,#4
FFFC6FD8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC6FDC E45FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC6FE0 00000028		dw		'('
FFFC6FE4 04000C63		bra		.paren
FFFC6FE8 00106513		ldi		a0,#1
FFFC6FEC D9CFF0EF		call	TSTV
FFFC6FF0 000C1863		bne		s8,x0,.0001
FFFC6FF4 FFFC7537		ldi		a0,#msgVar
FFFC6FF8 2E250513
FFFC6FFC 9A5FF06F		jmp		ERROR
                        	.0001:
FFFC7000 E21FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC7004 00000029		dw		')'
FFFC7008 02000A63		bra		.paren
FFFC700C 000C64B3		mov		s1,s8
FFFC7010 00E06513		ldi		a0,#14			; get current tid
FFFC7014 00000073		ecall
FFFC7018 0004E633		mov		a2,s1
FFFC701C 00606513		ldi		a0,#6
FFFC7020 00000073		ecall
FFFC7024 00051463		bne		a0,x0,.0002
FFFC7028 0194A023		sw		s9,[s1]				; save handle in variable
                        	.0002:
FFFC702C 00006CB3		mov		s9,x0
FFFC7030 00012083		lw		$ra,[$sp]
FFFC7034 00410113		add		$sp,$sp,#4
FFFC7038 00008067		ret
                        	.paren:
FFFC703C FFFC7537		ldi		a0,#msgParen
FFFC7040 3EF50513
FFFC7044 95DFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC7048 DD9FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC704C 00000028		dw		'('
FFFC7050 08000463		bra		.paren
FFFC7054 8F4FF0EF		call	OREXPR	; get the mailbox handle
FFFC7058 000C64B3		mov		s1,s8
FFFC705C DC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC7060 0000002C		dw		','
FFFC7064 06000463		bra		.err
FFFC7068 8E0FF0EF		call	OREXPR	; get the memory address
FFFC706C 000C6933		mov		s2,s8
FFFC7070 DB1FF0EF		call	TSTC		; it must be followed by a comma
FFFC7074 0000002C		dw		','
FFFC7078 04000A63		bra		.err
FFFC707C 8CCFF0EF		call	OREXPR	; get the memory address
FFFC7080 000C69B3		mov		s3,s8
FFFC7084 D9DFF0EF		call	TSTC		; it must be followed by a comma
FFFC7088 0000002C		dw		','
FFFC708C 04000063		bra		.err
FFFC7090 8B8FF0EF		call	OREXPR	; get the memory address
FFFC7094 000C6A33		mov		s4,s8
FFFC7098 D89FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC709C 00000029		dw		')'
FFFC70A0 02000C63		bra		.paren
FFFC70A4 00906513		ldi		a0,#9		; SendMsg
FFFC70A8 0004E5B3		mov		a1,s1
FFFC70AC 00096633		mov		a2,s2
FFFC70B0 0009E6B3		mov		a3,s3
FFFC70B4 000A6733		mov		a4,s4
FFFC70B8 00000073		ecall
FFFC70BC 00006CB3		mov		s9,x0
FFFC70C0 00012083		lw		$ra,[$sp]
FFFC70C4 00410113		add		$sp,$sp,#4
FFFC70C8 00008067		ret
                        	.err:
FFFC70CC FFFC7537		ldi		a0,#msgComma
FFFC70D0 2BA50513
FFFC70D4 8CDFF06F		jmp		ERROR
                        	.paren:
FFFC70D8 FFFC7537		ldi		a0,#msgParen
FFFC70DC 3EF50513
FFFC70E0 8C1FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC70E4 D3DFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC70E8 00000028		dw		'('
FFFC70EC 0C000263		bra		.paren
FFFC70F0 858FF0EF		call	OREXPR	; get the mailbox handle
FFFC70F4 000C64B3		mov		s1,s8
FFFC70F8 D29FF0EF		call	TSTC		; it must be followed by a comma
FFFC70FC 0000002C		dw		','
FFFC7100 0A000263		bra		.err
FFFC7104 00106513		ldi		a0,#1
FFFC7108 C80FF0EF		call	TSTV
FFFC710C 000C1863		bne		s8,x0,.0001
                        	.0002:
FFFC7110 FFFC7537		ldi		a0,#msgVar
FFFC7114 2E250513
FFFC7118 889FF06F		jmp		ERROR
                        	.0001:
FFFC711C D05FF0EF		call	TSTC		; it must be followed by a comma
FFFC7120 0000002C		dw		','
FFFC7124 08000063		bra		.err
FFFC7128 000C6933		mov		s2,s8
FFFC712C 00106513		ldi		a0,#1
FFFC7130 C58FF0EF		call	TSTV
FFFC7134 FC0C0EE3		beq		s8,x0,.0002
FFFC7138 CE9FF0EF		call	TSTC		; it must be followed by a comma
FFFC713C 0000002C		dw		','
FFFC7140 06000263		bra		.err
FFFC7144 000C69B3		mov		s3,s8
FFFC7148 00106513		ldi		a0,#1
FFFC714C C3CFF0EF		call	TSTV
FFFC7150 FC0C00E3		beq		s8,x0,.0002
FFFC7154 000C6A33		mov		s4,s8
FFFC7158 CC9FF0EF		call	TSTC		; it must be followed by a comma
FFFC715C 0000002C		dw		','
FFFC7160 04000263		bra		.err
FFFC7164 FE5FE0EF		call	OREXPR	; get queue remove flag
FFFC7168 000C67B3		mov		a5,s8
FFFC716C 000C6A33		mov		s4,s8
FFFC7170 CB1FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC7174 00000029		dw		')'
FFFC7178 02000C63		bra		.paren
FFFC717C 00A06513		ldi		a0,#10		; WaitMsg
FFFC7180 0004E5B3		mov		a1,s1
FFFC7184 00096633		mov		a2,s2
FFFC7188 0009E6B3		mov		a3,s3
FFFC718C 000A6733		mov		a4,s4
FFFC7190 00000073		ecall
FFFC7194 00006CB3		mov		s9,x0
FFFC7198 00012083		lw		$ra,[$sp]
FFFC719C 00410113		add		$sp,$sp,#4
FFFC71A0 00008067		ret
                        	.err:
FFFC71A4 FFFC7537		ldi		a0,#msgComma
FFFC71A8 2BA50513
FFFC71AC FF4FF06F		jmp		ERROR
                        	.paren:
FFFC71B0 FFFC7537		ldi		a0,#msgParen
FFFC71B4 3EF50513
FFFC71B8 FE8FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC71BC B24F906F		jmp		Putch
                        	
                        	; ===== Input a character from the console into register s8 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC71C0 FFC10113		sub		$sp,$sp,#4
FFFC71C4 00112023		sw		$ra,[$sp]
FFFC71C8 AE8F90EF		call	Getch
FFFC71CC 00150513		add		$a0,$a0,#1			; prepare test -1
FFFC71D0 00050A63		beqz	$a0,INCH1			  ; was = -1
FFFC71D4 FFF50513		sub		$a0,$a0,#1			; get char back
FFFC71D8 00012083		ldt		$ra,[$sp]
FFFC71DC 00410113		add		$sp,$sp,#4
FFFC71E0 00008067		ret
                        	INCH1:
FFFC71E4 00012083		ldt		$ra,[$sp]		; return a zero for no-char
FFFC71E8 00410113		add		$sp,$sp,#4
FFFC71EC 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	;message "BYEBYE"
                        	BYEBYE:
                        	;	call	ReleaseIOFocus
FFFC71F0 01606513	  ldi   $a0,#22     ; release I/O focus
FFFC71F4 00000073	  ecall
FFFC71F8 70002103		ldt		$sp,OSSP
FFFC71FC 02206513		ldi   $a0,#34     ; activate Monitor
FFFC7200 00000073		ecall
                        	 
                        	
FFFC7204 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.3",CR,LINEFD,"(C) 2017-2021  Robert Finch",CR,CR,0
FFFC7208 54203130
FFFC720C 20796E69
FFFC7210 49534142
FFFC7214 31762043
FFFC7218 0A0D332E
FFFC721C 20294328
FFFC7220 37313032
FFFC7224 3230322D
FFFC7228 52202031
FFFC722C 7265626F
FFFC7230 69462074
FFFC7234 0D68636E
FFFC7238 0A0D000D
FFFC723A 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC723E 6857000D
FFFC7240 74616857	msgWhat	db	"What?",CR,0
FFFC7244 53000D3F
FFFC7247 72726F53	SRYMSG	db	"Sorry."
FFFC724B 000D2E79
FFFC724D 6F43000D	CLMSG	db	CR,0
FFFC724F 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC7253 20746361
FFFC7257 53414C46
FFFC725B 65722048
FFFC725F 65206461
FFFC7263 726F7272
FFFC7267 754E000D
FFFC7269 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC726D 69207265
FFFC7271 6F742073
FFFC7275 6962206F
FFFC7279 44000D67
FFFC727C 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC7280 6E6F6973
FFFC7284 20796220
FFFC7288 6F72657A
FFFC728C 754F000D
FFFC728E 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC7292 7620666F
FFFC7296 61697261
FFFC729A 20656C62
FFFC729E 63617073
FFFC72A2 20000D65
FFFC72A5 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC72A9 66207365
FFFC72AD 0D656572
FFFC72B1 65520D00
FFFC72B2 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC72B6 000D7964
FFFC72BA 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC72BE 6E697463
FFFC72C2 20612067
FFFC72C6 6D6D6F63
FFFC72CA 4C000D61
FFFC72CD 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC72D1 6D756E20
FFFC72D5 20726562
FFFC72D9 206F6F74
FFFC72DD 0D676962
FFFC72E1 70784500
FFFC72E2 65707845	msgVar			db "Expecting a variable",CR,0
FFFC72E6 6E697463
FFFC72EA 20612067
FFFC72EE 69726176
FFFC72F2 656C6261
FFFC72F6 4E52000D
FFFC72F8 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC72FC 20646162
FFFC7300 61726170
FFFC7304 6574656D
FFFC7308 53000D72
FFFC730B 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC730F 20646162
FFFC7313 72646461
FFFC7317 0D737365
FFFC731B 504E4900
FFFC731C 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC7320 78652054
FFFC7324 74636570
FFFC7328 20676E69
FFFC732C 61762061
FFFC7330 62616972
FFFC7334 000D656C
FFFC7338 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC733C 74697720
FFFC7340 74756F68
FFFC7344 524F4620
FFFC7348 454E000D
FFFC734A 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC734E 70786520
FFFC7352 69746365
FFFC7356 6120676E
FFFC735A 66656420
FFFC735E 64656E69
FFFC7362 72617620
FFFC7366 6C626169
FFFC736A 47000D65
FFFC736D 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC7371 534F472F
FFFC7375 62204255
FFFC7379 6C206461
FFFC737D 20656E69
FFFC7381 626D756E
FFFC7385 000D7265
FFFC7389 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC738D 77204E52
FFFC7391 6F687469
FFFC7395 47207475
FFFC7399 4255534F
FFFC739D 7250000D
FFFC739F 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC73A3 206D6172
FFFC73A7 74207369
FFFC73AB 62206F6F
FFFC73AF 000D6769
FFFC73B3 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC73B7 68632061
FFFC73BB 63617261
FFFC73BF 73726574
FFFC73C3 206E6F20
FFFC73C7 656E696C
FFFC73CB 6E676920
FFFC73CF 6465726F
FFFC73D3 4520000D
FFFC73D5 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC73D9 6E6F7269
FFFC73DD 746E656D
FFFC73E1 6C616320
FFFC73E5 6166206C
FFFC73E9 64656C69
FFFC73ED 7845000D
FFFC73EF 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC73F3 6E697463
FFFC73F7 61702067
FFFC73FB 746E6572
FFFC73FF 69736568
FFFC7403 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
1417 symbols
  Symbol Name                              seg     address bits
  ABS                                        code  fffc681c 18
  ABS1                                       code  fffc6830 18
  ACBCommandLine                            const  00034e 11
  ACBCursorCol                              const  000363 11
  ACBCursorRow                              const  000362 11
  ACBDataSize                               const  000048 8
  ACBEnd                                    const  001000 14
  ACBExitRunFile                            const  00034c 11
  ACBGCMarkingQue                           const  000078 8
  ACBGCMarkingQueEmpty                      const  000081 9
  ACBGCMarkingQueFull                       const  000080 9
  ACBGCNdx                                  const  000070 8
  ACBGCOverflow                             const  000082 9
  ACBGCRootCnt                              const  000068 8
  ACBGCRoots                                const  000060 8
  ACBGarbageList                            const  000098 9
  ACBHasFocus                               const  0003c2 11
  ACBHeap                                   const  0000a0 9
  ACBKeyState1                              const  000368 11
  ACBKeyState2                              const  00036a 11
  ACBKeybdBuffer                            const  000370 11
  ACBKeybdHead                              const  00036e 11
  ACBKeybdTail                              const  00036f 11
  ACBKeybdWaitFlag                          const  00036c 11
  ACBNext                                   const  0003b8 11
  ACBNormAttr                               const  000364 11
  ACBObject                                 const  000000 1
  ACBObjectList                             const  000090 9
  ACBPad                                    const  000bc8 13
  ACBPath                                   const  00034a 11
  ACBPtrs                                   const  ff000600 33
  ACBStatus                                 const  0003c6 11
  ACBStrings                                const  000c00 13
  ACBTask                                   const  0003c0 11
  ACBTemplates                              const  0003c8 11
  ACBUIDataSize                             const  000058 8
  ACBUserName                               const  000348 11
  ACBVideoCols                              const  000361 11
  ACBVideoRows                              const  000360 11
  ACB_MAGIC                                 const  20414342 31
  ACBiofNext                                const  000338 11
  ACBiofPrev                                const  000340 11
  ACBmid                                    const  0003c4 11
  ACBnumber                                 const  0003b0 11
  ACBpCode                                  const  000086 9
  ACBpData                                  const  000040 8
  ACBpUIData                                const  000050 8
  ACBpVidMem                                const  000350 11
  ACBpVirtVidMem                            const  000358 11
  ADDEXPR                                    code  fffc63c4 18
  ALLOCMBX                                   code  fffc6fdc 18
  ALLOCMBX.0001                              code  fffc7000 18
  ALLOCMBX.0002                              code  fffc702c 18
  ALLOCMBX.paren                             code  fffc703c 18
  ANDEXPR                                    code  fffc61b0 18
  APPID_POOL                                const  ff0002f0 33
  ASRAffinity                               const  000004 4
  ASRCodeSize                               const  000008 5
  ASRDataSize                               const  000010 6
  ASRHeapSize                               const  000020 7
  ASRPageSize                               const  000000 1
  ASRPriority                               const  000001 2
  ASRRegset                                 const  000002 3
  ASRStackSize                              const  000028 7
  ASRUIDataSize                             const  000018 6
  ASR_SIZE                                  const  000048 8
  ASRmid                                    const  000003 3
  ASRpCode                                  const  000030 7
  ASRpData                                  const  000038 7
  ASRpUIData                                const  000040 8
  AS_DEAD                                   const  000002 3
  AS_LIVE                                   const  000001 2
  AS_NONE                                   const  000000 1
  AS_UNDEAD                                 const  000004 4
  AUXIN                                      code  8000000000000429 32
  AUXIN_INIT                                 code  80000000000004e6 32
  AUXOCRLF                                   code  fffc5ffc 18
  AUXOUT                                     code  8000000000000427 32
  AUXOUT_FLUSH                               code  80000000000004f3 32
  AUXOUT_INIT                                code  80000000000004ea 32
  AccountTime                                code  fffc34dc 18
  Alloc                                      code  fffc19b0 18
  Alloc.0001                                 code  fffc1a30 18
  Alloc.allocZero                            code  fffc1a98 18
  Alloc.enough                               code  fffc19f0 18
  Alloc.noRun                                code  fffc1a78 18
  Alloc.noRun2                               code  fffc19e8 18
  Alloc.xit                                  code  fffc1a7c 18
  Alloc.zm                                   code  fffc1a60 18
  AllocAppId                                 code  fffc42e0 18
  AllocAppId.0001                            code  fffc4318 18
  AllocAppId.0002                            code  fffc42f4 18
  AllocMsg                                   code  fffc3ef0 18
  AllocMsg.0001                              code  fffc3f6c 18
  AllocMsg.gotMsg                            code  fffc3f84 18
  AllocMsg.outOfMem                          code  fffc3fb4 18
  AllocStack                                 code  fffc1ab0 18
  AllocStack.0001                            code  fffc1af0 18
  AllocStack.xit                             code  fffc1b08 18
  AllocTCBId                                 code  fffc45f0 18
  AllocTCBId.0001                            code  fffc462c 18
  AllocTCBId.0002                            code  fffc4600 18
  BASPRMPT                                   code  fffc5514 18
  BS                                        const  000008 5
  BUFFER                                    const  000724 12
  BUFLEN                                    const  000054 8
  BYEBYE                                     code  fffc71f0 18
  CHAINA0                                   const  ff000378 33
  CHAINA1                                   const  ff000380 33
  CHAINA2                                   const  ff000388 33
  CHAINA3                                   const  ff000390 33
  CHAINA4                                   const  ff000398 33
  CHAINA5                                   const  ff0003a0 33
  CHKIO                                      code  fffc6f94 18
  CHKRET                                     code  fffc6fb0 18
  CLMSG                                      code  fffc724d 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc6fbc 18
  CSR_IMSTACK                               const  0007c5 12
  CSR_MEPC                                  const  000341 11
  CSR_MSEMA                                 const  0007c1 12
  CSR_MSTATUS                               const  000300 11
  CSR_PMSTACK                               const  0007c4 12
  CSR_REGSET                                const  0007c0 12
  CSR_RSSTACK                               const  0007c3 12
  CSR_SATP                                  const  000180 10
  CSR_TASKID                                const  0007c2 12
  CSR_TRACECTRL                             const  0007a0 12
  CSR_UIE                                   const  000004 4
  CSTART                                     code  fffc5430 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLT                                     const  000014 6
  CTRLX                                     const  000018 6
  CURIN                                     const  ff000370 33
  CUROUT                                    const  ff000371 33
  CURRNT                                    const  000718 12
  CheckDevOwner                              code  fffc5210 18
  CheckDevOwner.notOwner                     code  fffc5254 18
  CheckDevOwner.xit                          code  fffc5248 18
  Clrbit                                     code  fffc4700 18
  CopyDevDCB                                 code  fffc51d0 18
  CopyDevDCB.again                           code  fffc51e8 18
  CopyDevFuncTbl                             code  fffc51a0 18
  CopyDevFuncTbl.again                       code  fffc51b4 18
  CurrentTid                                const  ff000210 33
  CursorFlash                               const  0007b8 12
  DCB_Base                                  const  ff003000 33
  DCB_LastErc                               const  000018 6
  DCB_Limit                                 const  ff003c00 33
  DCB_Mbx                                   const  000050 8
  DCB_Name                                  const  000000 1
  DCB_ReentCount                            const  000040 8
  DCB_Resv1                                 const  000060 8
  DCB_Size                                  const  000060 8
  DCB_StartBlock                            const  000020 7
  DCB_Type                                  const  00000c 5
  DCB_fSingleUser                           const  000041 8
  DCB_fUI                                   const  000042 8
  DCB_hJob                                  const  000048 8
  DCB_nBPB                                  const  000010 6
  DCB_nBlocks                               const  000028 7
  DCB_pCmdProc                              const  000030 7
  DCB_pIRQProc                              const  000038 7
  DCB_pSema                                 const  000058 8
  DEFLT                                      code  fffc5d70 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc57c0 18
  DOQUO                                      code  fffc6f54 18
  DOQUO1                                     code  fffc6f60 18
  DRSP_DONE                                 const  000001 2
  DVC_BuildBPB                              const  000005 4
  DVC_Close                                 const  000007 4
  DVC_FlushInput                            const  000014 6
  DVC_FlushOutput                           const  000015 6
  DVC_GetChar                               const  000008 5
  DVC_GetCharDirect                         const  00000a 5
  DVC_IOCTRL_READ                           const  000018 6
  DVC_IOCTRL_WRITE                          const  000019 6
  DVC_IRQ                                   const  000016 6
  DVC_Initialize                            const  000002 3
  DVC_InputStatus                           const  00000c 5
  DVC_IsRemoveable                          const  000017 6
  DVC_IsUI                                  const  00001b 6
  DVC_MediaCheck                            const  000004 4
  DVC_Nop                                   const  000000 1
  DVC_Open                                  const  000006 4
  DVC_OutputStatus                          const  000013 6
  DVC_OutputUntilBusy                       const  00001a 6
  DVC_PeekChar                              const  000009 5
  DVC_PeekCharDirect                        const  00000b 5
  DVC_PutChar                               const  00000d 5
  DVC_ReadBlock                             const  000010 6
  DVC_SetPosition                           const  00000f 5
  DVC_Setup                                 const  000001 2
  DVC_Status                                const  000003 3
  DVC_VerifyBlock                           const  000012 6
  DVC_WriteBlock                            const  000011 6
  DVF_Base                                  const  ff002000 33
  DVF_Limit                                 const  ff003000 33
  DeleteLine                                 code  fffc55d0 18
  DeleteLine.0003                            code  fffc55dc 18
  DumpACB                                    code  fffc45dc 18
  DumpACBPtrs                                code  fffc4580 18
  DumpACBPtrs.0001                           code  fffc45a0 18
  DumpReadyQueue                             code  fffc4a30 18
  DumpReadyQueue.0002                        code  fffc4a9c 18
  DumpReadyQueue.0004                        code  fffc4b1c 18
  DumpReadyQueue.0005                        code  fffc4b08 18
  DumpReadyQueue.0006                        code  fffc4a68 18
  DumpReadyQueue.0007                        code  fffc4ad4 18
  DumpReadyQueue.0008                        code  fffc4afc 18
  DumpReadyQueue.brk                         code  fffc4b08 18
  DumpReadyQueue.nxtT                        code  fffc4ba8 18
  DumpRegs                                   code  fffc08e0 18
  DumpRegs.0001                              code  fffc08fc 18
  DumpRegs.0002                              code  fffc0970 18
  DumpRegs.0003                              code  fffc091c 18
  DumpTimeoutList                            code  fffc4bf0 18
  DumpTimeoutList.0002                       code  fffc4c30 18
  DumpTimeoutList.brk                        code  fffc4c70 18
  DumpTraceQueue                             code  fffc0f34 18
  DumpTraceQueue.00001                       code  fffc0f98 18
  DumpTraceQueue.0001                        code  800000000000022e 32
  DumpTraceQueue.dmpTrace                    code  fffc0f4c 18
  DumpTraceQueue.dmpTraceEmpty               code  fffc0f9c 18
  DumpTraceQueue.inf                         code  fffc0fa4 18
  ENDCHK                                     code  fffc6950 18
  ENDMEM                                    const  00f000 17
  EOF                                       const  00001a 6
  ERETx2                                     code  fffc1208 18
  ERROR                                      code  fffc69a0 18
  ERROR1                                     code  fffc69e0 18
  EX1                                        code  fffc580c 18
  EXEC                                       code  fffc57d0 18
  EXGO                                       code  fffc582c 18
  EXLP                                       code  fffc57dc 18
  EXMAT                                      code  fffc581c 18
  EXNGO                                      code  fffc57f4 18
  EXPR                                       code  fffc62a0 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadAppId                                const  00001c 6
  E_BadBlockNum                             const  000025 7
  E_BadDCBOffset                            const  00001a 6
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_BadTcbPointer                           const  000027 7
  E_BadTid                                  const  000028 7
  E_Busy                                    const  00001b 6
  E_DCBInUse                                const  000019 6
  E_Func                                    const  000002 3
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  000047 8
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreAppIds                            const  000046 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTcbs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc0b20 18
  FI1                                        code  fffc6930 18
  FI2                                        code  fffc6944 18
  FILEBUF                                   const  07f600 20
  FILENAME                                  const  0006c0 12
  FIN                                        code  fffc6914 18
  FINISH                                     code  fffc5ac8 18
  FMTKInit                                   code  fffc2b20 18
  FMTKInit.0001                              code  fffc2cf8 18
  FMTKInit.0002                              code  fffc2d0c 18
  FMTKInit.0003                              code  fffc2c8c 18
  FMTKInit.0004                              code  fffc2d48 18
  FMTK_Alloc                                 code  fffc1c40 18
  FMTK_AllocMbx                              code  fffc3c98 18
  FMTK_AllocMbx.0001                         code  fffc3d44 18
  FMTK_AllocMbx.gotMbx                       code  fffc3d5c 18
  FMTK_AllocMbx.outOfMem                     code  fffc3dac 18
  FMTK_DumpReadyQueue                        code  fffc4a30 18
  FMTK_ExitApp                               code  fffc4520 18
  FMTK_ExitTask                              code  fffc3b80 18
  FMTK_ForceReleaseIOFocus                   code  fffc4f10 18
  FMTK_ForceReleaseIOFocus.0001              code  fffc4f80 18
  FMTK_ForceReleaseIOFocus.noFocus           code  fffc4fa8 18
  FMTK_ForceReleaseIOFocus.notAtTop          code  fffc4f90 18
  FMTK_FreeMbx                               code  fffc3dc0 18
  FMTK_GetAppTaskId                          code  fffc2e60 18
  FMTK_GetCurrentAppId                       code  fffc2df0 18
  FMTK_GetCurrentTid                         code  fffc2da0 18
  FMTK_GetDCBField                           code  fffc50f0 18
  FMTK_GetDCBField.badDev                    code  fffc5134 18
  FMTK_GetDCBField.badFunc                   code  fffc512c 18
  FMTK_GetDCBField.ldWord                    code  fffc5120 18
  FMTK_GetDCBField.ok                        code  fffc5124 18
  FMTK_GetDCBField.xit                       code  fffc5128 18
  FMTK_GetTaskAppId                          code  fffc2e00 18
  FMTK_HasIOFocus                            code  fffc4d30 18
  FMTK_HasIOFocus.hasFocus                   code  fffc4d90 18
  FMTK_HasIOFocus.notEqual                   code  fffc4d9c 18
  FMTK_IO                                    code  fffc5080 18
  FMTK_IO.badDev                             code  fffc50dc 18
  FMTK_IO.badFunc                            code  fffc50cc 18
  FMTK_IO.xit                                code  fffc50c8 18
  FMTK_Initialize                            code  fffc2d80 18
  FMTK_KillApp                               code  fffc4530 18
  FMTK_KillApp.immortal                      code  fffc4548 18
  FMTK_KillTask                              code  fffc3b90 18
  FMTK_KillTask.immortal                     code  fffc3be4 18
  FMTK_MapOSVars                             code  fffc2f00 18
  FMTK_MapOSVars.mapMore                     code  fffc2f20 18
  FMTK_MapOSVars.noMem                       code  fffc2f4c 18
  FMTK_MapOSVars.retx                        code  fffc2f40 18
  FMTK_PeekMsg                               code  fffc41d0 18
  FMTK_PostMsg                               code  8000000000000319 32
  FMTK_ReleaseIOFocus                        code  fffc4f00 18
  FMTK_RequestIOFocus                        code  fffc4e50 18
  FMTK_RequestIOFocus.badAppId               code  fffc4ef0 18
  FMTK_RequestIOFocus.notEmpty               code  fffc4ec4 18
  FMTK_RequestIOFocus.ret                    code  fffc4ed8 18
  FMTK_RunAsOS                               code  fffc2ef0 18
  FMTK_RunAsOS.badFunc                       code  fffc2ef8 18
  FMTK_SendMsg                               code  fffc4100 18
  FMTK_SetDCBField                           code  fffc5190 18
  FMTK_SetTaskAppId                          code  fffc2e30 18
  FMTK_SetTaskId                             code  fffc2e90 18
  FMTK_SetTaskPriority                       code  fffc2ea0 18
  FMTK_SetTaskPriority.badPtr                code  fffc2ed8 18
  FMTK_SetTaskPriority.badTid                code  fffc2ed0 18
  FMTK_Sleep                                 code  fffc3660 18
  FMTK_StartApp                              code  fffc4330 18
  FMTK_StartTask                             code  fffc3890 18
  FMTK_SwitchIOFocus                         code  fffc4e40 18
  FMTK_TCBFinalizerExit                      code  fffc5340 18
  FMTK_TCBFinalizerExit.0001                 code  fffc5378 18
  FMTK_WaitMsg                               code  fffc41e0 18
  FMTK_WaitMsg.qempty                        code  fffc4280 18
  FMTK_WaitMsg.qt                            code  fffc4210 18
  FMTK_WaitMsg.setA                          code  fffc4288 18
  FNDLN                                      code  fffc6ad8 18
  FNDLNP                                     code  fffc6b0c 18
  FNDLNT                                     code  fffc6b04 18
  FNDNXT                                     code  fffc6b30 18
  FNDRET1                                    code  fffc6b20 18
  FNDRET2                                    code  fffc6b28 18
  FOR                                        code  fffc5b58 18
  FORCEFIT                                   code  fffc6278 18
  FORCEFIT.0001                              code  fffc629c 18
  FORCEFIT.intAnd                            code  fffc628c 18
  FR1                                        code  fffc5b78 18
  FR2                                        code  fffc5b94 18
  FR3                                        code  fffc5b9c 18
  FR4                                        code  fffc5ba0 18
  FR5                                        code  fffc5ba4 18
  FR6                                        code  fffc5bbc 18
  FR7                                        code  fffc5bc0 18
  FR8                                        code  fffc5be0 18
  FUNCEXPR                                   code  fffc64f8 18
  FetchMemoryWord                            code  fffc1c30 18
  FillMem                                    code  fffc0be0 18
  FillMem.0001                               code  fffc0bfc 18
  Finalizer                                  code  fffc5280 18
  Finalizer.noFinalizer                      code  fffc5324 18
  Finalizer.nxt2                             code  fffc52b4 18
  Finalizer.oscode                           code  fffc52c8 18
  Finalizer.yield                            code  fffc52a8 18
  Find                                       code  fffc0c10 18
  Find.0001                                  code  fffc0c80 18
  Find.endOfWord                             code  fffc0c54 18
  Find.found                                 code  fffc0cc8 18
  Find.fwe                                   code  fffc0c28 18
  Find.loop                                  code  fffc0c70 18
  Find.next                                  code  fffc0ca8 18
  Find.notFound                              code  fffc0ce0 18
  FindRun                                    code  fffc1950 18
  FindRun.0001                               code  fffc196c 18
  FindRun.0002                               code  fffc197c 18
  FindRun.empty0                             code  fffc1984 18
  FindRun.empty1                             code  fffc1988 18
  FindRun.foundEnough                        code  fffc19a8 18
  FreeAll                                    code  fffc1b20 18
  FreeAll.0001                               code  fffc1b84 18
  FreeAll.nxt                                code  fffc1b30 18
  FreeAllTCBId                               code  fffc4680 18
  FreeMbx                                   const  ff000c08 33
  FreeMbx1                                   code  fffc3e28 18
  FreeMbx1.0001                              code  fffc3e80 18
  FreeMbx1.0002                              code  fffc3e2c 18
  FreeMbx1.0003                              code  fffc3e54 18
  FreeMbx1.badMbx                            code  fffc3ed4 18
  FreeMsg                                   const  ff000c00 33
  FreeMsgRout                                code  fffc3fd0 18
  FreeTCBId                                  code  fffc4650 18
  FreeTID                                    code  800000000000033c 32
  GCHAR                                      code  fffc5df4 18
  GCHAR1                                     code  fffc5e0c 18
  GETLN                                      code  fffc69e4 18
  GETLN.GL1                                  code  fffc6a04 18
  GETLN.GL2                                  code  fffc6a2c 18
  GETLN.GL3                                  code  fffc6a58 18
  GETLN.GL4                                  code  fffc6a80 18
  GETLN.GL5                                  code  fffc6a94 18
  GETLN.GL6                                  code  fffc6ab4 18
  GETLN.GL7                                  code  fffc6abc 18
  GOAUXI                                     code  fffc5418 18
  GOAUXO                                     code  fffc5410 18
  GOBYE                                      code  fffc5420 18
  GOIN                                       code  fffc540c 18
  GOOUT                                      code  fffc5408 18
  GOSTART                                    code  fffc5400 18
  GOSUB                                      code  fffc5ad0 18
  GOTO                                       code  fffc5944 18
  GOWARM                                     code  fffc5404 18
  GetBuflen                                  code  fffc5620 18
  GetBuflen.0001                             code  fffc5648 18
  GetBuflen.0002                             code  fffc562c 18
  GetBuflen.0004                             code  fffc5644 18
  GetCurrentTid                              code  fffc2d90 18
  GetDecNum                                  code  fffc0dc0 18
  GetDecNum.0001                             code  fffc0df0 18
  GetDecNum.isDigit                          code  fffc0dfc 18
  GetDecNum.next                             code  fffc0dd0 18
  GetFilename                                code  fffc5e58 18
  GetHexNum                                  code  fffc0d20 18
  GetHexNum.0001                             code  fffc0d70 18
  GetHexNum.isDigit                          code  fffc0dac 18
  GetHexNum.isHexLower                       code  fffc0d94 18
  GetHexNum.isHexUpper                       code  fffc0d7c 18
  GetHexNum.next                             code  fffc0d30 18
  GetIRQFlag                                 code  fffc2db0 18
  GetPamBit                                  code  fffc2020 18
  GetUIFlag                                  code  fffc5040 18
  Getbit                                     code  fffc46b0 18
  Getch                                      code  fffc04b0 18
  HEADRDY                                   const  ff000400 33
  HEADRDY0                                  const  ff000400 33
  HEADRDY1                                  const  ff000404 33
  HEADRDY2                                  const  ff000408 33
  HEADRDY3                                  const  ff00040c 33
  HEADRDY4                                  const  ff000410 33
  HEADRDY5                                  const  ff000414 33
  HEADRDY6                                  const  ff000418 33
  HEADRDY7                                  const  ff00041c 33
  IF0                                        code  fffc5c5c 18
  IF1                                        code  fffc5c60 18
  IF2                                        code  fffc5c68 18
  IF3                                        code  fffc5c8c 18
  IGB1                                       code  fffc6efc 18
  IGB2                                       code  fffc6ee8 18
  IGBRET                                     code  fffc6f04 18
  IGNBLK                                     code  fffc6edc 18
  INBUF                                     const  ff000100 33
  INCH                                       code  fffc71c0 18
  INCH1                                      code  fffc71e4 18
  INPERR                                     code  fffc5c94 18
  INPPTR                                    const  0007b4 12
  INPUT                                      code  fffc5cb0 18
  INSLINE                                    code  fffc5584 18
  INSLINE.0001                               code  fffc55b4 18
  IOF_NEXT                                   code  8000000000000371 32
  IOF_PREV                                   code  8000000000000372 32
  IOFocusNdx                                const  ff001080 33
  IOFocusTbl                                const  ff001088 33
  IP2                                        code  fffc5cd8 18
  IP3                                        code  fffc5d14 18
  IP4                                        code  fffc5d54 18
  IP5                                        code  fffc5d64 18
  IP6                                        code  fffc5cb8 18
  IP7                                        code  fffc5cf8 18
  IRQCause                                  const  ff001098 33
  IRQExit                                    code  fffc1174 18
  IRQExit.InitDev                            code  fffc11b0 18
  IRQExit.devAgain                           code  800000000000024b 32
  IRQExit.gcIrq                              code  fffc1204 18
  IRQExit.noIRQ                              code  fffc11a4 18
  IRQExit.notSerial                          code  fffc11d8 18
  IRQExit.notVia                             code  fffc1200 18
  IRQExit.softwareIrq                        code  fffc11ac 18
  IRQExit.timerIrq                           code  fffc11ac 18
  IRQFlag                                   const  ff001090 33
  IRQROUT                                   const  0007ac 12
  IRQRout                                    code  fffc1050 18
  IRQRout.busError                           code  fffc1078 18
  IRQRout.devAgain                           code  fffc1154 18
  IRQRout.ecall                              code  fffc10b0 18
  IRQRout.gcIrq                              code  800000000000023e 32
  IRQRout.illegal                            code  fffc1078 18
  IRQRout.illegal1                           code  fffc108c 18
  IRQRout.instAlign                          code  fffc1098 18
  IRQRout.instAlign1                         code  fffc10ac 18
  IRQRout.isIRQ                              code  fffc10b4 18
  IRQRout.noIRQ                              code  8000000000000240 32
  IRQRout.soc                                code  fffc1094 18
  IRQRout.softwareIrq                        code  800000000000023c 32
  IRQRout.timerIrq                           code  800000000000023d 32
  ISendMsg                                   code  fffc4020 18
  ISendMsg.badMbx                            code  fffc40e8 18
  ISendMsg.mbxEmpty                          code  fffc40d0 18
  ISendMsg.noMsg                             code  fffc40e0 18
  ISendMsg.noWaiters                         code  fffc40a4 18
  ISendMsg.xit                               code  fffc40ec 18
  ISetDCBField                               code  fffc5140 18
  ISetDCBField.badDev                        code  fffc5184 18
  ISetDCBField.badFunc                       code  fffc517c 18
  ISetDCBField.ok                            code  fffc5174 18
  ISetDCBField.stWord                        code  fffc5170 18
  ISetDCBField.xit                           code  fffc5178 18
  ISleep                                     code  fffc3590 18
  ISleep.0001                                code  fffc35e0 18
  ISleep.noCtxSwitch                         code  fffc363c 18
  ISleep.noException                         code  fffc362c 18
  ISleep.xit                                 code  fffc3644 18
  IStartApp                                  code  fffc4330 18
  IStartApp.0001                             code  fffc43f4 18
  IStartApp.0002                             code  fffc4454 18
  IStartApp.0003                             code  fffc4418 18
  IStartApp.0004                             code  fffc4410 18
  IStartApp.0005                             code  fffc446c 18
  IStartApp.0006                             code  fffc4484 18
  IStartApp.0007                             code  fffc449c 18
  IStartApp.noMem                            code  fffc4510 18
  IStartApp.noMoreApps                       code  fffc4508 18
  IStartApp.norm                             code  fffc44b8 18
  IStartApp.retx                             code  fffc44f0 18
  IStartApp.tskErr                           code  fffc44fc 18
  IStartTask                                 code  fffc3890 18
  IStartTask.AllocStackErr                   code  fffc3ac4 18
  IStartTask.err                             code  fffc3abc 18
  IStartTask.mm                              code  fffc3a18 18
  IStartTask.mm1                             code  fffc3a1c 18
  IStartTask.noTcbId                         code  fffc3afc 18
  IStartTask.notIdleTask                     code  fffc3a90 18
  IStartTask.xit                             code  fffc3a9c 18
  IdleTask                                   code  fffc03a0 18
  IdleTask.0001                              code  fffc0488 18
  IdleTask.IdleCode                          code  fffc0428 18
  IdleTask.addToReady                        code  fffc046c 18
  IdleTask.loop                              code  fffc03c0 18
  IdleTask.loop2                             code  fffc03b0 18
  IdleTask.noAnnounce                        code  fffc03fc 18
  IdleTask.noMsg                             code  fffc03fc 18
  IdleTask.nxtObj                            code  fffc042c 18
  IdleTaskId                                const  ff000c2a 33
  IdleTaskMbx                               const  ff000c10 33
  IdleTaskMsgD1                             const  ff000c18 33
  IdleTaskMsgD2                             const  ff000c20 33
  IdleTaskMsgD3                             const  ff000c28 33
  InsertIntoReadyQueue                       code  fffc4730 18
  InsertIntoReadyQueue.badTcb                code  fffc47bc 18
  InsertIntoReadyQueue.qempty                code  fffc47cc 18
  InsertIntoReadyQueue.retx                  code  fffc47c8 18
  InsertIntoTimeoutList                      code  fffc4980 18
  InsertIntoTimeoutList.retx                 code  fffc49c0 18
  InsertLine                                 code  fffc5600 18
  InsertLine.0001                            code  fffc5604 18
  InsertLine.done                            code  fffc561c 18
  LET                                        code  fffc5d7c 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc59e4 18
  LNFD                                      const  00000a 5
  LOAD                                       code  fffc5d94 18
  LOAD3                                      code  fffc5ec4 18
  LOAD4                                      code  fffc5ef0 18
  LOAD5                                      code  fffc5f28 18
  LOD1                                       code  fffc5da4 18
  LOD2                                       code  fffc5dd0 18
  LODEND                                     code  fffc5dec 18
  LOG_ACBSZ                                 const  00000c 5
  LOG_PGSZ                                  const  00000a 5
  LOG_TCBSZ                                 const  00000a 5
  LOPINC                                    const  000780 12
  LOPLMT                                    const  000784 12
  LOPLN                                     const  00077c 12
  LOPPT                                     const  000778 12
  LOPVAR                                    const  000710 12
  LS1                                        code  fffc59f8 18
  LS2                                        code  fffc5a24 18
  LS3                                        code  fffc5a2c 18
  LS4                                        code  fffc5a04 18
  LS5                                        code  fffc59fc 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc5d90 18
  LoadWord                                   code  fffc6d98 18
  LockOS                                     code  fffc2f60 18
  LockOS.spin                                code  fffc2f64 18
  LockOSSemaphore                            code  fffc2f60 18
  MAX_DEV_OP                                const  00001f 6
  MAX_TID                                   const  00003f 7
  MBX_BLOCKPTR_BUFSZ                        const  000008 5
  MBX_LINK                                  const  000004 4
  MBX_MAGIC                                 const  204d4258 31
  MBX_MQHEAD                                const  00000c 5
  MBX_MQTAIL                                const  000010 6
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000014 6
  MBX_TQHEAD                                const  000004 4
  MBX_TQTAIL                                const  000008 5
  MEMSZ                                     const  000200 11
  MEPC0                                     const  ff000350 33
  MEPC1                                     const  ff000358 33
  MEPC2                                     const  ff000360 33
  MEPC3                                     const  ff000368 33
  MMUInit                                    code  fffc1880 18
  MMUInit.0001                               code  fffc18b8 18
  MMUInit.0002                               code  fffc1910 18
  MMUInit.0003                               code  fffc18d8 18
  MMUInit.0004                               code  fffc18ac 18
  MMUInit.0005                               code  fffc18d4 18
  MMUInit.0006                               code  fffc18f4 18
  MMUInit.0007                               code  fffc1928 18
  MMUInit.0008                               code  fffc18d0 18
  MSG_D1                                    const  000008 5
  MSG_D2                                    const  00000c 5
  MSG_D3                                    const  000010 6
  MSG_LINK                                  const  000000 1
  MSG_MAGIC                                 const  204d5347 31
  MSG_RETADR                                const  000004 4
  MSG_SIZE                                  const  000014 6
  MSG_TGTADR                                const  000005 4
  MSG_TYPE                                  const  000006 4
  MT_ANNOUNCE                               const  000010 6
  MT_IRQ                                    const  ffffffff 33
  MULEXPR                                    code  fffc645c 18
  MVDOWN                                     code  fffc6b6c 18
  MVDOWN1                                    code  fffc6b5c 18
  MVUP                                       code  fffc6b54 18
  MVUP1                                      code  fffc6b44 18
  MachineStart                               code  fffc0100 18
  MapTCBStorage                              code  fffc3b14 18
  MbxBlockCounter                           const  ff0010e0 33
  MbxBlockPtr                               const  ff0010a0 33
  MbxBlockPtrEnd                            const  ff0010c0 33
  MbxFinalizer                               code  800000000000037d 32
  MbxRemoveTask                              code  fffc3bf0 18
  MbxRemoveTask.atHead                       code  fffc3c28 18
  MbxRemoveTask.tqEmpty                      code  fffc3c6c 18
  MbxRemoveTask.xit                          code  fffc3c74 18
  MonEntry                                   code  fffc05e0 18
  Monitor                                    code  fffc05f8 18
  Monitor.0001                               code  fffc0634 18
  Monitor.0002                               code  fffc0690 18
  Monitor.0003                               code  fffc06f4 18
  Monitor.0004                               code  fffc0780 18
  Monitor.0005                               code  fffc08d0 18
  Monitor.0006                               code  fffc080c 18
  Monitor.0007                               code  fffc0840 18
  Monitor.0008                               code  fffc084c 18
  Monitor.0009                               code  fffc0878 18
  Monitor.0010                               code  fffc0890 18
  Monitor.0011                               code  fffc08ac 18
  Monitor.0012                               code  fffc08c4 18
  Monitor.0013                               code  fffc08d0 18
  Monitor.basSize                            code  fffc07d0 18
  Monitor.bufndx1                            code  fffc0680 18
  Monitor.doBackspace                        code  fffc06e4 18
  Monitor.doDelete                           code  fffc0688 18
  Monitor.getFocus                           code  fffc05f8 18
  Monitor.hasFocus                           code  fffc0618 18
  Monitor.noT                                code  fffc0834 18
  Monitor.notFind                            code  fffc0874 18
  Monitor.notX                               code  fffc07a0 18
  Monitor.procLine                           code  fffc0748 18
  Monitor.skip                               code  fffc075c 18
  Monitor.skip2                              code  fffc0778 18
  MonitorASR                                 code  fffc1230 18
  MsgFinalizer                               code  fffc42d0 18
  NEW                                        code  fffc5840 18
  NEXT                                       code  fffc5be4 18
  NPAGES                                    const  ff000300 33
  NR_DCB                                    const  000020 7
  NR_DCB.done                                code  000000 18
  NR_DCB.noWait                              code  000000 18
  NR_TCB                                    const  000040 8
  NTASK                                     const  000020 7
  NUMWKA                                    const  00079c 12
  NX0                                        code  fffc5c00 18
  NX1                                        code  fffc5c40 18
  NX2                                        code  fffc5c20 18
  NX3                                        code  fffc5c44 18
  NX4                                        code  fffc5bfc 18
  NX5                                        code  fffc5c14 18
  NXPurge                                    code  fffc5c54 18
  OBJCollectionIndex                        const  00001c 6
  OBJFWAddr                                 const  000028 7
  OBJFinalizer                              const  000030 7
  OBJID                                     const  000014 6
  OBJMagic                                  const  000000 1
  OBJOwningMap                              const  00001a 6
  OBJPad1                                   const  00001b 6
  OBJPad3                                   const  000024 7
  OBJScavcnt                                const  000019 6
  OBJSize                                   const  000008 5
  OBJState                                  const  000018 6
  OBJTypenum                                const  000010 6
  OBJUsedInMap                              const  000020 7
  OBJ_SIZE                                  const  000040 8
  OKMSG                                      code  fffc723a 18
  ONIRQ                                      code  fffc59a8 18
  ONIRQ1                                     code  fffc59c8 18
  OREXPR                                     code  fffc6148 18
  OSCallTbl                                  code  fffc2a94 18
  OSECALL                                    code  fffc33a0 18
  OSECALL.badFunc                            code  fffc3454 18
  OSECALL.busy                               code  fffc345c 18
  OSEcallTbl                                 code  fffc2aa0 18
  OSExit                                     code  fffc3470 18
  OSOCall                                    code  fffc3300 18
  OSOCall.badFunc                            code  fffc338c 18
  OSOCall.busy                               code  fffc3394 18
  OSPAGES                                   const  000030 7
  OSSP                                      const  000700 12
  OST_BLACK                                 const  000002 3
  OST_DEAD                                  const  000080 9
  OST_GREY                                  const  000001 2
  OST_UNDEAD                                const  000040 8
  OST_WHITE                                 const  000000 1
  OS_SEMA                                   const  ffdb0000 33
  OT_ACB                                    const  000001 2
  OT_MBX                                    const  000003 3
  OT_MSG                                    const  000002 3
  OT_TCB                                    const  000000 1
  OUTC                                       code  fffc71bc 18
  OUTPTR                                    const  0007b0 12
  OpenSpace                                  code  fffc564c 18
  OpenSpace.0003                             code  fffc5664 18
  OpenSpace.noSpace                          code  fffc5680 18
  PAGESZ                                    const  000400 12
  PAM                                       const  ff001000 33
  PAMAlloc                                   code  fffc1d30 18
  PAMAlloc.markNext                          code  fffc1d90 18
  PAMAlloc.outOfMem                          code  fffc1dcc 18
  PAMAlloc.xit                               code  fffc1db0 18
  PAMAlloc.xit2                              code  fffc1dd4 18
  PAMDump                                    code  fffc2050 18
  PAMDump.0001                               code  fffc205c 18
  PAMFindRun                                 code  fffc1c50 18
  PAMFindRun.foundRun                        code  fffc1d08 18
  PAMFindRun.nextPage                        code  fffc1c70 18
  PAMFindRun.notAvailable                    code  fffc1cf4 18
  PAMFindRun.outOfMem                        code  fffc1d00 18
  PAMFindRun.runInc                          code  fffc1ca8 18
  PAMFindRun.xit                             code  fffc1d0c 18
  PAMFree                                    code  fffc1e00 18
  PAMFree.endOfRun                           code  fffc1e64 18
  PAMFree.lastPage                           code  fffc1e54 18
  PAMFree.nextPage                           code  fffc1e28 18
  PAMFree.xit                                code  fffc1e88 18
  PAMGetbitPair                              code  fffc1f60 18
  PAMInit                                    code  fffc1f90 18
  PAMInit.0001                               code  fffc1fd4 18
  PAMInit.0002                               code  fffc1fb0 18
  PAMInit.0003                               code  fffc1ff4 18
  PAMMarkPage                                code  fffc1ea0 18
  PAMMarkPage.0001                           code  fffc1eb4 18
  PAMMarkPage.gotFree                        code  fffc1ed4 18
  PAMMarkPage.xit                            code  fffc1ee0 18
  PAMPtr                                    const  ff000ff8 33
  PAMSetbitPair                              code  fffc1f10 18
  PAMUnmarkPage                              code  fffc1ef0 18
  PAMend                                    const  ff001080 33
  PAMxit                                     code  fffc1f54 18
  PARN                                       code  fffc6548 18
  PEEK                                       code  fffc6738 18
  PEEKH                                      code  fffc6768 18
  PEEKW                                      code  fffc6750 18
  PKER                                       code  fffc6110 18
  POKE                                       code  fffc608c 18
  POKEH                                      code  fffc60e4 18
  POKEW                                      code  fffc60b8 18
  POPA_                                      code  fffc6b74 18
  PP1                                        code  fffc6ba8 18
  PR0                                        code  fffc5a5c 18
  PR1                                        code  fffc5a74 18
  PR2                                        code  fffc5a48 18
  PR3                                        code  fffc5a94 18
  PR4                                        code  fffc5a8c 18
  PR6                                        code  fffc5aa8 18
  PR8                                        code  fffc5ab0 18
  PRINT                                      code  fffc5a30 18
  PRI_LOW                                   const  000003 3
  PRI_NORMAL                                const  000002 3
  PRMESG                                     code  fffc6fc4 18
  PRTLN                                      code  fffc6dc4 18
  PRTNUM                                     code  fffc6cf0 32
  PRTNUM.PN1                                 code  fffc6d24 18
  PRTNUM.PN2                                 code  fffc6d20 18
  PRTNUM.PN3                                 code  fffc6d4c 18
  PRTNUM.PN4                                 code  fffc6d5c 18
  PRTNUM.PN5                                 code  fffc6d68 18
  PRTNUM.PN6                                 code  fffc6d6c 18
  PRTNUM.PN7                                 code  fffc6d34 18
  PRTSTG                                     code  fffc6bf0 18
  PRTSTG.PRTRET                              code  fffc6c34 18
  PRTSTG.PS1                                 code  fffc6c10 18
  PU1                                        code  fffc6be4 18
  PUSHA_                                     code  fffc6bac 18
  PWORD                                      code  fffc6020 18
  PeekMsg                                    code  fffc4110 18
  PeekMsg.badMbx                             code  fffc41bc 18
  PeekMsg.noMsg                              code  fffc41b4 18
  PeekMsg.nod1                               code  fffc4184 18
  PeekMsg.nod2                               code  fffc4198 18
  PeekMsg.nod3                               code  fffc41ac 18
  PeekMsg.nodq                               code  fffc4164 18
  PeekMsg.ret                                code  fffc41c0 18
  PickACB                                    code  fffc4550 18
  PickACB.0001                               code  fffc4554 18
  PickACB.xit                                code  fffc457c 18
  PutHexByte                                 code  fffc0e80 18
  PutHexHalf                                 code  fffc0e50 18
  PutHexNybble                               code  fffc0eb0 18
  PutHexNybble.0001                          code  fffc0ee4 18
  PutHexNybble.lt10                          code  fffc0edc 18
  PutHexWord                                 code  fffc0e20 18
  PutString                                  code  fffc0f00 18
  PutString.0001                             code  fffc0f10 18
  PutString.done                             code  fffc0f24 18
  Putch                                      code  fffc04e0 18
  QNDX                                      const  ff000304 33
  QSORRY                                     code  fffc698c 18
  QT1                                        code  fffc6c70 18
  QT2                                        code  fffc6cb0 18
  QT3                                        code  fffc6c88 18
  QT4                                        code  fffc6c9c 18
  QT5                                        code  fffc6cbc 18
  QTSTG                                      code  fffc6c58 18
  QWHAT                                      code  fffc6998 18
  READYQ                                    const  ff000400 33
  RETURN                                     code  fffc5b14 18
  RND                                        code  fffc67c0 18
  RUN                                        code  fffc5898 18
  RUN1                                       code  fffc5910 18
  RUN2                                       code  fffc58b4 18
  RUN3                                       code  fffc58b8 18
  RUNNXL                                     code  fffc58ac 18
  RUNSML                                     code  fffc592c 18
  RUNTSL                                     code  fffc5924 18
  RegsetTid                                 const  ff0010f0 33
  RemoveFromReadyQueue                       code  fffc4810 18
  RemoveFromReadyQueue.badTcb                code  fffc4868 18
  RemoveFromReadyQueue.emptyList             code  fffc4878 18
  RemoveFromReadyQueue.hr1                   code  fffc48ac 18
  RemoveFromReadyQueue.hr2                   code  fffc48e0 18
  RemoveFromReadyQueue.hr3                   code  fffc4914 18
  RemoveFromReadyQueue.hr4                   code  fffc4948 18
  RemoveFromReadyQueue.retx                  code  fffc4874 18
  RemoveFromReadyQueue.xit                   code  fffc4860 18
  RemoveFromTimeoutList                      code  fffc49e0 18
  RemoveFromTimeoutList.retx                 code  fffc4a24 18
  SAVE                                       code  fffc5f98 18
  SAVE1                                      code  fffc5fa8 18
  SAVE2                                      code  fffc5fc4 18
  SAVE3                                      code  fffc5f2c 18
  SAVE4                                      code  fffc5f5c 18
  SAVEND                                     code  fffc5fdc 18
  SDReadSector                               code  80000000000004e7 32
  SDWriteSector                              code  80000000000004ec 32
  SENDMSG                                    code  fffc7048 18
  SENDMSG.err                                code  fffc70cc 18
  SENDMSG.paren                              code  fffc70d8 18
  SETVAL                                     code  fffc68ac 18
  SETVAL.sv2                                 code  fffc68d0 18
  SGN                                        code  fffc6854 18
  SGN1                                       code  fffc6884 18
  SGN2                                       code  fffc6874 18
  SIZEX                                      code  fffc6890 18
  SLEEP                                      code  fffc585c 18
  SLEEP1                                     code  fffc5868 18
  SRCHLN                                    const  00071c 12
  SRYMSG                                     code  fffc7247 18
  ST2                                        code  fffc5560 18
  STACKOFFS                                 const  00fffc 17
  STKBOT                                    const  0007a4 12
  STKGOS                                    const  000714 12
  STKINP                                    const  0007a0 12
  STOP                                       code  fffc5854 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc690c 18
  SYSX                                       code  fffc611c 18
  SchedulerIRQ                               code  fffc3670 18
  SchedulerIRQ.0001                          code  fffc3698 18
  SchedulerIRQ.0002                          code  fffc3740 18
  SchedulerIRQ.0003                          code  fffc372c 18
  SchedulerIRQ.0004                          code  fffc36c0 18
  SchedulerIRQ.0005                          code  fffc3768 18
  SchedulerIRQ.0006                          code  fffc37d4 18
  SchedulerIRQ.0007                          code  fffc37e8 18
  SchedulerIRQ.noCtxSwitch                   code  fffc3864 18
  SchedulerIRQ.noException                   code  fffc385c 18
  SchedulerIRQ.noOS                          code  fffc3680 18
  SchedulerIRQ.toDone                        code  fffc3808 18
  SelectTaskToRun                            code  fffc2fc0 18
  SelectTaskToRun.0001                       code  fffc30d0 18
  SelectTaskToRun.dq                         code  fffc304c 18
  SelectTaskToRun.listCorrupt                code  fffc30c4 18
  SelectTaskToRun.mod                        code  fffc3038 18
  SelectTaskToRun.nxtQ                       code  fffc3014 18
  SelectTaskToRun.xit                        code  fffc30b0 18
  SerHeadRcv                                const  ff001c00 33
  SerHeadXmit                               const  ff001c08 33
  SerRcvBuf                                 const  ff001400 33
  SerRcvXoff                                const  ff001c11 33
  SerRcvXon                                 const  ff001c10 33
  SerTailRcv                                const  ff001c04 33
  SerTailXmit                               const  ff001c0c 33
  SerXmitBuf                                const  ff001800 33
  SerialDCB                                  code  fffc2108 18
  SerialFinishCmd                            code  fffc22e4 18
  SerialFinishCmd.0001                       code  fffc2318 18
  SerialFuncTbl                              code  fffc2088 18
  SerialGetChar                              code  fffc2320 18
  SerialGetChar.0001                         code  fffc23d8 18
  SerialGetChar.0002                         code  fffc2388 18
  SerialGetChar.noChars                      code  fffc23d8 18
  SerialGetChar.xit                          code  fffc23dc 18
  SerialGetCharEx                            code  fffc23fc 18
  SerialGetCharEx.0001                       code  fffc24b4 18
  SerialGetCharEx.0002                       code  fffc2460 18
  SerialGetCharEx.noChars                    code  fffc24b4 18
  SerialGetCharEx.xit                        code  fffc24b8 18
  SerialGetUI                                code  fffc2810 18
  SerialIRQ                                  code  fffc2730 18
  SerialIRQ.0001                             code  fffc2764 18
  SerialIRQ.notRxInt                         code  fffc2800 18
  SerialIRQ.nxtByte                          code  fffc2740 18
  SerialIRQ.rxFull                           code  fffc2800 18
  SerialInit                                 code  fffc21b0 18
  SerialNOP                                  code  fffc2260 18
  SerialPeekChar                             code  fffc24e0 18
  SerialPeekChar.0001                        code  fffc2528 18
  SerialPeekChar.noChars                     code  fffc2528 18
  SerialPeekChar.xit                         code  fffc252c 18
  SerialPeekCharDirect                       code  fffc25b0 18
  SerialPeekCharDirect.0001                  code  fffc25ec 18
  SerialPeekCharDirect.xit                   code  fffc25f0 18
  SerialPeekCharEx                           code  fffc2548 18
  SerialPeekCharEx.0001                      code  fffc2590 18
  SerialPeekCharEx.noChars                   code  fffc2590 18
  SerialPeekCharEx.xit                       code  fffc2594 18
  SerialPutChar                              code  fffc2610 18
  SerialPutChar.0001                         code  fffc2640 18
  SerialPutChar.0003                         code  fffc2628 18
  SerialPutChar.goSleep                      code  fffc2678 18
  SerialPutChar.noFunc                       code  fffc2690 18
  SerialPutChar.xit                          code  fffc265c 18
  SerialPutCharEx                            code  fffc26d0 18
  SerialPutCharEx.0001                       code  fffc26d8 18
  SerialRcvCount                             code  fffc26f0 18
  SerialRcvCount.xit                         code  fffc2728 18
  SerialService                              code  fffc227c 18
  SerialServiceInit                          code  fffc2264 18
  SerialServiceLoop                          code  fffc2298 18
  SerialServiceLoop.0001                     code  fffc2298 18
  SerialSetup                                code  fffc2170 18
  SetIRQFlag                                 code  fffc2dd0 18
  Setbit                                     code  fffc46d0 18
  SkipSpaces                                 code  fffc0cf4 18
  SkipSpaces.skip1                           code  fffc0d18 18
  SkipSpaces.skip2                           code  fffc0cf4 18
  StackTbl                                   code  fffc0fb0 18
  StackTbl2                                  code  fffc1030 18
  SwapContext                                code  fffc30f0 18
  SwitchIOFocusHelper                        code  fffc4db0 18
  SwitchIOFocusHelper.notSame                code  fffc4e1c 18
  SwitchIOFocusHelper.pickACB                code  fffc4e20 18
  SwitchIOFocusHelper.zeroAppId              code  fffc4e0c 18
  SysHeapEnd                                const  020000 19
  SysHeapStart                              const  004000 16
  SysSema                                   const  ff000340 33
  SystemASR                                  code  fffc1278 18
  TAB                                       const  000009 5
  TAB1                                       code  fffc5688 18
  TAB10                                      code  fffc5747 18
  TAB10_1                                    code  fffc57b8 18
  TAB1_1                                     code  fffc574a 18
  TAB2                                       code  fffc569f 18
  TAB2_1                                     code  fffc5756 18
  TAB4                                       code  fffc56f8 18
  TAB4_1                                     code  fffc5784 18
  TAB5                                       code  fffc5731 18
  TAB5_1                                     code  fffc579e 18
  TAB6                                       code  fffc5734 18
  TAB6_1                                     code  fffc57a2 18
  TAB8                                       code  fffc5739 18
  TAB8_1                                     code  fffc57a6 18
  TAB9                                       code  fffc5743 18
  TAB9_1                                     code  fffc57b4 18
  TAILRDY                                   const  ff000420 33
  TAILRDY0                                  const  ff000420 33
  TAILRDY1                                  const  ff000424 33
  TAILRDY2                                  const  ff000428 33
  TAILRDY3                                  const  ff00042c 33
  TAILRDY4                                  const  ff000430 33
  TAILRDY5                                  const  ff000434 33
  TAILRDY6                                  const  ff000438 33
  TAILRDY7                                  const  ff00043c 33
  TBASR                                      code  80000000000001ed 32
  TC1                                        code  fffc6e54 18
  TCBEndTick                                const  0002d8 11
  TCBException                              const  000308 11
  TCBFltRegs                                const  000140 10
  TCBHasFocus                               const  0002cd 11
  TCBID_POOL                                const  ff0002f8 33
  TCBID_TL                                  const  ff000230 33
  TCBImMask                                 const  000345 11
  TCBIntRegs                                const  000040 8
  TCBMbxNext                                const  000348 11
  TCBMbxPrev                                const  000350 11
  TCBMsgD1                                  const  0002d8 11
  TCBMsgD2                                  const  0002e0 11
  TCBMsgD3                                  const  0002e8 11
  TCBName                                   const  000360 11
  TCBNext                                   const  000310 11
  TCBObject                                 const  000000 1
  TCBOpMode                                 const  000344 11
  TCBPTR_MASK                               const  fff803ff 33
  TCBPrev                                   const  000318 11
  TCBPriority                               const  0002c9 11
  TCBPtrs                                   const  ff000500 33
  TCBRegsEnd                                const  000240 11
  TCBRegset                                 const  0002cc 11
  TCBStackBot                               const  0002d0 11
  TCBStartTick                              const  0002d0 11
  TCBStatus                                 const  0002c8 11
  TCBTaskNum                                const  000358 11
  TCBTicks                                  const  000300 11
  TCBTimeout                                const  000320 11
  TCBWaitMbx                                const  0002ca 11
  TCB_MAGIC                                 const  20544342 31
  TCBappid                                  const  000342 11
  TCBbases                                  const  000240 11
  TCBepc                                    const  0002c0 11
  TCBmid                                    const  000340 11
  TCBtid                                    const  000338 11
  TCBxA0                                    const  000090 9
  TCBxA1                                    const  000098 9
  TCBxA2                                    const  0000a0 9
  TCBxA3                                    const  0000a8 9
  TCBxA4                                    const  0000b0 9
  TCBxA5                                    const  0000b8 9
  TCBxA6                                    const  0000c0 9
  TCBxA7                                    const  0000c8 9
  TCBxFP                                    const  000080 9
  TCBxGP                                    const  000058 8
  TCBxRA                                    const  000048 8
  TCBxS1                                    const  000088 9
  TCBxS10                                   const  000110 10
  TCBxS11                                   const  000118 10
  TCBxS2                                    const  0000d0 9
  TCBxS3                                    const  0000d8 9
  TCBxS4                                    const  0000e0 9
  TCBxS5                                    const  0000e8 9
  TCBxS6                                    const  0000f0 9
  TCBxS7                                    const  0000f8 9
  TCBxS8                                    const  000100 10
  TCBxS9                                    const  000108 10
  TCBxSP                                    const  000050 8
  TCBxT0                                    const  000068 8
  TCBxT1                                    const  000070 8
  TCBxT2                                    const  000078 8
  TCBxT3                                    const  000120 10
  TCBxT4                                    const  000128 10
  TCBxT5                                    const  000130 10
  TCBxT6                                    const  000138 10
  TCBxTP                                    const  000060 8
  TICKX                                      code  fffc6840 18
  TID_POOL                                  const  ff000310 33
  TMOQ                                      const  ffdc0400 33
  TN1                                        code  fffc6e84 18
  TN2                                        code  fffc6eb0 18
  TOOBIG                                     code  fffc6980 18
  TOUPB1                                     code  fffc6f24 18
  TOUPBRT                                    code  fffc6f6c 18
  TOUPBUF                                    code  fffc6f14 18
  TOUPRET                                    code  fffc6f90 18
  TSNMRET                                    code  fffc6ecc 18
  TSTC                                       code  fffc6e20 18
  TSTNUM                                     code  fffc6e6c 18
  TSTV                                       code  fffc6588 18
  TSTVRT                                     code  fffc65f8 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_UNDEAD                                 const  000040 8
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc65e4 18
  TV2                                        code  fffc65d8 18
  TV3                                        code  fffc65b8 18
  TXTBGN                                    const  001800 14
  TXTUNF                                    const  000704 12
  TaskNum                                   const  ff000220 33
  Tick                                      const  ff000330 33
  TidTcbMap                                  code  80000000000003f7 32
  TimeoutList                               const  ff000328 33
  TinyBasic                                  code  fffc5400 18
  TinyBasicASR                               code  fffc12c0 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  UNDEADQ                                   const  000007 4
  USRX                                       code  fffc6780 18
  UnlockOS                                   code  fffc2fa0 18
  UnlockOSSemaphore                          code  fffc2fa0 18
  UnmapTCBStorage                            code  fffc3b44 18
  UpdateMsgFields                            code  fffc3510 18
  UpdateMsgFields.noMsg                      code  fffc3560 18
  UpdateMsgFields.notWaiting                 code  fffc3574 18
  UserASR                                    code  fffc1308 18
  UserStart                                  code  fffc0268 18
  UserStart2                                 code  fffc0274 18
  UserStart2.0001                            code  fffc02a0 18
  UserStart2.0002                            code  fffc02b8 18
  UserStart2.0003                            code  fffc02ec 18
  UserStart2.0004                            code  fffc0308 18
  UserStart2.0005                            code  fffc0328 18
  UserStart2.0006                            code  fffc0340 18
  UserStart2.appBad                          code  fffc0284 18
  UserStart3                                 code  fffc0354 18
  UserStart3.0002                            code  fffc0390 18
  UserStart3.0003                            code  fffc03a0 18
  UserStart3.0004                            code  fffc0380 18
  UserStart3.noMbx                           code  fffc0390 18
  VARBGN                                    const  000708 12
  VAREND                                    const  00070c 12
  VIA                                       const  ffdc0600 33
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IER                                   const  000038 7
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  VIA_T2CH                                  const  000024 7
  VIA_T2CL                                  const  000020 7
  ViaDCB                                     code  fffc28a8 18
  ViaFuncTbl                                 code  fffc2828 18
  ViaIRQ                                     code  fffc29b0 18
  ViaIRQ.0001                                code  fffc29cc 18
  ViaIRQ.timer2irq                           code  fffc2a34 18
  ViaIRQ.timer3irq                           code  fffc29e0 18
  ViaInit                                    code  fffc2950 18
  ViaNOP                                     code  fffc2944 18
  ViaSetup                                   code  fffc2910 18
  ViaTime                                    code  fffc2a50 18
  VirtToLinear                               code  fffc1b90 18
  VirtToPhys                                 code  fffc1bc0 18
  VirtToPhys.notMapped                       code  fffc1bf8 18
  VirtToPhys2                                code  fffc1c10 18
  VirtToPhys2.notMapped                      code  fffc1c18 18
  WAITIRQ                                    code  fffc59d0 18
  WAITMSG                                    code  fffc70e4 18
  WAITMSG.0001                               code  fffc711c 18
  WAITMSG.0002                               code  fffc7110 18
  WAITMSG.err                                code  fffc71a4 18
  WAITMSG.paren                              code  fffc71b0 18
  WSTART                                     code  fffc54f0 18
  WaitForIOFocus                             code  fffc4fc0 18
  WaitForIOFocus.0001                        code  fffc4ff0 18
  WaitForIOFocus.HasFocus                    code  fffc5024 18
  WaitForIOFocus.WFF1                        code  fffc4fd0 18
  WaitForIOFocus.WFF2                        code  fffc5014 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc62cc 18
  XP12                                       code  fffc62e4 18
  XP13                                       code  fffc62fc 18
  XP14                                       code  fffc6314 18
  XP15                                       code  fffc632c 18
  XP16                                       code  fffc6344 18
  XP17                                       code  fffc6384 18
  XP18                                       code  fffc639c 18
  XP21                                       code  fffc63ec 18
  XP22                                       code  fffc63f8 18
  XP23                                       code  fffc63fc 18
  XP24                                       code  fffc6418 18
  XP25                                       code  fffc642c 18
  XP26                                       code  fffc6438 18
  XP31                                       code  fffc6468 18
  XP34                                       code  fffc6498 18
  XP35                                       code  fffc64bc 18
  XP40                                       code  fffc6514 18
  XP41                                       code  fffc6530 18
  XP42                                       code  fffc656c 18
  XP43                                       code  fffc6578 18
  XP45                                       code  fffc6444 18
  XP46                                       code  fffc653c 18
  XP47                                       code  fffc64e0 18
  XPRT0                                      code  fffc635c 18
  XPRT1                                      code  fffc6370 18
  XP_AND                                     code  fffc61dc 18
  XP_AND1                                    code  fffc61bc 18
  XP_ANDX                                    code  fffc61f0 18
  XP_OR                                      code  fffc617c 18
  XP_OR1                                     code  fffc615c 18
  XP_ORX                                     code  fffc6190 18
  YIELD0                                     code  fffc5890 18
  _WaitForIOFocus                            code  fffc4fc0 18
  _clr                                       code  fffc5968 18
  _cls                                       code  800000000000046b 32
  _end_init_data                           rodata  fffc8000 32
  _rdcf                                      code  800000000000046d 32
  a2h1                                       code  fffc5e4c 18
  asciiToHex                                 code  fffc5e40 18
  begin_init_data                          rodata  fffc8000 32
  clearVars                                  code  fffc5970 18
  clearVars.cv1                              code  fffc5984 18
  doMem                                      code  fffc0a10 18
  doMem.0001                                 code  fffc0a34 18
  doMem.0002                                 code  fffc0ab8 18
  doMem.0003                                 code  fffc0aec 18
  doMem.0004                                 code  fffc0ad0 18
  doMem.loop                                 code  fffc0a94 18
  doMem.loop2                                code  fffc0a6c 18
  doMem.unprintable                          code  fffc0ae4 18
  doMem.userMem                              code  fffc0ab4 18
  doPStat                                    code  fffc0ba0 18
  doPStat.0001                               code  fffc0bb4 18
  doVMem                                     code  fffc0b40 18
  doVMem.0001                                code  fffc0b50 18
  doVMem.notLF                               code  fffc0b68 18
  ec1                                        code  fffc6974 18
  end_init_data                            rodata  fffc8000 32
  fgetc                                      code  fffc0580 18
  fgetc.0001                                 code  fffc05b4 18
  fgetc.0002                                 code  fffc05c4 18
  fgetc.0003                                 code  fffc05c0 18
  fgetc.checkOwner                           code  fffc05a8 18
  fgetc.notOwner                             code  fffc05d8 18
  findVar                                    code  fffc66c8 18
  fl1                                        code  fffc6af0 18
  flt10                                      code  fffc1499 18
  flt20                                      code  fffc1489 18
  flt50                                      code  fffc1479 18
  fltMillion                                 code  fffc1870 18
  fltOne                                     code  fffc1868 18
  fltTen                                     code  fffc186c 18
  fltToString                                code  fffc14a9 18
  fltToString.0001                           code  fffc150a 18
  fltToString.0002                           code  fffc158a 18
  fltToString.0003                           code  fffc1576 18
  fltToString.0004                           code  fffc15d6 18
  fltToString.0005                           code  fffc15ce 18
  fltToString.0006                           code  fffc15b6 18
  fltToString.0007                           code  fffc15f2 18
  fltToString.0008                           code  fffc1606 18
  fltToString.0009                           code  fffc1602 18
  fltToString.0010                           code  fffc1626 18
  fltToString.0011                           code  fffc16b2 18
  fltToString.0012                           code  fffc166a 18
  fltToString.0013                           code  fffc1656 18
  fltToString.0014                           code  fffc1686 18
  fltToString.0015                           code  fffc16a2 18
  fltToString.0016                           code  fffc163e 18
  fltToString.0017                           code  fffc16aa 18
  fltToString.0018                           code  fffc16b2 18
  fltToString.0019                           code  fffc16e6 18
  fltToString.0020                           code  fffc16f2 18
  fltToString.0021                           code  fffc1716 18
  fltToString.0022                           code  fffc1722 18
  fltToString.0023                           code  fffc1732 18
  fltToString.0024                           code  fffc173e 18
  fltToString.0025                           code  fffc172a 18
  fltToString.0026                           code  fffc1752 18
  fltToString.0027                           code  fffc175a 18
  fltToString.0028                           code  fffc1762 18
  fltToString.0029                           code  fffc176e 18
  fltToString.0030                           code  fffc177a 18
  fltToString.0031                           code  fffc1786 18
  fltToString.0032                           code  fffc178e 18
  fltToString.0034                           code  fffc1796 18
  fltToString.0035                           code  fffc17a2 18
  fltToString.0036                           code  fffc17b2 18
  fltToString.0037                           code  fffc17be 18
  fltToString.0038                           code  fffc17c6 18
  fltToString.0039                           code  fffc17da 18
  fltToString.0040                           code  fffc17ce 18
  fltToString.0041                           code  fffc1836 18
  fltToString.0042                           code  fffc17fa 18
  fltToString.0043                           code  fffc180a 18
  fltToString.0044                           code  fffc181e 18
  fltToString.0045                           code  fffc1802 18
  fltToString.0046                           code  fffc182a 18
  fltToString.0047                           code  fffc1836 18
  fltToString.0048                           code  fffc1822 18
  fltToString.0050                           code  fffc1856 18
  fltToString.0051                           code  fffc1852 18
  fltToString.0052                           code  fffc1842 18
  fltToString.inf                            code  fffc14f2 18
  fltToString.notZero                        code  fffc1546 18
  fltToString.pos                            code  fffc1532 18
  fltToString.prt                            code  fffc17ea 18
  fputc                                      code  fffc0510 18
  fputc.0001                                 code  fffc0550 18
  fputc.checkOwner                           code  fffc0548 18
  fputc.noBypass                             code  fffc0530 18
  fputc.notOwner                             code  fffc0570 18
  fputc.xit                                  code  fffc0554 18
  fv1                                        code  fffc6710 18
  fv2                                        code  fffc6724 18
  fv3                                        code  fffc6708 18
  fv4                                        code  fffc66d8 18
  gcIncrement                                code  fffc5394 18
  gen_rand                                   code  8000000000000535 32
  getVarName                                 code  fffc661c 18
  gfn1                                       code  fffc5ec0 18
  gfn2                                       code  fffc5e70 18
  gfn3                                       code  fffc5ea0 18
  gosub1                                     code  fffc5af0 18
  gvn1                                       code  fffc66b4 18
  gvn2                                       code  fffc6678 18
  gvn3                                       code  fffc6694 18
  gvn4                                       code  fffc663c 18
  gvn6                                       code  fffc6668 18
  isAlnum                                    code  fffc6258 18
  isAlpha                                    code  fffc6228 18
  isAlphaFalse                               code  fffc6250 18
  isAlphaTrue                                code  fffc6248 18
  isDigit                                    code  fffc6208 18
  isDigitFalse                               code  fffc6220 18
  isDigitx                                   code  fffc626c 18
  mbxs                                      const  ff000800 33
  mbxs_end                                  const  ff000c00 33
  milliseconds                              const  ff000208 33
  missed_ticks                              const  ff000320 33
  msgACBPtrs                                 code  fffc45e0 18
  msgBadGotoGosub                            code  fffc736d 18
  msgBytesFree                               code  fffc72a5 18
  msgCRLF                                    code  fffc1476 18
  msgComma                                   code  fffc72ba 18
  msgDivZero                                 code  fffc727c 18
  msgEnvFail                                 code  fffc73d5 18
  msgExtraChars                              code  fffc73b3 18
  msgFinalizerRunning                        code  fffc537c 18
  msgIdleAnnounce                            code  fffc0490 18
  msgInf                                     code  fffc1860 18
  msgInit                                    code  fffc7204 18
  msgInputVar                                code  fffc731c 18
  msgLineRange                               code  fffc72cd 18
  msgMonHelp                                 code  fffc1366 18
  msgNan                                     code  fffc1864 18
  msgNextFor                                 code  fffc7338 18
  msgNextVar                                 code  fffc734a 18
  msgNumTooBig                               code  fffc7269 18
  msgPC                                      code  fffc0a00 18
  msgParen                                   code  fffc73ef 18
  msgRNDBad                                  code  fffc72f8 18
  msgRamTest                                 code  fffc1224 18
  msgReadError                               code  fffc724f 18
  msgReady                                   code  fffc72b2 18
  msgReadyQueue                              code  fffc4c98 18
  msgReadyQueueCorrupt                       code  fffc30d4 18
  msgRegName                                 code  fffc0980 18
  msgRetWoGosub                              code  fffc7389 18
  msgSYSBad                                  code  fffc730b 18
  msgStart                                   code  fffc1350 18
  msgTOLCorrupt                              code  fffc49c4 18
  msgTaskInfo                                code  fffc4cc2 18
  msgTaskStart                               code  fffc1468 18
  msgTimeoutList                             code  fffc4cf4 18
  msgTooBig                                  code  fffc739f 18
  msgVar                                     code  fffc72e2 18
  msgVarSpace                                code  fffc728e 18
  msgWhat                                    code  fffc7240 18
  nmeSerial                                  code  fffc281c 18
  prCRLF                                     code  fffc6cc8 18
  pword1                                     code  fffc6034 18
  pword2                                     code  fffc6050 18
  qToChk                                     code  fffc2b00 18
  ramtest                                    code  fffc0150 18
  ramtest.0001                               code  fffc016c 18
  ramtest.0002                               code  fffc019c 18
  ramtest.0003                               code  fffc01b4 18
  ramtest.0004                               code  fffc01d0 18
  return1                                    code  fffc5b2c 18
  rnd1                                       code  fffc67f4 18
  rnd2                                       code  fffc6804 18
  switchflag                                const  ff000200 33
  sysx1                                      code  fffc6130 18
  tah1                                       code  fffc6084 18
  toAsciiHex                                 code  fffc6074 18
  toUpper                                    code  fffc6f78 18
  tstv_notfound                              code  fffc6608 18
  usrJmp                                    const  0007a8 12

Undefined Symbols
  AUXIN                                      code  8000000000000429 32
  AUXIN_INIT                                 code  80000000000004e6 32
  AUXOUT                                     code  8000000000000427 32
  AUXOUT_FLUSH                               code  80000000000004f3 32
  AUXOUT_INIT                                code  80000000000004ea 32
  DumpTraceQueue.0001                        code  800000000000022e 32
  FMTK_PostMsg                               code  8000000000000319 32
  FreeTID                                    code  800000000000033c 32
  IOF_NEXT                                   code  8000000000000371 32
  IOF_PREV                                   code  8000000000000372 32
  IRQExit.devAgain                           code  800000000000024b 32
  IRQRout.gcIrq                              code  800000000000023e 32
  IRQRout.noIRQ                              code  8000000000000240 32
  IRQRout.softwareIrq                        code  800000000000023c 32
  IRQRout.timerIrq                           code  800000000000023d 32
  MbxFinalizer                               code  800000000000037d 32
  SDReadSector                               code  80000000000004e7 32
  SDWriteSector                              code  80000000000004ec 32
  TBASR                                      code  80000000000001ed 32
  TidTcbMap                                  code  80000000000003f7 32
  _cls                                       code  800000000000046b 32
  _rdcf                                      code  800000000000046d 32
  gen_rand                                   code  8000000000000535 32

  Macro Name
 mDI                                       -842150451

  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts

 mEI                                       -842150451

  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts

 mGetAppMid                                -842150451

  sll   $a0,$a0,#2
  ldt		$a0,ACBPtrs[$a0]
  and		$a0,$a0,#$FFC00
  ldb   $a0,ACBmid[$a0]

 mGetCurrentTid                            -842150451

  csrrw $a0,#CSR_TASKID,$x0

 mHasFocus                                 -842150451

	ldi		$a0,#20
	ecall

 mMbxHandleToPointer                       -842150451

  srl   $t0,$a0,#8    ; extract collection index
  sll   $t0,$t0,#2
  ldt   $t0,MbxBlockPtr[$t0]
  and   $a0,$a0,#$FF
  sll   $a0,$a0,#2
  or    $a0,$a0,$t0

 mMbxHandleToPointer2                      2

    srl   1,0,#8        ; extract collection index
    sll   1,1,#2
    ldt   1,MbxBlockPtr[1]
    and   0,0,#$FF
    sll   0,0,#2
    or    0,0,1

 mSleep                                    1

		ldi				$a0,#5                        ; FMTK Sleep() function
		ldi				$a1,#0
		ecall

 mTimeSliceDI                              -842150451

	ldi		$t0,#$100						; disable timer3 (time slice) interrupts
	stt		$t0,VIA_IER+VIA
	nop                   ; make sure disable has time for effect
	nop

 mTimeSliceEI                              -842150451

	ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
	stt		$t0,VIA_IER+VIA

 mTimeSliceEI2                             1

		ldi				$t0,#$000180|(0<<24)				; enable timer3 interrupts after tm cycles
		stt				$t0,VIA_IER+VIA

 mUnlockSemaphore                          1

		ldi				a0,#-1
		stt				a0,0

 mWaitForFocus                             -842150451

.WFF1@:
  mov   $t2,$a1
	
	ldi		$a0,#20
	ecall
bnez	$a1,.HasFocus@
	ldi   $a0,#26             ; FMTK_IO
	mov   $a1,$t2
	ldi   $a2,#9              ; peekchar function
	ecall
	ldi		$t3,#$14						; CTRL-T
	bne		$a0,$t3,.WFF2@
	; eat up the CTRL-T
	ldi		$a0,#26							; FMTK_IO
	mov   $a1,$t2
	ldi		$a2,#8							; getchar function
	ecall
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
		ldi				$a0,#5                        ; FMTK Sleep() function
		ldi				$a1,#1
		ecall

	bra		.WFF1@
.HasFocus@:

0 compressable instructions
The top 1024 are:
Comp  Opcode  Count

number of bytes: 25752.000000
number of instructions: 6438
number of compressed instructions: 0
4.000000 bytes (32 bits) per instruction
Compression ratio: 0.000000%
Number of long branches: 0
