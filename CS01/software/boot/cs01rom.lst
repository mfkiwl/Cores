                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_UNDEAD   EQU   64
                        	TS_RUNNING	EQU		128
                        	
                        	AS_NONE     EQU   0
                        	AS_LIVE     EQU   1
                        	AS_DEAD     EQU   2
                        	AS_UNDEAD   EQU   4
                        	
                        	PRI_NORMAL  EQU   2
                        	PRI_LOW     EQU   3
                        	
                        	OST_WHITE   EQU   0
                        	OST_GREY    EQU   1
                        	OST_BLACK   EQU   2
                        	OST_UNDEAD  EQU   64    ; no longer alive, but not dead yet (finalizer hasn't been called)
                        	OST_DEAD    EQU   128   ; completely dead, finalizer called already
                        	
                        	TCB_MAGIC     EQU   ((' ' << 24) | ('T' << 16) | ('C' << 8) | 'B')
ACB_MAGIC     EQU   ((' ' << 24) | ('A' << 16) | ('C' << 8) | 'B')
MSG_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('S' << 8) | 'G')
MBX_MAGIC     EQU   ((' ' << 24) | ('M' << 16) | ('B' << 8) | 'X')

                        	UNDEADQ     EQU   7
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_Func  =   0x02
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadDCBOffset = 0x1A
                        	E_Busy = 0x1B
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	E_BadTcbPointer = 0x27
                        	E_BadTid = 0x28
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	= 0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMoreAppIds = 0x46
                        	E_NoMem = 0x47
                        	
                        	CSR_SATP		= $180
                        	CSR_MSTATUS = $300
                        	CSR_MEPC    = $341
                        	CSR_TRACECTRL = $7A0
                        	CSR_REGSET  = $7C0
                        	CSR_MSEMA   = $7C1
                        	CSR_TASKID  = $7C2
                        	CSR_RSSTACK = $7C3
                        	CSR_PMSTACK = $7C4
                        	CSR_IMSTACK = $7C5
                        	TCBPTR_MASK = $FFF803FF
                        	
                        	; Message types
                        	MT_ANNOUNCE = $00000010
                        	MT_IRQ      = $FFFFFFFF
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/types.r5a",1
                        	.file "../fmtk/types.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	OBJMagic    EQU   0
                        	OBJSize     EQU   8
                        	OBJTypenum  EQU   16
                        	OBJID       EQU   20
                        	OBJState    EQU   24    ; WHITE, GREY, BLACK
                        	OBJScavcnt  EQU   25    ; scavange count
                        	OBJOwningMap  EQU   26
                        	OBJPad1       EQU   27
                        	OBJCollectionIndex  EQU   28
                        	OBJUsedInMap  EQU   32    ; used in map
                        	OBJPad3       EQU   36
                        	OBJFWAddr     EQU   40    ; forwarding address
                        	OBJFinalizer  EQU   48
                        	OBJ_SIZE      EQU   64
                        	
                        	; Task Control Block
                        	TCBObject   EQU   $000    ; Object structure, state
                        	TCBIntRegs  EQU   $040    ; integer register set storage area (room for 64-bit)
                        	TCBxRA      EQU   $048
                        	TCBxSP      EQU   $050
                        	TCBxGP      EQU   $058
                        	TCBxTP      EQU   $060
                        	TCBxT0      EQU   $068
                        	TCBxT1      EQU   $070
                        	TCBxT2      EQU   $078
                        	TCBxFP      EQU   $080
                        	TCBxS1      EQU   $088
                        	TCBxA0      EQU   $090
                        	TCBxA1      EQU   $098
                        	TCBxA2      EQU   $0A0
                        	TCBxA3      EQU   $0A8
                        	TCBxA4      EQU   $0B0
                        	TCBxA5      EQU   $0B8
                        	TCBxA6      EQU   $0C0
                        	TCBxA7      EQU   $0C8
                        	TCBxS2      EQU   $0D0
                        	TCBxS3      EQU   $0D8
                        	TCBxS4      EQU   $0E0
                        	TCBxS5      EQU   $0E8
                        	TCBxS6      EQU   $0F0
                        	TCBxS7      EQU   $0F8
                        	TCBxS8      EQU   $100
                        	TCBxS9      EQU   $108
                        	TCBxS10     EQU   $110
                        	TCBxS11     EQU   $118
                        	TCBxT3      EQU   $120
                        	TCBxT4      EQU   $128
                        	TCBxT5      EQU   $130
                        	TCBxT6      EQU   $138
                        	TCBFltRegs  EQU   $140    ; float register set storage area
                        	TCBRegsEnd  EQU   $240
                        	; First 128 bytes are for integer register set
                        	; Second 128 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBbases  	EQU		$240		; base register storage
                        	TCBepc  		EQU		$2C0
                        	TCBStatus		EQU		$2C8
                        	TCBPriority	EQU		$2C9
                        	TCBWaitMbx	EQU		$2CA
                        	TCBRegset   EQU   $2CB
                        	TCBHasFocus EQU   $2CC
                        	TCBStackBot	EQU		$2D0
                        	TCBMsgD1		EQU		$2D8
                        	TCBMsgD2		EQU		$2E0
                        	TCBMsgD3		EQU		$2E8
                        	TCBStartTick	EQU	$2D0
                        	TCBEndTick	EQU		$2D8
                        	TCBTicks		EQU		$300
                        	TCBException	EQU	$308
                        	TCBNext			EQU		$310
                        	TCBPrev			EQU		$318
                        	TCBTimeout	EQU		$320
                        	TCBtid      EQU   $338
                        	TCBmid      EQU   $340
                        	TCBappid    EQU   $342
                        	TCBOpMode   EQU   $344
                        	TCBMbxNext  EQU   $348
                        	TCBMbxPrev  EQU   $350
                        	TCBTaskNum  EQU   $358
                        	TCBName			EQU		$360
                        	
                        	; Application Control Block
                        	ACBObject     EQU   0
                        	ACBpData      EQU   64
                        	ACBDataSize   EQU   72
                        	ACBpUIData    EQU   80
                        	ACBUIDataSize EQU   88
                        	ACBGCRoots    EQU   96
                        	ACBGCRootCnt  EQU   104
                        	ACBGCNdx      EQU   112
                        	ACBGCMarkingQue EQU   120
                        	ACBGCMarkingQueFull   EQU   128
                        	ACBGCMarkingQueEmpty  EQU   129
                        	ACBGCOverflow EQU   130
                        	ACBpCode      EQU   134
                        	ACBObjectList EQU   144
                        	ACBGarbageList  EQU   152
                        	ACBHeap       EQU   160   ; 640+ bytes for heap object info
                        	ACBiofNext    EQU   824
                        	ACBiofPrev    EQU   832
                        	ACBUserName   EQU   840   ; 2 byte index of string in string area
                        	ACBPath       EQU   842   ; 2 byte index of string in string area
                        	ACBExitRunFile  EQU   844 ; 2 byte index of string in string area
                        	ACBCommandLine  EQU   846 ; 2 byte index of string in string area
                        	ACBpVidMem    EQU   848
                        	ACBpVirtVidMem  EQU 856
                        	ACBVideoRows  EQU   864
                        	ACBVideoCols  EQU   865
                        	ACBCursorRow  EQU   866
                        	ACBCursorCol  EQU   867
                        	ACBNormAttr   EQU   868
                        	ACBKeyState1  EQU   872
                        	ACBKeyState2  EQU   874
                        	ACBKeybdWaitFlag  EQU   876
                        	ACBKeybdHead  EQU   878
                        	ACBKeybdTail  EQU   879
                        	ACBKeybdBuffer  EQU   880
                        	ACBnumber     EQU   944
                        	ACBNext       EQU   952
                        	ACBTask       EQU   960
                        	ACBHasFocus   EQU   962
                        	ACBmid        EQU   964
                        	ACBStatus     EQU   966
                        	ACBTemplates  EQU   968   ; 256 * 8 bytes reserved for template pointers
                        	ACBPad        EQU   3016
                        	ACBStrings    EQU   3072  ; start of 1kB string area
                        	ACBEnd        EQU   4096
                        	
                        	; Application startup record
                        	ASRPageSize   EQU   0
                        	ASRPriority   EQU   1
                        	ASRRegset     EQU   2
                        	ASRmid        EQU   3
                        	ASRAffinity   EQU   4
                        	ASRCodeSize   EQU   8
                        	ASRDataSize   EQU   16
                        	ASRUIDataSize EQU   24
                        	ASRHeapSize   EQU   32
                        	ASRStackSize  EQU   40
                        	ASRpCode      EQU   48
                        	ASRpData      EQU   56
                        	ASRpUIData    EQU   64
                        	ASR_SIZE      EQU   72
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	;MBX_WTIDS			equ		4		; tasks waiting at mailbox
                        	MBX_LINK      equ   4
                        	MBX_TQHEAD    equ   4   ; link field for free list shared with task queue head
                        	MBX_TQTAIL    equ   8
                        	MBX_MQHEAD		equ		12		
                        	MBX_MQTAIL		equ		16
                        	MBX_SIZE			equ		20
                        	
                        	MSG_LINK	  equ		0
                        	MSG_RETADR  equ   4
                        	MSG_TGTADR  equ   5
                        	MSG_TYPE    equ   6
                        	MSG_D1		  equ		8
                        	MSG_D2		  equ		12
                        	MSG_D3		  equ		16
                        	MSG_SIZE	  equ		20
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	MAX_TID		EQU		15
                        	NR_TCB		EQU		32
                        	NTASK     EQU   32    ; number of tasks allowed
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		10
                        	LOG_ACBSZ EQU   12
                        	OSPAGES		EQU		16		; pages of memory dedicated to OS
                        	PAGESZ    EQU   1024  ; size of a page of memory
                        	MEMSZ     EQU   512   ; 512 pages
                        	MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_pIRQProc		EQU		0x38		; pointer to IRQ processing routine
                        	DCB_ReentCount		EQU		0x40		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x41
                        	DCB_fUI       EQU   0x42    ; user interface device
                        	DCB_hJob			EQU		0x48		; handle to associated job
                        	DCB_Mbx				EQU		0x50
                        	DCB_pSema			EQU		0x58		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x60		; 96 bytes
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	DVC_IsUI          EQU   27
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Front Panel 		FP
                        	;11
                        	;12		Hard disk				HD1
                        	;13		Hard disk				HD2
                        	;14
                        	;15   Time slice / GP	VIA
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; disable interrupts
                        	macro mDI
  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
endm
                        	
                        	; disable interrupts
                        	macro mEI
  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
endm
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		a0,#-1
	stt		a0,adr
endm
                        	
                        	macro mGetCurrentTid
  csrrw $a0,#CSR_TASKID,$x0
endm
                        	
                        	macro	mHasFocus
	ldi		$a0,#20
	ecall
endm
                        	
                        	macro mSleep(tm)
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#tm
	ecall
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   a1 = device # to check
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
  mov   $t2,$a1
	
	ldi		$a0,#20
	ecall
bnez	$a1,.HasFocus@
	ldi   $a0,#26             ; FMTK_IO
	mov   $a1,$t2
	ldi   $a2,#9              ; peekchar function
	ecall
	ldi		$t3,#$14						; CTRL-T
	bne		$a0,$t3,.WFF2@
	; eat up the CTRL-T
	ldi		$a0,#26							; FMTK_IO
	mov   $a1,$t2
	ldi		$a2,#8							; getchar function
	ecall
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = mailbox handle
                        	; Modifies:
                        	;   $t0
                        	; Returns:
                        	;   $a0 = mailbox pointer
                        	;------------------------------------------------------------------------------
                        	
                        	macro mMbxHandleToPointer
  srl   $t0,$a0,#8    ; extract collection index
  sll   $t0,$t0,#2
  ldt   $t0,MbxBlockPtr[$t0]
  and   $a0,$a0,#$FF
  sll   $a0,$a0,#2
  or    $a0,$a0,$t0
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list pointer to TCB
                        	;------------------------------------------------------------------------------
                        	
                        	;macro mPopTimeoutList
                        	;	lbu		$v1,TCBStatus[$v0]		; no longer a waiting status
                        	;	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
                        	;	beqz	$t1,.noWait@
                        	;	ldbu  $a0,TCBtid[$v0]
                        	;	mMbxRemoveTask							; remove task from mailbox list
                        	.noWait@:
                        	;	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
                        	;	stb		$v1,TCBStatus[$v0]
                        	;	ldt		$v1,TCBNext[$v0]			; get next task on timeout list
                        	;	stt		$v1,TimeoutList				; update list head
                        	;	beqz	$v1,.done@
                        	;	stt		$x0,TCBPrev[$v1]			; TimeoutList->prev = 0
                        	.done@:
                        	;	stt		$x0,TCBNext[$v0]
                        	;	stt		$x0,TCBPrev[$v0]
                        	endm
                        	
                        	macro mGetAppMid
  sll   $a0,$a0,#LOG_PGSZ
  ldb   $a0,ACBmid[$a0]
endm
                        	
                        	; Macros to enable and disable time-slice interrupts
                        	macro mTimeSliceEI
	ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
	stt		$t0,VIA_IER+VIA
endm
                        	
                        	macro mTimeSliceDI
	ldi		$t0,#$100						; disable timer3 (time slice) interrupts
	stt		$t0,VIA_IER+VIA
	nop                   ; make sure disable has time for effect
	nop
endm
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/globals.r5a",1
                        	.file "../fmtk/globals.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	INBUF				equ		$0100
                        	switchflag	equ		$0200
                        	milliseconds	equ		$0208
                        	CurrentTid  equ   $210
                        	TaskNum     equ   $220
                        	
                        	ACBPtrs EQU $0280
                        	APPID_POOL  EQU   $02F0
                        	NPAGES	equ		$0300
                        	QNDX		EQU		$0304
                        	READYQ	EQU		$0308
                        	TID_POOL  EQU		$0310
                        	missed_ticks	equ		$0320
                        	TimeoutList		equ		$0328
                        	Tick		EQU		$0330
                        	SysSema	EQU		$0340
                        	MEPC0   EQU   $0350
                        	MEPC1   EQU   $0358
                        	MEPC2   EQU   $0360
                        	MEPC3   EQU   $0368
                        	CURIN   EQU   $0370
                        	CUROUT  EQU   $0371
                        	CHAINA0 EQU   $0378
                        	CHAINA1 EQU   $0380
                        	CHAINA2 EQU   $0388
                        	CHAINA3 EQU   $0390
                        	CHAINA4 EQU   $0398
                        	CHAINA5 EQU   $03A0
                        	READYQ  EQU   $0400
                        	HEADRDY		EQU		$0400
                        	HEADRDY0	EQU		$0400
                        	HEADRDY1	EQU		$0404
                        	HEADRDY2	EQU		$0408
                        	HEADRDY3	EQU		$040C
                        	HEADRDY4	EQU		$0410
                        	TAILRDY		EQU		$0420
                        	TAILRDY0	EQU		$0420
                        	TAILRDY1	EQU		$0424
                        	TAILRDY2	EQU		$0428
                        	TAILRDY3	EQU		$042C
                        	TAILRDY4	EQU		$0430
                        	RDYQ1		EQU		$0500
                        	RDYQ2		EQU		$0600
                        	RDYQ3		EQU		$0700
                        	mbxs		EQU		$0800
                        	mbxs_end	EQU	$0C00
                        	FreeMsg	EQU		$0C00
                        	FreeMbx EQU   $0C08
                        	IdleTaskMbx EQU   $0C10
                        	IdleTaskMsgD1 EQU   $0C18
                        	IdleTaskMsgD2 EQU   $0C20
                        	IdleTaskMsgD3 EQU   $0C28
                        	IdleTaskId    EQU   $0C2A
                        	PAMPtr  EQU   $0FF8
                        	PAM     EQU   $1000
                        	PAMend  EQU   $1080
                        	IOFocusNdx		EQU		$1080
                        	IOFocusTbl		EQU		$1088
                        	IRQFlag   EQU $1090
                        	IRQCause  EQU $1098
                        	MbxBlockPtr EQU   $10A0
                        	MbxBlockPtrEnd  EQU MbxBlockPtr + MBX_BLOCKPTR_BUFSZ * 4
                        	MbxBlockCounter EQU $10E0
                        	RegsetTid   EQU   $10F0
                        	SerRcvBuf		EQU		$1400
                        	SerXmitBuf	EQU		$1800
                        	SerHeadRcv	EQU		$1C00
                        	SerTailRcv	EQU		$1C04
                        	SerHeadXmit	EQU		$1C08
                        	SerTailXmit	EQU		$1C0C
                        	SerRcvXon		EQU		$1C10
                        	SerRcvXoff	EQU		$1C11
                        	; The following must be at least 128 byte aligned
                        	DVF_Base		EQU		$2000
                        	DVF_Limit		EQU		$3000
                        	DCB_Base    EQU   $3000
                        	DCB_Limit   EQU   $3C00
                        	
                        	SysHeapStart  EQU   $4000
                        	SysHeapEnd    EQU   $20000
                        	
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	
                        	CTRLC				equ		$03
                        	CTRLT       equ   $14
                        	BS					equ		$08
                        	LF					equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	EOF         equ   $1A
                        	DEL					equ		$7F
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_T2CL    equ   $20
                        	VIA_T2CH    equ   $24
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        	
                        	CSR_UIE     equ   $004
                        	
                        	.file "cs01rom.r5a",31
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0000				; user mode exception
FFFC0000 4610006F		jmp		IRQRout
FFFC0004 00000000		org 	$FFFC00C0				; machine mode exception
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 00000000
FFFC0044 00000000
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 00000000
FFFC0084 00000000
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 3A10006F		jmp		IRQRout
FFFC00C4 00000000		org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F		jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; Reset starting address.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0100
                        	MachineStart:
FFFC0100 20080137		ldi		$sp,#$20080000-4		; setup machine mode stack pointer
FFFC0104 FFC10113
FFFC0108 7A00E073		csrrs $x0,#CSR_TRACECTRL,#1 ; turn on tracing
FFFC010C 274010EF		call	MMUInit					; initialize MMU for address space zero.
FFFC0110 158020EF		call	FMTKInit
FFFC0114 7D5010EF		call	ViaSetup
FFFC0118 209010EF		call	SerialInit
FFFC011C 0ED010EF		call	PAMDump
FFFC0120 00506293		ldi   $t0,#5          ; set current input and output to serial port
FFFC0124 36500823		stb   $t0,CURIN
FFFC0128 365008A3		stb   $t0,CUROUT
FFFC012C 00006293		ldi		$t0,#0
FFFC0130 7C129073		csrrw $x0,#CSR_MSEMA,$t0  ; turn off semaphores
FFFC0134 7C229073		csrrw $x0,#CSR_TASKID,$t0 ; clear task id
FFFC0138 FFFC02B7		ldi		$t0,#$FFFC0000
FFFC013C 00028293
FFFC0140 30129073		csrrw $x0,#$301,$t0		; set tvec
FFFC0144 000002B7		ldi   $t0,#$FFFFFC1D  ; run user mode in register set #0
FFFC0148 C1D28293
FFFC014C 7C329073		csrrw $x0,#CSR_RSSTACK,$t0
FFFC0150 FFFC02B7		ldi		$t0,#UserStart
FFFC0154 19828293
FFFC0158 34129073		csrrw	$x0,#$341,$t0		; set mepc
FFFC015C 34502C23		stt   $t0,MEPC1
FFFC0160 00106513	  ldi   $a0,#1          ; start task
FFFC0164 00006593	  ldi   $a1,#0
FFFC0168 00006613	  ldi   $a2,#0
FFFC016C FFFC06B7	  ldi   $a3,#UserStart2
FFFC0170 1A868693
FFFC0174 00006713	  ldi   $a4,#$00
FFFC0178 468020EF	  call  OSOCall
FFFC017C 7C259073	  csrrw $x0,#CSR_TASKID,$a1
FFFC0180 7C501573	  csrrw	$a0,#CSR_IMSTACK,$x0
FFFC0184 F0057513	  and		$a0,$a0,#$FFFFFF00
FFFC0188 7C551073		csrrw	$x0,#CSR_IMSTACK,$a0	; set lowest IRQ level on return
FFFC018C 7C446073	  csrrs $x0,#CSR_PMSTACK,#8 	; enable interrupts on return
FFFC0190 7A007073		csrrc $x0,#CSR_TRACECTRL,#0 ; turn off tracing
FFFC0194 30200073		mret                      	; switch to user mode
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	; First thing to do is start a task so that the startup code may run on the
                        	; first task switch.
                        	;------------------------------------------------------------------------------
                        	UserStart:
FFFC0198 20080137		ldi		$sp,#$2007fff0
FFFC019C FF010113
FFFC01A0 1E5000EF	  call  DumpTraceQueue
FFFC01A4 10100073	  wfi                   ; wait for task switch
                        	UserStart2:
FFFC01A8 00C06513	  ldi   $a0,#12         ; start app
FFFC01AC FFFC15B7	  ldi   $a1,#SystemASR
FFFC01B0 DDC58593
FFFC01B4 00000073	  ecall
                        	.appBad:
FFFC01B8 00051063	  bnez  $a0,.appBad
FFFC01BC 0005E4B3	  mov   $s1,$a1
FFFC01C0 00E06513	  ldi   $a0,#14         ; get current tid
FFFC01C4 00000073	  ecall                 ; $a1 = task id
FFFC01C8 01E06513	  ldi   $a0,#30         ; set task's app id
FFFC01CC 0004E633	  mov   $a2,$s1         ; $a2 = app id
FFFC01D0 00000073	  ecall
                        	
FFFC01D4 0005E4B3	  mov   $s1,$a1         ; s1 = app id
FFFC01D8 20080137		ldi		$sp,#$20080000-4  ; setup user mode stack pointer
FFFC01DC FFC10113
                        	
FFFC01E0 00C06513	  ldi   $a0,#12         ; start app
FFFC01E4 FFFC15B7	  ldi   $a1,#TinyBasicASR
FFFC01E8 E2458593
FFFC01EC 00000073	  ecall
FFFC01F0 00106513		ldi		$a0,#1          ; Start finalizer task, task #1
FFFC01F4 0004E5B3		mov   $a1,$s1
FFFC01F8 00006613		ldi		$a2,#0
FFFC01FC FFFC46B7		ldi		$a3,#Finalizer
FFFC0200 B9068693
FFFC0204 00B06713		ldi   $a4,#$0B        ; user mode, regset 11
FFFC0208 00000073		ecall
FFFC020C 00106513		ldi		$a0,#1          ; Start task for monitor, task #2
FFFC0210 0004E5B3		mov   $a1,$s1
FFFC0214 00006613		ldi		$a2,#0
FFFC0218 FFFC06B7		ldi		$a3,#MonEntry
FFFC021C 4C868693
FFFC0220 00A06713		ldi   $a4,#$0A        ; user mode, regset 10
FFFC0224 00000073		ecall
FFFC0228 01906513	  ldi   $a0,#25         ; map OS vars
FFFC022C 00000073	  ecall
FFFC0230 0005E1B3	  mov   $gp,$a1
                        	
                        	UserStart3:
FFFC0234 20080137		ldi		$sp,#$20080000-4  ; setup user mode stack pointer
FFFC0238 FFC10113
FFFC023C 01806513		ldi		$a0,#24							; RequestIOFocus
FFFC0240 0004E5B3		mov   $a1,$s1
FFFC0244 00000073		ecall
                        	;	ldi		$sp,#$70000		      ; setup temporary user mode stack pointer
                        	;	mov   $a0,$a1             ; $a0 = tid
                        	;	call  AllocStack
                        	;	add   $sp,$v1,#1020       ; place stack pointer at top of allocated region
FFFC0248 00806293		ldi		$t0,#$08						; turn on the LED
FFFC024C FFDC08B7		stt		$t0,VIA+VIA_PARAW
FFFC0250 63C88893
FFFC0254 000888B3
FFFC0258 0058A023
FFFC025C 01006393		ldi		$t2,#16							; send an XON just in case
FFFC0260 01106693		ldi		$a3,#XON
                        	.0004:
FFFC0264 12C000EF		call	Putch ;SerialPutChar
FFFC0268 FFF38393		sub		$t2,$t2,#1
FFFC026C FE039CE3		bnez	$t2,.0004
                        	.0002:
                        	;  ldi   $a0,#25             ; Map OS vars
                        	;  ecall
                        	;  mov   $gp,$a1
                        	  ; Request that the idle task announce itself.
                        	;  ldi   $a0,#9              ; SendMsg
                        	;  ldwu  $a1,IdleTaskMbx[$gp]
                        	;  beqz  $a1,.noMbx
                        	;  ldi   $a2,#MT_ANNOUNCE
                        	;  ldi   $a3,#0
                        	;  ldi   $a4,#0
                        	;  ecall
                        	.noMbx:
FFFC0270 FFFC1537		ldi		$a0,#msgStart				; spit out a startup message
FFFC0274 E6C50513
FFFC0278 0D9000EF		call	PutString
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		ecall
FFFC027C 24C030EF		call	DumpReadyQueue
FFFC0280 2480006F		jmp		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#9							; peekchar function
                        	;	ecall
                        	;	mov   $v0,$v1
                        	;	bltz	$v1,.0003
                        	;	ldi		$a0,#26							; FMTK_IO
                        	;	ldi   $a1,#5
                        	;	ldi		$a2,#8							; getchar function
                        	;	ecall
                        	;	mov		$a3,$v1
                        	;	mov   $a0,$a3
                        	;	call  PutHexByte
                        	;	bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	; This task runs only if nothing else can run. It must run at the machine
                        	; operating mode.
                        	; Search for ready tasks and add them back into the ready queue.
                        	;------------------------------------------------------------------------------
FFFC0284 00000000	  align 1
FFFC0288 00000000
FFFC028C 00000000
                        	
                        	IdleTask:
FFFC0290 00606513	  ldi   $a0,#6                ; alloc mailbox
FFFC0294 00006593	  ldi   $a1,#0                ; app #0
FFFC0298 00000073	  ecall
FFFC029C 000018B7	  stw   $a1,IdleTaskMbx[$gp]  ; save mailbox handle off
FFFC02A0 C1088893
FFFC02A4 003888B3
FFFC02A8 00B89023
                        	.loop2:
FFFC02AC 000042B7	  ldi   $t0,#$4000
FFFC02B0 00028293
FFFC02B4 00106313	  ldi   $t1,#1
                        	.loop:
FFFC02B8 00B06513	  ldi   $a0,#11               ; PeekMsg
FFFC02BC 000018B7	  ldwu  $a1,IdleTaskMbx[$gp]
FFFC02C0 C1088893
FFFC02C4 003888B3
FFFC02C8 0008D583
FFFC02CC 00001637	  ldi   $a2,#IdleTaskMsgD1
FFFC02D0 C1860613
FFFC02D4 000016B7	  ldi   $a3,#IdleTaskMsgD2
FFFC02D8 C2068693
FFFC02DC 00001737	  ldi   $a4,#IdleTaskMsgD3
FFFC02E0 C2870713
FFFC02E4 00106793	  ldi   $a5,#1                ; remove from queue if present
                        	;  ecall
                        	;  bnez  $a0,.noMsg
                        	;  ldt   $a0,IdleTaskMsgD1
                        	;  xor   $t1,$a0,#MT_ANNOUNCE
                        	;  bnez  $t1,.noAnnounce
                        	;  ldi   $a0,#msgIdleAnnounce
                        	;  call  PutString
                        	.noAnnounce:
                        	.noMsg:
FFFC02E8 01106513	  ldi   $a0,#17               ; run as OS
FFFC02EC FFFC05B7	  ldi   $a1,#.IdleCode
FFFC02F0 31058593
FFFC02F4 0002E633	  mov   $a2,$t0
FFFC02F8 00000073	  ecall
FFFC02FC 40028293	  add   $t0,$t0,#PAGESZ
FFFC0300 000808B7	  slt   $t2,$t0,#MEMSZ*1024
FFFC0304 00088893
FFFC0308 FA0398E3	  bnez  $t2,.loop
FFFC030C FA0000E3		bra		.loop2
                        	  ; This section of code runs as part of the OS
                        	  ; Don't call any functions though as there's no stack available
                        	.IdleCode:
FFFC0310 00062283	  ldt   $t0,OBJMagic[$a2]
FFFC0314 20544E37	  ldi   $t3,#TCB_MAGIC
FFFC0318 342E0E13
FFFC031C E9C293E3	  bne   $t0,$t3,.nxtObj
FFFC0320 2C83CE03	  ldbu  $t3,TCBStatus[$t2]    ; get status
FFFC0324 001E7E13	  and   $t3,$t3,#TS_READY
FFFC0328 E60E0DE3	  beqz  $t3,.nxtObj
                        	  ; The task was ready, but not found in the ready queue. So add it
FFFC032C 00A65513	  srl   $a0,$a2,#LOG_PGSZ
                        	  
FFFC0330 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
                        	mInsertIntoReadyQueue
                        	  
FFFC0334 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
                        	.nxtObj:
FFFC0338 00006513	  ldi   $a0,#E_Ok
FFFC033C 3640206F	  jmp   OSExit
                        	
                        	msgIdleAnnounce:
FFFC0340 656C6449	  db  "Idle task running.",CR,0
FFFC0344 73617420
FFFC0348 7572206B
FFFC034C 6E696E6E
FFFC0350 000D2E67
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		$a0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
FFFC0354 00000000	  align 1
FFFC0358 00000000
FFFC035C 00000000
                        	
                        	Getch:
FFFC0360 FF410113		sub		$sp,$sp,#12
FFFC0364 00112023		stt		$ra,[$sp]
FFFC0368 00B12423		stt		$a1,8[$sp]
FFFC036C 00506593		ldi   $a1,#5  ;CURIN
FFFC0370 0E0000EF		call  fgetc
FFFC0374 00012083		ldt		$ra,[$sp]
FFFC0378 00812583		ldt		$a1,8[$sp]
FFFC037C 00C10113		add		$sp,$sp,#12
FFFC0380 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a0 = character to put
                        	;------------------------------------------------------------------------------
FFFC0384 00000000	  align 1
FFFC0388 00000000
FFFC038C 00000000
                        	
                        	Putch:
FFFC0390 FE810113		sub		$sp,$sp,#24
FFFC0394 00112023		stt		$ra,[$sp]
FFFC0398 00D12423		stt		$a3,8[$sp]
FFFC039C 00B12823		stt		$a1,16[$sp]
FFFC03A0 000566B3		mov		$a3,$a0
FFFC03A4 00506593		ldi		$a1,#5  ;CUROUT    ; serial port
FFFC03A8 018000EF		call	fputc
FFFC03AC 00012083		ldt		$ra,[$sp]
FFFC03B0 00812683		ldt		$a3,8[$sp]
FFFC03B4 01012583		ldt		$a1,16[$sp]
FFFC03B8 01810113		add		$sp,$sp,#24
FFFC03BC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   EOF if error occurred, otherwise character to put
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	fputc:
FFFC03C0 FE810113		sub		$sp,$sp,#24
FFFC03C4 00112023		stt		$ra,[$sp]
FFFC03C8 00A12423		stt		$a0,8[$sp]
FFFC03CC 00B12823		stt		$a1,16[$sp]
FFFC03D0 00C12A23		stt		$a2,20[$sp]
FFFC03D4 04284813		xor   $a6,$a6,#'B'
FFFC03D8 00081663		bnez  $a6,.noBypass
FFFC03DC 275010EF		call  SerialPutChar
FFFC03E0 0480006F		jmp   .xit
                        	.noBypass:
                        		; If the device is a UI device there may be multiple owning jobs. It doesn't
                        		; do any good to check for ownership. Instead the I/O focus is checked to
                        		; see if it's present.
FFFC03E4 02000863		bra		.0001
FFFC03E8 5D4030EF		call  GetUIFlag
FFFC03EC 000048B7		stt		$a1,$4024
FFFC03F0 02488893
FFFC03F4 000888B3
FFFC03F8 00B8A023
FFFC03FC 00058863		beqz  $a1,.checkOwner
FFFC0400 01012583	  ldt   $a1,16[$sp]
FFFC0404 540030EF		call  WaitForIOFocus
FFFC0408 00000663		bra   .0001
                        	.checkOwner:
FFFC040C 720030EF	  call  CheckDevOwner
FFFC0410 02051863	  bnez  $a0,.notOwner
                        	.0001:
FFFC0414 01012583	  ldt   $a1,16[$sp]
FFFC0418 01A06513		ldi		$a0,#26							; FMTK_IO
FFFC041C 00D06613		ldi		$a2,#13							; putchar function
FFFC0420 00000073		ecall
FFFC0424 0006E533		mov   $a0,$a3
                        	.xit:
FFFC0428 00012083		ldt		$ra,[$sp]
FFFC042C 00812503		ldt		$a0,8[$sp]
FFFC0430 01012583		ldt		$a1,16[$sp]
FFFC0434 01412603		ldt		$a2,20[$sp]
FFFC0438 01810113		add		$sp,$sp,#24
FFFC043C 00008067		ret
                        	.notOwner:
FFFC0440 01A06513	  ldi   $a0,#EOF
FFFC0444 FE0002E3	  bra   .xit
                        	 
                        	;------------------------------------------------------------------------------
                        	; fgetc - get a character from an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device getchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		a0 character, -1 if none available
                        	;------------------------------------------------------------------------------
FFFC0448 00000000	  align 1
FFFC044C 00000000
                        	
                        	fgetc:
FFFC0450 FE810113		sub		$sp,$sp,#24
FFFC0454 00112023		stt		$ra,[$sp]
FFFC0458 00A12423		stt		$a0,8[$sp]
FFFC045C 00B12823		stt		$a1,16[$sp]
FFFC0460 00C12A23		stt		$a2,20[$sp]
FFFC0464 558030EF		call  GetUIFlag
FFFC0468 000048B7		stt		$a1,$4024
FFFC046C 02488893
FFFC0470 000888B3
FFFC0474 00B8A023
FFFC0478 00058863		beqz  $a1,.checkOwner
FFFC047C 01012583		ldt		$a1,16[$sp]
FFFC0480 4C4030EF		call  WaitForIOFocus
FFFC0484 00000863		bra   .0001
                        	.checkOwner:
FFFC0488 01012583		ldt		$a1,16[$sp]
FFFC048C 6A0030EF	  call  CheckDevOwner
FFFC0490 02051863	  bnez  $a0,.notOwner
                        	.0001:
FFFC0494 01A06513		ldi		$a0,#26							; FMTK_IO
FFFC0498 01012583		ldt		$a1,16[$sp]
FFFC049C 00806613		ldi		$a2,#8							; getchar function
FFFC04A0 00000073		ecall
FFFC04A4 0005E533		mov   $a0,$a1
                        	.0002:
FFFC04A8 00012083		ldt		$ra,[$sp]
FFFC04AC 00812503		ldt		$a0,8[$sp]
FFFC04B0 01012583		ldt		$a1,16[$sp]
FFFC04B4 01412603		ldt		$a2,20[$sp]
FFFC04B8 01810113		add		$sp,$sp,#24
FFFC04BC 00008067		ret
                        	.notOwner:
FFFC04C0 FFF06513	  ldi   $a0,#-1
FFFC04C4 FE0002E3	  bra   .0002
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC04C8 00A06513			ldi		$a0,#10
FFFC04CC 00606613			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	Monitor:
                        	.getFocus:
                        	;	ldi   $a0,#20       ; has IO focus
                        	;	ecall
                        	;	bnez  $v1,.hasFocus
                        	;	ldi   $a0,#21       ; switch focus
                        	;	ecall
                        	;	bra   .getFocus
                        	.hasFocus:
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFC04D0 00006493		ldi		$s1,#0					; s1 = input pointer
FFFC04D4 00D06513		ldi		$a0,#CR
FFFC04D8 EB9FF0EF		call	Putch
FFFC04DC 00006513		ldi		$a0,#LF
	call	Putch
FFFC04E0 EB1FF0EF
FFFC04E4 03E06513		ldi		$a0,#'>'
FFFC04E8 EA9FF0EF		call	Putch
                        	.0001:
FFFC04EC E75FF0EF		call	Getch						; wait until character pressed
FFFC04F0 FE054EE3		bltz	$a0,.0001
FFFC04F4 00054293		xor		$t0,$a0,#LF			; ignore line feed
	beqz	$t0,.procLine
FFFC04F8 08028263
FFFC04FC 00D54293		xor		$t0,$a0,#CR
FFFC0500 06028E63		beqz	$t0,.procLine
FFFC0504 00854293		xor		$t0,$a0,#BS
FFFC0508 04028263		beqz	$t0,.doBackspace
FFFC050C 07F54293		xor		$t0,$a0,#DEL
FFFC0510 00028A63		beqz	$t0,.doDelete
FFFC0514 10A48023		stb		$a0,INBUF[$s1]
FFFC0518 00148493		add		$s1,$s1,#1
FFFC051C E75FF0EF		call	Putch
FFFC0520 FC0006E3		bra		.0001
                        	.doDelete:
FFFC0524 0004E933		mov		$s2,$s1
FFFC0528 00190913		add		$s2,$s2,#1
                        	.0002:
FFFC052C 10090283		ldb		$t0,INBUF[$s2]
FFFC0530 0E590FA3		stb		$t0,INBUF-1[$s2]
FFFC0534 00190913		add		$s2,$s2,#1
FFFC0538 10090293		add		$t0,$s2,#INBUF
FFFC053C 17F2A293		slt		$t0,$t0,#INBUF+$7F
FFFC0540 FE0296E3		bne		$t0,$x0,.0002
FFFC0544 10090023		stb		$x0,INBUF[$s2]
FFFC0548 FA0002E3		bra		.0001
                        	.doBackspace:
FFFC054C FA0480E3		beq		$s1,$x0,.0001		; can't backspace anymore
FFFC0550 E41FF0EF		call	Putch           ; show the backspace
FFFC0554 FFF48493		sub		$s1,$s1,#1
FFFC0558 0004E933		mov		$s2,$s1
                        	.0003:
FFFC055C 10190283		ldb		$t0,INBUF+1[$s2]
FFFC0560 10590023		stb		$t0,INBUF[$s2]
FFFC0564 00190913		add		$s2,$s2,#1
FFFC0568 10090293		add		$t0,$s2,#INBUF
FFFC056C 17F2A293		slt		$t0,$t0,#INBUF+$7F
FFFC0570 FE0296E3		bne		$t0,$x0,.0003
FFFC0574 10090023		stb		$x0,INBUF[$s2]
FFFC0578 F6000AE3		bra		.0001
                        	.procLine:
FFFC057C 10048023		stb		$x0,INBUF[$s1]
FFFC0580 00006493		ldi		$s1,#0
                        	.skip:
FFFC0584 10048283		ldb		$t0,INBUF[$s1]
FFFC0588 14028E63		beq		$t0,$x0,.0005
FFFC058C 03E2C313		xor		$t1,$t0,#'>'
FFFC0590 00031663		bne		$t1,$x0,.0004
                        	.skip2:
FFFC0594 00148493		add		$s1,$s1,#1
FFFC0598 FE0006E3		bra		.skip
                        	.0004:
FFFC059C 0202C313		xor		$t1,$t0,#' '
FFFC05A0 FE030AE3		beq		$t1,$x0,.skip2
FFFC05A4 0092C313		xor		$t1,$t0,#'\t'
FFFC05A8 FE0306E3		beq		$t1,$x0,.skip2
FFFC05AC 0582C313		xor   $t1,$t0,#'X'  ; exit from monitor
FFFC05B0 00031663		bnez  $t1,.notX
FFFC05B4 00006513		ldi   $a0,#E_Ok
FFFC05B8 0E80206F		jmp   OSExit
                        	.notX:
FFFC05BC 04D2C313		xor		$t1,$t0,#'M'
FFFC05C0 12030863		beqz	$t1,doMem
FFFC05C4 0562C313		xor   $t1,$t0,#'V'
FFFC05C8 22030C63		beqz  $t1,doVMem
FFFC05CC 0502C313		xor   $t1,$t0,#'P'
FFFC05D0 28030863		beqz  $t1,doPStat
FFFC05D4 04206313		ldi		$t1,#'B'
FFFC05D8 06629863		bne		$t0,$t1,.0006
FFFC05DC 474000EF		call  GetDecNum
FFFC05E0 00051663		bnez  $a0,.basSize
FFFC05E4 00008537		ldi   $a0,#32000
FFFC05E8 D0050513
                        	.basSize:
FFFC05EC 00C06513		ldi		$a0,#12					; Start App
FFFC05F0 000005B7		ldi   $a1,#TBASR
FFFC05F4 1CB58593
FFFC05F8 00000073		ecall
FFFC05FC 0005E4B3		mov		$s1,$a1					; save v1
FFFC0600 FFFC1537		ldi		$a0,#msgCRLF
FFFC0604 F8250513
FFFC0608 548000EF		call	PutString
FFFC060C 0004E533		mov		$a0,$s1					; get back v1
FFFC0610 4D0000EF		call	PutHexByte
FFFC0614 FFFC1537		ldi		$a0,#msgTaskStart
FFFC0618 F7450513
FFFC061C 534000EF		call	PutString
FFFC0620 6A9020EF		call  DumpReadyQueue
                        		; The monitor is running in machine mode. A return instruction is used to
                        		; switch to user mode. The return address must be set to the desired user
                        		; code address.
                        		
FFFC0624 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
                        	; disable interrupts
FFFC0628 FFFC42B7		ldi   $t0,#CSTART       ; pick start of Tiny Basic
FFFC062C D3028293
FFFC0630 34129073		csrrw $x0,#$341,$t0     ; set as return address
FFFC0634 000112B7		ldi   $t0,#$00011111    ; bits to select register set #1
FFFC0638 11128293
FFFC063C 7C029073		csrrw $x0,#CSR_REGSET,$t0     ; select register set #1 (will decrement to zero then on mret)
FFFC0640 30200073		mret                    ; will begin running Tiny Basic in user mode
                        		;ldi		$a0,#5					; Reschedule task
                        		;ldi		$a1,#1					; sleep(0)
                        		;ecall
FFFC0644 E8DFF06F		jmp		Monitor
                        	.0006:
FFFC0648 04406313		ldi		$t1,#'D'
FFFC064C 02629063		bne		$t0,$t1,.0007
FFFC0650 10148283		lb		$t0,INBUF+1[$s1]
FFFC0654 05406313		ldi		$t1,#'T'
FFFC0658 00629663		bne		$t0,$t1,.noT
FFFC065C 054030EF		call	DumpTimeoutList
FFFC0660 E71FF06F		jmp		Monitor
                        	.noT:
FFFC0664 665020EF		call 	DumpReadyQueue
                        		;ldi		$a0,#15
                        		;ecall
FFFC0668 E69FF06F		jmp		Monitor
                        	.0007:
FFFC066C 04506313		ldi		$t1,#'E'
FFFC0670 00629463		bne		$t0,$t1,.0008
FFFC0674 16C0006F		jmp		EditMem
                        	.0008:
FFFC0678 04606313		ldi		$t1,#'F'
FFFC067C 00629E63		bne		$t0,$t1,.0009
FFFC0680 10148283		ldb   $t0,INBUF+1[$s1]
FFFC0684 04906313		ldi   $t1,#'I'
FFFC0688 00531663		bne   $t1,$t0,.notFind
FFFC068C 00148493		add   $s1,$s1,#1
FFFC0690 2400006F		jmp   Find
                        	.notFind:
FFFC0694 20C0006F		jmp		FillMem
                        	.0009:
FFFC0698 05306313		ldi		$t1,#'S'
FFFC069C 00629A63		bne		$t0,$t1,.0010
FFFC06A0 00506513		ldi		$a0,#5					; sleep(0)
FFFC06A4 00106593		ldi		$a1,#1
FFFC06A8 00000073		ecall
FFFC06AC E25FF06F		jmp		Monitor
                        	.0010:
FFFC06B0 04B06313		ldi		$t1,#'K'
FFFC06B4 00629C63		bne		$t0,$t1,.0011
FFFC06B8 2F8000EF		call	GetHexNum
FFFC06BC 000565B3		mov		$a1,$a0					; a0 = pid
FFFC06C0 00306513		ldi		$a0,#3					; kill task
FFFC06C4 00000073		ecall
FFFC06C8 E09FF06F		jmp		Monitor
                        	.0011:
FFFC06CC 03F06313		ldi		$t1,#'?'
FFFC06D0 00629A63		bne		$t0,$t1,.0012
FFFC06D4 FFFC1537		ldi		$a0,#msgMonHelp
FFFC06D8 E8250513
FFFC06DC 474000EF		call	PutString
FFFC06E0 DF1FF06F		jmp		Monitor
                        	.0012:
                        	.0005:
FFFC06E4 DEDFF06F		jmp		Monitor
                        	
FFFC06E8 00000000	  align 1
FFFC06EC 00000000
                        	
                        	doMem:
FFFC06F0 FFC1310D		gcsub	$sp,$sp,#4
FFFC06F4 00148493		add		$s1,$s1,#1
FFFC06F8 10048283		ldb		$t0,INBUF[$s1]
FFFC06FC 04F2C293		xor   $t0,$t0,#'O'
FFFC0700 00029463		bnez  $t0,.0001
FFFC0704 00148493		add		$s1,$s1,#1
                        	.0001:
FFFC0708 00912023		stt		$s1,[$sp]
FFFC070C 00D06513		ldi		$a0,#CR
FFFC0710 C81FF0EF		call	Putch
FFFC0714 10006513		ldi		$a0,#INBUF
FFFC0718 438000EF		call	PutString
FFFC071C 00012483		ldt		$s1,[$sp]
FFFC0720 00410113		add		$sp,$sp,#4
FFFC0724 28C000EF		call	GetHexNum
FFFC0728 000569B3		mov		$s3,$a0
FFFC072C 00056AB3		mov   $s5,$a0
FFFC0730 00148493		add		$s1,$s1,#1
FFFC0734 27C000EF		call	GetHexNum
FFFC0738 01350A33		add		$s4,$a0,$s3
                        	.loop2:
FFFC073C C25FF0EF		call	Getch						; check for ctrl-c
FFFC0740 00354513		xor		$a0,$a0,#3
FFFC0744 D80506E3		beq		$a0,$x0,Monitor
FFFC0748 00D06513		ldi		$a0,#CR
FFFC074C C45FF0EF		call	Putch
FFFC0750 0009E533		mov		$a0,$s3
FFFC0754 34C000EF		call	PutHexWord
FFFC0758 03A06513		ldi		$a0,#':'
FFFC075C C35FF0EF		call	Putch
FFFC0760 00706913		ldi		$s2,#7
                        	.loop:
FFFC0764 02006513		ldi		$a0,#' '
FFFC0768 C29FF0EF		call	Putch
FFFC076C 00029C63		bnez  $t0,.userMem
FFFC0770 02106513		ldi   $a0,#33         ; Fetch memory word
FFFC0774 0009E5B3		mov   $a1,$s3
FFFC0778 00000073		ecall
FFFC077C 0005E533		mov   $a0,$a1
FFFC0780 00000463		bra   .0002
                        	.userMem
FFFC0784 00098503		ldb		$a0,[$s3]
                        	.0002:
FFFC0788 358000EF		call	PutHexByte
FFFC078C 00198993		add		$s3,$s3,#1
FFFC0790 FFF90913		sub		$s2,$s2,#1
FFFC0794 FC0958E3		bge		$s2,$x0,.loop
FFFC0798 FB49E2E3		bltu	$s3,$s4,.loop2
FFFC079C 02006513		ldi		$a0,#' '
FFFC07A0 BF1FF0EF		call	Putch
FFFC07A4 02006513		ldi		$a0,#' '
FFFC07A8 BE9FF0EF		call	Putch
                        	
FFFC07AC 000AE9B3		mov   $s3,$s5
                        	.0004:
FFFC07B0 0009C503		ldbu  $a0,[$s3]
FFFC07B4 02052293		slt   $t0,$a0,#$20
FFFC07B8 00029663		bnez  $t0,.unprintable
FFFC07BC BD5FF0EF		call  Putch
FFFC07C0 00000663		bra   .0003
                        	.unprintable:
FFFC07C4 02E06513	  ldi   $a0,#'.'
FFFC07C8 BC9FF0EF	  call  Putch
                        	.0003:
FFFC07CC 00198993	  add   $s3,$s3,#1
FFFC07D0 FF49E0E3	  bltu  $s3,$s4,.0004
FFFC07D4 00D06513	  ldi   $a0,#CR
FFFC07D8 BB9FF0EF	  call  Putch
FFFC07DC CF5FF06F		jmp		Monitor		
                        	
                        	  align 16                        	
                        	EditMem:
FFFC07E0 0040E073		csrrs $x0,#CSR_UIE,#1        ; enable gc interrupt
FFFC07E4 1CC000EF		call	GetHexNum			; get address to edit
FFFC07E8 000569B3		mov		$s3,$a0
FFFC07EC 00148493		add		$s1,$s1,#1
FFFC07F0 1C0000EF		call	GetHexNum			; get value to set
FFFC07F4 01350023		stb		$s3,[$a0]			; update mem
FFFC07F8 CD9FF06F		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >V 0
                        	; Displays the virtual memory map for the specified app.
                        	;------------------------------------------------------------------------------
                        	
FFFC07FC 00000000	  align 1
                        	
                        	doVMem:
FFFC0800 00148493	  add   $s1,$s1,#1
FFFC0804 24C000EF	  call  GetDecNum
FFFC0808 00006313	  ldi   $t1,#0
FFFC080C 01051293	  sll   $t0,$a0,#16
                        	.0001:
FFFC0810 00337513	  and   $a0,$t1,#3
FFFC0814 00051A63	  bnez  $a0,.notLF
FFFC0818 00D06513	  ldi   $a0,#CR
FFFC081C B75FF0EF	  call  Putch
FFFC0820 00006513	  ldi   $a0,#LF
  call  Putch
FFFC0824 B6DFF0EF
                        	.notLF:
FFFC0828 0002E533	  mov   $a0,$t0
FFFC082C 274000EF	  call  PutHexWord
FFFC0830 03A06513	  ldi   $a0,#':'
FFFC0834 B5DFF0EF	  call  Putch
FFFC0838 0250050D	  mvmap $a0,$x0,$t0
FFFC083C 284000EF	  call  PutHexHalf
FFFC0840 02006513	  ldi   $a0,#' '
FFFC0844 B4DFF0EF	  call  Putch
FFFC0848 00128293	  add   $t0,$t0,#1
FFFC084C 00130313	  add   $t1,$t1,#1
FFFC0850 10032513	  slt   $a0,$t1,#256
FFFC0854 FA051EE3	  bnez  $a0,.0001  
FFFC0858 C79FF06F	  jmp   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; >P
                        	; Display the PAM bits status.
                        	;------------------------------------------------------------------------------
                        	
FFFC085C 00000000	  align 1
                        	
                        	doPStat:
FFFC0860 00D06513	  ldi   $a0,#CR
FFFC0864 B2DFF0EF	  call  Putch
FFFC0868 00006513	  ldi   $a0,#LF
  call  Putch
FFFC086C B25FF0EF
FFFC0870 00006313	  ldi   $t1,#0        ; $a1 = bit number
                        	.0001:
FFFC0874 02006513	  ldi   $a0,#32       ; Get PAM bit pair
FFFC0878 00000073	  ecall
FFFC087C 03058513	  add   $a0,$a1,#'0'
FFFC0880 B11FF0EF	  call  Putch
FFFC0884 00130313	  add   $t1,$t1,#1
FFFC0888 20032513	  slt   $a0,$t1,#MEMSZ
FFFC088C FE0514E3	  bnez  $a0,.0001
FFFC0890 C41FF06F	  jmp   Monitor
                        	 
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
FFFC0894 00000000	  align 1
FFFC0898 00000000
FFFC089C 00000000
                        	
                        	FillMem:
FFFC08A0 110000EF		call	GetHexNum			; get address
FFFC08A4 000569B3		mov		$s3,$a0
FFFC08A8 00148493		add		$s1,$s1,#1
FFFC08AC 104000EF		call	GetHexNum			; get length
FFFC08B0 00056A33		mov		$s4,$a0
FFFC08B4 00148493		add		$s1,$s1,#1
FFFC08B8 0F8000EF		call	GetHexNum			; get byte to use
                        	.0001:
FFFC08BC 00A98023		stb		$a0,[$s3]
FFFC08C0 FFFA0A13		sub		$s4,$s4,#1
FFFC08C4 FF404CE3		bgt		$s4,$x0,.0001
FFFC08C8 C09FF06F		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; FI Hello
                        	;------------------------------------------------------------------------------
                        	
FFFC08CC 00000000	  align 1
                        	
                        	Find:
FFFC08D0 00D06513	  ldi   $a0,#CR
FFFC08D4 ABDFF0EF	  call  Putch
FFFC08D8 00006513	  ldi   $a0,#LF
  call  Putch
FFFC08DC AB5FF0EF
FFFC08E0 0B0000EF	  call  SkipSpaces
FFFC08E4 0004E933	  mov   $s2,$s1
                        	.fwe:
FFFC08E8 10094283	  ldbu  $t0,INBUF[$s2]
FFFC08EC 00028E63	  beqz  $t0,.endOfWord
FFFC08F0 02006313	  ldi   $t1,#' '
FFFC08F4 00628A63	  beq   $t0,$t1,.endOfWord
FFFC08F8 00D06313	  ldi   $t1,#CR
FFFC08FC 00628663	  beq   $t0,$t1,.endOfWord
FFFC0900 00190913	  add   $s2,$s2,#1
FFFC0904 FE0002E3	  bra   .fwe
                        	.endOfWord:
FFFC0908 10090023	  stb   $x0,INBUF[$s2]
FFFC090C 0004E933	  mov   $s2,$s1
FFFC0910 00006513	  ldi   $a0,#0
FFFC0914 00006593	  ldi   $a1,#0
                        	.loop:
FFFC0918 A49FF0EF		call	Getch						; check for ctrl-c
FFFC091C 00354513		xor		$a0,$a0,#3
FFFC0920 00051463		bnez	$a0,.0001
FFFC0924 BADFF06F		jmp   Monitor
                        	.0001:
FFFC0928 00054283	  ldbu  $t0,[$a0]
FFFC092C 10094303	  ldbu  $t1,INBUF[$s2]
FFFC0930 02030A63	  beqz  $t1,.found
FFFC0934 00629863	  bne   $t0,$t1,.next
FFFC0938 00150513	  add   $a0,$a0,#1
FFFC093C 00190913	  add   $s2,$s2,#1
FFFC0940 FC000CE3	  bra   .loop
                        	.next:
FFFC0944 0004E933	  mov   $s2,$s1         ; start over again with $s2
FFFC0948 00158513	  add   $a0,$a1,#1      ; start over again with $a0, but increment by one
FFFC094C 000803B7	  ldi   $t2,#$80000     ; 512k
FFFC0950 00038393
FFFC0954 000565B3	  mov   $a1,$a0         ; remember new starting pos.
FFFC0958 007523B3	  slt   $t2,$a0,$t2
FFFC095C FA039EE3	  bnez  $t2,.loop
FFFC0960 00000E63	  bra   .notFound
                        	.found:
FFFC0964 13C000EF	  call  PutHexWord
FFFC0968 00D06513	  ldi   $a0,#CR
FFFC096C A25FF0EF	  call  Putch
FFFC0970 00006513	  ldi   $a0,#LF
  call  Putch
FFFC0974 A1DFF0EF
FFFC0978 FC0006E3	  bra   .next
                        	.notFound:
FFFC097C 00D06513	  ldi   $a0,#CR
FFFC0980 A11FF0EF	  call  Putch
FFFC0984 00006513	  ldi   $a0,#LF
  call  Putch
FFFC0988 A09FF0EF
FFFC098C B45FF06F	  jmp   Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC0990 10048283		ldb		$t0,INBUF[$s1]
FFFC0994 0202C313		xor		$t1,$t0,#' '
FFFC0998 00030863		beqz	$t1,.skip1
FFFC099C 0092C313		xor		$t1,$t0,#'\t'
FFFC09A0 00030463		beqz	$t1,.skip1
FFFC09A4 00008067		ret
                        	.skip1:
FFFC09A8 00148493		add		$s1,$s1,#1
FFFC09AC FE0002E3		bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	  align 16                        	
                        	GetHexNum:
FFFC09B0 00006513		ldi		$a0,#0							; a0 = num
FFFC09B4 FFC10113		sub		$sp,$sp,#4
FFFC09B8 00112023		stt		$ra,[$sp]
FFFC09BC FD5FF0EF		call	SkipSpaces
                        	.next:
FFFC09C0 10048283		ldb		$t0,INBUF[$s1]
FFFC09C4 03006393		ldi		$t2,#'0'
FFFC09C8 0272C663		blt		$t0,$t2,.0001
FFFC09CC 03A06393		ldi		$t2,#'9'+1
FFFC09D0 0672C063		blt		$t0,$t2,.isDigit
FFFC09D4 04106393		ldi		$t2,#'A'
FFFC09D8 0072CE63		blt		$t0,$t2,.0001
FFFC09DC 04706393		ldi		$t2,#'F'+1
FFFC09E0 0272C063		blt		$t0,$t2,.isHexUpper
FFFC09E4 06106393		ldi		$t2,#'a'
FFFC09E8 0072C663		blt		$t0,$t2,.0001
FFFC09EC 06706393		ldi		$t2,#'f'+1
FFFC09F0 0272C463		blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC09F4 00012083		ldt		$ra,[$sp]
FFFC09F8 00410113		add		$sp,$sp,#4
FFFC09FC 00008067		ret
                        	.isHexUpper:
FFFC0A00 00451513		sll		$a0,$a0,#4
FFFC0A04 FBF28293		sub		$t0,$t0,#'A'
FFFC0A08 00A28293		add		$t0,$t0,#10
FFFC0A0C 00556533		or		$a0,$a0,$t0
FFFC0A10 00148493		add		$s1,$s1,#1
FFFC0A14 FA0006E3		bra		.next
                        	.isHexLower:
FFFC0A18 00451513		sll		$a0,$a0,#4
FFFC0A1C F9F28293		sub		$t0,$t0,#'a'
FFFC0A20 00A28293		add		$t0,$t0,#10
FFFC0A24 00556533		or		$a0,$a0,$t0
FFFC0A28 00148493		add		$s1,$s1,#1
FFFC0A2C F8000AE3		bra		.next
                        	.isDigit:
FFFC0A30 00451513		sll		$a0,$a0,#4
FFFC0A34 FD028293		sub		$t0,$t0,#'0'
FFFC0A38 00556533		or		$a0,$a0,$t0
FFFC0A3C 00148493		add		$s1,$s1,#1
FFFC0A40 F80000E3		bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a decimal number from the input buffer.
                        	;------------------------------------------------------------------------------
FFFC0A44 00000000	  align 1
FFFC0A48 00000000
FFFC0A4C 00000000
                        	
                        	GetDecNum:
FFFC0A50 00006513		ldi		$a0,#0							; a0 = num
FFFC0A54 FFC10113		sub		$sp,$sp,#4
FFFC0A58 00112023		stt		$ra,[$sp]
FFFC0A5C F35FF0EF		call	SkipSpaces
                        	.next:
FFFC0A60 10048283		ldb		$t0,INBUF[$s1]
FFFC0A64 03006393		ldi		$t2,#'0'
FFFC0A68 0072C663		blt		$t0,$t2,.0001
FFFC0A6C 03A06393		ldi		$t2,#'9'+1
FFFC0A70 0072C863		blt		$t0,$t2,.isDigit
                        	.0001:
FFFC0A74 00012083		ldt		$ra,[$sp]
FFFC0A78 00410113		add		$sp,$sp,#4
FFFC0A7C 00008067		ret
                        	.isDigit:
FFFC0A80 00151393		sll		$t2,$a0,#1    ; multiply by 10
FFFC0A84 00351513		sll   $a0,$a0,#3    ; * 8
FFFC0A88 00750533		add   $a0,$a0,$t2   ; + *2
FFFC0A8C FD028293		sub		$t0,$t0,#'0'
FFFC0A90 00550533		add		$a0,$a0,$t0
FFFC0A94 00148493		add		$s1,$s1,#1
FFFC0A98 FC0004E3		bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains word to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
FFFC0A9C 00000000	  align 1
                        	
                        	PutHexWord:
FFFC0AA0 FF810113		sub		$sp,$sp,#8
FFFC0AA4 00112023		stt		$ra,[$sp]
FFFC0AA8 00A12223		stt		$a0,4[$sp]
FFFC0AAC 01055513		srl		$a0,$a0,#16
FFFC0AB0 010000EF		call	PutHexHalf
FFFC0AB4 00012083		ldt		$ra,[$sp]
FFFC0AB8 00412503		ldt		$a0,4[$sp]
FFFC0ABC 00810113		add		$sp,$sp,#8	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexHalf:
FFFC0AC0 FF810113		sub		$sp,$sp,#8
FFFC0AC4 00112023		stt		$ra,[$sp]
FFFC0AC8 00A12223		stt		$a0,4[$sp]
FFFC0ACC 00855513		srl		$a0,$a0,#8
FFFC0AD0 010000EF		call	PutHexByte
FFFC0AD4 00012083		ldt		$ra,[$sp]
FFFC0AD8 00412503		ldt		$a0,4[$sp]		
FFFC0ADC 00810113		add		$sp,$sp,#8	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexByte:
FFFC0AE0 FF810113		sub		$sp,$sp,#8
FFFC0AE4 00112023		stt		$ra,[$sp]
FFFC0AE8 00A12223		stt		$a0,4[$sp]
FFFC0AEC 00455513		srl		$a0,$a0,#4		; put the high order nybble first
FFFC0AF0 010000EF		call	PutHexNybble
FFFC0AF4 00012083		ldt		$ra,[$sp]
FFFC0AF8 00412503		ldt		$a0,4[$sp]
FFFC0AFC 00810113		add		$sp,$sp,#8		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;
                        	; Parameters:
                        	;   a0 = contains nybble to output
                        	; Registers Affected:
                        	;   none
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexNybble:
FFFC0B00 FF410113		sub		$sp,$sp,#12
FFFC0B04 00112023		stt		$ra,[$sp]
FFFC0B08 00A12223		stt		$a0,4[$sp]
FFFC0B0C 00512423		stt   $t0,8[$sp]
FFFC0B10 00F57513		and		$a0,$a0,#15		; strip off high order bits
FFFC0B14 00A06293		ldi		$t0,#10
FFFC0B18 00554A63		blt		$a0,$t0,.lt10
FFFC0B1C FF650513		sub		$a0,$a0,#10
FFFC0B20 04150513		add		$a0,$a0,#'A'
FFFC0B24 86DFF0EF		call	Putch
FFFC0B28 00000663		bra		.0001
                        	.lt10:
FFFC0B2C 03050513		add		$a0,$a0,#'0'
FFFC0B30 861FF0EF		call	Putch
                        	.0001:
FFFC0B34 00012083		ldt		$ra,[$sp]
FFFC0B38 00412503		ldt		$a0,4[$sp]
FFFC0B3C 00812283		ldt   $t0,8[$sp]
FFFC0B40 00C10113		add		$sp,$sp,#12
FFFC0B44 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
FFFC0B48 00000000	  align 1
FFFC0B4C 00000000
                        	
                        	PutString:
FFFC0B50 FF810113		sub		$sp,$sp,#8				; save link register
FFFC0B54 00112023		stt		$ra,[$sp]
FFFC0B58 00A12223		stt		$a0,4[$sp]				; and argument
FFFC0B5C 00056333		mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0B60 00030503		ldb		$a0,[$t1]
FFFC0B64 00130313		add		$t1,$t1,#1				; advance pointer to next byte
FFFC0B68 00050663		beqz	$a0,.done			    ; branch if done
FFFC0B6C 825FF0EF		call	Putch							; output character
FFFC0B70 FE0008E3		bra		.0001
                        	.done:
FFFC0B74 00012083		ldt		$ra,[$sp]					; restore return address
FFFC0B78 00412503		ldt		$a0,4[$sp]				; and argument
FFFC0B7C 00810113		add		$sp,$sp,#8
FFFC0B80 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	DumpTraceQueue:
FFFC0B84 FFC10113		sub		$sp,$sp,#4
FFFC0B88 00112023		stt		$ra,[$sp]
FFFC0B8C 05806813		ldi   $a6,#'X'        ; bypass='B' in fputc routine
                        	.dmpTrace:
FFFC0B90 00D06513		ldi   $a0,#CR
FFFC0B94 FFCFF0EF		call  Putch
FFFC0B98 00E06593		ldi   $a1,#14         ; processor trace queue
FFFC0B9C 1A05850D		popq  $a0,$a1
	bltz  $a0,.dmpTraceEmpty  ; emptied out?
FFFC0BA0 02054063
FFFC0BA4 001008B7		and   $a0,$a0,#$FFFFF
FFFC0BA8 FFF88893
FFFC0BAC 00A8F533
FFFC0BB0 EF1FF0EF		call  PutHexWord
FFFC0BB4 02006513		ldi		$a0,#' '
FFFC0BB8 FD8FF0EF		call	Putch
FFFC0BBC FC000AE3		bra   .dmpTrace
                        	.dmpTraceEmpty:
FFFC0BC0 00D06513		ldi   $a0,#CR
FFFC0BC4 FCCFF0EF		call  Putch
                        	.inf:
                        	;  bra   .inf
FFFC0BC8 00012083		ldt		$ra,[$sp]
FFFC0BCC 00410113		add		$sp,$sp,#4
FFFC0BD0 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;
                        	; On incoming the register file has been set to the interrupt register file
                        	; or the machine mode register file.
                        	;------------------------------------------------------------------------------
FFFC0BD4 00000000	  align 1
FFFC0BD8 00000000
FFFC0BDC 00000000
                        	
                        	; Top of stack for different register sets
                        	StackTbl:
FFFC0BE0 00000000	  dw    $0
FFFC0BE4 00000000	  dw    $0
FFFC0BE8 00000000	  dw    $0
FFFC0BEC 00000000	  dw    $0
FFFC0BF0 00000000	  dw    $0
FFFC0BF4 00000000	  dw    $0
FFFC0BF8 00000000	  dw    $0
FFFC0BFC 00000000	  dw    $0
FFFC0C00 00000000	  dw    $0
FFFC0C04 00000000	  dw    $0
FFFC0C08 00000000	  dw    $0
FFFC0C0C 00000000	  dw    $0
FFFC0C10 00000000	  dw    $0
FFFC0C14 00000000	  dw    $0
FFFC0C18 00000000	  dw    $0
FFFC0C1C 00000000	  dw    $0
FFFC0C20 00000000	  dw    $0
FFFC0C24 00000000	  dw    $0
FFFC0C28 00000000	  dw    $0
FFFC0C2C 00000000	  dw    $0
FFFC0C30 00000000	  dw    $0
FFFC0C34 00000000	  dw    $0
FFFC0C38 00000000	  dw    $0
FFFC0C3C 00000000	  dw    $0
FFFC0C40 00000000	  dw    $0
FFFC0C44 00000000	  dw    $0
FFFC0C48 00000000	  dw    $0
FFFC0C4C 00000000	  dw    $0
FFFC0C50 2007F3FC	  dw    $2007F400-4
FFFC0C54 2007F7FC	  dw    $2007F800-4
FFFC0C58 2007FBFC	  dw    $2007FC00-4
FFFC0C5C 2007FFFC	  dw    $20080000-4
                        	
                        	.file "cs01rom.r5a",1067
                        		code
                        		align	16                        	
                        	IRQRout:
FFFC0C60 342012F3		csrrw	$t0,#$342,$x0			; get cause code
FFFC0C64 0602C063		bltz	$t0,.isIRQ		  ; irq or ecall?
FFFC0C68 0022C393		xor   $t2,$t0,#2      ; illegal instruction?
FFFC0C6C 00038863		beqz  $t2,.illegal
FFFC0C70 FFC2F393		and   $t2,$t0,#$FFFFFFFC
FFFC0C74 0083C393		xor   $t2,$t2,#8
FFFC0C78 02038663		beqz  $t2,.ecall
                        		; Some other cause
                        	.illegal:
FFFC0C7C 000048B7	  stt   $t0,$4018
FFFC0C80 01888893
FFFC0C84 000888B3
FFFC0C88 0058A023
FFFC0C8C 7A00F073		csrrc $x0,#CSR_TRACECTRL,#1 ; turn off tracing
FFFC0C90 FFFC12B7		ldi   $t0,#DumpTraceQueue
FFFC0C94 B8428293
FFFC0C98 34129073		csrrw $x0,#CSR_MEPC,$t0
FFFC0C9C 30200073		mret
                        	.soc:
FFFC0CA0 00000063	  bra   .soc
                        	.ecall:
                        	  ; We reset the stack pointer at each call to the OS in case an error causes
                        	  ; it to be messed up.
FFFC0CA4 7C3012F3	  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
FFFC0CA8 01F2F293	  and   $t0,$t0,#31       ; extract register set selection (will be 13,14, or 15)
FFFC0CAC 00229393	  sll   $t2,$t0,#2        ; $t2 = table index
FFFC0CB0 FFFC18B7		ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFC0CB4 BE088893
FFFC0CB8 007888B3
FFFC0CBC 0008A103
FFFC0CC0 1610106F		jmp		OSECALL					  ; goto operating system call dispatcher
                        	.isIRQ:
FFFC0CC4 7C3012F3	  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
FFFC0CC8 01F2F293	  and   $t0,$t0,#31       ; extract register set selection (will be 13,14, or 15)
FFFC0CCC 00229393	  sll   $t2,$t0,#2        ; $t2 = table index
FFFC0CD0 FFFC18B7		ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFC0CD4 BE088893
FFFC0CD8 007888B3
FFFC0CDC 0008A103
FFFC0CE0 342012F3		csrrw	$t0,#$342,$x0			; get cause code
                        	
FFFC0CE4 000018B7	  ldt   $t1,IRQFlag     ; update IRQ flag for Tiny Basic
FFFC0CE8 09088893
FFFC0CEC 000888B3
FFFC0CF0 0008A303
FFFC0CF4 00130313	  add   $t1,$t1,#1
FFFC0CF8 000018B7	  stt   $t1,IRQFlag
FFFC0CFC 09088893
FFFC0D00 000888B3
FFFC0D04 0068A023
FFFC0D08 0FF2F293	  and   $t0,$t0,#$FF
FFFC0D0C 000018B7	  stt   $t0,IRQCause    ; update cause code for Tiny Basic
FFFC0D10 09888893
FFFC0D14 000888B3
FFFC0D18 0058A023
FFFC0D1C FFF28313	  sub   $t1,$t0,#1
FFFC0D20 04030263	  beqz  $t1,.softwareIrq
FFFC0D24 FFF30313	  sub   $t1,$t1,#1
FFFC0D28 02030E63	  beqz  $t1,.timerIrq
FFFC0D2C FFF30313	  sub   $t1,$t1,#1      ; garbage collect interrupt?
FFFC0D30 08030663	  beqz  $t1,.gcIrq
FFFC0D34 01F2FE93		and		$t4,$t0,#31			; interrupting device # is low order 5 bits of cause code
FFFC0D38 00506E13		ldi   $t3,#5          ; try 5 times
                        	.devAgain:
FFFC0D3C 000EEF33		mov   $t5,$t4
FFFC0D40 007F1F13		sll		$t5,$t5,#7				; 128 bytes per device func table
FFFC0D44 000028B7		add		$t5,$t5,#DVF_Base+22*4	; load IRQ routine vector from device func table
FFFC0D48 05888893
FFFC0D4C 01E88F33
FFFC0D50 000F2F03		ldt		$t5,[$t5]
FFFC0D54 000F0463		beqz	$t5,.noIRQ	    ; make sure there's an address to go to
FFFC0D58 000F0067		jmp		[$t5]						; jump to the IRQ routine
                        	.noIRQ:
FFFC0D5C FFFE0E13	  sub   $t3,$t3,#1
FFFC0D60 000E1463	  bnez  $t3,.InitDev
                        	.softwareIrq:
                        	.timerIrq:
FFFC0D64 05C0006F	  jmp   ERETx2
                        		; The device function tables may have been zeroed out, try initializing them.
                        		; The following uses $a0-$a1, $t0-$t2
                        	.InitDev:
FFFC0D68 00506513		ldi		$a0,#5							; serial device
FFFC0D6C 03D51263		bne   $a0,$t4,.notSerial
FFFC0D70 FFFC25B7		ldi		$a1,#SerialFuncTbl
FFFC0D74 A4058593
FFFC0D78 551020EF		call	CopyDevFuncTbl
FFFC0D7C 00506513		ldi		$a0,#5							; serial device
FFFC0D80 FFFC25B7		ldi   $a1,#SerialDCB
FFFC0D84 AC058593
FFFC0D88 571020EF		call  CopyDevDCB
FFFC0D8C FA0008E3		bra   .devAgain
                        	.notSerial:
FFFC0D90 00F06513		ldi		$a0,#15							; VIA device
FFFC0D94 03D51263		bne   $a0,$t4,.notVia
FFFC0D98 FFFC25B7		ldi		$a1,#ViaFuncTbl
FFFC0D9C 00858593
FFFC0DA0 529020EF		call	CopyDevFuncTbl
FFFC0DA4 00F06513		ldi		$a0,#15							; VIA device
FFFC0DA8 FFFC25B7		ldi		$a1,#ViaDCB
FFFC0DAC 08858593
FFFC0DB0 549020EF		call	CopyDevDCB
FFFC0DB4 F80004E3		bra   .devAgain
                        	.notVia:
FFFC0DB8 0080006F	  jmp   ERETx2
                        	.gcIrq:
                        	;	ldi		$sp,#$7F800-4		; setup interrupt mode stack pointer
FFFC0DBC 6E5020EF	  call  gcIncrement
                        	ERETx2:
                        	;  mDI
                        	;  csrrc $x0,#$7C0,#31   ; select machine regs only
                        	;  csrrw $t0,#$7C0,$x0   ; get register sets
                        	;  srl   $t0,$t0,#5      ; extract register set selection
                        	;  sll   $t0,$t0,#3
                        	;  ldt   $t1,MEPC0[$t0]  ; get it
                        	;  csrrw $x0,#$341,$t1   ; set mepc
                        	  
FFFC0DC0 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC0DC4 00000013	nop
FFFC0DC8 00000013	  nop
                        	;  csrrw $t0,#CSR_RSSTACK,$x0   ; get register sets
                        	;  and   $t0,$t0,#15       ; extract register set selection (will be 13,14, or 15)
                        	;  sll   $t2,$t0,#2        ; $t2 = table index
                        	;	ldt		$sp,StackTbl[$t2]	; setup machine mode stack pointer
FFFC0DCC 30200073		mret
                        	
                        		; In case the pipeline runs ahead into the following table which will
                        		; result in illegal instructions.
FFFC0DD0 00000013		nop
FFFC0DD4 00000013		nop
FFFC0DD8 00000013	  nop
                        	
                        	; Application startup record for system
                        	SystemASR:
FFFC0DDC 000C0200	  db    0     ; page size (can't change on this system)
FFFC0DDD 00000C02	  db    2     ; priority normal
FFFC0DDE 0000000C	  db    12    ; register set for startup task
FFFC0DDF 00000000	  db    0     ; memory map #0
FFFC0DE0 00000000	  dw    0     ; processor affinity
FFFC0DE4 00000000	  dw    0     ; code size (0 = in ROM, don't move)
FFFC0DE8 00000000	  dw    0     ; reserved
FFFC0DEC 00000000	  dw    0     ; data size (preinitialized data)
FFFC0DF0 00000000	  dw    0     ; reserved
FFFC0DF4 00000000	  dw    0     ; uninitialized data size
FFFC0DF8 00000000	  dw    0     ; reserved
FFFC0DFC 00000000	  dw    0     ; Heap size
FFFC0E00 00000000	  dw    0     ; reserved
FFFC0E04 00000400	  dw    1024  ; stack size
FFFC0E08 00000000	  dw    0     ; reserved
FFFC0E0C FFFC0290	  dw    IdleTask  ; pointer to code
FFFC0E10 00000000	  dw    0       ; reserved
FFFC0E14 00000000	  dw    0     ; pointer to data
FFFC0E18 00000000	  dw    0     ; reserved
FFFC0E1C 00000000	  dw    0     ; ui data
FFFC0E20 00000000	  dw    0     ; reserved
                        	
                        	; Application startup record for Tiny Basic
                        	TinyBasicASR:
FFFC0E24 01000200	  db    0     ; page size (can't change on this system)
FFFC0E25 00010002	  db    2     ; priority normal
FFFC0E26 00000100	  db    0     ; register set
FFFC0E27 00000001	  db    1     ; memory map
FFFC0E28 00000000	  dw    0     ; processor affinity
FFFC0E2C 00000000	  dw    0     ; code size (0 = in ROM, don't move)
FFFC0E30 00000000	  dw    0     ; reserved
FFFC0E34 00000000	  dw    0     ; data size (preinitialized data)
FFFC0E38 00000000	  dw    0     ; reserved
FFFC0E3C 00008000	  dw    32768 ; uninitialized data size
FFFC0E40 00000000	  dw    0     ; reserved
FFFC0E44 00000000	  dw    0     ; Heap size
FFFC0E48 00000000	  dw    0     ; reserved
FFFC0E4C 00000800	  dw    2048  ; stack size
FFFC0E50 00000000	  dw    0     ; reserved
FFFC0E54 FFFC3D30	  dw    CSTART  ; pointer to code
FFFC0E58 00000000	  dw    0       ; reserved
FFFC0E5C 00000000	  dw    0     ; pointer to data
FFFC0E60 00000000	  dw    0     ; reserved
FFFC0E64 00000000	  dw    0     ; ui data
FFFC0E68 00000000	  dw    0     ; reserved
                        	    
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC0E6C 31305343			db		"CS01 System Starting.",13
FFFC0E70 73795320
FFFC0E74 206D6574
FFFC0E78 72617453
FFFC0E7C 676E6974
FFFC0E80 6F4D0D2E
                        	msgMonHelp:
FFFC0E82 696E6F4D			db		"Monitor Commands",13
FFFC0E86 20726F74
FFFC0E8A 6D6D6F43
FFFC0E8E 73646E61
FFFC0E92 2D20420D
FFFC0E93 202D2042			db		"B - start tiny basic",13
FFFC0E97 72617473
FFFC0E9B 69742074
FFFC0E9F 6220796E
FFFC0EA3 63697361
FFFC0EA7 2D20440D
FFFC0EA8 202D2044			db		"D - dump ready que",13
FFFC0EAC 706D7564
FFFC0EB0 61657220
FFFC0EB4 71207964
FFFC0EB8 450D6575
FFFC0EBB 202D2045			db		"E - edit memory",13
FFFC0EBF 74696465
FFFC0EC3 6D656D20
FFFC0EC7 0D79726F
FFFC0ECB 202D2046			db		"F - fill memory",13
FFFC0ECF 6C6C6966
FFFC0ED3 6D656D20
FFFC0ED7 0D79726F
FFFC0EDB 3C204946			db    "FI <string>- find string in memory",13
FFFC0EDF 69727473
FFFC0EE3 2D3E676E
FFFC0EE7 6E696620
FFFC0EEB 74732064
FFFC0EEF 676E6972
FFFC0EF3 206E6920
FFFC0EF7 6F6D656D
FFFC0EFB 4B0D7972
FFFC0EFE 743C204B			db		"K <tid> - kill task", 13
FFFC0F02 203E6469
FFFC0F06 696B202D
FFFC0F0A 74206C6C
FFFC0F0E 0D6B7361
FFFC0F12 733C204D			db		"M <start> <length>	- dump memory",13
FFFC0F16 74726174
FFFC0F1A 6C3C203E
FFFC0F1E 74676E65
FFFC0F22 2D093E68
FFFC0F26 6D756420
FFFC0F2A 656D2070
FFFC0F2E 79726F6D
FFFC0F32 2D20500D
FFFC0F33 202D2050			db    "P - display PAM",13
FFFC0F37 70736964
FFFC0F3B 2079616C
FFFC0F3F 0D4D4150
FFFC0F43 202D2053			db		"S - switch task",13
FFFC0F47 74697773
FFFC0F4B 74206863
FFFC0F4F 0D6B7361
FFFC0F53 6D3C2056			db    "V <mid> dump virtual memory map",13
FFFC0F57 203E6469
FFFC0F5B 706D7564
FFFC0F5F 72697620
FFFC0F63 6C617574
FFFC0F67 6D656D20
FFFC0F6B 2079726F
FFFC0F6F 0D70616D
FFFC0F73 61742000			db		0
                        			align 4                        	
                        	msgTaskStart:
FFFC0F74 73617420			db		" task started."
FFFC0F78 7473206B
FFFC0F7C 65747261
FFFC0F80 0A0D2E64
                        	msgCRLF:
FFFC0F82 00000A0D			db		13,10,0
                        	flt50:
FFFC0F85 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC0F89 00000000
FFFC0F8D 00000000
FFFC0F91 40049000
                        	flt20:
FFFC0F95 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC0F99 00000000
FFFC0F9D 00000000
FFFC0FA1 40034000
                        	flt10:
FFFC0FA5 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC0FA9 00000000
FFFC0FAD 00000000
FFFC0FB1 40024000
                        	
                        	.file "fltToString.r5a",1
                        	.file "fltToString.r5a",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC0FB5 00639300			ldi		$t2,#0				; $t2 = 0
FFFC0FB9 09055300
FFFC0FBA E0090553			fmv		$a0,$f18
FFFC0FBE 7F8008B7			and		$t0,$a0,#$7F800000
FFFC0FC2 00088893
FFFC0FC6 00A8F2B3
FFFC0FCA 7F800337			ldi		$t1,#$7F800000
FFFC0FCE 00030313
FFFC0FD2 04629263			bne		$t0,$t1,.0001
FFFC0FD6 008008B7			and		$t0,$a0,#$007FFFFF
FFFC0FDA FFF88893
FFFC0FDE 00A8F2B3
FFFC0FE2 00028E63			beq		$t0,$x0,.inf
FFFC0FE6 FFFC18B7			ldt		$t0,msgNan
FFFC0FEA 37088893
FFFC0FEE 000888B3
FFFC0FF2 0008A283
FFFC0FF6 20502023			stt		$t0,STRTMP
FFFC0FFA 2E000E63			bra		.prt
                        	.inf:
FFFC0FFE FFFC18B7			ldt		$t0,msgInf
FFFC1002 36C88893
FFFC1006 000888B3
FFFC100A 0008A283
FFFC100E 20502023			stt		$t0,STRTMP
FFFC1012 2E000263			bra		.prt
                        	.0001:
FFFC1016 800008B7			and		$t0,$a0,#$80000000
FFFC101A 00088893
FFFC101E 00A8F2B3
FFFC1022 00028E63			beq		$t0,$x0,.pos
FFFC1026 02D06293			ldi		$t0,#'-'
FFFC102A 20538023			stb		$t0,STRTMP[$t2]
FFFC102E 00138393			add		$t2,$t2,#1
FFFC1032 800008B7			and		$a0,$a0,#$7FFFFFFF
FFFC1036 FFF88893
FFFC103A 00A8F533
                        	.pos:
FFFC103E 00051A63			bne		$a0,$x0,.notZero
FFFC1042 03006293			ldi		$t0,#'0'
FFFC1046 20538023			stb		$t0,STRTMP[$t2]
FFFC104A 200380A3			stb		$x0,STRTMP+1[$t2]
FFFC104E 2A000463			bra		.prt		
                        	.notZero:
FFFC1052 00006CB3			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC1056 FFFC18B7			flw		$f3,fltOne
FFFC105A 37488893
FFFC105E 000888B3
FFFC1062 0008A187
FFFC1066 F0050053			fmv		$f0,$a0
FFFC106A A03912D3			flt		$t0,$f18,$f3
FFFC106E 02028463			beq		$t0,$x0,.0002
FFFC1072 FFFC18B7			flw		$f4,fltMillion
FFFC1076 37C88893
FFFC107A 000888B3
FFFC107E 0008A207
                        	.0003:
FFFC1082 A03912D3			flt		$t0,$f18,$f3
FFFC1086 00028863			beq		$t0,$x0,.0002
FFFC108A 10490953			fmul	$f18,$f18,$f4
FFFC108E FFAC8C93			sub		$s9,$s9,#6
FFFC1092 FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC1096 FFFC18B7			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC109A 37488893
FFFC109E 000888B3
FFFC10A2 0008A087
FFFC10A6 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC10AA A12092D3			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC10AE 02028A63			beq		$t0,$x0,.0004
FFFC10B2 FFFC18B7			flw		$f5,fltTen				; $f5 = 10.0
FFFC10B6 37888893
FFFC10BA 000888B3
FFFC10BE 0008A287
                        	.0006:
FFFC10C2 A12082D3			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC10C6 00028A63			beq		$t0,$x0,.0005
FFFC10CA 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC10CE 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC10D2 001C8C93			add		$s9,$s9,#1				; exp++;
FFFC10D6 FE0006E3			bra		.0006
                        	.0005:
FFFC10DA 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC10DE FFFC8C93			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC10E2 000CCE63			blt		$s9,$x0,.0007
FFFC10E6 00606A93			ldi		$s5,#6
FFFC10EA 015CDA63			bge		$s9,$s5,.0007
FFFC10EE FFFFE4B3			mov		$s1,#s0						; s1 = digits before decpt
FFFC10F2 00148493			add		$s1,$s1,#1
FFFC10F6 00006C93			ldi		$s9,#0						; exp = 0
FFFC10FA 00000C63			bra		.0008
                        	.0007:
FFFC10FE FF906A93			ldi		$s5,#-7
FFFC1102 015CC663			blt		$s9,$s5,.0009
FFFC1106 00106493			ldi		$s1,#1
FFFC110A 00000463			bra		.0008
                        	.0009:
FFFC110E FFF06493			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC1112 FFA06A93			ldi		$s5,#-6
FFFC1116 015CDE63			bge		$s9,$s5,.0010
FFFC111A 03006293			ldi		$t0,#'0'
FFFC111E 20538023			stb		$t0,STRTMP[$t2]
FFFC1122 00138393			add		$t2,$t2,#1
FFFC1126 02E06293			ldi		$t0,#'.'
FFFC112A 20538023			stb		$t0,STRTMP[$t2]
FFFC112E 00138393			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC1132 00006993			ldi		$s3,#0						; s3 = nn = 0
FFFC1136 01E06A93			ldi		$s5,#30
FFFC113A FFFC18B7			flw		$f7,fltTen				; f7 = 10.0
FFFC113E 37888893
FFFC1142 000888B3
FFFC1146 0008A387
                        	.0016:
FFFC114A 0159A2B3			slt		$t0,$s3,$s5
FFFC114E 06028863			beq		$t0,$x0,.0011
FFFC1152 00006A93			ldi		$s5,#0
FFFC1156 06CAD463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC115A 00006A13			ldi		$s4,#0						; s4 = digit = 0
FFFC115E 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC1162 A12082D3			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC1166 00028863			beq		$t0,$x0,.0012
FFFC116A 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC116E 001A0A13			add		$s4,$s4,#1						; digit++
FFFC1172 FE0008E3			bra		.0013
                        	.0012:
FFFC1176 030A0A93			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC117A 21538023			stb		$s5,STRTMP[$t2]
FFFC117E 00206A93			ldi		$s5,#2						; if (2 < digit)
FFFC1182 014AD863			bge		$s5,$s4,.0014
FFFC1186 D00A02D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC118A 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC118E 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC1192 00138393			add		$t2,$t2,#1				; ndx++
FFFC1196 FFF48493			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC119A 00049A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC119E 02E06293			ldi		$t0,#'.'
FFFC11A2 20538023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC11A6 00138393			add		$t2,$t2,#1				; ndx++
FFFC11AA 00000663			bra		.0017
                        	.0015:
FFFC11AE 0004D463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC11B2 FFF60613			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC11B6 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC11BA F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC11BE FFF38393			sub		$t2,$t2,#1				; ndx--
FFFC11C2 20038283			ldb		$t0,STRTMP[$t2]
FFFC11C6 0302C293			xor		$t0,$t0,#'0'
FFFC11CA FE028AE3			beq		$t0,$x0,.0018
FFFC11CE 00138393			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC11D2 20038283			ldb		$t0,STRTMP[$t2]
FFFC11D6 02E2C293			xor		$t0,$t0,#'.'
FFFC11DA 00029C63			bne		$t0,$x0,.0019
FFFC11DE 00138393			add		$t2,$t2,#1
FFFC11E2 03006293			ldi		$t0,#'0'
FFFC11E6 20538023			stb		$t0,STRTMP[$t2]
FFFC11EA 00138393			add		$t2,$t2,#1
FFFC11EE 20038023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC11F2 000C9663			bne		$s9,$x0,.0020
FFFC11F6 20038023			stb		$x0,STRTMP[$t2]
FFFC11FA 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC11FE 04506293			ldi		$t0,#'E'
FFFC1202 20538023			stb		$t0,STRTMP[$t2]
FFFC1206 00138393			add		$t2,$t2,#1
FFFC120A 000CDC63			bge		$s9,$x0,.0021
FFFC120E 02D06293			ldi		$t0,#'-'
FFFC1212 20538023			stb		$t0,STRTMP[$t2]
FFFC1216 00138393			add		$t2,$t2,#1
FFFC121A 41900CB3			sub		$s9,$x0,$s9			; exp = -exp
FFFC121E 00000863			bra		.0022
                        	.0021:
FFFC1222 02B06293			ldi		$t0,#'+'
FFFC1226 20538023			stb		$t0,STRTMP[$t2]
FFFC122A 00138393			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC122E 00006A13			ldi		$s4,#0
FFFC1232 3E806293			ldi		$t0,#1000
                        	.0025:
FFFC1236 005CD463			bge		$s9,$t0,.0023
FFFC123A 00000863			bra		.0024
                        	.0023:
FFFC123E 405C8CB3			sub		$s9,$s9,$t0
FFFC1242 001A0A13			add		$s4,$s4,#1
FFFC1246 FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC124A 000A6B33			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC124E 000A1863			bne		$s4,$x0,.0026
FFFC1252 030A0293			add		$t0,$s4,#'0'
FFFC1256 20538023			stb		$t0,STRTMP[$t2]
FFFC125A 00138393			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC125E 00006A13			ldi		$s4,#0
FFFC1262 06406293			ldi		$t0,#100
                        	.0027:
FFFC1266 005CD463			bge		$s9,$t0,.0028
FFFC126A 00000863			bra		.0029
                        	.0028:
FFFC126E 405C8CB3			sub		$s9,$s9,$t0
FFFC1272 001A0A13			add		$s4,$s4,#1
FFFC1276 FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC127A 000A6BB3			mov		$s7,$s4				; $s7 = d2
FFFC127E 000B1463			bne		$s6,$x0,.0030
FFFC1282 000A0863			beq		$s4,$x0,.0031
                        	.0030:
FFFC1286 030A0293			add		$t0,$s4,#'0'
FFFC128A 20538023			stb		$t0,STRTMP[$t2]
FFFC128E 00138393			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC1292 00006A13			ldi		$s4,#0
FFFC1296 00A06293			ldi		$t0,#10
                        	.0032:
FFFC129A 005CD463			bge		$s9,$t0,.0034
FFFC129E 00000863			bra		.0035
                        	.0034:
FFFC12A2 405C8CB3			sub		$s9,$s9,$t0
FFFC12A6 001A0A13			add		$s4,$s4,#1
FFFC12AA FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC12AE 000A6C33			mov		$s8,$s4
FFFC12B2 000A1663			bne		$s4,$x0,.0036
FFFC12B6 000B1463			bne		$s6,$x0,.0036
FFFC12BA 000B8863			beq		$s7,$x0,.0037
                        	.0036:
FFFC12BE 030A0293			add		$t0,$s4,#'0'
FFFC12C2 20538023			stb		$t0,STRTMP[$t2]
FFFC12C6 00138393			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC12CA 00006A13			ldi		$s4,#0
FFFC12CE 00106293			ldi		$t0,#1
                        	.0038:
FFFC12D2 005CD463			bge		$s9,$t0,.0040
FFFC12D6 00000863			bra		.0039
                        	.0040:
FFFC12DA 405C8CB3			sub		$s9,$s9,$t0
FFFC12DE 001A0A13			add		$s4,$s4,#1
FFFC12E2 FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC12E6 030A0293			add		$t0,$s4,#'0'
FFFC12EA 20538023			sb		$t0,STRTMP[$t2]
FFFC12EE 00138393			add		$t2,$t2,#1
FFFC12F2 20038023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC12F6 0405C663			blt		$a1,$x0,.0041
FFFC12FA 04058463			beq		$a1,$x0,.0041
FFFC12FE 00B3C463			blt		$t2,$a1,.0042
FFFC1302 04000063			bra		.0041
                        	.0042:
FFFC1306 02706993			ldi		$s3,#39					; s3 = nn
FFFC130A 407582B3			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC130E 0059D463			bge		$s3,$t0,.0043
FFFC1312 00000C63			bra		.0044
                        	.0043:
FFFC1316 40598B33			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC131A 20098303			ldb		$t1,STRTMP[$s3]
FFFC131E 206B0023			stb		$t1,STRTMP[$s6]
FFFC1322 FFF98993			sub		$s3,$s3,#1
FFFC1326 FE0004E3			bra		.0045
                        	.0044:
FFFC132A 02006293			ldi		$t0,#' '
                        	.0048:
FFFC132E 0009D463			bge		$s3,$x0,.0046
FFFC1332 00000863			bra		.0047
                        	.0046:
FFFC1336 20598023			stb		$t0,STRTMP[$s3]
FFFC133A FFF98993			sub		$s3,$s3,#1
FFFC133E FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC1342 0205D063			bge		$a1,$x0,.0050
FFFC1346 40B005B3			sub		$a1,$x0,$a1
FFFC134A 02006293			ldi		$t0,#' '
                        	.0052:
FFFC134E 00B3D863			bge		$t2,$a1,.0051
FFFC1352 20538023			stb		$t0,STRTMP[$t2]
FFFC1356 00138393			add		$t2,$t2,#1
FFFC135A FE000AE3			bra		.0052
                        	.0051:
FFFC135E 20038023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC1362 0003E533			mov		$a0,$t2
FFFC1366 00008067			ret
                        	
FFFC136A 6E490000			align	
                        	
                        	msgInf:
FFFC136C 00666E49			db	"Inf",0
                        	msgNan:
FFFC1370 006E614E			db	"Nan",0
                        	fltOne:
FFFC1374 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC1378 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC137C 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01Mem.r5a",1
                        	.file "cs01Mem.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "cs01Mem.r5a",25
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC1380 FFC10113		sub		$sp,$sp,#4
FFFC1384 00112023		stt		$ra,[$sp]
FFFC1388 1EC06293		ldi		$t0,#MEMSZ-OSPAGES-4  ; set number of available pages (20 pages already allocated)
FFFC138C 30502023		stt		$t0,NPAGES
                        	
                        		; satp register setting
FFFC1390 602002B7		ldi		$t0,#$60200100			; 32 maps of 256 entries, ASID = 0, custom MMU selected
FFFC1394 10028293
FFFC1398 18029073		csrrw	$x0,#CSR_SATP,$t0	  ; set ASID
                        	
                        		; Free all memory for all tasks
                        		; Sets all pages to map to page zero for all tasks, except for the system
                        		; task (task #0) which pre-allocates the first 16kB of memory.
FFFC139C 00006293		ldi		$t0,#$00
FFFC13A0 01F06E93		ldi		$t4,#31					; app id
                        	.0004:
FFFC13A4 00006313		ldi		$t1,#$000				; regno
FFFC13A8 10006393		ldi		$t2,#256				; number of registers to update
FFFC13AC 01006E13		ldi		$t3,#16					; number of pages pre-allocated
                        	.0001:
FFFC13B0 010E9493		sll		$s1,$t4,#16			; put app id in place
FFFC13B4 0064E4B3		or		$s1,$s1,$t1			; or in page number
FFFC13B8 0292800D		mvmap	$x0,$t0,$s1
FFFC13BC 00128293		add		$t0,$t0,#$01
FFFC13C0 00130313		add		$t1,$t1,#$01		; increment page number
FFFC13C4 01D04463		bgtz  $t4,.0005
FFFC13C8 07C36463		bltu	$t1,$t3,.0003
                        	.0005:
FFFC13CC 000062B3		mov		$t0,$x0					; mark pages unallocated
                        	.0003:
FFFC13D0 FFF38393		sub		$t2,$t2,#1
FFFC13D4 FC039EE3		bnez	$t2,.0001
FFFC13D8 FFFE8E93		sub		$t4,$t4,#1      ; next app id
FFFC13DC FC0ED4E3		bge		$t4,$x0,.0004
                        	
                        		; allocate last 4 pages for system stacks
FFFC13E0 0FF06313		ldi		$t1,#$FF				
FFFC13E4 1FF06293		ldi		$t0,#$1FF
FFFC13E8 0262800D		mvmap	$x0,$t0,$t1
FFFC13EC 0FE06313		ldi		$t1,#$FE
FFFC13F0 1FE06293		ldi		$t0,#$1FE
FFFC13F4 0262800D		mvmap	$x0,$t0,$t1
FFFC13F8 0FD06313		ldi		$t1,#$FD			
FFFC13FC 1FD06293		ldi		$t0,#$1FD
FFFC1400 0262800D		mvmap	$x0,$t0,$t1
FFFC1404 0FC06313		ldi		$t1,#$FC			
FFFC1408 1FC06293		ldi		$t0,#$1FC
FFFC140C 0262800D		mvmap	$x0,$t0,$t1
                        	
                        		; Now setup segment registers
FFFC1410 00006293		ldi		$t0,#$0
FFFC1414 00706313		ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC1418 0053000D		mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC141C 00128293		add		$t0,$t0,#1			; pick next segment register
FFFC1420 0802A393		slt		$t2,$t0,#128		; 128 base regs
FFFC1424 FE039AE3		bnez	$t2,.0002
FFFC1428 08006293		ldi		$t0,#128
FFFC142C FFF06313		ldi		$t1,#-1					; t1 = value to load, bounds max
                        	.0003:
FFFC1430 0053000D		mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC1434 00128293		add		$t0,$t0,#1			; pick next segment register
FFFC1438 1002A393		slt		$t2,$t0,#256		; 128 bound regs
FFFC143C FE039AE3		bnez	$t2,.0003
                        	
                        		; Now ensure all pages in PAM are marked as free or OS allocated
FFFC1440 538000EF		call  PAMInit
                        	
FFFC1444 00012083		ldt		$ra,[$sp]
FFFC1448 00410113		add		$sp,$sp,#4
FFFC144C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		a0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindRun:
FFFC1450 01F57E13		and			$t3,$a0,#$1F			; t3 = mid
FFFC1454 010E1E13		sll			$t3,$t3,#16				; shift into usable position
FFFC1458 00006313		ldi			$t1,#0						; t1 = count of consecutive empty buckets
FFFC145C 000E63B3		mov			$t2,$t3						; t2 = map entry number
FFFC1460 0103E393		or			$t2,$t2,#OSPAGES	; start looking at page 32 (others are for OS)
FFFC1464 1FF06F13		ldi			$t5,#511					; max number of pages - 1
FFFC1468 01CF6F33		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0001:
FFFC146C 0270050D		mvmap		$a0,$x0,$t2				; get map entry into v0
FFFC1470 00050A63		beq			$a0,$x0,.empty0		; is it empty?
FFFC1474 00138393		add			$t2,$t2,#1
FFFC1478 FFE3EAE3		bltu		$t2,$t5,.0001
                        	.0002:
FFFC147C FFF06513		ldi			$a0,#-1						; got here so no run was found
FFFC1480 00008067		ret
                        	.empty0:
FFFC1484 0003EE33		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC1488 FFE3FAE3		bgeu		$t2,$t5,.0002
FFFC148C 00130313		add			$t1,$t1,#1
FFFC1490 00B37C63		bgeu		$t1,$a1,.foundEnough
FFFC1494 00138393		add			$t2,$t2,#1				; next bucket
FFFC1498 0270050D		mvmap		$a0,$x0,$t2				; get map entry
FFFC149C FE0506E3		beq			$a0,$x0,.empty1
FFFC14A0 00006333		mov			$t1,$x0						; reset counter
FFFC14A4 FC0004E3		bra			.0001							; go back and find another run
                        	.foundEnough:
FFFC14A8 000E6533		mov			$a0,$t3						; v0 = start of run
FFFC14AC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = mid
                        	;		$a1 = amount of memory to allocate
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		$a1 = pointer to allocated memory in virtual address space.
                        	;		$a0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        	;
                        	Alloc:
FFFC14B0 FE810113		sub			$sp,$sp,#24
FFFC14B4 00112023		stt			$ra,[$sp]
FFFC14B8 00912223		stt			$s1,4[$sp]			; these regs must be saved
FFFC14BC 01212423		stt			$s2,8[$sp]
FFFC14C0 01312823		stt			$s3,16[$sp]
FFFC14C4 01412A23		stt     $s4,20[$sp]
FFFC14C8 0A058663		beqz    $a1,.allocZero
                        		; First check if there are enough pages available in the system.
FFFC14CC 3FF58A13		add			$s4,$a1,#PAGESZ-1	; v0 = round memory request
FFFC14D0 00AA5A13		srl			$s4,$s4,#LOG_PGSZ	; v0 = convert to pages required
FFFC14D4 30002283		ldt			$t0,NPAGES				; check number of pages available
FFFC14D8 0142F663		bleu		$s4,$t0,.enough
                        	.noRun2:
FFFC14DC 00006593		ldi			$a1,#0						; not enough, return null
FFFC14E0 06000A63		bra			.noRun
                        	.enough:
FFFC14E4 000564B3		mov			$s1,$a0
                        		; There are enough pages, but is there a run long enough in map space?
FFFC14E8 000A6933		mov			$s2,$s4				    ; save required # pages
FFFC14EC 000A65B3		mov			$a1,$s4
FFFC14F0 F61FF0EF		call		FindRun						; find a run of available slots
FFFC14F4 FE0544E3		bltz		$a0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC14F8 000564B3		mov			$s1,$a0						; s1 = start of run
FFFC14FC 30002983		ldt			$s3,NPAGES				; decrease number of pages available in system
FFFC1500 412989B3		sub			$s3,$s3,$s2
FFFC1504 31302023		stt			$s3,NPAGES
FFFC1508 000569B3		mov			$s3,$a0						; s3 = start of run
                        	.0001:
FFFC150C 38C000EF	  call    PAMMarkPage       ; allocates a page
                        	;	palloc	$v0								; allocate a page (cheat and use hardware)
                        		;call		AllocPage
FFFC1510 04050263		beqz		$a0,.noRun        ; shouldn't get an error here
FFFC1514 0335000D		mvmap		$x0,$a0,$s3				; map the page
FFFC1518 00198993		add			$s3,$s3,#1				; next bucket
FFFC151C FFF90913		sub			$s2,$s2,#1
FFFC1520 FE0916E3		bnez		$s2,.0001
FFFC1524 000108B7		and     $a1,$s1,#$FFFF    ; strip out ASID
FFFC1528 FFF88893
FFFC152C 0098F5B3
FFFC1530 00A59593		sll			$a1,$a1,#LOG_PGSZ	; $a1 = virtual address of allocated mem.
FFFC1534 00C12483		ldt     $s1,12[$sp]
                        		; Clear the allocated memory
FFFC1538 0005EA33	  mov     $s4,$a1
                        	.zm:
FFFC153C 000A2023	  stt     $x0,[$s4]
FFFC1540 004A0A13	  add     $s4,$s4,#4
FFFC1544 FFC48493	  sub     $s1,$s1,#4
FFFC1548 FE04DAE3	  bge     $s1,$x0,.zm	
FFFC154C 00006513		ldi			$a0,#E_Ok
FFFC1550 00000463		bra			.xit
                        	.noRun:
FFFC1554 00906513		ldi			$a0,#E_NotAlloc
                        	.xit
FFFC1558 00012083		ldt			$ra,[$sp]
FFFC155C 00412483		ldt			$s1,4[$sp]			; restore regs
FFFC1560 00812903		ldt			$s2,8[$sp]
FFFC1564 01012983		ldt			$s3,16[$sp]
FFFC1568 01412A03		ldt     $s4,20[$sp]
FFFC156C 01810113		add			$sp,$sp,#24
FFFC1570 00008067		ret
                        	.allocZero:
FFFC1574 00006593	  ldi     $a1,#0
FFFC1578 00006513		ldi			$a0,#E_Ok
FFFC157C FC000EE3	  bra     .xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a task. The stack is located at the highest
                        	; virtual address ($7FC00).
                        	;
                        	; Parameters:
                        	;		$a0 = mid to allocate for
                        	;	Returns:
                        	;		$a0 = physical address, 0 if unsuccessful
                        	;		$a1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        	
                        	AllocStack:
FFFC1580 FF410113	  sub   	$sp,$sp,#12
FFFC1584 00112023	  stt     $ra,[$sp]
FFFC1588 00912223	  stt     $s1,4[$sp]
FFFC158C 01212423	  stt     $s2,8[$sp]
FFFC1590 00056933	  mov     $s2,$a0
FFFC1594 01051493		sll			$s1,$a0,#16			; 
FFFC1598 1FF4E493		or			$s1,$s1,#511		; last page of memory is for stack
FFFC159C 0290050D		mvmap		$a0,$x0,$s1			; check if stack already allocated
FFFC15A0 02051063		bnez		$a0,.0001
FFFC15A4 FE912E23		stt     $s1,-4[$sp]
FFFC15A8 FFC10113	  sub     $sp,$sp,#4
FFFC15AC 2EC000EF		call    PAMMarkPage
FFFC15B0 00410113	  add     $sp,$sp,#4
FFFC15B4 FFC12483		ldt     $s1,-4[$sp]
                        	;	palloc	$v0							; allocate a page
FFFC15B8 02050063		beqz		$a0,.xit		    ; success?
FFFC15BC 0295000D		mvmap		$x0,$a0,$s1
                        	.0001:
FFFC15C0 1FF4F493		and			$s1,$s1,#511
FFFC15C4 00A51513		sll			$a0,$a0,#LOG_PGSZ			; convert pages to addresses
FFFC15C8 00A49493		sll			$s1,$s1,#LOG_PGSZ
                        	;	beqz    $s2,.xit
FFFC15CC A00008B7		or      $a1,$s1,#$A0000000    ; set stack segment
FFFC15D0 00088893
FFFC15D4 0098E5B3
                        	.xit:
FFFC15D8 00012083	  ldt     $ra,[$sp]
FFFC15DC 00412483	  ldt     $s1,4[$sp]
FFFC15E0 00812903	  ldt     $s2,8[$sp]
FFFC15E4 00C10113	  add     $sp,$sp,#12
FFFC15E8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a task including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		$a0 = mid to free memory for
                        	;	Modifies:
                        	;		a0,t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FreeAll:
FFFC15EC FFC10113	  sub   	$sp,$sp,#4
FFFC15F0 00112023	  stt     $ra,[$sp]
FFFC15F4 00006E13		ldi			$t3,#0
FFFC15F8 01051E93		sll			$t4,$a0,#16
                        	.nxt:
FFFC15FC 200E2313		slt			$t1,$t3,#512		; number of buckets to check
FFFC1600 02030C63		beqz		$t1,.0001
FFFC1604 001F08B7		and			$t4,$t4,#$1F0000
FFFC1608 00088893
FFFC160C 01D8FEB3
FFFC1610 01CEEEB3		or			$t4,$t4,$t3			; combine pid and bucket number
FFFC1614 00006513		ldi			$a0,#0					; new page number to set (indicates free)
FFFC1618 03D5050D		mvmap		$a0,$a0,$t4			; get page mapping and set to zero
FFFC161C 001E0E13		add			$t3,$t3,#1			; advance to next bucket
FFFC1620 FC050EE3		beqz		$a0,.nxt				; 0 = no map in this bucket
FFFC1624 2C4000EF		call    PAMUnmarkPage
                        	;	pfree		$t0							; free the page
FFFC1628 30002283		ldt			$t0,NPAGES			; update the number of available pages
FFFC162C 00128293		add			$t0,$t0,#1
FFFC1630 30502023		stt			$t0,NPAGES
FFFC1634 FC0004E3		bra			.nxt
                        	.0001:
FFFC1638 00012083	  ldt     $ra,[$sp]
FFFC163C 00410113	  add     $sp,$sp,#4
FFFC1640 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a linear one.
                        	;
                        	; Parameters:
                        	;		$a0 = virtual address to convert
                        	; Modifies:
                        	;		$a1,$t0
                        	; Returns:
                        	;		$a0 = linear address
                        	;------------------------------------------------------------------------------
                        	
                        	VirtToLinear:
FFFC1644 01C55593		srl   $a1,$a0,#28         ; get segment register of address
FFFC1648 00B0058D		mvseg $a1,$x0,$a1         ; get segment register value
FFFC164C FF05F593		and   $a1,$a1,#$FFFFFFF0  ; mask off acr bits
FFFC1650 00659593		sll   $a1,$a1,#6          ; shift into position
FFFC1654 100008B7		and   $t0,$a0,#$0FFFFFFF  ; mask off segment
FFFC1658 FFF88893
FFFC165C 00A8F2B3
FFFC1660 00558533		add   $a0,$a1,$t0         ; v0 = linear address (segment base + address)
FFFC1664 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a linear one.
                        	;
                        	; Parameters:
                        	;   $a0 = tid
                        	;		$a1 = virtual address to convert
                        	; Modifies:
                        	;		$v1
                        	; Returns:
                        	;		$v0 = linear address
                        	;------------------------------------------------------------------------------
                        	
                        	;VirtToLinear2:
                        	;	srl   $v0,$a1,#28         ; get base register selector of address
                        	;	sll   $v0,$v0,#2          ; convert to index
                        	;	sll   $v1,$a0,#2
                        	;	ldt   $v1,TidTcbMap[$v1]  ; $v1 = pointer to TCB
                        	;	add   $v0,$v0,$v1
                        	;	ldt   $v1,TCBbases[$v0]   ; $v1 = base register value
                        	;	and   $v0,$v1,#$FFFFFFF0  ; mask off acr bits
                        	;	sll   $v0,$v0,#6          ; shift into position
                        	;	and   $v1,$a1,#$0FFFFFFF  ; mask off base selector
                        	;	add   $v0,$v1,$v0         ; v0 = linear address (base + address)
                        	;  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		$a0 = virtual address to convert
                        	; Modifies:
                        	;		$t0, $t1
                        	; Returns:
                        	;		$a0 = physical address
                        	;------------------------------------------------------------------------------
                        	
                        	VirtToPhys:
FFFC1668 FF810113		sub 	$sp,$sp,#8
FFFC166C 00112023		stt   $ra,[$sp]
FFFC1670 00912223		stt   $s1,4[$sp]
FFFC1674 000564B3		mov   $s1,$a0
FFFC1678 FCDFF0EF		call  VirtToLinear
FFFC167C 02054263		bltz	$a0,.notMapped
FFFC1680 00A55293		srl		$t0,$a0,#LOG_PGSZ		; convert virt to page
                        		
FFFC1684 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC1688 01051513	sll		$a0,$a0,#16
FFFC168C 00556533		or		$a0,$a0,$t0					; and in tid
FFFC1690 02A0050D		mvmap	$a0,$x0,$a0					; get the translation
FFFC1694 00A51513		sll		$a0,$a0,#LOG_PGSZ		; convert page to address
FFFC1698 3FF4F293		and		$t0,$s1,#$3FF				; insert LSB's
FFFC169C 00556533		or		$a0,$a0,$t0
                        	.notMapped:
FFFC16A0 00012083		ldt   $ra,[$sp]
FFFC16A4 00412483		ldt   $s1,4[$sp]
FFFC16A8 00810113		add   $sp,$sp,#8
FFFC16AC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; VirtToPhys2:
                        	;   Used by the OS to convert virtual to physcial addresses.
                        	; Convert a virtual address to a physical one. Slightly tricky as linear
                        	; addresses are associated with the TID while paged addresses are associated
                        	; with the MID of the task.
                        	;
                        	; Parameters:
                        	;   $a0 = tid
                        	;		$a1 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		$v0 = physical address
                        	;------------------------------------------------------------------------------
                        	
                        	VirtToPhys2:
FFFC16B0 FFC10113		sub 	$sp,$sp,#4
FFFC16B4 00112023		stt   $ra,[$sp]
                        	;	call  VirtToLinear2
                        	;	bltz	$v0,.notMapped
                        	;	srl		$t0,$v0,#LOG_PGSZ		; convert virt to page
                        	;	sll   $v1,$a0,#2
                        	;	ldt   $v1,TidTcbMap[$v1]  ; $v1 = pointer to TCB
                        	;	ldbu  $v1,TCBmid[$v1]     ; $v1 = mid
                        	;	sll		$v0,$v1,#16         ; set map id field
                        	;	or		$v0,$v0,$t0					; and in tid
                        	;	mvmap	$v0,$x0,$v0					; get the translation
                        	;	sll		$v0,$v0,#LOG_PGSZ		; convert page to address
                        	;	and		$t0,$a0,#$3FF				; insert LSB's
                        	;	or		$v0,$v0,$t0
                        	.notMapped:
FFFC16B8 00012083		ldt   $ra,[$sp]
FFFC16BC 00410113		add   $sp,$sp,#4
FFFC16C0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FetchMemoryWord:
FFFC16C4 0005A583	  ldt   $a1,[$a1]
FFFC16C8 00006513	  ldi   $a0,#E_Ok
FFFC16CC 7D50006F	  jmp   OSExit
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01PAM.r5a",1
                        	.file "cs01PAM.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	; PAM
                        	; 0 = unallocated
                        	; 1 = reserved
                        	; 2 = end of run of pages
                        	; 3 = allocated
                        	;------------------------------------------------------------------------------
                        	
                        	;------------------------------------------------------------------------------
                        	; PAMFindRun
                        	;    Find a run of unallocated pages.
                        	;
                        	; Parameters:
                        	;   $a0 = number of consecutive pages required
                        	; Returns:
                        	;   $a0 = page starting run, -1 if not enough memory
                        	;------------------------------------------------------------------------------
                        	
                        	PAMFindRun:
FFFC16D0 FEC10113	  sub 	$sp,$sp,#20
FFFC16D4 00112023	  stt   $ra,[$sp]
FFFC16D8 00912223	  stt   $s1,4[$sp]
FFFC16DC 01212423	  stt   $s2,8[$sp]
FFFC16E0 01312623	  stt   $s3,12[$sp]
FFFC16E4 01412823	  stt   $s4,16[$sp]
FFFC16E8 000564B3	  mov   $s1,$a0             ; save argument value
FFFC16EC 000048B7	  stt   $a0,$4010
FFFC16F0 01088893
FFFC16F4 000888B3
FFFC16F8 00A8A023
FFFC16FC 01006513	  ldi   $a0,#OSPAGES
                        	.nextPage:
FFFC1700 00056A33	  mov   $s4,$a0
FFFC1704 248000EF	  call  PAMGetbitPair
FFFC1708 04051263	  bnez  $a0,.notAvailable
FFFC170C 000A69B3	  mov   $s3,$s4             ; remember start of run
FFFC1710 0004E933	  mov   $s2,$s1             ; $s2 = run length
                        	.runInc:
FFFC1714 FFF90913	  sub   $s2,$s2,#1
FFFC1718 04090463	  beqz  $s2,.foundRun
FFFC171C 001A0513	  add   $a0,$s4,#1          ; increment run start
FFFC1720 20052313	  slt   $t1,$a0,#MEMSZ
FFFC1724 02030A63	  beqz  $t1,.outOfMem
FFFC1728 00056A33	  mov   $s4,$a0             ; remember $a0
FFFC172C 000048B7	  stt   $s4,$4020
FFFC1730 02088893
FFFC1734 000888B3
FFFC1738 0148A023
FFFC173C 210000EF	  call  PAMGetbitPair
FFFC1740 FC050AE3	  beqz  $a0,.runInc
FFFC1744 00198513	  add   $a0,$s3,#1          ; increment run start pos
FFFC1748 FA000CE3	  bra   .nextPage
                        	.notAvailable:
                        	;	add		$a3,$a0,#'0'
                        	;	call	SerialPutChar
                        	;	stt		$s4,$4030
FFFC174C 001A0513	  add   $a0,$s4,#1
FFFC1750 20052313	  slt   $t1,$a0,#MEMSZ
FFFC1754 FA0316E3	  bnez  $t1,.nextPage
                        	.outOfMem:
FFFC1758 FFF06513	  ldi   $a0,#-1
FFFC175C 00000463	  bra   .xit
                        	.foundRun:
FFFC1760 0009E533	  mov   $a0,$s3
                        	.xit
FFFC1764 00012083	  ldt   $ra,[$sp]
FFFC1768 00412483	  ldt   $s1,4[$sp]
FFFC176C 00812903	  ldt   $s2,8[$sp]
FFFC1770 00C12983	  ldt   $s3,12[$sp]
FFFC1774 01012A03	  ldt   $s4,16[$sp]
FFFC1778 01410113	  add   $sp,$sp,#20
FFFC177C 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of pages and mark them all allocated.
                        	;
                        	; Parameters:
                        	;   $a0 = amount of memory to allocate
                        	; Returns:
                        	;   $a0 = pointer to memory, -1 if insufficient memory
                        	;------------------------------------------------------------------------------
                        	
                        	PAMAlloc:
FFFC1780 FF010113	  sub 	$sp,$sp,#16
FFFC1784 00112023	  stt   $ra,[$sp]
FFFC1788 00912223	  stt   $s1,4[$sp]
FFFC178C 01412423	  stt   $s4,8[$sp]
FFFC1790 01512623	  stt   $s5,12[$sp]
FFFC1794 06050663	  beqz  $a0,.outOfMem       ; request sensible?
FFFC1798 3FF50293	  add   $t0,$a0,#PAGESZ-1   ; round allocation up
FFFC179C 00A2D513	  srl   $a0,$t0,#LOG_PGSZ   ; convert size to pages
FFFC17A0 00056A33	  mov   $s4,$a0             ; $s4 = length of run in pages
FFFC17A4 30002283	  ldt   $t0,NPAGES          ; check number of pages of memory available
FFFC17A8 40A282B3	  sub   $t0,$t0,$a0
FFFC17AC 0402CA63	  bltz  $t0,.outOfMem
FFFC17B0 30502023	  stt   $t0,NPAGES          ; update the number of available pages
FFFC17B4 F1DFF0EF	  call  PAMFindRun
FFFC17B8 04054863	  bltz  $a0,.xit2
FFFC17BC 000564B3	  mov   $s1,$a0
FFFC17C0 000566B3	  mov   $a3,$a0
FFFC17C4 00056AB3	  mov   $s5,$a0             ; $s5 = start of run
                        	.markNext:
FFFC17C8 0006E533	  mov   $a0,$a3
FFFC17CC 002A2593	  slt   $a1,$s4,#2          ; if $s4 <= 1
FFFC17D0 0035C593	  xor   $a1,$a1,#3          ; $a1 = 3, 2 if end of run
FFFC17D4 128000EF	  call  PAMSetbitPair
FFFC17D8 00168693	  add   $a3,$a3,#1          ; increment page number
FFFC17DC FFFA0A13	  sub   $s4,$s4,#1          ; decrement length
FFFC17E0 FF4044E3	  bgtz  $s4,.markNext
FFFC17E4 00AA9513	  sll   $a0,$s5,#LOG_PGSZ   ; $a0 = physical address of page
                        	.xit:
FFFC17E8 00012083	  ldt   $ra,[$sp]
FFFC17EC 00412483	  ldt   $s1,4[$sp]
FFFC17F0 00812A03	  ldt   $s4,8[$sp]
FFFC17F4 00C12A83	  ldt   $s5,12[$sp]
FFFC17F8 01010113	  add   $sp,$sp,#16
FFFC17FC 00008067	  ret
                        	.outOfMem:
FFFC1800 FFF06513	  ldi   $a0,#-1
FFFC1804 FE0002E3	  bra   .xit
                        	  ; Failed to find a run so,
                        	  ; restore number of pages available
                        	.xit2:
FFFC1808 30002283		ldt		$t0,NPAGES
FFFC180C 014282B3		add		$t0,$t0,$s4
FFFC1810 30502023		stt		$t0,NPAGES
FFFC1814 FC000AE3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Free memory previously allocated with PAMAlloc.
                        	;
                        	; Parameters:
                        	;   $a0 = pointer to start of memory
                        	; Modifies:
                        	;   $a0,$t0,$t1,$t2,$t3,$t4
                        	; Returns:
                        	;   none
                        	;------------------------------------------------------------------------------
                        	
                        	PAMFree:
FFFC1818 FF410113	  sub   	$sp,$sp,#12
FFFC181C 00112023	  stt     $ra,[$sp]
FFFC1820 00912223	  stt     $s1,4[$sp]
FFFC1824 000564B3	  mov     $s1,$a0
FFFC1828 FFF808B7	  and     $a0,$a0,#$FFF803FF  ; check page 1kB aligned
FFFC182C 3FF88893
FFFC1830 00A8F533
FFFC1834 04051A63	  bnez    $a0,.xit
FFFC1838 00A4D513	  srl     $a0,$s1,#LOG_PGSZ   ; convert to page number
FFFC183C 00106E93	  ldi     $t4,#1
                        	.nextPage:
FFFC1840 000564B3	  mov     $s1,$a0
FFFC1844 108000EF	  call    PAMGetbitPair
FFFC1848 02050A63	  beqz    $a0,.endOfRun
FFFC184C 00352513	  slt     $a0,$a0,#3
FFFC1850 00051E63	  bnez    $a0,.lastPage
FFFC1854 0004E533	  mov     $a0,$s1
FFFC1858 00006593	  ldi     $a1,#0
FFFC185C 0A0000EF	  call    PAMSetbitPair
FFFC1860 00150493	  add     $s1,$a0,#1
FFFC1864 001E8E93	  add     $t4,$t4,#1
FFFC1868 FC000CE3	  bra     .nextPage  
                        	.lastPage:
FFFC186C 0004E533	  mov     $a0,$s1
FFFC1870 00006593	  ldi     $a1,#0
FFFC1874 088000EF	  call    PAMSetbitPair
FFFC1878 001E8E93	  add     $t4,$t4,#1
                        	.endOfRun:
FFFC187C 30002583	  ldt     $a1,NPAGES
FFFC1880 01D585B3	  add     $a1,$a1,$t4
FFFC1884 30B02023	  stt     $a1,NPAGES
                        	.xit:
FFFC1888 00012083	  ldt     $ra,[$sp]
FFFC188C 00412483	  ldt     $s1,4[$sp]
FFFC1890 00C10113	  add     $sp,$sp,#12
FFFC1894 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a single page of memory. Available memory is indicated by a bitmmap
                        	; called the PAM for page allocation map.
                        	;
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	; Returns:
                        	;		$a0 = page allocated
                        	;------------------------------------------------------------------------------
                        	;
                        	PAMMarkPage:
FFFC1898 FF810113		sub		$sp,$sp,#8
FFFC189C 00112023		stt		$ra,[$sp]
FFFC18A0 00912223		stt   $s1,4[$sp]
FFFC18A4 01006513		ldi   $a0,#OSPAGES
FFFC18A8 000564B3	  mov   $s1,$a0
                        	.0001:
FFFC18AC 0004E533	  mov   $a0,$s1
FFFC18B0 09C000EF		call  PAMGetbitPair
FFFC18B4 00050C63		beqz  $a0,.gotFree
FFFC18B8 00148493		add   $s1,$s1,#1
FFFC18BC 2004A293		slt   $t0,$s1,#MEMSZ
FFFC18C0 FE0296E3		bnez  $t0,.0001
FFFC18C4 00006513		ldi   $a0,#0
FFFC18C8 00000863		bra   .xit
                        	.gotFree:
FFFC18CC 0004E533	  mov   $a0,$s1
FFFC18D0 00206593	  ldi   $a1,#2          ; end of run bits
FFFC18D4 028000EF	  call  PAMSetbitPair
                        	.xit:
FFFC18D8 00012083		ldt		$ra,[$sp]
FFFC18DC 00412483		ldt   $s1,4[$sp]
FFFC18E0 00810113		add		$sp,$sp,#8
FFFC18E4 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = page number to free
                        	; Modifies:
                        	;		$a1,$t0,$t1,$t2,$t3
                        	;------------------------------------------------------------------------------
                        	
                        	PAMUnmarkPage:
FFFC18E8 1FF06393		ldi		$t2,#MEMSZ-1  			; last page is permanently allocated to system stack
FFFC18EC 04757E63		bgeu	$a0,$t2,PAMxit
FFFC18F0 01006393		ldi		$t2,#OSPAGES
FFFC18F4 04756A63		bltu	$a0,$t2,PAMxit			; first 64 pages (64kB) allocated permanently to system
FFFC18F8 00006593		ldi   $a1,#0
                        	; Tail recursion here
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = bit number to set
                        	;   $a1 = value to set 0,1,2 or 3
                        	; Does not modify:
                        	;   $a0, $a1
                        	; Modifies:
                        	;		$t0,$t1,$t2,$t3
                        	;------------------------------------------------------------------------------
                        	
                        	PAMSetbitPair:
FFFC18FC 00455393	  srl   $t2,$a0,#4          ; t2 = word
FFFC1900 00239393	  sll   $t2,$t2,#2          ; t2 = word index
FFFC1904 00F57E13	  and   $t3,$a0,#15         ; t3 = bit pair no
FFFC1908 001E1E13	  sll   $t3,$t3,#1          ; t3 = bit pair index
FFFC190C 00306293	  ldi   $t0,#3              ; make a bit mask
FFFC1910 01C292B3	  sll   $t0,$t0,$t3
FFFC1914 FFF2C293	  xor   $t0,$t0,#-1         ; get inverted mask
FFFC1918 01C595B3	  sll   $a1,$a1,$t3
FFFC191C 000018B7		ldt		$t1,PAM[$t2]        ; get word
FFFC1920 00088893
FFFC1924 007888B3
FFFC1928 0008A303
FFFC192C 005372B3		and		$t0,$t1,$t0					; clear bit
FFFC1930 00B2E2B3		or    $t0,$t0,$a1         ; set new bit status
FFFC1934 000018B7		stt		$t0,PAM[$t2]        ; store word
FFFC1938 00088893
FFFC193C 007888B3
FFFC1940 0058A023
FFFC1944 01C5D5B3		srl   $a1,$a1,$t3         ; restore $a1
                        	PAMxit:
FFFC1948 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = bit pair number to get
                        	; Modifies:
                        	;		$t0,$t2,$t3
                        	; Returns:
                        	;   $a0 = value of bit pair (0, 1, 2 or 3)
                        	;------------------------------------------------------------------------------
                        	
                        	PAMGetbitPair:
FFFC194C 00455393	  srl   $t2,$a0,#4          ; $t2 = word, bit pair num/16
FFFC1950 00239393	  sll   $t2,$t2,#2          ; $t2 = word index, 4 bytes per word
FFFC1954 00F57E13	  and   $t3,$a0,#15         ; $t3 = bit pair num in word = 0 to 15
FFFC1958 001E1E13	  sll   $t3,$t3,#1          ; $t3 = bit pair index
FFFC195C 000018B7		ldt		$t0,PAM[$t2]        ; get word
FFFC1960 00088893
FFFC1964 007888B3
FFFC1968 0008A283
FFFC196C 01C2D3B3		srl   $t2,$t0,$t3         ; extract bits
FFFC1970 0033F513		and   $a0,$t2,#3          ; return 0,1,2, or 3
FFFC1974 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	PAMInit:
FFFC1978 FFC10113	  sub 	$sp,$sp,#4
FFFC197C 00112023	  stt   $ra,[$sp]
                        	  ; First zero out the entire PAM using word stores
FFFC1980 00006513	  ldi   $a0,#0
                        	.0002:
FFFC1984 000018B7	  stt   $x0,PAM[$a0]
FFFC1988 00088893
FFFC198C 00A888B3
FFFC1990 0008A023
FFFC1994 00450513	  add   $a0,$a0,#4
FFFC1998 08052293	  slt   $t0,$a0,#32*4   ; 1024 bits = 128 bytes
FFFC199C FE0294E3	  bnez  $t0,.0002
                        	
                        	  ; Now set bits for preallocated memory pages
FFFC19A0 00F06513	  ldi   $a0,#OSPAGES-1  ; OS pages
FFFC19A4 00306593	  ldi   $a1,#3
                        	.0001:
FFFC19A8 F55FF0EF	  call  PAMSetbitPair
FFFC19AC FFF50513	  sub   $a0,$a0,#1
FFFC19B0 FE055CE3	  bge   $a0,$x0,.0001
FFFC19B4 00F06513	  ldi   $a0,#15         ; Last OS page
FFFC19B8 00206593	  ldi   $a1,#2          ; set mark end of run
FFFC19BC F41FF0EF	  call  PAMSetbitPair
FFFC19C0 00206593	  ldi   $a1,#2          ; end of run
FFFC19C4 1FF06513	  ldi   $a0,#MEMSZ-1    ; OS stack page
FFFC19C8 F35FF0EF	  call  PAMSetbitPair
FFFC19CC 1FE06513	  ldi   $a0,#MEMSZ-2    ; OS stack page
FFFC19D0 00306593	  ldi   $a1,#3          ; mid run
FFFC19D4 F29FF0EF	  call  PAMSetbitPair
FFFC19D8 1FD06513	  ldi   $a0,#MEMSZ-3    ; OS stack page
FFFC19DC F21FF0EF	  call  PAMSetbitPair
FFFC19E0 1FC06513	  ldi   $a0,#MEMSZ-4    ; OS stack page
FFFC19E4 F19FF0EF	  call  PAMSetbitPair
FFFC19E8 00012083	  ldt   $ra,[$sp]
FFFC19EC 00410113	  add   $sp,$sp,#4
FFFC19F0 00008067	  ret
                        	
                        	GetPamBit:
FFFC19F4 0005E533	  mov   $a0,$a1
FFFC19F8 F55FF0EF	  call  PAMGetbitPair
FFFC19FC 000565B3	  mov   $a1,$a0
FFFC1A00 00006513	  ldi   $a0,#E_Ok
FFFC1A04 49D0006F	  jmp   OSExit
                        	
                        	PAMDump:
FFFC1A08 FFC10113		sub		$sp,$sp,#4
FFFC1A0C 00112023		stt		$ra,[$sp]
FFFC1A10 00006493		ldi		$s1,#0
                        	.0001:
FFFC1A14 0004E533		mov		$a0,$s1
FFFC1A18 F35FF0EF		call	PAMGetbitPair
FFFC1A1C 03050693		add		$a3,$a0,#'0'
FFFC1A20 430000EF		call	SerialPutChar
FFFC1A24 00148493		add		$s1,$s1,#1
FFFC1A28 2004A313		slt		$t1,$s1,#MEMSZ
FFFC1A2C FE0314E3		bnez	$t1,.0001
FFFC1A30 00012083		ldt		$ra,[$sp]
FFFC1A34 00410113		add		$sp,$sp,#4
FFFC1A38 00008067		ret
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        	.file "../fmtk/serial.r5a",29
                        		code
FFFC1A3C 00000000		align	
                        	
                        	SerialFuncTbl:
FFFC1A40 FFFC1BF0		dw		SerialNOP			; no operation
FFFC1A44 00000000		dw		0							; setup
FFFC1A48 00000000		dw		0							; initialize
FFFC1A4C 00000000		dw		0							; status
FFFC1A50 00000000		dw		0							; media check
FFFC1A54 00000000		dw		0							; build BPB
FFFC1A58 00000000		dw		0							; open
FFFC1A5C 00000000		dw		0							; close
FFFC1A60 FFFC1CAC		dw		SerialGetChar	; get char
FFFC1A64 FFFC1D8C		dw		SerialPeekChar
FFFC1A68 00000000		dw		0							; get char direct
FFFC1A6C FFFC1DF4		dw		SerialPeekCharDirect	; peek char direct
FFFC1A70 00000000		dw		0							; input status
FFFC1A74 FFFC1E50		dw		SerialPutChar
FFFC1A78 00000000		dw		0							; reserved
FFFC1A7C 00000000		dw		0							; set position
FFFC1A80 00000000		dw		0							; read block
FFFC1A84 00000000		dw		0							; write block
FFFC1A88 00000000		dw		0							; verify block
FFFC1A8C 00000000		dw		0							; output status
FFFC1A90 00000000		dw		0							; flush input
FFFC1A94 00000000		dw		0							; flush output
FFFC1A98 FFFC1F0C		dw		SerialIRQ			; IRQ routine
FFFC1A9C 00000000		dw		0							; Is removable
FFFC1AA0 00000000		dw		0							; ioctrl read
FFFC1AA4 00000000		dw		0							; ioctrl write
FFFC1AA8 00000000		dw		0							; output until busy
FFFC1AAC FFFC1FF4		dw		SerialGetUI		; get ui flag
FFFC1AB0 00000000		dw		0
FFFC1AB4 00000000		dw		0
FFFC1AB8 00000000		dw		0
FFFC1ABC 00000000		dw		0							; 31
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	  align 8                        	
                        	SerialDCB:
FFFC1AC0 4D4F4304	  db    4,"COM1       "
FFFC1AC4 20202031
FFFC1AC8 20202020
FFFC1ACC 00000000	  dw    0     ; type
FFFC1AD0 00000000	  dw    0     ; nBPB
FFFC1AD4 00000000	  dw    0
FFFC1AD8 00000000	  dw    0     ; last error code
FFFC1ADC 00000000	  dw    0
                        	; 32
FFFC1AE0 00000000	  dw    0     ; starting block number
FFFC1AE4 00000000	  dw    0
FFFC1AE8 00000000	  dw    0     ; number of blocks
FFFC1AEC 00000000	  dw    0
FFFC1AF0 00000000	  dw    0     ; command processing routine
FFFC1AF4 00000000	  dw		0
FFFC1AF8 FFFC1F0C	  dw		SerialIRQ			; IRQ routine
FFFC1AFC 00000000	  dw    0
                        	;64
FFFC1B00 00010000	  db    0     ; reentrancy count
FFFC1B01 00000100	  db    0     ; single user flag
FFFC1B02 00000001	  db    1     ; user interface device flag
FFFC1B03 00000000	  db    0
FFFC1B04 00000000	  dw    0
FFFC1B08 00000000	  dw    0     ; hJob
FFFC1B0C 00000000	  dw    0
FFFC1B10 00000000	  dw    0     ; Mailbox handle
FFFC1B14 00000000	  dw    0
FFFC1B18 00000000	  dw    0     ; pointer to device semaphore
FFFC1B1C 00000000	  dw    0
                        	; 96
                        	;  dw    0     ; reserved
                        	;  dw    0
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC1B20 FFC10113		sub		$sp,$sp,#4
FFFC1B24 00112023		stt		$ra,[$sp]
FFFC1B28 00506513		ldi		$a0,#5							; serial device
FFFC1B2C FFFC25B7		ldi		$a1,#SerialFuncTbl
FFFC1B30 A4058593
FFFC1B34 795010EF		call	CopyDevFuncTbl
FFFC1B38 00506513		ldi		$a0,#5							; serial device
FFFC1B3C FFFC25B7		ldi   $a1,#SerialDCB
FFFC1B40 AC058593
FFFC1B44 7B5010EF		call  CopyDevDCB
FFFC1B48 000028B7		stt		$x0,SerHeadRcv
FFFC1B4C C0088893
FFFC1B50 000888B3
FFFC1B54 0008A023
FFFC1B58 000028B7		stt		$x0,SerTailRcv
FFFC1B5C C0488893
FFFC1B60 000888B3
FFFC1B64 0008A023
FFFC1B68 000028B7		stt		$x0,SerHeadXmit
FFFC1B6C C0888893
FFFC1B70 000888B3
FFFC1B74 0008A023
FFFC1B78 000028B7		stt		$x0,SerTailXmit
FFFC1B7C C0C88893
FFFC1B80 000888B3
FFFC1B84 0008A023
FFFC1B88 000028B7		stb		$x0,SerRcvXon
FFFC1B8C C1088893
FFFC1B90 000888B3
FFFC1B94 00088023
FFFC1B98 000028B7		stb		$x0,SerRcvXoff
FFFC1B9C C1188893
FFFC1BA0 000888B3
FFFC1BA4 00088023
FFFC1BA8 00906293		ldi		$t0,#$09						; dtr,rts active, rxint enabled, no parity
FFFC1BAC FFDC18B7		stt		$t0,UART+8
FFFC1BB0 A0888893
FFFC1BB4 000888B3
FFFC1BB8 0058A023
FFFC1BBC 000602B7		ldi		$t0,#$0006001E			; reset the fifo's
FFFC1BC0 01E28293
FFFC1BC4 FFDC18B7		stt		$t0,UART+12
FFFC1BC8 A0C88893
FFFC1BCC 000888B3
FFFC1BD0 0058A023
FFFC1BD4 01E06293		ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC1BD8 FFDC18B7		stt		$t0,UART+12
FFFC1BDC A0C88893
FFFC1BE0 000888B3
FFFC1BE4 0058A023
FFFC1BE8 00012083		ldt		$ra,[$sp]
FFFC1BEC 00410113		add		$sp,$sp,#4
                        	SerialNOP:
FFFC1BF0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialServiceInit:
FFFC1BF4 00106513		ldi		$a0,#1			; start task
FFFC1BF8 40006593		ldi		$a1,#1024		; memory required
FFFC1BFC FFFC2637		ldi		$a2,#SerialService
FFFC1C00 C0C60613
FFFC1C04 00000073		ecall
FFFC1C08 00008067		ret
                        	
                        	SerialService:
FFFC1C0C FD810113		sub		$sp,$sp,#40		; allocate stack for local vars
FFFC1C10 00E06513		ldi		$a0,#14				; get current tid
FFFC1C14 00000073		ecall
FFFC1C18 00016633		mov		$a2,$sp				; where to put mailbox handle
FFFC1C1C 000565B3		mov		$a1,$a0				; a1 = tid
FFFC1C20 00606513		ldi		$a0,#6				; alloc mailbox
FFFC1C24 00000073		ecall
                        	
                        	SerialServiceLoop:
                        	.0001:
FFFC1C28 00A06513		ldi		$a0,#10				; waitmsg
FFFC1C2C 00012583		lw		$a1,[$sp]			; mailbox handle
FFFC1C30 00410613		add		$a2,$sp,#4		; where to put D1
FFFC1C34 00810693		add		$a3,$sp,#8		; where to put D2
FFFC1C38 00C10713		add		$a4,$sp,#12		; where to put D3
FFFC1C3C FFF06793		ldi		$a5,#-1				; timeout
FFFC1C40 00000073		ecall
FFFC1C44 FE0512E3		bnez	$a0,.0001			; E_Ok?
                        	
FFFC1C48 00412283		lw		$t0,4[$sp]
FFFC1C4C 00812503		lw		$a0,8[$sp]
FFFC1C50 00C12583		lw		$a1,12[$sp]
FFFC1C54 01F2F293		and		$t0,$t0,#31		; command in bits 0 to 4 of D1
FFFC1C58 00129293		sll		$t0,$t0,#1
FFFC1C5C FFFC28B7		lw		$t0,SerialFuncTbl[$t0]
FFFC1C60 A4088893
FFFC1C64 005888B3
FFFC1C68 0008A283
FFFC1C6C FA028EE3		beqz	$t0,.0001
FFFC1C70 00028067		jmp		[$t0]
                        	
                        	SerialFinishCmd:
FFFC1C74 00412583		lw		$a1,4[$sp]		; reply mbx handle in bits 8 to 23 of D1
FFFC1C78 0085D593		srl		$a1,$a1,#8
FFFC1C7C 000108B7		and		$a1,$a1,#$FFFF
FFFC1C80 FFF88893
FFFC1C84 00B8F5B3
FFFC1C88 00158593		add		$a1,$a1,#1		; -1 = no reply requested
FFFC1C8C 00058E63		beqz	$a1,.0001
FFFC1C90 FFF58593		sub		$a1,$a1,#1		; $a1 = mailbox handle again
FFFC1C94 00906513		ldi		$a0,#9				; sendmsg
FFFC1C98 FFF06613		ldi		$a2,#-1
FFFC1C9C FFF06693		ldi		$a3,#-1
FFFC1CA0 FFF06713		ldi		$a4,#-1
FFFC1CA4 00000073		ecall
                        	.0001:
FFFC1CA8 F81FF06F		jmp		SerialServiceLoop
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialGetChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. If the buffer is almost empty then send an
                        	; XON.
                        	;
                        	; Stack Space:
                        	;		4 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   $v0 = E_Ok
                        	;		$v1 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialGetChar:
FFFC1CAC FF010113		sub		$sp,$sp,#16
FFFC1CB0 00112023		stt		$ra,[$sp]
FFFC1CB4 00912423		stt		$s1,8[$sp]          ; XON status
FFFC1CB8 01212623		stt   $s2,12[$sp]         ; interrupt state
FFFC1CBC 000028B7		ldb		$s1,SerRcvXon				; skip sending XON if already sent
FFFC1CC0 C1088893
FFFC1CC4 000888B3
FFFC1CC8 00088483
FFFC1CCC 7C40F973		csrrc	$s2,#$7C4,#1				; disable interrupts
FFFC1CD0 200000EF		call	SerialRcvCount			; check number of chars in receive buffer
FFFC1CD4 00852513		slt		$a0,$a0,#8					; less than 8?
FFFC1CD8 02050E63		beqz	$a0,.0002
FFFC1CDC 02049C63		bnez	$s1,.0002           ; XON already sent?
FFFC1CE0 01106513		ldi		$a0,#XON						; if <8 send an XON
FFFC1CE4 000028B7		stb		$x0,SerRcvXoff			; clear XOFF status
FFFC1CE8 C1188893
FFFC1CEC 000888B3
FFFC1CF0 00088023
FFFC1CF4 000028B7		stb		$a0,SerRcvXon				; flag so we don't send it multiple times
FFFC1CF8 C1088893
FFFC1CFC 000888B3
FFFC1D00 00A88023
FFFC1D04 FFDC18B7		stb		$a0,UART+UART_TRB
FFFC1D08 A0088893
FFFC1D0C 000888B3
FFFC1D10 00A88023
                        	.0002:
FFFC1D14 000028B7		ldbu	$a1,SerHeadRcv			; check if anything is in buffer
FFFC1D18 C0088893
FFFC1D1C 000888B3
FFFC1D20 0008C583
FFFC1D24 000028B7		ldbu	$a0,SerTailRcv
FFFC1D28 C0488893
FFFC1D2C 000888B3
FFFC1D30 0008C503
FFFC1D34 02B50863		beq		$a0,$a1,.noChars		; no?
FFFC1D38 000018B7		ldb		$a0,SerRcvBuf[$a1]	; get byte from buffer
FFFC1D3C 40088893
FFFC1D40 00B888B3
FFFC1D44 00088503
FFFC1D48 00158593		add		$a1,$a1,#1					; update head index
FFFC1D4C 0FF5F593		and   $a1,$a1,#255        ; ring buffer wrapping
FFFC1D50 000028B7		stb		$a1,SerHeadRcv
FFFC1D54 C0088893
FFFC1D58 000888B3
FFFC1D5C 00B88023
FFFC1D60 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC1D64 FFF06513		ldi		$a0,#-1
                        	.xit:
FFFC1D68 000565B3	  mov   $a1,$a0
FFFC1D6C 00006513	  ldi   $a0,#E_Ok
FFFC1D70 7C491073		csrrw	$x0,#$7C4,$s2				; restore interrupts
FFFC1D74 0040F073		csrrc $x0,#$004,#1
FFFC1D78 00012083		ldt		$ra,[$sp]
FFFC1D7C 00812483		ldt		$s1,8[$sp]
FFFC1D80 00C12903		ldt   $s2,12[$sp]
FFFC1D84 01010113		add		$sp,$sp,#16
FFFC1D88 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. But don't update the buffer indexes. No need
                        	; to send an XON here.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   $v0 = E_Ok
                        	;		$v1 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC1D8C FF810113		sub		$sp,$sp,#8
FFFC1D90 00112023		stt		$ra,[$sp]
FFFC1D94 00912223		stt		$s1,4[$sp]
FFFC1D98 7C40F4F3		csrrc	$s1,#$7C4,#1				; disable interrupts
FFFC1D9C 000028B7		ldbu	$a1,SerHeadRcv			; check if anything is in buffer
FFFC1DA0 C0088893
FFFC1DA4 000888B3
FFFC1DA8 0008C583
FFFC1DAC 000028B7		ldbu	$a0,SerTailRcv
FFFC1DB0 C0488893
FFFC1DB4 000888B3
FFFC1DB8 0008C503
FFFC1DBC 00B50C63		beq		$a0,$a1,.noChars		; no?
FFFC1DC0 000018B7		ldb		$a0,SerRcvBuf[$a1]	; get byte from buffer
FFFC1DC4 40088893
FFFC1DC8 00B888B3
FFFC1DCC 00088503
FFFC1DD0 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC1DD4 FFF06513		ldi		$a0,#-1
                        	.xit
FFFC1DD8 000565B3	  mov   $a1,$a0
FFFC1DDC 00006513	  ldi   $a0,#E_Ok
FFFC1DE0 7C449073		csrrw	$x0,#$7C4,$s1				; restore interrupts
FFFC1DE4 00012083		ldt		$ra,[$sp]
FFFC1DE8 00412483		ldt		$s1,4[$sp]
FFFC1DEC 00810113		add		$sp,$sp,#8
FFFC1DF0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;		Get a character directly from the I/O port. This bypasses the input
                        	; buffer.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;   $v0 = E_Ok
                        	;		$v1 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekCharDirect:
FFFC1DF4 FF810113		sub		$sp,$sp,#8
FFFC1DF8 00112023		stt		$ra,[$sp]
FFFC1DFC 00912223		stt		$s1,4[$sp]
FFFC1E00 7C40F4F3		csrrc	$s1,#$7C4,#1				; disable interrupts
FFFC1E04 FFDC18B7		ldb		$a0,UART+UART_STAT
FFFC1E08 A0488893
FFFC1E0C 000888B3
FFFC1E10 00088503
FFFC1E14 00857513		and		$a0,$a0,#8					; look for Rx not empty
FFFC1E18 00050C63		beqz	$a0,.0001
FFFC1E1C FFDC18B7		ldb		$a1,UART+UART_TRB
FFFC1E20 A0088893
FFFC1E24 000888B3
FFFC1E28 00088583
FFFC1E2C 00000463		bra		.xit
                        	.0001:
FFFC1E30 FFF06593		ldi		$a1,#-1
                        	.xit:
FFFC1E34 00006513	  ldi   $a0,#E_Ok
FFFC1E38 7C449073		csrrw	$x0,#$7C4,$s1				; restore interrupts
FFFC1E3C 0040E073		csrrs $x0,#$004,#1
FFFC1E40 00012083		ldt		$ra,[$sp]
FFFC1E44 00412483		ldt		$s1,4[$sp]
FFFC1E48 00810113		add		$sp,$sp,#8
FFFC1E4C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty. The routine will attempt to transmit the char up to 
                        	; 10 times. If it still can't transmit the char then sleep is called and the
                        	; task is put to sleep for a tick. When it wakes up the routine continues to
                        	; try and send a character.
                        	;
                        	; Stack Space
                        	;		5 words
                        	; Parameters:
                        	;		$a3 = character to put
                        	; Modifies:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
FFFC1E50 FF010113		sub		$sp,$sp,#16
FFFC1E54 00A12023		stt		$a0,[$sp]
FFFC1E58 00112223		stt		$ra,4[$sp]
FFFC1E5C 00B12423		stt		$a1,8[$sp]
FFFC1E60 00912623		stt		$s1,12[$sp]
                        	.0002:
FFFC1E64 00A06593		ldi		$a1,#10
FFFC1E68 7C40F4F3		csrrc	$s1,#$7C4,#1				; disable interrupts
                        	.0001:
FFFC1E6C FFF58593		sub		$a1,$a1,#1
FFFC1E70 04058663		beqz	$a1,.goSleep
FFFC1E74 10300073		pfi												; poll for an interrupt here
FFFC1E78 FFDC18B7		ldb		$a0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC1E7C A0488893
FFFC1E80 000888B3
FFFC1E84 00088503
FFFC1E88 01057513		and		$a0,$a0,#16					; bit #4 of the status reg
FFFC1E8C FE0500E3		beqz	$a0,.0001				    ; branch if transmitter is not empty
FFFC1E90 FFDC18B7		stb		$a3,UART+UART_TRB		; send the byte
FFFC1E94 A0088893
FFFC1E98 000888B3
FFFC1E9C 00D88023
FFFC1EA0 7C449073		csrrw	$x0,#$7C4,$s1				; restore interrupt setting
FFFC1EA4 00012503		ldt		$a0,[$sp]
FFFC1EA8 00412083		ldt		$ra,4[$sp]
FFFC1EAC 00812583		ldt		$a1,8[$sp]
FFFC1EB0 00C12483		ldt		$s1,12[$sp]
FFFC1EB4 01010113		add		$sp,$sp,#16
FFFC1EB8 00008067		ret
                        	.goSleep:
FFFC1EBC 7C449073		csrrw	$x0,#$7C4,$s1				; restore interrupt setting
FFFC1EC0 00306513		ldi		$a0,#3							; ISleep function
FFFC1EC4 00106593		ldi		$a1,#1							; 1 tick
FFFC1EC8 718000EF		call  OSOCall
FFFC1ECC F8000CE3		bra		.0002
                        	
                        	;------------------------------------------------------------------------------
                        	; Calculate number of character in input buffer
                        	;------------------------------------------------------------------------------
                        	
                        	SerialRcvCount:
FFFC1ED0 000028B7		ldbu	$a0,SerTailRcv	; v0 = tail index
FFFC1ED4 C0488893
FFFC1ED8 000888B3
FFFC1EDC 0008C503
FFFC1EE0 000028B7		ldbu	$a1,SerHeadRcv	; v1 = head index
FFFC1EE4 C0088893
FFFC1EE8 000888B3
FFFC1EEC 0008C583
FFFC1EF0 40B502B3		sub		$t0,$a0,$a1
FFFC1EF4 0002D863		bge		$t0,$x0,.xit
FFFC1EF8 10006293		ldi		$t0,#256
FFFC1EFC 40B282B3		sub		$t0,$t0,$a1
FFFC1F00 00A282B3		add		$t0,$t0,$a0
                        	.xit:
FFFC1F04 0002E533		mov		$a0,$t0
FFFC1F08 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialIRQ:
                        	.nxtByte:
FFFC1F0C FFDC18B7		ldt		$a0,UART+UART_STAT	; check the status
FFFC1F10 A0488893
FFFC1F14 000888B3
FFFC1F18 0008A503
FFFC1F1C 00857293		and		$t0,$a0,#$08				; bit 3 = rx full
FFFC1F20 0C028863		beqz	$t0,.notRxInt
FFFC1F24 FFDC18B7		ldt		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC1F28 A0088893
FFFC1F2C 000888B3
FFFC1F30 0008A583
FFFC1F34 0145C393		xor   $t2,$a1,#CTRLT
FFFC1F38 00039863		bnez  $t2,.0001
FFFC1F3C 0005E4B3		mov   $s1,$a1
FFFC1F40 C45FE0EF		call  DumpTraceQueue
FFFC1F44 0004E5B3		mov   $a1,$s1
                        	.0001:
FFFC1F48 000028B7		ldbu	$t2,SerHeadRcv			; get buffer indexes
FFFC1F4C C0088893
FFFC1F50 000888B3
FFFC1F54 0008C383
FFFC1F58 000028B7		ldbu	$t3,SerTailRcv
FFFC1F5C C0488893
FFFC1F60 000888B3
FFFC1F64 0008CE03
FFFC1F68 000E6EB3		mov   $t4,$t3
FFFC1F6C 001E0E13		add		$t3,$t3,#1					; see if buffer full
FFFC1F70 0FFE7E13		and		$t3,$t3,#255
FFFC1F74 07C38E63		beq		$t2,$t3,.rxFull
FFFC1F78 000028B7		stb		$t3,SerTailRcv			; update tail pointer
FFFC1F7C C0488893
FFFC1F80 000888B3
FFFC1F84 01C88023
FFFC1F88 000018B7		stb		$a1,SerRcvBuf[$t4]	; store recieved byte in buffer
FFFC1F8C 40088893
FFFC1F90 01D888B3
FFFC1F94 00B88023
FFFC1F98 000028B7		ldb		$a0,SerRcvXoff			; check if xoff already sent
FFFC1F9C C1188893
FFFC1FA0 000888B3
FFFC1FA4 00088503
FFFC1FA8 F60512E3		bnez	$a0,.nxtByte
FFFC1FAC F25FF0EF		call	SerialRcvCount			; if more than 240 chars in buffer
FFFC1FB0 0F052513		slt		$a0,$a0,#240				; send an XOFF
FFFC1FB4 F4051CE3		bnez	$a0,.nxtByte
FFFC1FB8 01306513		ldi		$a0,#XOFF
FFFC1FBC 000028B7		stb		$x0,SerRcvXon				; clear XON status
FFFC1FC0 C1088893
FFFC1FC4 000888B3
FFFC1FC8 00088023
FFFC1FCC 000028B7		stb		$a0,SerRcvXoff			; set XOFF status
FFFC1FD0 C1188893
FFFC1FD4 000888B3
FFFC1FD8 00A88023
FFFC1FDC FFDC18B7		stb		$a0,UART+UART_TRB
FFFC1FE0 A0088893
FFFC1FE4 000888B3
FFFC1FE8 00A88023
FFFC1FEC F20000E3		bra		.nxtByte            ; check the status for another byte
                        	;	ldi		$a0,#$0B						; dtr,rts active, rxint disabled, no parity
                        	;	sw		$a0,UART+UART_CMD
                        	.rxFull:
                        	.notRxInt:
FFFC1FF0 30200073		mret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	SerialGetUI:
FFFC1FF4 00006513	  ldi   $a0,#E_Ok           ; no errors
FFFC1FF8 00106593	  ldi   $a1,#1              ; yes this is a UI device
FFFC1FFC 00008067	  ret
                        	
                        	nmeSerial:
FFFC2000 69726553		db		"Serial",0
FFFC2004 00006C61
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC2007 FC211C00		align	
                        	
                        	ViaFuncTbl:
FFFC2008 FFFC211C		dw		ViaNOP				; no operation
FFFC200C FFFC20E8		dw		ViaSetup			; setup
FFFC2010 00000000		dw		0							; initialize
FFFC2014 00000000		dw		0							; status
FFFC2018 00000000		dw		0							; media check
FFFC201C 00000000		dw		0							; build BPB
FFFC2020 00000000		dw		0							; open
FFFC2024 00000000		dw		0							; close
FFFC2028 00000000		dw		0							; get char
FFFC202C 00000000		dw		0							; Peek char
FFFC2030 00000000		dw		0							; get char direct
FFFC2034 00000000		dw		0							; peek char direct
FFFC2038 00000000		dw		0							; input status
FFFC203C 00000000		dw		0							; Put char
FFFC2040 00000000		dw		0							; reserved
FFFC2044 00000000		dw		0							; set position
FFFC2048 00000000		dw		0							; read block
FFFC204C 00000000		dw		0							; write block
FFFC2050 00000000		dw		0							; verify block
FFFC2054 00000000		dw		0							; output status
FFFC2058 00000000		dw		0							; flush input
FFFC205C 00000000		dw		0							; flush output
FFFC2060 FFFC2180		dw		ViaIRQ				; IRQ routine
FFFC2064 00000000		dw		0							; Is removable
FFFC2068 00000000		dw		0							; ioctrl read
FFFC206C 00000000		dw		0							; ioctrl write
FFFC2070 00000000		dw		0							; output until busy
FFFC2074 00000000		dw		0							; 27
FFFC2078 00000000		dw		0
FFFC207C 00000000		dw		0
FFFC2080 00000000		dw		0
FFFC2084 00000000		dw		0							; 31
                        	
                        	  align 8                        	
                        	ViaDCB:
FFFC2088 41495603	  db    3,"VIA        "
FFFC208C 20202020
FFFC2090 20202020
FFFC2094 00000000	  dw    0     ; type
FFFC2098 00000000	  dw    0     ; nBPB
FFFC209C 00000000	  dw    0
FFFC20A0 00000000	  dw    0     ; last error code
FFFC20A4 00000000	  dw    0
FFFC20A8 00000000	  dw    0     ; starting block number
FFFC20AC 00000000	  dw    0
FFFC20B0 00000000	  dw    0     ; number of blocks
FFFC20B4 00000000	  dw    0
FFFC20B8 00000000	  dw    0     ; command processing routine
FFFC20BC 00000000	  dw    0
FFFC20C0 00000000	  db    0     ; reentrancy count
FFFC20C1 00000000	  db    0     ; single user flag
FFFC20C2 00000000	  db    0     ; user interface device flag
FFFC20C3 00000000	  db    0
FFFC20C4 00000000	  dw    0
FFFC20C8 00000000	  dw    0     ; hJob
FFFC20CC 00000000	  dw    0
FFFC20D0 00000000	  dw    0     ; Mailbox handle
FFFC20D4 00000000	  dw    0
FFFC20D8 00000000	  dw    0     ; pointer to device semaphore
FFFC20DC 00000000	  dw    0
FFFC20E0 00000000	  dw    0     ; reserved
FFFC20E4 00000000	  dw    0
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	ViaSetup:
FFFC20E8 FFC10113		sub		$sp,$sp,#4
FFFC20EC 00112023		stt		$ra,[$sp]
FFFC20F0 00F06513		ldi		$a0,#15							; VIA device
FFFC20F4 FFFC25B7		ldi		$a1,#ViaFuncTbl
FFFC20F8 00858593
FFFC20FC 1CD010EF		call	CopyDevFuncTbl
FFFC2100 00F06513		ldi		$a0,#15							; VIA device
FFFC2104 FFFC25B7		ldi		$a1,#ViaDCB
FFFC2108 08858593
FFFC210C 1ED010EF		call	CopyDevDCB
FFFC2110 010000EF		call  ViaInit
FFFC2114 00012083		ldt		$ra,[$sp]
FFFC2118 00410113		add		$sp,$sp,#4
                        	ViaNOP:
FFFC211C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; ViaInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	; Initialize port A low order eight bits as output, the remaining bits as
                        	; input. Setup timer #3 as the system time slice (30ms).
                        	;------------------------------------------------------------------------------
                        	
                        	ViaInit:
FFFC2120 FFC10113		sub		$sp,$sp,#4
FFFC2124 00112023		stt		$ra,[$sp]
FFFC2128 FFDC0337		ldi		$t1,#VIA
FFFC212C 60030313
FFFC2130 0FF06293		ldi		$t0,#$000000FF      ; low eight bits output
FFFC2134 00532623		stt		$t0,VIA_DDRA[$t1]
FFFC2138 00106293		ldi		$t0,#1							; select timer 3 access
FFFC213C 025308A3		stb		$t0,VIA_PCR+1[$t1]
FFFC2140 000022B7		ldi		$t0,#$1F00
FFFC2144 F0028293
FFFC2148 02531623		stw		$t0,VIA_ACR[$t1]		; set timer 3 mode, timer 1/2 = 64 bit
FFFC214C 0016E2B7		ldi		$t0,#$0016E360			;	divider value for 33.333Hz (30 ms)
FFFC2150 36028293
FFFC2154 00532823		stt		$t0,VIA_T1CL[$t1]
FFFC2158 00032A23		stt		$x0,VIA_T1CH[$t1]		; trigger transfer to count registers
FFFC215C 004C52B7		ldi   $t0,#$004C4B40      ; divider value for 10 Hz (100 ms)
FFFC2160 B4028293
FFFC2164 02532023		stt   $t0,VIA_T2CL[$t1]
FFFC2168 02032223		stt   $x0,VIA_T2CH[$t1]
FFFC216C 1C006293		ldi		$t0,#$1C0						; emable timer3/timer2 interrupts
FFFC2170 02532C23		stt		$t0,VIA_IER[$t1]
FFFC2174 00012083		ldt		$ra,[$sp]
FFFC2178 00410113		add		$sp,$sp,#4
FFFC217C 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	ViaIRQ:
FFFC2180 FFDC0337		ldi		$t1,#VIA
FFFC2184 60030313
FFFC2188 03431283		ldw		$t0,VIA_IFR[$t1]    ; get the flag register
FFFC218C 0402F513		and   $a0,$t0,#$40        ; timer 2? (bit 6)
FFFC2190 02051C63		bnez  $a0,.timer2irq
                        	.0001:
FFFC2194 1002F513		and   $a0,$t0,#$100       ; timer 3? (bit 8)
FFFC2198 00051463		bnez  $a0,.timer3irq
FFFC219C 30200073		mret
                        	.timer3irq:
FFFC21A0 00106393		ldi		$t2,#1							; assume timer3, select timer 3 access
FFFC21A4 027308A3		stb		$t2,VIA_PCR+1[$t1]
FFFC21A8 01032383		ldt		$t2,VIA_T1CL[$t1]		; yes, clear interrupt
FFFC21AC 20802383		ldt		$t2,milliseconds
FFFC21B0 01E38393		add		$t2,$t2,#30
FFFC21B4 20702423		stt		$t2,milliseconds
FFFC21B8 20702023		stt		$t2,switchflag
FFFC21BC 00006513		ldi   $a0,#0
FFFC21C0 420000EF		call  OSOCall
FFFC21C4 30200073		mret
                        		; reset countdown to clear interrupt
                        	.timer2irq:
FFFC21C8 004C53B7		ldi   $t2,#$004C4B40      ; divider value for 10 Hz (100 ms)
FFFC21CC B4038393
FFFC21D0 02732023		stt   $t2,VIA_T2CL[$t1]
FFFC21D4 02032223		stt   $x0,VIA_T2CH[$t1]
FFFC21D8 0440E073		csrrs $x0,#$044,#1        ; set GC interrupt pending bit
FFFC21DC FA000CE3		bra   .0001               ; there might be a timer 3 irq too
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/task.r5a",25
                        		code
                        		align	4                        	
                        	OSCallTbl:
FFFC21E0 28F02820	  dh    SchedulerIRQ
FFFC21E2 2ED028F0	  dh    IStartTask
FFFC21E4 27602ED0	  dh    ISendMsg
FFFC21E6 239C2760	  dh    ISleep
                        	
                        	OSEcallTbl:
FFFC21E8 2A68239C		dh		FMTK_Initialize					; 0
FFFC21EA 2A702A68		dh		FMTK_StartTask					; 1
FFFC21EC 2A802A70		dh		FMTK_ExitTask
FFFC21EE 243C2A80		dh		FMTK_KillTask
FFFC21F0 280C243C		dh		FMTK_SetTaskPriority
FFFC21F2 2BA4280C		dh		FMTK_Sleep							; 5
FFFC21F4 2CE02BA4		dh		FMTK_AllocMbx
FFFC21F6 02CC2CE0		dh		FMTK_FreeMbx
FFFC21F8 2FB002CC		dh		FMTK_PostMsg
FFFC21FA 30902FB0		dh		FMTK_SendMsg
FFFC21FC 30803090		dh		FMTK_WaitMsg						; 10
FFFC21FE 31703080		dh		FMTK_PeekMsg
FFFC2200 33383170		dh		FMTK_StartApp           ; 12
FFFC2202 23B03338		dh		FMTK_ExitApp            ; 13
FFFC2204 3C4C23B0		dh		FMTK_GetCurrentTid
FFFC2206 33503C4C		dh		FMTK_TCBFinalizerExit   ; 15
FFFC2208 24683350		dh		FMTK_KillApp
FFFC220A 23FC2468		dh		FMTK_RunAsOS            ; 17
FFFC220C 243023FC		dh		FMTK_GetTaskAppId       ; 18
FFFC220E 37D82430		dh		FMTK_SetTaskId          ; 19
FFFC2210 385437D8		dh		FMTK_HasIOFocus					; 20
FFFC2212 38BC3854		dh		FMTK_SwitchIOFocus			; 21
FFFC2214 38C838BC		dh		FMTK_ReleaseIOFocus			; 22
FFFC2216 385C38C8		dh		FMTK_ForceReleaseIOFocus	; 23
FFFC2218 2478385C		dh		FMTK_RequestIOFocus			; 24
FFFC221A 39E82478		dh		FMTK_MapOSVars          ; 25
FFFC221C 3A3039E8		dh		FMTK_IO									; 26
FFFC221E 3A7C3A30		dh    FMTK_GetDCBField        ; 27
FFFC2220 24203A7C		dh    FMTK_SetDCBField        ; 28
FFFC2222 240C2420		dh    FMTK_GetAppTaskId       ; 29
FFFC2224 0000240C		dh    FMTK_SetTaskAppId       ; 30
FFFC2226 19F40000		dh    0
FFFC2228 16C419F4		dh    GetPamBit               ; 32
FFFC222A 04D016C4		dh    FetchMemoryWord         ; 33
FFFC222C 23C404D0		dh    Monitor                 ; 34
FFFC222E 23E023C4		dh    GetIRQFlag              ; 35
FFFC2230 000023E0		dh    SetIRQFlag              ; 36
FFFC2232 00000000		dh    0
FFFC2234 00000000		dh    0
FFFC2236 00000000		dh    0
FFFC2238 00000000		dh    0                       ; 40
FFFC223A 00000000		dh    0                       ; 41
FFFC223C 00000000		dh    0                       ; 42
FFFC223E 00000000		dh    0                       ; 43
FFFC2240 00000000		dh    0                       ; 44
FFFC2242 00000000		dh    0                       ; 45
FFFC2244 00000000		dh    0                       ; 46
FFFC2246 00000000		dh    0                       ; 47
                        	
                        	qToChk:
FFFC2248 01000000		db	0,0,0,1,0,0,2,1
FFFC224C 01020000
FFFC2250 01030000		db	0,0,3,1,0,0,2,1
FFFC2254 01020000
FFFC2258 01040000		db	0,0,4,1,0,0,2,1
FFFC225C 01020000
FFFC2260 01030000		db	0,0,3,1,0,0,2,1
FFFC2264 01020000
                        	
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTKInit:
FFFC2268 30002223		stt		$x0,QNDX
FFFC226C 2E002823		stt   $x0,APPID_POOL
FFFC2270 36002C23		stt   $x0,CHAINA0
FFFC2274 32002023		stt		$x0,missed_ticks
FFFC2278 00006293		ldi   $t0,#0
FFFC227C 7C229073		csrrw $x0,#CSR_TASKID,$t0   ; task id = 0
FFFC2280 22002023		stt   $x0,TaskNum
FFFC2284 32002423		stt		$x0,TimeoutList
FFFC2288 40002023		stt		$x0,HEADRDY0
FFFC228C 40002223		stt		$x0,HEADRDY1
FFFC2290 40002423		stt		$x0,HEADRDY2
FFFC2294 40002623		stt		$x0,HEADRDY3
FFFC2298 40002823		stt		$x0,HEADRDY4
FFFC229C 42002023		stt		$x0,TAILRDY0
FFFC22A0 42002223		stt		$x0,TAILRDY1
FFFC22A4 42002423		stt		$x0,TAILRDY2
FFFC22A8 42002623		stt		$x0,TAILRDY3
FFFC22AC 42002823		stt		$x0,TAILRDY4
                        	
FFFC22B0 000018B7		stt		$x0,IOFocusNdx
FFFC22B4 08088893
FFFC22B8 000888B3
FFFC22BC 0008A023
                        	
                        	  ; one out the register set last tid
FFFC22C0 000002B7	  ldi   $t0,#$FFFFFFFF
FFFC22C4 FFF28293
FFFC22C8 000018B7	  stt   $t0,RegsetTid
FFFC22CC 0F088893
FFFC22D0 000888B3
FFFC22D4 0058A023
FFFC22D8 000018B7	  stt   $t0,RegsetTid+4
FFFC22DC 0F488893
FFFC22E0 000888B3
FFFC22E4 0058A023
FFFC22E8 000018B7	  stt   $t0,RegsetTid+8
FFFC22EC 0F888893
FFFC22F0 000888B3
FFFC22F4 0058A023
FFFC22F8 000018B7	  stt   $t0,RegsetTid+12
FFFC22FC 0FC88893
FFFC2300 000888B3
FFFC2304 0058A023
                        	
                        		; zero out device function table
FFFC2308 000022B7		ldi		$t0,#DVF_Base
FFFC230C 00028293
FFFC2310 40006313		ldi		$t1,#32*32
                        	.0003:
FFFC2314 0002A023		stt		$x0,[$t0]
FFFC2318 00428293		add		$t0,$t0,#4
FFFC231C FFF30313		sub		$t1,$t1,#1
FFFC2320 FE604AE3		bgtz	$t1,.0003
                        	
                        		; Initialize free message list
FFFC2324 000018B7		stt		$x0,FreeMsg
FFFC2328 C0088893
FFFC232C 000888B3
FFFC2330 0008A023
                        	
                        		; Initialize mailboxes
FFFC2334 000018B7		stt   $x0,FreeMbx
FFFC2338 C0888893
FFFC233C 000888B3
FFFC2340 0008A023
FFFC2344 000018B7		stw   $x0,IdleTaskMbx
FFFC2348 C1088893
FFFC234C 000888B3
FFFC2350 00089023
FFFC2354 000018B7		stw   $x0,IdleTaskId
FFFC2358 C2A88893
FFFC235C 000888B3
FFFC2360 00089023
FFFC2364 000018B7		stb   $x0,MbxBlockCounter
FFFC2368 0E088893
FFFC236C 000888B3
FFFC2370 00088023
FFFC2374 00806293		ldi   $t0,#MBX_BLOCKPTR_BUFSZ
FFFC2378 00001337		ldi   $t1,#MbxBlockPtr
FFFC237C 0A030313
                        	.0001:
FFFC2380 00032023		stt   $x0,[$t1]
FFFC2384 00430313		add   $t1,$t1,#4
FFFC2388 FFF28293		sub   $t0,$t0,#1
FFFC238C FE029AE3		bnez  $t0,.0001
                        	
                        		; unlock the system semaphore	
                        		
FFFC2390 FFF06513		ldi		a0,#-1
FFFC2394 34A02023		stt		a0,SysSema
                        	
FFFC2398 00008067		ret
                        	
                        	FMTK_Initialize:
                        	  
FFFC239C 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC23A0 EC9FF0EF	call  FMTKInit
FFFC23A4 2FC0006F	  jmp   OSExit
                        	 
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	GetCurrentTid:
                        		
FFFC23A8 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC23AC 00008067	ret
                        	
                        	FMTK_GetCurrentTid:
                        	  
FFFC23B0 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
                        	
FFFC23B4 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC23B8 000565B3	mov		$a1,$a0
FFFC23BC 00006513		ldi		$a0,#E_Ok
FFFC23C0 2E00006F		jmp		OSExit
                        	
                        	GetIRQFlag:
                        	  
FFFC23C4 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC23C8 000018B7	ldt   $a1,IRQFlag
FFFC23CC 09088893
FFFC23D0 000888B3
FFFC23D4 0008A583
FFFC23D8 00006513	  ldi   $a0,#E_Ok
FFFC23DC 2C40006F	  jmp   OSExit
                        	
                        	SetIRQFlag:
                        	  
FFFC23E0 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC23E4 000018B7	stt   $a1,IRQFlag
FFFC23E8 09088893
FFFC23EC 000888B3
FFFC23F0 00B8A023
FFFC23F4 00006513	  ldi   $a0,#E_Ok
FFFC23F8 2A80006F	  jmp   OSExit
                        	
                        	; Accessors
                        	
                        	FMTK_GetTaskAppId:
FFFC23FC 00A59593	  sll   $a1,$a1,#LOG_PGSZ
FFFC2400 3425D583	  ldwu  $a1,TCBappid[$a1]
FFFC2404 00006513	  ldi   $a0,#E_Ok
FFFC2408 2980006F	  jmp   OSExit
                        	
                        	FMTK_SetTaskAppId:
FFFC240C 00A59593	  sll   $a1,$a1,#LOG_PGSZ
FFFC2410 34C59123	  stw   $a2,TCBappid[$a1]
FFFC2414 00A5D593	  srl   $a1,$a1,#LOG_PGSZ ; be nice, return what was passed
FFFC2418 00006513	  ldi   $a0,#E_Ok
FFFC241C 2840006F	  jmp   OSExit
                        	
                        	FMTK_GetAppTaskId:
FFFC2420 00A59593	  sll   $a1,$a1,#LOG_PGSZ
FFFC2424 3C05D583	  ldwu  $a1,ACBTask[$a1]
FFFC2428 00006513	  ldi   $a0,#E_Ok
FFFC242C 2740006F	  jmp   OSExit
                        	
                        	; The following only really needed by startup code, otherwise the task id
                        	; is completely managed by the OS.
                        	FMTK_SetTaskId:
                        	  ; Should get the id and see if it's currently zero (unset).
                        	  ; but this would be more code bloat.
FFFC2430 7C259073	  csrrw $x0,#CSR_TASKID,$a1
FFFC2434 00006513	  ldi   $a0,#E_Ok
FFFC2438 2680006F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Setting the task priority will take effect the next time the task is
                        	; scheduled.
                        	;
                        	; Parameters:
                        	;   $a1 = new priority to set
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SetTaskPriority:
                        	  
FFFC243C 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2440 00A51293	sll   $t0,$a0,#LOG_TCBSZ
FFFC2444 2CB284A3	  stb   $a1,TCBPriority[$t0]
FFFC2448 00006513	  ldi   $a0,#E_Ok
FFFC244C 2540006F	  jmp   OSExit
                        	.badTid:
FFFC2450 02806513	  ldi   $a0,#E_BadTid
FFFC2454 24C0006F	  jmp   OSExit
                        	.badPtr:
FFFC2458 000008B7	  call  FreeTID
FFFC245C 2EB880E7
FFFC2460 02706513	  ldi   $a0,#E_BadTcbPointer
FFFC2464 23C0006F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; RunAsOS
                        	;   Runs a piece of code as part of the OS. The code must return by jumping
                        	; to OSExit. Only certain tasks are allowed to run code this way.
                        	;
                        	; Parameters:
                        	;   $a1 = pointer to code to run
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_RunAsOS:
FFFC2468 0005E2B3	  mov   $t0,$a1
FFFC246C 00028067	  jmp   [$t0]
                        	.badFunc:
FFFC2470 00206513	  ldi   $a0,#E_Func
FFFC2474 22C0006F	  jmp   OSExit
                        	 
                        	;------------------------------------------------------------------------------
                        	; Map operating system variables into the app's address space.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;   $a0 = E_Ok if successful
                        	;   $a1 = virtual address space location of vars., -1 if unsuccessful
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_MapOSVars:
FFFC2478 00006513	  ldi   $a0,#0          ; OS app
FFFC247C 01006593	  ldi   $a1,#OSPAGES
FFFC2480 FD1FE0EF	  call  FindRun
FFFC2484 02054863	  bltz  $a0,.noMem
FFFC2488 00006293	  ldi   $t0,#0
FFFC248C 000565B3	  mov   $a1,$a0
                        	.mapMore:
FFFC2490 02A2800D	  mvmap $x0,$t0,$a0
FFFC2494 00128293	  add   $t0,$t0,#1
FFFC2498 00150513	  add   $a0,$a0,#1
FFFC249C 0102A313	  slt   $t1,$t0,#16
FFFC24A0 FE0318E3	  bnez  $t1,.mapMore
FFFC24A4 1FF5F593	  and   $a1,$a1,#$1FF
FFFC24A8 00A59593	  sll   $a1,$a1,#LOG_PGSZ
FFFC24AC 00006513	  ldi   $a0,#E_Ok
FFFC24B0 1F00006F	  jmp   OSExit
                        	.noMem:
FFFC24B4 FFF06593	  ldi   $a1,#-1
FFFC24B8 04706513	  ldi   $a0,#E_NoMem
FFFC24BC 1E40006F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready lists are searched in a circular
                        	; fashion beginning with the list identified indirectly by QNDX. There are
                        	; four ready lists to hold tasks of four different priorities. 
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		$a1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		$a0 = task id of task to run
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	SelectTaskToRun:
FFFC24C0 FFC10113	  sub   $sp,$sp,#4
FFFC24C4 00112023	  stt   $ra,[$sp]
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
                        	.checkAgain:
                        	  
FFFC24C8 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC24CC 30404583	ldbu	$a1,QNDX						; get index into que check table
FFFC24D0 00158593		add		$a1,$a1,#1					; increment it, and limit
FFFC24D4 01F5F593		and		$a1,$a1,#31
FFFC24D8 30B00223		stb		$a1,QNDX						; store back
FFFC24DC FFFC28B7		ldbu	$a1,qToChk[$a1]			; assume this will be valid
FFFC24E0 24888893
FFFC24E4 00B888B3
FFFC24E8 0008C583
FFFC24EC 00506393		ldi		$t2,#5							; 5 queues to check
                        	.nxtQ:
                        	  
FFFC24F0 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC24F4 00259593	sll		$a1,$a1,#2					; turn $a1 into index
FFFC24F8 4005A503	  ldt		$a0,HEADRDY[$a1]
FFFC24FC 0025D593	  srl		$a1,$a1,#2					; get back $a1
FFFC2500 02051E63	  bnez  $a0,.dq      				;
FFFC2504 00158593		add		$a1,$a1,#1					; no, advance to next queue
FFFC2508 0055A513		slt   $a0,$a1,#5
FFFC250C 00051463		bnez  $a0,.mod
FFFC2510 00006593		ldi   $a1,#0
                        	.mod:
FFFC2514 FFF38393		sub		$t2,$t2,#1					;
FFFC2518 FC704CE3		bgtz	$t2,.nxtQ				    ; go back to check next queue
                        		; Here, nothing else is actually ready to run?
                        		; -> Go to low power mode, stop clock, wait for interrupt
                        		; Then push the idle task which will search for other tasks
                        		; ready to run.
                        	;	ldi		$a3,#'T'
                        	;	call	SerialPutChar
FFFC251C 10100073		wfi
FFFC2520 000018B7		ldwu  $a0,IdleTaskId
FFFC2524 C2A88893
FFFC2528 000888B3
FFFC252C 0008D503
                        	;	beqz  $a0,.checkAgain
FFFC2530 00406593		ldi   $a1,#4
FFFC2534 649000EF	  call  InsertIntoReadyQueue
                        	;	pushq $a0,$a1
FFFC2538 F80008E3		bra   .checkAgain
                        	.dq:
                        	  ; If we got a task but it isn't actually ready anymore go back
                        	  ; and get another task. This is how tasks get removed from the
                        	  ; queue.
FFFC253C 2C850283	  ldb   $t0,TCBStatus[$a0]
FFFC2540 0012F293	  and   $t0,$t0,#TS_READY
                        	  ; Remove task from ready list
FFFC2544 31052303	  ldt   $t1,TCBNext[$a0]
FFFC2548 4065A023	  stt		$t1,HEADRDY[$a1]
FFFC254C F6028EE3	  beqz  $t0,.checkAgain
                        	  ; The task was ready and we removed it from the queue so put it back on the
                        	  ; queue.
                        	  ; The task's priority level may have been changed, so update accordingly.
FFFC2550 62D000EF	  call  InsertIntoReadyQueue
                        	.xit:
FFFC2554 00012083	  ldt   $ra,[$sp]
FFFC2558 00410113	  add   $sp,$sp,#4
FFFC255C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	;
                        	; Parameters:
                        	;		$s1 = pointer to TCB of outgoing context
                        	;		$s2 = pointer to TCB of incoming context
                        	; Must not modify:
                        	;   $t2
                        	; Modifies:
                        	;   $t0,$t1,$t3,$t4,$t5
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	SwapContext:
                        		; Save the operating mode
FFFC2560 7C401E73		csrrw $t3,#CSR_PMSTACK,$x0
FFFC2564 038E7E13		and   $t3,$t3,#$38
FFFC2568 35C48223		stb   $t3,TCBOpMode[$s1]
                        	
                        		; Switch to destination memory map
FFFC256C 34094503	  ldbu  $a0,TCBmid[$s2]
FFFC2570 01651513	  sll		$a0,$a0,#22					; shift into position
FFFC2574 18001373	  csrrw	$t1,#$180,$x0				; get satp
FFFC2578 F84008B7	  and		$t1,$t1,#$f83fffff	; mask off asid
FFFC257C FFF88893
FFFC2580 0068F333
FFFC2584 00A36333	  or		$t1,$t1,$a0					; set new asid
FFFC2588 18031073		csrrw	$x0,#$180,$t1				; set satp
FFFC258C 00A95513	  srl   $a0,$s2,#LOG_PGSZ
FFFC2590 7C251073		csrrw $x0,#CSR_TASKID,$a0
                        		; User map has now been switched
                        	
                        		; Select register set to return to
FFFC2594 7C301373		csrrw $t1,#CSR_RSSTACK,$x0
FFFC2598 C1F37313		and   $t1,$t1,#$FFFFFC1F
FFFC259C 00551293		sll   $t0,$a0,#5
FFFC25A0 00536333		or    $t1,$t1,$t0
FFFC25A4 7C331073		csrrw $x0,#CSR_RSSTACK,$t1
                        	
                        	  ; Setup return privilege mode
FFFC25A8 34494E03	  ldbu  $t3,TCBOpMode[$s2]
FFFC25AC 7C4012F3	  csrrw $t0,#CSR_PMSTACK,$x0
FFFC25B0 FC72F293	  and   $t0,$t0,#$FFFFFFC7
FFFC25B4 038E7E13	  and   $t3,$t3,#$38          ; four operating modes max
FFFC25B8 01C2E2B3	  or    $t0,$t0,$t3
FFFC25BC 7C429073	  csrrw $x0,#CSR_PMSTACK,$t0
                        	
                        		; Setup EPC to return to task
FFFC25C0 2C092E03	  ldt   $t3,TCBepc[$s2]
FFFC25C4 341E1073	  csrrw $x0,#CSR_MEPC,$t3
FFFC25C8 00008067		ret
                        	/*
	; Save outgoing register set in TCB
	csrrs	$x0,#CSR_REGSET,#4	  ; select prior register set for Rs2, epc
	stt		$x1,TCBxRA[$s1]
	stt		$x2,TCBxSP[$s1]
	stt		$x3,TCBxGP[$s1]
	stt		$x4,TCBxTP[$s1]
	stt		$x5,TCBxT0[$s1]
	stt		$x6,TCBxT1[$s1]
	stt		$x7,TCBxT2[$s1]
	stt		$x8,TCBxFP[$s1]
	stt		$x9,TCBxS1[$s1]
	stt		$x10,TCBxA0[$s1]
	stt		$x11,TCBxA1[$s1]
	stt		$x12,TCBxA2[$s1]
	stt		$x13,TCBxA3[$s1]
	stt		$x14,TCBxA4[$s1]
	stt		$x15,TCBxA5[$s1]
	stt		$x16,TCBxA6[$s1]
	stt		$x17,TCBxA7[$s1]
	stt		$x18,TCBxS2[$s1]
	stt		$x19,TCBxS3[$s1]
	stt		$x20,TCBxS4[$s1]
	stt		$x21,TCBxS5[$s1]
	stt		$x22,TCBxS6[$s1]
	stt		$x23,TCBxS7[$s1]
	stt		$x24,TCBxS8[$s1]
	stt		$x25,TCBxS9[$s1]
	stt		$x26,TCBxS10[$s1]
	stt		$x27,TCBxS11[$s1]
	stt		$x28,TCBxT3[$s1]
	stt		$x29,TCBxT4[$s1]
	stt		$x30,TCBxT5[$s1]
	stt		$x31,TCBxT6[$s1]
	csrrc	$x0,#CSR_REGSET,#31   ; restore register set selections
	csrrw $t3,#CSR_MEPC,$x0
	stt   $t3,TCBepc[$s1]
	; Save the operating mode
	csrrw $t3,#CSR_PMSTACK,$x0
	and   $t3,$t3,#$38
	stb   $t3,TCBOpMode[$s1]

	; Now save off segment registers
	ldi		$t1,#0
.svseg:
	mvseg	$t0,$x0,$t1
	sll		$t3,$t1,#2
	add		$t3,$t3,$s1
	stt		$t0,TCBbases[$t3]
	add		$t1,$t1,#1
	and		$t1,$t1,#15
	bnez	$t1,.svseg

	; Switch memory maps
;	srl		$v0,$a1,#10					; convert pointer to tid
;	and		$v0,$v0,#$F					; mask to 16 task
  ldbu  $a0,TCBmid[$s2]
  sll		$a0,$a0,#22					; shift into position
  csrrw	$t1,#$180,$x0				; get satp
  and		$t1,$t1,#$f83fffff	; mask off asid
  or		$t1,$t1,$a0					; set new asid
	csrrw	$x0,#$180,$t1				; set satp
  srl   $a0,$s2,#LOG_PGSZ
	csrrw $x0,#CSR_TASKID,$a0
	; User map has now been switched

	; Restore segment register set
	ldi		$t1,#0
.rsseg:
	sll		$t3,$t1,#2
	add		$t3,$t3,$s2
	ldt		$t0,TCBbases[$t3]
	mvseg	$x0,$t0,$t1
	add		$t1,$t1,#1
	and		$t1,$t1,#15
	bnez	$t1,.rsseg

  ; Setup return privilege mode
  ldbu  $t3,TCBOpMode[$s2]
  csrrw $t0,#CSR_PMSTACK,$x0
  and   $t0,$t0,#$FFFFFFC7
  and   $t3,$t3,#$38          ; four operating modes max
  or    $t0,$t0,$t3
  csrrw $x0,#CSR_PMSTACK,$t0

.0005:
	; Restore incoming registers
	ldbu  $t0,TCBRegset[$s2]
	csrrw $t1,#CSR_RSSTACK,$x0
	and   $t1,$t1,#$FFFFFC1F
	sll   $t0,$t0,#5
	or    $t1,$t1,$t0
	csrrw $x0,#CSR_RSSTACK,$t1
	; We can skip over a bunch of load operations if the last task to use the
	; register set is the same task that wants it. In that event there are no
	; registers to reload other than the return value ones.
	srl   $t0,$t0,#4              ; position $t0 as index
	ldbu  $t1,RegsetTid[$t0]
	beq   $t1,$t0,.0001:
	stb   $t0,RegsetTid[$t0]      ; flag as the last user
	ldi   $t1,#1
	jmp   .0002
.0001:
  ldi   $t1,#0
.0002:
	csrrs $x0,#CSR_REGSET,#1      ; select task's register set
	; These two registers always need to be loaded so that the OS return values
	; can be transferred.
	ldt		$x2,TCBxSP[$s2]         ; manipulated by StartTask
	ldt		$x3,TCBxGP[$s2]         ; manipulated by StartApp
	ldt		$x10,TCBxA0[$s2]
	ldt		$x11,TCBxA1[$s2]
;	beqz  $t1,.skipCtxLoad
	ldt		$x1,TCBxRA[$s2]
	ldt		$x4,TCBxTP[$s2]
	ldt		$x5,TCBxT0[$s2]
	ldt		$x6,TCBxT1[$s2]
	ldt		$x7,TCBxT2[$s2]
	ldt		$x8,TCBxFP[$s2]
	ldt		$x9,TCBxS1[$s2]
	ldt		$x12,TCBxA2[$s2]
	ldt		$x13,TCBxA3[$s2]
	ldt		$x14,TCBxA4[$s2]
	ldt		$x15,TCBxA5[$s2]
	ldt		$x16,TCBxA6[$s2]
	ldt		$x17,TCBxA7[$s2]
	ldt		$x18,TCBxS2[$s2]
	ldt		$x19,TCBxS3[$s2]
	ldt		$x20,TCBxS4[$s2]
	ldt		$x21,TCBxS5[$s2]
	ldt		$x22,TCBxS6[$s2]
	ldt		$x23,TCBxS7[$s2]
	ldt		$x24,TCBxS8[$s2]
	ldt		$x25,TCBxS9[$s2]
	ldt		$x26,TCBxS10[$s2]
	ldt		$x27,TCBxS11[$s2]
	ldt		$x28,TCBxT3[$s2]
	ldt		$x29,TCBxT4[$s2]
	ldt		$x30,TCBxT5[$s2]
	ldt		$x31,TCBxT6[$s2]
.skipCtxLoad:
  ; Setup the EPC to return to the task
  ; Before the epc register is set we don't want any interrupts
  mDI
	csrrc	$x0,#CSR_REGSET,#15				; restore register set selection
  ldt   $t3,TCBepc[$s2]
  csrrw $x0,#CSR_MEPC,$t3
	ret
*/
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system ordinary call dispatcher.
                        	;------------------------------------------------------------------------------
FFFC25CC 00000000	  align 
                        	
FFFC25D0 434F534F	  db  "OSOCall",0
FFFC25D4 006C6C61
FFFC25D8 00000000	  align 1
FFFC25DC 00000000
                        	
                        	OSOCall:
FFFC25E0 00852293	  slt   $t0,$a0,#8
FFFC25E4 02028663		beqz  $t0,.badFunc
                        		; The function address table is compressed by assuming all the code is
                        		; located within the same 64kB block of memory. We're really saving bytes
                        		; here.
FFFC25E8 00A50533		add		$a0,$a0,$a0         ; shift left one bit, assume add might be faster
FFFC25EC FFFC28B7		ldwu  $t0,OSCallTbl[$a0]  ; get the low order 16 bits of the address
FFFC25F0 1E088893
FFFC25F4 00A888B3
FFFC25F8 0008D283
FFFC25FC 00028A63		beqz  $t0,.badFunc
FFFC2600 FFFC08B7		or    $t0,$t0,#$FFFC0000  ; add in the high order address bits
FFFC2604 00088893
FFFC2608 0058E2B3
FFFC260C 00028067		jmp		[$t0]
                        	.badFunc:
FFFC2610 00206513	  ldi   $a0,#E_Func
FFFC2614 00008067	  ret
                        	  
                        	;------------------------------------------------------------------------------
                        	; Operating system ecall dispatcher.
                        	; On entry machine registers are selected.
                        	;------------------------------------------------------------------------------
FFFC2618 00000000	  align 1
FFFC261C 00000000
                        	
                        	OSECALL:
FFFC2620 7C10E073	  csrrs $x0,#$7C1,#1    ; set OS running semaphore
                        	  
FFFC2624 10006293		ldi		$t0,#$100						; disable timer3 (time slice) interrupts
FFFC2628 FFDC08B7		stt		$t0,VIA_IER+VIA
FFFC262C 63888893
FFFC2630 000888B3
FFFC2634 0058A023
FFFC2638 00000013		nop                   ; make sure disable has time for effect
FFFC263C 00000013		nop
FFFC2640 7C016073	csrrs	$x0,#CSR_REGSET,#2  ; get register sets
FFFC2644 00056533		mov		$a0,$a0					; move user to machine
FFFC2648 0005E5B3		mov		$a1,$a1
FFFC264C 00066633		mov		$a2,$a2
FFFC2650 0006E6B3		mov		$a3,$a3
FFFC2654 00076733		mov		$a4,$a4
FFFC2658 0007E7B3		mov		$a5,$a5
FFFC265C 7C07F073		csrrc	$x0,#CSR_REGSET,#15 ; get back current registers for all
                        	  ; Enable other kinds of interrupts. While accessing the previous register set
                        	  ; we cannot be interrupted because the regset would be in flux.
                        	  
FFFC2660 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2664 02F52293	slt   $t0,$a0,#47     
FFFC2668 02028663		beqz  $t0,.badFunc
                        		; The function address table is compressed by assuming all the code is
                        		; located within the same 64kB block of memory. We're really saving bytes
                        		; here.
FFFC266C 00A50533		add		$a0,$a0,$a0     ; shift left one bit, assume add might be faster
FFFC2670 FFFC28B7		ldwu  $t0,OSEcallTbl[$a0] ; get the low order 16 bits of the address
FFFC2674 1E888893
FFFC2678 00A888B3
FFFC267C 0008D283
FFFC2680 00028A63		beqz  $t0,.badFunc
FFFC2684 FFFC08B7		or    $t0,$t0,#$FFFC0000  ; add in the high order address bits
FFFC2688 00088893
FFFC268C 0058E2B3
FFFC2690 00028067		jmp		[$t0]
                        	.badFunc:
FFFC2694 00206513	  ldi   $a0,#E_Func
FFFC2698 0080006F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit from the operating system. All operating system routines use this
                        	; fragment of code to return. Return values are transferred to the previously
                        	; active register set.
                        	;------------------------------------------------------------------------------
FFFC269C 00000000	  align 1
                        	
                        	OSExit:
                        	  
FFFC26A0 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC26A4 00000013	nop                       ; landing zone for interrupts
FFFC26A8 00000013	  nop
FFFC26AC 7C00E073		csrrs	$x0,#CSR_REGSET,#1		; get register sets
FFFC26B0 0005E5B3		mov		$a1,$a1							; move return values to user registers
FFFC26B4 00056533		mov		$a0,$a0
FFFC26B8 7C07F073		csrrc $x0,#CSR_REGSET,#15 ; restore register set selection
                        		
FFFC26BC 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC26C0 7C10F073	csrrc $x0,#$7C1,#1        ; clear OS running semaphore
                        		
FFFC26C4 1A0002B7		ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
FFFC26C8 18028293
FFFC26CC FFDC08B7		stt		$t0,VIA_IER+VIA
FFFC26D0 63888893
FFFC26D4 000888B3
FFFC26D8 0058A023
FFFC26DC 30200073	mret
                        	
                        	;------------------------------------------------------------------------------
                        	; Time accounting.
                        	; Update the length of time the task has been running.
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB
                        	; Modifies:
                        	;		t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	AccountTime:
                        	.again:
                        	;	csrrw	$t3,#$741,$x0					; get high time
                        	;	csrrw	$t2,#$701,$x0					; get low time
                        	;	csrrw	$t4,#$741,$x0
                        	;	bne		$t3,$t4,.again
FFFC26E0 33002383		ldt		$t2,Tick
FFFC26E4 2C74AC23		stt		$t2,TCBEndTick[$s1]
FFFC26E8 2D04AE03		ldt		$t3,TCBStartTick[$s1]
FFFC26EC 41C38EB3		sub		$t4,$t2,$t3						; end - start
FFFC26F0 3004AF03		ldt		$t5,TCBTicks[$s1]
FFFC26F4 01DF0F33		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC26F8 31E4A023		stt		$t5,TCBTicks[$s1]
FFFC26FC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; UpdateMsgFields
                        	;    Place message data in target address by calling PeekMsg().
                        	;
                        	; Parameters:
                        	;   $a0 = target tid
                        	;   $t2 = TCB status (updated)
                        	;   $s2 = target TCB to update
                        	; Modifies:
                        	;   $a1,$a2,$a3,$a4,$a5,$t3,$t4
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	UpdateMsgFields:
FFFC2700 FFC1310D	  gcsub $sp,$sp,#4
FFFC2704 00112023	  stt   $ra,[$sp]
FFFC2708 0083FE13	  and   $t3,$t2,#TS_WAITMSG
FFFC270C 040E0263	  beqz  $t3,.notWaiting
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC2710 00B06E13		ldi		$t3,#E_NoMsg						; setup to return E_NoMsg
FFFC2714 09C92823		stt		$t3,TCBxA0[$s2]					; in v0
FFFC2718 0043FE13		and		$t3,$t2,#TS_MSGRDY
FFFC271C 020E0663		beqz	$t3,.noMsg
FFFC2720 0005EEB3		mov   $t4,$a1                 ; save $a1
FFFC2724 09892583		ldt		$a1,TCBxA1[$s2]					; user a1 (x20)
FFFC2728 0A092603		ldt		$a2,TCBxA2[$s2]					; user a2 (x20)
FFFC272C 0A892683		ldt		$a3,TCBxA3[$s2]					; user a3 (x20)
FFFC2730 0B092703		ldt		$a4,TCBxA4[$s2]					; user a4 (x20)
FFFC2734 0B892783		ldt		$a5,TCBxA5[$s2]					; user a5 (x20)
FFFC2738 089000EF		call  PeekMsg
FFFC273C 000EE5B3		mov   $a1,$t4                 ; restore $a1
FFFC2740 00006E13		ldi		$t3,#E_Ok						    ; setup to return E_Ok
FFFC2744 09C92823		stt		$t3,TCBxA0[$s2]					; in a0
                        	.noMsg:
FFFC2748 FF33F393		and		$t2,$t2,#~(TS_WAITMSG|TS_MSGRDY)  ; mask out message ready status
	stb		$t2,TCBStatus[$s2]
FFFC274C 2C790423
                        	.notWaiting:
FFFC2750 00012083	  ldt   $ra,[$sp]
FFFC2754 00410113	  add   $sp,$sp,#4
FFFC2758 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
                        	; Passing a time of zero or less causes the function to return right away.
                        	;
                        	; Parameters:
                        	;		$a1 = length of time to sleep (must be >= 0)
                        	; Returns:
                        	;		$v0 = E_Ok
                        	;   $v1 = 1 = context switched, 0 = same context
                        	;------------------------------------------------------------------------------
FFFC275C 00000000	  align 1
                        	
                        	ISleep:
FFFC2760 FF410113	  sub 	$sp,$sp,#12
FFFC2764 00112023	  stt   $ra,[$sp]
FFFC2768 00912223	  stt   $s1,4[$sp]
FFFC276C 01212423	  stt   $s2,8[$sp]
FFFC2770 0805C263		bltz	$a1,.xit
                        		
FFFC2774 7C201573	  csrrw $a0,#CSR_TASKID,$x0
                        	;	beqz  $a0,.xit
FFFC2778 000564B3		mov   $s1,$a0
FFFC277C 0004E933		mov   $s2,$s1               ; for bad ppinter processing
FFFC2780 00058663		beqz	$a1,.0001             ; zero timeout?
FFFC2784 435000EF		call	RemoveFromReadyQueue
FFFC2788 441000EF		call	InsertIntoTimeoutList	; a1 = timeout
                        	.0001:
FFFC278C 2C84C503		ldbu	$a0,TCBStatus[$s1]		; flag task as no longer running
FFFC2790 F7F57513		and		$a0,$a0,#~TS_RUNNING
FFFC2794 2CA48423		stb		$a0,TCBStatus[$s1]
                        	
FFFC2798 F49FF0EF		call	AccountTime						; uses s1
FFFC279C D25FF0EF		call	SelectTaskToRun
FFFC27A0 00056933	  mov   $s2,$a0    						; $s2 = $a0 = tid
FFFC27A4 000048B7	  stt   $s2,$3F00
FFFC27A8 F0088893
FFFC27AC 000888B3
FFFC27B0 0128A023
FFFC27B4 2C894383		ldbu	$t2,TCBStatus[$s2]		; x2 = incoming status
FFFC27B8 0803E393		or		$t2,$t2,#TS_RUNNING	  ; set status = running
FFFC27BC 2C790423		stb   $t2,TCBStatus[$s2]
FFFC27C0 30892E03		ldt		$t3,TCBException[$s2]	;
FFFC27C4 000E0A63		beqz	$t3,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC27C8 09C92823		stt		$t3,TCBxA0[$s2]						; r1 = exception
FFFC27CC 30092423		stt		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC27D0 02D06E13		ldi		$t3,#45
FFFC27D4 09C92C23		stt		$t3,TCBxA1[$s2]						; r2 = 45
                        	.noException:
FFFC27D8 00006593		ldi   $a1,#0
FFFC27DC 01248663		beq		$s1,$s2,.noCtxSwitch	; incoming and outgoing contexts the same?
FFFC27E0 D81FF0EF		call	SwapContext
FFFC27E4 00106593		ldi   $a1,#1
                        	.noCtxSwitch:
FFFC27E8 F19FF0EF		call  UpdateMsgFields       ; must be after context is set
FFFC27EC 33002383		ldt		$t2,Tick						; get tick
FFFC27F0 2C74A823		stt		$t2,TCBStartTick[$s1]
                        	.xit:
FFFC27F4 00006513		ldi   $a0,#E_Ok
FFFC27F8 00012083	  ldt   $ra,[$sp]
FFFC27FC 00412483	  ldt   $s1,4[$sp]
FFFC2800 00812903	  ldt   $s2,8[$sp]
FFFC2804 00C10113	  add   $sp,$sp,#12
FFFC2808 00008067		ret
                        	
                        	FMTK_Sleep:
FFFC280C F55FF0EF	  call  ISleep
FFFC2810 E91FF06F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR. This routine will not
                        	; be invoked if the operating system is active.
                        	; Does not return anything.
                        	; The user mode task may be switched to the highest priority task.
                        	;------------------------------------------------------------------------------
FFFC2814 00000000	  align 1
FFFC2818 00000000
FFFC281C 00000000
                        	
                        	SchedulerIRQ:
                        		; See if the OS was interrupted.
FFFC2820 7C101573		csrrw $a0,#$7C1,$x0   ; Is the OS running?
FFFC2824 00157513		and   $a0,$a0,#1
FFFC2828 00050463		beqz  $a0,.noOS
FFFC282C 00008067		ret                   ; refuse to continue this function
                        	.noOS:
FFFC2830 FF410113		sub		$sp,$sp,#12
FFFC2834 00112023		stt		$ra,[$sp]
FFFC2838 00912223		stt   $s1,4[$sp]
FFFC283C 01212423		stt   $s2,8[$sp]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
                        	.0001:
FFFC2840 32802503		ldt		$a0,TimeoutList
FFFC2844 04050063		beqz	$a0,.toDone
FFFC2848 32052303		ldt		$t1,TCBTimeout[$a0]
FFFC284C FFF30313		sub		$t1,$t1,#1			; decrement timeouts for tasks on timeout list
FFFC2850 32652023		stt		$t1,TCBTimeout[$a0]
FFFC2854 00030463		beqz	$t1,.rmvFromTol
FFFC2858 02000663		bra		.toDone
                        	.rmvFromTol:
FFFC285C 2C854383		ldbu	$t2,TCBStatus[$a0]
FFFC2860 FE73F393		and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG) ; no longer timing out or waiting
	stb		$t2,TCBStatus[$a0]
FFFC2864 2C750423
FFFC2868 238000EF		call  MbxRemoveTask
FFFC286C 311000EF		call	InsertIntoReadyQueue
FFFC2870 31052303		ldt		$t1,TCBNext[$a0]
FFFC2874 32602423		stt		$t1,TimeoutList
FFFC2878 00030663		beqz	$t1,.toDone				; list empty?
FFFC287C 30032C23		stt		$x0,TCBPrev[$t1]
FFFC2880 FC0000E3		bra		.0001
                        	.toDone:
                        		
FFFC2884 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2888 000564B3	mov   $s1,$a0
                        	; Might need the following if the external timer isn't used.
                        	;	csrrw	$v0,#$701,$x0					; get the time
                        	;	add		$v0,$v0,#600000				; wait 600,000 cycles @20MHz (30ms)
                        	;	csrrw	$x0,#$321,$v0					; set next interrupt time
FFFC288C 33002F03		ldt		$t5,Tick							; update tick count
FFFC2890 001F0F13		add		$t5,$t5,#1
FFFC2894 33E02823		stt		$t5,Tick
FFFC2898 E49FF0EF		call	AccountTime
FFFC289C 2C84CF03		ldbu	$t5,TCBStatus[$s1]
FFFC28A0 020F6F13		or		$t5,$t5,#TS_PREEMPT
FFFC28A4 F7FF7F13		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC28A8 2DE48423		stb		$t5,TCBStatus[$s1]
                        		; The ready queue was just updated, there could be new tasks
                        		; ready to run.
FFFC28AC C15FF0EF		call	SelectTaskToRun
FFFC28B0 00056933	  mov   $s2,$a0
FFFC28B4 2C894E03		lbu		$t3,TCBStatus[$s2]	; t3 = incoming status
FFFC28B8 081E6393		or		$t2,$t3,#TS_RUNNING|TS_READY	; status = running
FFFC28BC FDF3F393		and   $t2,$t2,#~TS_PREEMPT
FFFC28C0 30892E03		ldt		$t3,TCBException[$s2]	;
FFFC28C4 000E0263		beqz	$t3,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
FFFC28C8 01248463		beq		$s1,$s2,.noCtxSwitch
FFFC28CC C95FF0EF		call	SwapContext
                        	.noCtxSwitch:
FFFC28D0 E31FF0EF		call  UpdateMsgFields       ; must be after context set
FFFC28D4 00012083		ldt		$ra,[$sp]
FFFC28D8 00412483		ldt   $s1,4[$sp]
FFFC28DC 00812903		ldt   $s2,8[$sp]
FFFC28E0 00C10113		add		$sp,$sp,#12
FFFC28E4 33002383		ldt		$t2,Tick					; get tick
FFFC28E8 2C74A823		stt		$t2,TCBStartTick[$s1] ;[$s1]
FFFC28EC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready queue. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;   $a1 = app id
                        	;		$a2 = memory required (task's local memory)
                        	;		$a3 = start pc (usually $400)
                        	;   $a4 = register set, operating mode
                        	;	Modifies:
                        	;	Returns:
                        	;		$a0 = E_Ok if successful
                        	;		$a1 = tid of started task if successful
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	IStartTask:
FFFC28F0 FE810113	  sub 	$sp,$sp,#24
FFFC28F4 00112023	  stt   $ra,[$sp]
FFFC28F8 00912223	  stt   $s1,4[$sp]
FFFC28FC 01212423	  stt   $s2,8[$sp]
FFFC2900 01312623	  stt   $s3,12[$sp]
FFFC2904 01412823	  stt   $s4,16[$sp]
FFFC2908 01512A23	  stt   $s5,20[$sp]
FFFC290C 0005E9B3	  mov   $s3,$a1       ; $s3 = app id
FFFC2910 00066933	  mov   $s2,$a2       ; $s2 = memory required
FFFC2914 0006EAB3	  mov   $s5,$a3       ; $s5 = start address
FFFC2918 40006513	  ldi   $a0,#1024     ; TCB is 1kB
FFFC291C E65FE0EF	  call  PAMAlloc      ; allocate storage for the TCB
FFFC2920 14054063		bltz	$a0,.err
FFFC2924 00056A33		mov   $s4,$a0
FFFC2928 00A55593		srl   $a1,$a0,#LOG_PGSZ
FFFC292C 32BA1C23	  stw   $a1,TCBtid[$s4]
FFFC2930 000564B3	  mov   $s1,$a0         ; $s1 = pointer to TCB
                        	;	call	FreeAll
                        	;	call	MapOSPages			; Map OS pages into address space
FFFC2934 0009E533	  mov   $a0,$s3         ; $a0 = app id
FFFC2938 34AA1123	  stw   $a0,TCBappid[$s4]
FFFC293C 00050663	  beqz  $a0,.appidZero
                        	  
FFFC2940 00A51513	  sll   $a0,$a0,#LOG_PGSZ
FFFC2944 3C450503	  ldb   $a0,ACBmid[$a0]
                        	.appidZero:
FFFC2948 34AA1023	  stw   $a0,TCBmid[$s4] ; record the mid
FFFC294C C35FE0EF		call	AllocStack
FFFC2950 10050863		beqz  $a0,.err
FFFC2954 200018B7		or		$t0,$a0,#$20000FFC	; set stack pointer
FFFC2958 FFC88893
FFFC295C 00A8E2B3
FFFC2960 0454A823		stt		$t0,TCBxSP[$s1]
FFFC2964 2D54A023		stt		$s5,TCBepc[$s1]	; address task will begin at
FFFC2968 00106293		ldi		$t0,#TS_READY
FFFC296C 2C548423		stb		$t0,TCBStatus[$s1]
FFFC2970 00206293		ldi		$t0,#2					; normal execution priority
FFFC2974 2C5484A3		stb		$t0,TCBPriority[$s1]
FFFC2978 3204A023		stt   $x0,TCBTimeout[$s1]
                        	
                        		; leave segment base at $0, flat memory model
FFFC297C 00606293		ldi		$t0,#6							; read,write
FFFC2980 00299513		sll		$a0,$s3,#2					; $a0 = appid shifted into place
FFFC2984 0055000D		mvseg	$x0,$a0,$t0
FFFC2988 00150513		add		$a0,$a0,#1
FFFC298C 0055000D		mvseg	$x0,$a0,$t0
FFFC2990 00150513		add		$a0,$a0,#1
FFFC2994 0055000D		mvseg	$x0,$a0,$t0
FFFC2998 00150513		add		$a0,$a0,#1
FFFC299C 0055000D		mvseg	$x0,$a0,$t0
                        		; Set bounds registers
FFFC29A0 FFF06293		ldi		$t0,#-1
FFFC29A4 08056513		or		$a0,$a0,#128
FFFC29A8 0FC57513		and		$a0,$a0,#$FC
FFFC29AC 0055000D		mvseg	$x0,$a0,$t0
FFFC29B0 00150513		add		$a0,$a0,#1
FFFC29B4 0055000D		mvseg	$x0,$a0,$t0
FFFC29B8 00150513		add		$a0,$a0,#1
FFFC29BC 0055000D		mvseg	$x0,$a0,$t0
FFFC29C0 00150513		add		$a0,$a0,#1
FFFC29C4 0055000D		mvseg	$x0,$a0,$t0
                        	
                        	;	srl		$a0,$s1,#LOG_TCBSZ	; need the tid again
FFFC29C8 3404A423	  stt   $x0,TCBMbxNext[$s1]
FFFC29CC 3404A823	  stt   $x0,TCBMbxPrev[$s1]
FFFC29D0 0004E533	  mov   $a0,$s1							; a0 = tid
FFFC29D4 01F77293	  and   $t0,$a4,#31
FFFC29D8 2C5485A3	  stb   $t0,TCBRegset[$s1]
FFFC29DC 03077293	  and   $t0,$a4,#$30
FFFC29E0 0082E293	  or    $t0,$t0,#$08        ; enable interrupts at startup
FFFC29E4 34548223	  stb   $t0,TCBOpMode[$s1]
FFFC29E8 2C048623	  stb   $x0,TCBHasFocus[$s1]
FFFC29EC 000008B7	  stt   $x0,IOF_NEXT[$s1]
FFFC29F0 30E88893
FFFC29F4 009888B3
FFFC29F8 0008A023
FFFC29FC 000008B7	  stt   $x0,IOF_PREV[$s1]
FFFC2A00 30F88893
FFFC2A04 009888B3
FFFC2A08 0008A023
FFFC2A0C 22002283	  ldt   $t0,TaskNum
FFFC2A10 3454AC23	  stt   $t0,TCBTaskNum[$s1]
FFFC2A14 00128293	  add   $t0,$t0,#1
FFFC2A18 22502023	  stt   $t0,TaskNum
                        	  ; Don't add the idle task to the queue.
FFFC2A1C FFF28293	  sub   $t0,$t0,#1
FFFC2A20 00029A63	  bnez  $t0,.notIdleTask
FFFC2A24 FFFC08B7	  stt   $a0,IdleTask
FFFC2A28 29088893
FFFC2A2C 000888B3
FFFC2A30 00A8A023
                        	.notIdleTask:
FFFC2A34 149000EF		call	InsertIntoReadyQueue
FFFC2A38 000565B3	  mov   $a1,$a0
FFFC2A3C 00006513		ldi   $a0,#E_Ok
                        	.xit:
FFFC2A40 00012083		ldt   $ra,[$sp]
FFFC2A44 00412483	  ldt   $s1,4[$sp]
FFFC2A48 00812903	  ldt   $s2,8[$sp]
FFFC2A4C 00C12983	  ldt   $s3,12[$sp]
FFFC2A50 01012A03	  ldt   $s4,16[$sp]
FFFC2A54 01412A83	  ldt   $s5,20[$sp]
FFFC2A58 01810113		add   $sp,$sp,#24
FFFC2A5C 00008067	  ret
                        	.err:
FFFC2A60 04706513	  ldi   $a0,#E_NoMem
FFFC2A64 FC000EE3	  bra   .xit
                        	
                        	FMTK_StartTask:
FFFC2A68 E89FF0EF	  call  IStartTask
FFFC2A6C C35FF06F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitTask:
                        		
FFFC2A70 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC2A74 000565B3	mov		$a1,$a0
                        		; fall through to KillTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
FFFC2A78 00000000	  align 1
FFFC2A7C 00000000
                        	
                        	FMTK_KillTask:
FFFC2A80 3585A283		ldt   $t0,TCBTaskNum[$a1]
FFFC2A84 00028A63		beqz	$t0,.immortal		    ; tid #0 is immortal (the system)
FFFC2A88 04006293		ldi		$t0,#TS_UNDEAD			; flag task as undead
FFFC2A8C 2C558423		stb		$t0,TCBStatus[$a1]
                        		; Move the task to the undead queue, it will no longer be selected by the
                        		; scheduler.
FFFC2A90 00706293		ldi   $t0,#UNDEADQ
FFFC2A94 2C5584A3		stb   $t0,TCBPriority[$a1]
                        	;	ldbu  $a0,TCBmid[$a1]
                        	;	call	FreeAll							; free all the memory associated with the task
                        	.immortal:
FFFC2A98 00006513		ldi		$a0,#E_Ok
FFFC2A9C C05FF06F		jmp		OSExit
                        	
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.r5a",34
                        		code  18 bits
                        	;------------------------------------------------------------------------------
                        	; Remove the task from the list of tasks waiting at the mailbox.
                        	;
                        	; Parameters:
                        	;		$a0 = task id
                        	;------------------------------------------------------------------------------
                        	  align  16                        	
                        	MbxRemoveTask:
FFFC2AA0 FEC10113		sub		$sp,$sp,#20
FFFC2AA4 00912023		stt		$s1,[$sp]
FFFC2AA8 00512223		stt		$t0,4[$sp]
FFFC2AAC 00612423		stt		$t1,8[$sp]
FFFC2AB0 00712623		stt		$t2,12[$sp]
FFFC2AB4 00A12823		stt   $a0,16[$sp]
                        		
FFFC2AB8 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC2ABC 35052283	ldt   $t0,TCBMbxPrev[$a0]
FFFC2AC0 34852303		ldt   $t1,TCBMbxNext[$a0]
FFFC2AC4 00028863		beqz  $t0,.atHead
FFFC2AC8 3462A423		stt   $t1,TCBMbxNext[$t0]
FFFC2ACC 34532823	  stt   $t0,TCBMbxPrev[$t1]
FFFC2AD0 02000E63	  bra   .xit
                        	.atHead:
FFFC2AD4 2CA51283		ldw		$t0,TCBWaitMbx[$a0]		; get mailbox handle
FFFC2AD8 02505A63		ble	  $t0,$x0,.xit  		    ; handle good?
FFFC2ADC 00A29293		sll		$t0,$t0,#LOG_PGSZ			; convert to pointer
FFFC2AE0 0042A303		ldt		$t1,MBX_TQHEAD[$t0]		; get waiting task list
FFFC2AE4 00030C63		beqz  $t1,.tqEmpty
FFFC2AE8 0082A303		ldt   $t1,MBX_TQTAIL[$t0]
FFFC2AEC 34A32423		stt   $a0,TCBMbxNext[$t1]
FFFC2AF0 34652823		stt   $t1,TCBMbxPrev[$a0]
FFFC2AF4 34052423		stt   $x0,TCBMbxNext[$a0]
FFFC2AF8 00000A63		bra   .xit
                        	.tqEmpty
FFFC2AFC 00A2A223		stt   $a0,MBX_TQHEAD[$t0]
FFFC2B00 00A2A423		stt   $a0,MBX_TQTAIL[$t0]
FFFC2B04 34052823		stt   $x0,TCBMbxPrev[$a0]
FFFC2B08 34052423		stt   $x0,TCBMbxNext[$a0]
                        	.xit:
                        	  
FFFC2B0C 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2B10 00012483	ldt		$s1,[$sp]
FFFC2B14 00412283		ldt		$t0,4[$sp]
FFFC2B18 00812303		ldt		$t1,8[$sp]
FFFC2B1C 00C12383		ldt		$t2,12[$sp]
FFFC2B20 01012503		ldt   $a0,16[$sp]
FFFC2B24 01410113		add		$sp,$sp,#20
FFFC2B28 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = app id of owner
                        	;		a2 = pointer where to store handle
                        	; Returns:
                        	;		a0 = E_Ok
                        	;------------------------------------------------------------------------------
FFFC2B2C 00000000	  align 1
                        	
                        	FMTK_AllocMbx_Old:
FFFC2B30 3000E073	  csrrs $x0,#$300,#1        ; enable interrupts
FFFC2B34 06060463		beq		$a2,$x0,.badArg
FFFC2B38 000012B7		ldi		$t0,#mbxs
FFFC2B3C 80028293
                        	  
FFFC2B40 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
                        	.nxt:
FFFC2B44 0002C303		lbu		$t1,MBX_OWNER[$t0]
FFFC2B48 00030E63		beq		$t1,$x0,.noOwner
FFFC2B4C 01428293		add		$t0,$t0,#MBX_SIZE
FFFC2B50 000018B7		slt		$t1,$t0,#mbxs_end
FFFC2B54 C0088893
FFFC2B58 FE0316E3		bne		$t1,$x0,.nxt
FFFC2B5C 04006513		ldi		$a0,#E_NoMoreMbx
FFFC2B60 B41FF06F		jmp   OSExit
                        	.noOwner:
FFFC2B64 00B28023		stb		$a1,MBX_OWNER[$t0]
FFFC2B68 0002A223		stt   $x0,MBX_TQHEAD[$t0]
FFFC2B6C 0002A423		stt   $x0,MBX_TQTAIL[$t0]
FFFC2B70 0002A623		stt   $x0,MBX_MQHEAD[$t0]
FFFC2B74 0002A823		stt   $x0,MBX_MQTAIL[$t0]
FFFC2B78 80028F13		sub		$t5,$t0,#mbxs				; convert pointer to handle
FFFC2B7C 005F5F13		srl		$t5,$t5,#5
FFFC2B80 0005E533		mov   $a0,$a1             ; $a0 = mid
FFFC2B84 000665B3		mov		$a1,$a2
FFFC2B88 B29FE0EF		call	VirtToPhys2
FFFC2B8C 01E51023		stw		$t5,[$a0]
                        	  
FFFC2B90 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2B94 00006513	ldi		$a0,#E_Ok
FFFC2B98 B09FF06F		jmp		OSExit
                        	.badArg:
FFFC2B9C 00106513		ldi		$a0,#E_Arg
FFFC2BA0 B01FF06F		jmp		OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; FMTK_AllocMbx
                        	;   Allocate a mailbox. Get the mailbox off the free list. If there are no
                        	; free mailboxes then allocate a block of new mailboxes.
                        	;
                        	; Parameters:
                        	;		$a1 = app id of owner
                        	; Returns:
                        	;		$a0 = E_Ok
                        	;   $a1 = mailbox handle
                        	;------------------------------------------------------------------------------
                        	FMTK_AllocMbx:
FFFC2BA4 000018B7	  ldt   $a0,FreeMbx
FFFC2BA8 C0888893
FFFC2BAC 000888B3
FFFC2BB0 0008A503
FFFC2BB4 0A051A63	  bnez  $a0,.gotMbx
                        	  ; no free mailboxes?
FFFC2BB8 40006513	  ldi   $a0,#1024         ; 1 page
FFFC2BBC BC5FE0EF	  call  PAMAlloc
FFFC2BC0 0E054C63	  bltz  $a0,.outOfMem
FFFC2BC4 000018B7	  ldbu  $t0,MbxBlockCounter
FFFC2BC8 0E088893
FFFC2BCC 000888B3
FFFC2BD0 0008C283
FFFC2BD4 00550E23	  stb   $t0,OBJCollectionIndex[$a0] ; store which index of the collection we are
FFFC2BD8 00229293	  sll   $t0,$t0,#2
FFFC2BDC 000018B7	  stt   $a0,MbxBlockPtr[$t0]
FFFC2BE0 0A088893
FFFC2BE4 005888B3
FFFC2BE8 00A8A023
FFFC2BEC 0022D293	  srl   $t0,$t0,#2
FFFC2BF0 00128293	  add   $t0,$t0,#1
FFFC2BF4 000018B7	  stb   $t0,MbxBlockCounter
FFFC2BF8 0E088893
FFFC2BFC 000888B3
FFFC2C00 00588023
FFFC2C04 02F06293	  ldi   $t0,#47           ; 48 mailboxes in block
                        	  ; Initialize object fields
FFFC2C08 204D4337	  ldi   $t1,#MBX_MAGIC
FFFC2C0C 25830313
FFFC2C10 00652023	  stt   $t1,OBJMagic[$a0]
FFFC2C14 3C006313	  ldi   $t1,#960
FFFC2C18 00652423	  stt   $t1,OBJSize[$a0]
FFFC2C1C 00050C23	  stb   $x0,OBJState[$a0]
FFFC2C20 00050CA3	  stb   $x0,OBJScavcnt[$a0]
FFFC2C24 00050D23	  stb   $x0,OBJOwningMap[$a0]
FFFC2C28 00000337	  ldi   $t1,#MbxFinalizer
FFFC2C2C 31C30313
FFFC2C30 02652823	  stt   $t1,OBJFinalizer[$a0]
                        	  
FFFC2C34 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC2C38 04050313	add   $t1,$a0,#64       ; point to first mailbox
FFFC2C3C 000018B7	  stt   $t1,FreeMbx
FFFC2C40 C0888893
FFFC2C44 000888B3
FFFC2C48 0068A023
FFFC2C4C 00036533	  mov   $a0,$t1
                        	.0001:
FFFC2C50 01430393	  add   $t2,$t1,#MBX_SIZE
FFFC2C54 00732223	  stt   $t2,MBX_LINK[$t1]
FFFC2C58 0003E333	  mov   $t1,$t2
FFFC2C5C FFF28293	  sub   $t0,$t0,#1
FFFC2C60 FE5048E3	  bgtz  $t0,.0001
FFFC2C64 00032223	  stt   $x0,MBX_LINK[$t1]
                        	.gotMbx:
FFFC2C68 00452283	  ldt   $t0,MBX_LINK[$a0]
FFFC2C6C 000018B7	  stt   $t0,FreeMbx
FFFC2C70 C0888893
FFFC2C74 000888B3
FFFC2C78 0058A023
FFFC2C7C 00052223	  stt   $x0,MBX_LINK[$a0]
FFFC2C80 00B50023		stb		$a1,MBX_OWNER[$a0]
FFFC2C84 00052223		stt   $x0,MBX_TQHEAD[$a0]
FFFC2C88 00052423		stt   $x0,MBX_TQTAIL[$a0]
FFFC2C8C 00052623		stt   $x0,MBX_MQHEAD[$a0]
FFFC2C90 00052823		stt   $x0,MBX_MQTAIL[$a0]
                        		; Create an id that is a hash code representing the location of the mailbox.
                        		; Given the hash code the mailbox pointer can be recreated easily.
FFFC2C94 C0057293		and   $t0,$a0,#$FFFFFC00    ; get pointer to block object
FFFC2C98 01C2C303		ldbu  $t1,OBJCollectionIndex[$t0]
                        		
FFFC2C9C 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2CA0 3FF57393	and   $t2,$a0,#$3FF         ; get offset of mailbox in block
FFFC2CA4 00A31313		sll   $t1,$t1,#10           ; make an id hash
FFFC2CA8 007365B3		or    $a1,$t1,$t2
FFFC2CAC 0025D593		srl   $a1,$a1,#2            ; 2 LSB's will be zero
FFFC2CB0 00006513	  ldi   $a0,#E_Ok
FFFC2CB4 9EDFF06F	  jmp   OSExit
                        	.outOfMem:
FFFC2CB8 04706513	  ldi   $a0,#E_NoMem
FFFC2CBC 9E5FF06F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Dequeue any waiting tasks returning to them a E_NoMsg status and removing
                        	; them from the timeout list as well. Then move any messages that are queued
                        	; back to the free message list.
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	FMTK_FreeMbx_Old:
FFFC2CC0 3000E073	  csrrs $x0,#$300,#1        ; enable interrupts
FFFC2CC4 0205A493		slt		$s1,$a1,#32
FFFC2CC8 E4048B63		beq		$s1,$x0,.badMbx
FFFC2CCC 00459493		sll		$s1,$a1,#4					; convert handle to pointer
FFFC2CD0 000018B7		add		$s1,$s1,#mbxs
FFFC2CD4 80088893
FFFC2CD8 009884B3
FFFC2CDC 04000C63		bra   FreeMbx1
                        	
                        	  align 16                        	
                        	FMTK_FreeMbx:
FFFC2CE0 0005E533	  mov   $a0,$a1
                        	  
FFFC2CE4 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC2CE8 00229293	  sll   $t0,$t0,#2
FFFC2CEC 000018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC2CF0 0A088893
FFFC2CF4 005888B3
FFFC2CF8 0008A283
FFFC2CFC 0FF57513	  and   $a0,$a0,#$FF
FFFC2D00 00251513	  sll   $a0,$a0,#2
FFFC2D04 00556533	  or    $a0,$a0,$t0
                        	
FFFC2D08 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC2D0C 000018B7	ldt   $t0,FreeMbx
FFFC2D10 C0888893
FFFC2D14 000888B3
FFFC2D18 0008A283
FFFC2D1C 00552223	  stt   $t0,MBX_LINK[$a0]
FFFC2D20 000018B7	  stt   $a0,FreeMbx
FFFC2D24 C0888893
FFFC2D28 000888B3
FFFC2D2C 00A8A023
                        	
FFFC2D30 000564B3	  mov   $s1,$a0
                        	FreeMbx1:
FFFC2D34 00006913		ldi		$s2,#0
FFFC2D38 02006A13		ldi		$s4,#NTASK							; possibly 32 tasks
FFFC2D3C 0044AB03		ldt		$s6,MBX_TQHEAD[$s1]
                        	.0002:
FFFC2D40 040B0263		beqz	$s6,.0001
FFFC2D44 2C8B4383		ldbu	$t2,TCBStatus[$s6]
FFFC2D48 FF73F393		and		$t2,$t2,#~TS_WAITMSG	; no longer waiting
FFFC2D4C 2C7B0423		stb		$t2,TCBStatus[$s6]
FFFC2D50 0103F393		and		$t2,$t2,#TS_TIMEOUT   ; Is the task timing out?
FFFC2D54 358B2503		ldt   $a0,TCBTaskNum[$s6]
FFFC2D58 00038463		beqz	$t2,.0003
FFFC2D5C 1005000D		setto	$a0,$x0           ; Remove from the timeout list
.0003:
FFFC2D60 338B5503	  ldwu  $a0,TCBtid[$s6]
FFFC2D64 618000EF		call	InsertIntoReadyQueue
FFFC2D68 00B06393		ldi		$t2,#E_NoMsg					; but no message
FFFC2D6C 087B2823		stt		$t2,TCBxA0[$s6]	; a0 = E_NoMsg
FFFC2D70 348B2A83		ldt   $s5,TCBMbxNext[$s6]
FFFC2D74 340B2423		stt   $x0,TCBMbxNext[$s6]
FFFC2D78 340B2823		stt   $x0,TCBMbxPrev[$s6]
FFFC2D7C 000AEB33		mov   $s6,$s5
FFFC2D80 FC0000E3		bra   .0002
                        	.0001:
FFFC2D84 0004A223	  stt   $x0,MBX_TQHEAD[$s1]
FFFC2D88 0004A423	  stt   $x0,MBX_TQTAIL[$s1]
                        	  ; Now free any messages queued at the mailbox. We are crafty here and
                        	  ; don't follow any links. Instead the entire chain of messages queued
                        	  ; is transferred to the free message list.
FFFC2D8C 0104AB03	  ldt   $s6,MBX_MQTAIL[$s1] ; get pointer to last message
FFFC2D90 000018B7	  ldt   $s5,FreeMsg
FFFC2D94 C0088893
FFFC2D98 000888B3
FFFC2D9C 0008AA83
FFFC2DA0 015B2023	  stt   $s5,MSG_LINK[$s6]   ; link current free list onto it
FFFC2DA4 00C4AB03	  ldt   $s6,MBX_MQHEAD[$s1]
FFFC2DA8 000018B7	  stt   $s6,FreeMsg         ; set new head of free list
FFFC2DAC C0088893
FFFC2DB0 000888B3
FFFC2DB4 0168A023
                        	  
FFFC2DB8 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2DBC 00006513	ldi		$a0,#E_Ok
FFFC2DC0 8E1FF06F		jmp		OSExit
                        	.badMbx:
FFFC2DC4 00406513		ldi		$a0,#E_BadMbx				; return null pointer if bad mailbox
FFFC2DC8 8D9FF06F		jmp		OSExit
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; AllocMsg
                        	;
                        	; This internally used routine to provide message space to store data in.
                        	; First the free list is checked to see if any messages are available.
                        	; If there are no message available then a block of 48 messages is allocated
                        	; and added to the free list. 48 messages fit nicely into a 1kB memory page.
                        	;
                        	; Parameters:
                        	;   none
                        	; Returns:
                        	;   $a0 = status (E_Ok)
                        	;   $a1 = pointer to message
                        	;------------------------------------------------------------------------------
FFFC2DCC 00000000	  align 1
                        	
                        	AllocMsg:
                        	  
FFFC2DD0 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC2DD4 000018B7	ldt   $a0,FreeMsg
FFFC2DD8 C0088893
FFFC2DDC 000888B3
FFFC2DE0 0008A503
FFFC2DE4 06051863	  bnez  $a0,.gotMsg
                        	  ; no free messages?
FFFC2DE8 40006513	  ldi   $a0,#1024         ; 1 page
FFFC2DEC 995FE0EF	  call  PAMAlloc
FFFC2DF0 08054663	  bltz  $a0,.outOfMem
FFFC2DF4 02F06293	  ldi   $t0,#47           ; 48 messages in block
                        	  ; Initialize object fields
FFFC2DF8 204D5337	  ldi   $t1,#MSG_MAGIC
FFFC2DFC 34730313
FFFC2E00 00652023	  stt   $t1,OBJMagic[$a0]
FFFC2E04 3C006313	  ldi   $t1,#960
FFFC2E08 00652423	  stt   $t1,OBJSize[$a0]
FFFC2E0C 00050C23	  stb   $x0,OBJState[$a0]
FFFC2E10 00050CA3	  stb   $x0,OBJScavcnt[$a0]
FFFC2E14 00050D23	  stb   $x0,OBJOwningMap[$a0]
FFFC2E18 FFFC3337	  ldi   $t1,#MsgFinalizer
FFFC2E1C 12830313
FFFC2E20 02652823	  stt   $t1,OBJFinalizer[$a0]
                        	 
FFFC2E24 04050313	  add   $t1,$a0,#64       ; point to first message
FFFC2E28 000018B7	  stt   $t1,FreeMsg
FFFC2E2C C0088893
FFFC2E30 000888B3
FFFC2E34 0068A023
FFFC2E38 00036533	  mov   $a0,$t1
                        	.0001:
FFFC2E3C 01430393	  add   $t2,$t1,#MSG_SIZE
FFFC2E40 00732023	  stt   $t2,MSG_LINK[$t1]
FFFC2E44 0003E333	  mov   $t1,$t2
FFFC2E48 FFF28293	  sub   $t0,$t0,#1
FFFC2E4C FE5048E3	  bgtz  $t0,.0001
FFFC2E50 00032023	  stt   $x0,MSG_LINK[$t1]
                        	.gotMsg:
FFFC2E54 00052283	  ldt   $t0,MSG_LINK[$a0]
FFFC2E58 000018B7	  stt   $t0,FreeMsg
FFFC2E5C C0088893
FFFC2E60 000888B3
FFFC2E64 0058A023
FFFC2E68 00052023	  stt   $x0,MSG_LINK[$a0]
                        	  
FFFC2E6C 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2E70 000565B3	mov   $a1,$a0
FFFC2E74 00006513	  ldi   $a0,#E_Ok
FFFC2E78 00008067	  ret
                        	.outOfMem:
                        	  
FFFC2E7C 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2E80 04706513	ldi   $a0,#E_NoMem
FFFC2E84 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; FreeMsg
                        	;
                        	; This internally used routine frees a message previously allocated with
                        	; AllocMsg. The message is added to the free list.
                        	;
                        	; Parameters:
                        	;   $a0 = pointer to message.
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;------------------------------------------------------------------------------
FFFC2E88 00000000	  align 1
FFFC2E8C 00000000
                        	
                        	FreeMsgRout:
                        	  
FFFC2E90 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC2E94 000018B7	ldt   $t0,FreeMsg
FFFC2E98 C0088893
FFFC2E9C 000888B3
FFFC2EA0 0008A283
FFFC2EA4 00552023	  stt   $t0,MSG_LINK[$a0]
FFFC2EA8 000018B7	  stt   $a0,FreeMsg
FFFC2EAC C0088893
FFFC2EB0 000888B3
FFFC2EB4 00A8A023
                        	  
FFFC2EB8 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2EBC 00006513	ldi   $a0,#E_Ok
FFFC2EC0 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		$t0 = mailbox pointer
                        	;		$t1 = message pointer
                        	;		$s1 = task id of waiting task
                        	; Modifies:
                        	;		$a0
                        	; Parameters:
                        	;		$a1 = mailbox handle
                        	;		$a2 = message d1
                        	;		$a3 = message d2
                        	;		$a4 = message d3
                        	;------------------------------------------------------------------------------
FFFC2EC4 00000000	  align 1
FFFC2EC8 00000000
FFFC2ECC 00000000
                        	
                        	ISendMsg:
FFFC2ED0 FFC10113	  sub   $sp,$sp,#4
FFFC2ED4 00112023	  stt   $ra,[$sp]
                        	;  mEI
                        	;	slt		$t0,$a1,#32
                        	;	beq		$t0,$x0,.badMbx
                        	;	sll		$t0,$a1,#4					; convert handle to pointer
                        	;	add		$t0,$t0,#mbxs
FFFC2ED8 0005E533	  mov   $a0,$a1
                        	  
FFFC2EDC 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC2EE0 00229293	  sll   $t0,$t0,#2
FFFC2EE4 000018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC2EE8 0A088893
FFFC2EEC 005888B3
FFFC2EF0 0008A283
FFFC2EF4 0FF57513	  and   $a0,$a0,#$FF
FFFC2EF8 00251513	  sll   $a0,$a0,#2
FFFC2EFC 00556533	  or    $a0,$a0,$t0
FFFC2F00 000562B3	mov   $t0,$a0
FFFC2F04 0042A983		ldt		$s3,MBX_TQHEAD[$t0]
FFFC2F08 04098663		beq		$s3,$x0,.noWaiters
FFFC2F0C 2CC9AC23		stt		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC2F10 2ED9A023		stt		$a3,TCBMsgD2[$s3]
FFFC2F14 2EE9A423		stt		$a4,TCBMsgD3[$s3]
FFFC2F18 2C89C383		ldbu	$t2,TCBStatus[$s3]
FFFC2F1C 0043E393		or		$t2,$t2,#TS_MSGRDY
FFFC2F20 2C798423		stb		$t2,TCBStatus[$s3]
FFFC2F24 3389D503		ldwu  $a0,TCBtid[$s3]
FFFC2F28 FFC10113		sub		$sp,$sp,#4
FFFC2F2C 00512023		stt		$t0,[$sp]						; push t0
FFFC2F30 44C000EF		call	InsertIntoReadyQueue
FFFC2F34 00012283		ldt		$t0,[$sp]						; pop t0
FFFC2F38 00410113		add		$sp,$sp,#4
FFFC2F3C 3489AA83		ldt   $s5,TCBMbxNext[$s3]
FFFC2F40 3409A423		stt   $x0,TCBMbxNext[$s3]
FFFC2F44 3409A823		stt   $x0,TCBMbxPrev[$s3]
FFFC2F48 0152A223		stt   $s5,MBX_TQHEAD[$t0]
FFFC2F4C 00006513		ldi		$a0,#E_Ok
FFFC2F50 04000663		bra   .xit
                        	.noWaiters:
FFFC2F54 E7DFF0EF	  call  AllocMsg
FFFC2F58 02051C63		bnez	$a0,.noMsg			    ; message available?
FFFC2F5C 00C5A423		stt		$a2,MSG_D1[$a1]
FFFC2F60 00D5A623		stt		$a3,MSG_D2[$a1]
FFFC2F64 00E5A823		stt		$a4,MSG_D3[$a1]
FFFC2F68 0102AE03		ldt		$t3,MBX_MQTAIL[$t0]
FFFC2F6C 000E0A63		beqz	$t3,.mbxEmpty
FFFC2F70 00BE2023		stt		$a1,MSG_LINK[$t3]
FFFC2F74 00B2A823		stt		$a1,MBX_MQTAIL[$t0]
FFFC2F78 00006513		ldi		$a0,#E_Ok
FFFC2F7C 02000063		bra   .xit
                        	.mbxEmpty:
FFFC2F80 00B2A623		stt		$a1,MBX_MQHEAD[$t0]
FFFC2F84 00B2A823		stt		$a1,MBX_MQTAIL[$t0]
FFFC2F88 00006513		ldi		$a0,#E_Ok
FFFC2F8C 00000863		bra   .xit
                        	.noMsg:
FFFC2F90 00B06513		ldi		$a0,#E_NoMsg
FFFC2F94 00000463		bra   .xit
                        	.badMbx:
FFFC2F98 00406513		ldi		$a0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit
FFFC2F9C 00012083		ldt   $ra,[$sp]
FFFC2FA0 00410113		add   $sp,$sp,#4
FFFC2FA4 00008067		ret
                        	
FFFC2FA8 00000000	  align 1
FFFC2FAC 00000000
                        	
                        	FMTK_SendMsg:
                        	  
FFFC2FB0 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC2FB4 F1DFF0EF	call  ISendMsg
                        	  
FFFC2FB8 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC2FBC EE4FF06F	jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a1 = mailbox handle
                        	;		$a2 = pointer where to put message D1
                        	;		$a3 = pointer where to put message D2
                        	;		$a4 = pointer where to put message D3
                        	;		$a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	  align 16                        	
                        	PeekMsg:
FFFC2FC0 FFC1310D		gcsub	$sp,$sp,#4
FFFC2FC4 00112023		stt		$ra,[$sp]
                        	;	slt		$t0,$a1,#32
                        	;	beq		$t0,$x0,.badMbx
                        	;	sll		$t2,$a1,#4					; convert handle to pointer
                        	;	add		$t2,$t2,#mbxs
FFFC2FC8 0005E533		mov   $a0,$a1
                        		
FFFC2FCC 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC2FD0 00229293	  sll   $t0,$t0,#2
FFFC2FD4 000018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC2FD8 0A088893
FFFC2FDC 005888B3
FFFC2FE0 0008A283
FFFC2FE4 0FF57513	  and   $a0,$a0,#$FF
FFFC2FE8 00251513	  sll   $a0,$a0,#2
FFFC2FEC 00556533	  or    $a0,$a0,$t0
FFFC2FF0 000563B3	mov   $t2,$a0
                        		
FFFC2FF4 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC2FF8 00C3A303	ldt		$t1,MBX_MQHEAD[$t2]
FFFC2FFC 06030463		beqz	$t1,.noMsg
FFFC3000 00078A63		beqz	$a5,.nodq
FFFC3004 00032E03		ldt		$t3,MSG_LINK[$t1]
FFFC3008 01C3A623		stt		$t3,MBX_MQHEAD[$t2]
                        		; This is done here only because interrupts are disabled
FFFC300C 000E6533		mov   $a0,$t3
FFFC3010 E81FF0EF		call  FreeMsgRout
                        	.nodq:
                        	  ; Makes use of the MPRV feature. PeekMsg() or WaitMsg() will be running in
                        	  ; the task context expecting to receive a message. That means the base
                        	  ; registers and ASID should be set appropriately.
FFFC3014 000205B7		ldi   $a1,#$20000       ; bit 17 = mprv
FFFC3018 00058593
FFFC301C 34030503	  ldb   $a0,TCBmid[$t1]   ; $a0 = mid
FFFC3020 00060A63		beqz  $a2,.nod1
FFFC3024 00832E03		ldt		$t3,MSG_D1[$t1]
FFFC3028 3005A073		csrrs $x0,#CSR_MSTATUS,$a1
FFFC302C 01C62023		stt		$t3,[$a2]
FFFC3030 3005B073		csrrc $x0,#CSR_MSTATUS,$a1
                        	.nod1:
FFFC3034 00068A63		beqz	$a3,.nod2
FFFC3038 00C32E03		ldt		$t3,MSG_D2[$t1]
FFFC303C 3005A073		csrrs $x0,#CSR_MSTATUS,$a1
FFFC3040 01C6A023		stt		$t3,[$a3]
FFFC3044 3005B073		csrrc $x0,#CSR_MSTATUS,$a1
                        	.nod2:
FFFC3048 00070A63		beqz	$a4,.nod3
FFFC304C 01032E03		ldt		$t3,MSG_D3[$t1]
FFFC3050 3005A073		csrrs $x0,#CSR_MSTATUS,$a1
FFFC3054 01C72023		stt		$t3,[$a4]
FFFC3058 3005B073		csrrc $x0,#CSR_MSTATUS,$a1
                        	.nod3:
FFFC305C 00006513		ldi		$a0,#E_Ok
FFFC3060 00000863		bra		.ret
                        	.noMsg:
FFFC3064 00B06513		ldi		$a0,#E_NoMsg
FFFC3068 00000463		bra		.ret
                        	.badMbx:
FFFC306C 00406513		ldi		$a0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
                        	  
FFFC3070 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC3074 00012083	ldt		$ra,[$sp]
FFFC3078 00410113		add		$sp,$sp,#4
FFFC307C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC3080 F41FF0EF		call	PeekMsg
FFFC3084 E1CFF06F		jmp		OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
FFFC3088 00000000	  align 1
FFFC308C 00000000
                        	
                        	FMTK_WaitMsg:
FFFC3090 0007EAB3		mov		$s5,$a5
FFFC3094 00106793		ldi		$a5,#1              ; dequeue messages
FFFC3098 F29FF0EF		call	PeekMsg							; check for a message, return if available
FFFC309C 00B06313		ldi		$t1,#E_NoMsg
FFFC30A0 00650463		beq		$a0,$t1,.qt					; no message? Then go queue task
FFFC30A4 DFCFF06F		jmp		OSExit
                        	.qt:
FFFC30A8 0005E533	  mov   $a0,$a1
                        	  
FFFC30AC 00855293	  srl   $t0,$a0,#8    ; extract collection index
FFFC30B0 00229293	  sll   $t0,$t0,#2
FFFC30B4 000018B7	  ldt   $t0,MbxBlockPtr[$t0]
FFFC30B8 0A088893
FFFC30BC 005888B3
FFFC30C0 0008A283
FFFC30C4 0FF57513	  and   $a0,$a0,#$FF
FFFC30C8 00251513	  sll   $a0,$a0,#2
FFFC30CC 00556533	  or    $a0,$a0,$t0
FFFC30D0 00056E33	mov   $t3,$a0
                        		
FFFC30D4 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC30D8 00A51313	sll		$t1,$a0,#LOG_TCBSZ  ; $t1 = tcb pointer
                        	;	sll		$t3,$a1,#5					; convert handle to pointer
                        	;	add		$t3,$t3,#mbxs
                        	  
FFFC30DC 7C40F073	  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts
FFFC30E0 008E2E83	ldt		$t4,MBX_TQTAIL[$t3]	; get waiting task list tail
FFFC30E4 000E8A63		beqz  $t4,.qempty
FFFC30E8 35D32823	  stt   $t4,TCBMbxPrev[$t1] ; add task onto tail of waiting list
FFFC30EC 346EA423	  stt   $t1,TCBMbxNext[$t4] ; tail->next = tid tcb pointer
FFFC30F0 006E2423	  stt   $t1,MBX_TQTAIL[$t3]
FFFC30F4 00000663	  bra   .setA
                        	.qempty:
FFFC30F8 006E2223	  stt   $t1,MBX_TQHEAD[$t3]
FFFC30FC 006E2423	  stt   $t1,MBX_TQTAIL[$t3]
                        	.setA:
FFFC3100 0AC32023	  stt   $a2,TCBxA2[$t1]   ; save pointers for data in task regs
FFFC3104 0AD32423	  stt   $a3,TCBxA3[$t1]
FFFC3108 0AE32823	  stt   $a4,TCBxA4[$t1]
FFFC310C 2C834E03		ldbu	$t3,TCBStatus[$t1]
FFFC3110 008E6E13		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC3114 FFEE7E13		and		$t3,$t3,#~TS_READY	; not ready
FFFC3118 2DC30423		stb		$t3,TCBStatus[$t1]
FFFC311C 2CB30523		stb		$a1,TCBWaitMbx[$t1]	; set mailbox task is waiting for
                        		
FFFC3120 7C40E073	  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts
FFFC3124 EE8FF06F	jmp		FMTK_Sleep          ; Continue by switching tasks
                        	
                        	MsgFinalizer:
FFFC3128 00008067	  ret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/app.r5a",1
                        	.file "../fmtk/app.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/app.r5a",25
                        		code
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   none
                        	; Returns:
                        	;   $a0 = app id (0 to 31), -1 if none available
                        	;------------------------------------------------------------------------------
FFFC312C 00000000	  align 1
                        	
                        	AllocAppId:
FFFC3130 2F002583	  ldt   $a1,APPID_POOL
FFFC3134 01F06513	  ldi   $a0,#31
                        	.0002:
FFFC3138 0005CC63	  bltz  $a1,.0001
FFFC313C 00106293	  ldi   $t0,#1
FFFC3140 00A292B3	  sll   $t0,$t0,$a0
FFFC3144 0055E5B3	  or    $a1,$a1,$t0
FFFC3148 2EB02823	  stt   $a1,APPID_POOL
FFFC314C 00008067	  ret
                        	.0001:
FFFC3150 00159593	  sll   $a1,$a1,#1
FFFC3154 FFF50513	  sub   $a0,$a0,#1
FFFC3158 FE0550E3	  bge   $a0,$x0,.0002
FFFC315C FFF06513	  ldi   $a0,#-1
FFFC3160 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;   $a1 = pointer to application start record
                        	;------------------------------------------------------------------------------
FFFC3164 00000000	  align 1
FFFC3168 00000000
FFFC316C 00000000
                        	
                        	FMTK_StartApp:
FFFC3170 0005E4B3	  mov   $s1,$a1
FFFC3174 00006533	  mov   $a0,$x0           ; OS owns the ACB
FFFC3178 000015B7	  ldi   $a1,#4096         ; size of application control block
FFFC317C 00058593
FFFC3180 E00FE0EF	  call  PAMAlloc          ; allocate ACB
FFFC3184 0005E9B3	  mov   $s3,$a1           ; $s3 = pointer to ACB
FFFC3188 204142B7	  ldi   $t0,#ACB_MAGIC
FFFC318C 34228293
FFFC3190 0059A023	  stt   $t0,OBJMagic[$s3]
FFFC3194 0809AC23	  stt   $x0,ACBGarbageList[$s3]
FFFC3198 3209AC23	  stt   $x0,ACBiofNext[$s3]
FFFC319C 3409A023	  stt   $x0,ACBiofPrev[$s3]
FFFC31A0 00348283	  ldb   $t0,ASRmid[$s1]
FFFC31A4 3C598223	  stb   $t0,ACBmid[$s3]
                        	  ; Allocate a virtual screen and set pointers to it.
FFFC31A8 00A9D513	  srl   $a0,$s3,#LOG_PGSZ ; App owns the screen
FFFC31AC 000025B7	  ldi   $a1,#8192         ; size of virtual screen
FFFC31B0 00058593
FFFC31B4 DCCFE0EF	  call  PAMAlloc
FFFC31B8 16054E63	  bltz  $a0,.noMem
FFFC31BC 34B9A823	  stt   $a1,ACBpVidMem[$s3]
FFFC31C0 34B9AC23	  stt   $a1,ACBpVirtVidMem[$s3]
                        	  ; Setup screen attributes
FFFC31C4 03806293	  ldi   $t0,#56
FFFC31C8 365980A3	  stb   $t0,ACBVideoCols[$s3]
FFFC31CC 01F06293	  ldi   $t0,#31
FFFC31D0 36598023	  stb   $t0,ACBVideoRows[$s3]
FFFC31D4 36098123	  stb   $x0,ACBCursorRow[$s3]
FFFC31D8 360981A3	  stb   $x0,ACBCursorCol[$s3]
FFFC31DC 008802B7	  ldi   $t0,#$0087FC00
FFFC31E0 C0028293
FFFC31E4 3659A223	  stt   $t0,ACBNormAttr[$s3]
                        	
                        	  ; Allocate memory for application code and copy code into position
FFFC31E8 0084A583	  ldt   $a1,ASRCodeSize[$s1]
FFFC31EC 02058C63	  beqz  $a1,.0004         ; 0 size code = in ROM
FFFC31F0 AC0FE0EF	  call  Alloc
FFFC31F4 14054063	  bltz  $a0,.noMem
FFFC31F8 08B9A323	  stt   $a1,ACBpCode[$s3] ; save pointer to code area in ACB
FFFC31FC 0005EA33	  mov   $s4,$a1           ; $s4 = pointer to application code
FFFC3200 FFFFE2B3	  mov   $t0,ASRCodeSize[$s1]  ; $t0 = code size
FFFC3204 0304AA83	  ldt   $s5,ASRpCode[$s1] ; $s5 = pointer to application code
                        	.0001:
FFFC3208 000AA303	  ldt   $t1,[$s5]
FFFC320C 006A2023	  stt   $t1,[$s4]
FFFC3210 004A8A93	  add   $s5,$s5,#4
FFFC3214 004A0A13	  add   $s4,$s4,#4
FFFC3218 FFF28293	  sub   $t0,$t0,#1
FFFC321C FE5046E3	  bgtz  $t0,.0001
FFFC3220 00000663	  bra   .0003
                        	.0004:
FFFC3224 0304AA83	  ldt   $s5,ASRpCode[$s1] ; $s5 = pointer to application code
FFFC3228 0959A323	  stt   $s5,ACBpCode[$s3] ; save pointer to code area in ACB
                        	
                        	.0003:
                        	  ; Allocate memory for application data and copy data into position
                        	  ; The memory requirements for both initialized and uninitialized data are
                        	  ; summed and a single block of memory allocated for both.
                        	  ; Vars will then be accessed via a global pointer offset from the start
                        	  ; of the data area.
FFFC322C 0409A023	  stt   $x0,ACBpData[$s3]
FFFC3230 0409A823	  stt   $x0,ACBpUIData[$s3]
FFFC3234 0104A583	  ldt   $a1,ASRDataSize[$s1]
FFFC3238 000008B7	  ldt   $a2,ASRIUDataSize[$s1]
FFFC323C 34188893
FFFC3240 009888B3
FFFC3244 0008A603
FFFC3248 00C585B3	  add   $a1,$a1,$a2
FFFC324C 02058E63	  beqz  $a1,.0005         ; no data?
FFFC3250 A60FE0EF	  call  Alloc
FFFC3254 0E054063	  bltz  $a0,.noMem
FFFC3258 04B9A023	  stt   $a1,ACBpData[$s3]
                        	
                        	  ; Copy pre-initialized data to data area.
FFFC325C 0005EA33	  mov   $s4,$a1           ; $s4 = pointer to application data
FFFC3260 0104A283	  ldt   $t0,ASRDataSize[$s1]  ; $t0 = data size
FFFC3264 00328293	  add   $t0,$t0,#3        ; round to whole words
FFFC3268 FFC2F293	  and   $t0,$t0,#$FFFFFFFC
FFFC326C 0384AA83	  ldt   $s5,ASRpData[$s1] ; $s5 = pointer to application data
                        	.0002:
FFFC3270 000AA303	  ldt   $t1,[$s5]
FFFC3274 006A2023	  stt   $t1,[$s4]
FFFC3278 004A8A93	  add   $s5,$s5,#4
FFFC327C 004A0A13	  add   $s4,$s4,#4
FFFC3280 FFC28293	  sub   $t0,$t0,#4
FFFC3284 FE5046E3	  bgtz  $t0,.0002
                        	
                        	.0005:
                        	  ; Record pointer to uninitialized data
FFFC3288 0104A503	  ldt   $a0,ASRDataSize[$s1]
FFFC328C 0404A583	  ldt   $a1,ACBpData[$s1]
FFFC3290 00B505B3	  add   $a1,$a0,$a1
FFFC3294 00358593	  add   $a1,$a1,#3
FFFC3298 FFC5F593	  and   $a1,$a1,#$FFFFFFFC
FFFC329C 04B9A823	  stt   $a1,ACBpUIData[$s3]
                        	
                        	.0006:
                        	  ; Allocate memory for heap
FFFC32A0 0204A583	  ldt   $a1,ASRHeapSize[$s1]
FFFC32A4 00058863	  beqz  $a1,.0007         ; no heap?
FFFC32A8 A08FE0EF	  call  Alloc
FFFC32AC 08054463	  bltz  $a0,.noMem
FFFC32B0 0AB9A023	  stt   $a1,ACBHeap[$s3]
                        	
                        	.0007:
FFFC32B4 00106513	  ldi   $a0,#1            ; IStartTask
FFFC32B8 00A9D593	  srl   $a1,$s3,#LOG_PGSZ ; $a1 = app id
FFFC32BC 000048B7	  stt   $a1,$3F48
FFFC32C0 F4888893
FFFC32C4 000888B3
FFFC32C8 00B8A023
FFFC32CC 000048B7	  stt   $s3,$3F50
FFFC32D0 F5088893
FFFC32D4 000888B3
FFFC32D8 0138A023
FFFC32DC 40006613	  ldi   $a2,#1024         ; task local memory
FFFC32E0 0304A683	  ldt   $a3,ASRpCode[$s1] ; get pointer to code area
FFFC32E4 00406713	  ldi   $a4,#$04
FFFC32E8 AF8FF0EF	  call  OSOCall           ; start the initial app task
FFFC32EC 02051C63	  bnez  $a0,.tskErr       ; error?
FFFC32F0 3CB99023	  stw   $a1,ACBTask[$s3]
FFFC32F4 000048B7	  stw   $a1,$3F48
FFFC32F8 F4888893
FFFC32FC 000888B3
FFFC3300 00B89023
FFFC3304 00A59293	  sll   $t0,$a1,#LOG_PGSZ
FFFC3308 0409A303	  ldt   $t1,ACBpData[$s3]
FFFC330C 0462AC23	  stt   $t1,TCBxGP[$t0]   ; set global pointer to data area
FFFC3310 00106313	  ldi   $t1,#AS_LIVE
FFFC3314 3C698323	  stb   $t1,ACBStatus[$s3]
FFFC3318 00A9D593	  srl   $a1,$s3,#LOG_PGSZ ; return app id
FFFC331C 00006513	  ldi   $a0,#E_Ok
FFFC3320 B80FF06F	  jmp   OSExit
                        	.tskErr:
FFFC3324 00406313	  ldi   $t1,#AS_UNDEAD
FFFC3328 3C698323	  stb   $t1,ACBStatus[$s3]
FFFC332C B74FF06F	  jmp   OSExit
                        	
                        	.noMoreApps:
FFFC3330 04606513	  ldi   $a0,#E_NoMoreAppIds
                        	.noMem
FFFC3334 B6CFF06F	  jmp   OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitApp:
                        		
FFFC3338 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC333C 00A51593	sll		$a1,$a0,#LOG_TCBSZ  ; convert TID to TCB address
FFFC3340 34058583		ldb   $a1,TCBmid[$a1]     ; get the mid
                        		; fall through to KillApp
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = mid of task to kill
                        	;------------------------------------------------------------------------------
FFFC3344 00000000	  align 1
FFFC3348 00000000
FFFC334C 00000000
                        	
                        	FMTK_KillApp:
FFFC3350 02058263		beqz	$a1,.immortal		    ; app #0 is immortal (the system)
FFFC3354 00206293		ldi		$t0,#TS_DEAD				; flag app as dead (prevents it from being re-queued)
FFFC3358 00259593		sll		$a1,$a1,#2	        
FFFC335C 000008B7		ldt   $a1,TidTcbMap[$a1]  ; convert TID to TCB address
FFFC3360 34988893
FFFC3364 00B888B3
FFFC3368 0008A583
FFFC336C 2C558423		stb		$t0,TCBStatus[$a1]
                        	;	ldbu  $a0,TCBmid[$a1]
                        	;	call	FreeAll							; free all the memory associated with the task
                        		; Now make task ID available for reuse
FFFC3370 3385C503		ldbu  $a0,TCBtid[$a1]
                        	.immortal:
FFFC3374 00006513		ldi		$a0,#E_Ok
FFFC3378 B28FF06F		jmp		OSExit
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/tcb.r5a",25
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready queue.
                        	; Inserting into the ready queue is done by both OS ecall functions and
                        	; interrupt driven scheduling. It's important to have interrupts disabled
                        	; so that there is no contention for the ready queue.
                        	;
                        	; Parameters:
                        	;		$a0 = tid to insert (TCB pointer)
                        	; Modifies:
                        	;	  $t0,$t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoReadyQueue:
FFFC337C 2C854303		ldbu	$t1,TCBStatus[$a0]		; set status to ready
FFFC3380 00136313		or		$t1,$t1,#TS_READY
FFFC3384 2C650423		stb		$t1,TCBStatus[$a0]
FFFC3388 2C950303		ldb		$t1,TCBPriority[$a0]	; $t1 = priority
FFFC338C 00231313		sll		$t1,$t1,#2						; $t1 = index to priority list
FFFC3390 42032383		ldt		$t2,TAILRDY[$t1]
FFFC3394 00038A63		beqz	$t2,.qempty
FFFC3398 30A3A823		stt		$a0,TCBNext[$t2]
FFFC339C 42A32023		stt		$a0,TAILRDY[$t1]
FFFC33A0 30052823		stt		$x0,TCBNext[$a0]
FFFC33A4 00008067		ret
                        	.qempty:
FFFC33A8 40A32023		stt		$a0,HEADRDY[$t1]
FFFC33AC 42A32023		stt		$a0,TAILRDY[$t1]
FFFC33B0 30052823		stt		$x0,TCBNext[$a0]
FFFC33B4 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Removal from the ready queue is easy. Just flag the task status as no longer
                        	; ready or running. The next time it appears in a dequeue the code will ignore
                        	; it and pop the next ready task.
                        	;
                        	; Parameters:
                        	;		$a0 = tid to remove
                        	; Modifies:
                        	;		t0,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromReadyQueue:
FFFC33B8 2C850303		ldb		$t1,TCBStatus[$a0]		; set status no longer ready or running
FFFC33BC F7E37313		and		$t1,$t1,#~(TS_READY|TS_RUNNING)
	stb		$t1,TCBStatus[$a0]
FFFC33C0 2C650423
FFFC33C4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		$a0 = task id to insert
                        	;		$a1 = timeout value
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoTimeoutList:
FFFC33C8 2C854383		ldbu	$t2,TCBStatus[$a0]		; set status to timing out
FFFC33CC 0103E393		or		$t2,$t2,#TS_TIMEOUT
FFFC33D0 2C750423		stb		$t2,TCBStatus[$a0]
FFFC33D4 32802283		ldt		$t0,TimeoutList
FFFC33D8 02028A63		beqz	$t0,.listEmpty
                        	.loop:
FFFC33DC 3202A303		ldt		$t1,TCBTimeout[$t0]
FFFC33E0 0065B3B3		sltu	$t2,$a1,$t1
FFFC33E4 04039063		bnez	$t2,.lessThan
                        		; Here timeout was >
FFFC33E8 406585B3		sub		$a1,$a1,$t1
FFFC33EC 3102A283		ldt		$t0,TCBNext[$t0]
FFFC33F0 FE0296E3		bnez	$t0,.loop
                        		; Add at end
FFFC33F4 30A2A823		stt		$a0,TCBNext[$t0]
FFFC33F8 30552C23		stt		$t0,TCBPrev[$a0]
FFFC33FC 30052823		stt		$x0,TCBNext[$a0]
FFFC3400 32B52023		stt		$a1,TCBTimeout[$a0]
FFFC3404 00006513		ldi		$a0,#E_Ok
FFFC3408 00008067		ret
                        	.listEmpty:
FFFC340C 32B52023		stt		$a1,TCBTimeout[$a0]
FFFC3410 32A02423		stt		$a0,TimeoutList
FFFC3414 30052823		stt		$x0,TCBNext[$a0]
FFFC3418 30052C23		stt		$x0,TCBPrev[$a0]
FFFC341C 00006513		ldi		$a0,#E_Ok
FFFC3420 00008067		ret
                        	.lessThan:
FFFC3424 40B30333		sub		$t1,$t1,$a1
FFFC3428 3262A023		stt		$t1,TCBTimeout[$t0]
FFFC342C 3182A383		ldt		$t2,TCBPrev[$t0]
FFFC3430 30552823		stt		$t0,TCBNext[$a0]
FFFC3434 30A2AC23		stt		$a0,TCBPrev[$t0]
FFFC3438 30752C23		stt		$t2,TCBPrev[$a0]
FFFC343C 00038863		beqz	$t2,.atHead
FFFC3440 30A3A823		stt		$a0,TCBNext[$t2]
FFFC3444 00006513		ldi		$a0,#E_Ok
FFFC3448 00008067		ret
                        	.atHead:
FFFC344C 32A02423		stt		$a0,TimeoutList
FFFC3450 00006513		ldi		$a0,#E_Ok
FFFC3454 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove a task from the timeout list.
                        	; Called when a mailbox is freed and a task is waiting at the
                        	; mailbox.
                        	;
                        	; Parameters:
                        	;		$a0 = task id to remove
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromTimeoutList:
FFFC3458 31852283		ldt		$t0,TCBPrev[$a0]
FFFC345C 02028A63		beqz	$t0,.atHead
FFFC3460 31052303		ldt		$t1,TCBNext[$a0]
FFFC3464 04030C63		beqz	$t1,.atTail2
FFFC3468 32032E03		ldt		$t3,TCBTimeout[$t1]
FFFC346C 32052E83		ldt		$t4,TCBTimeout[$a0]
FFFC3470 41DE0E33		sub		$t3,$t3,$t4
FFFC3474 33C32023		stt		$t3,TCBTimeout[$t1]
FFFC3478 3062A823		stt		$t1,TCBNext[$t0]	; this->prev->next = this->next
FFFC347C 31052383		ldt		$t2,TCBNext[$a0]
FFFC3480 00038463		beqz	$t2,.atTail
FFFC3484 3053AC23		stt		$t0,TCBPrev[$t2]	; this->next->prev = this->prev
                        	.atTail:
FFFC3488 32052023		stt		$x0,TCBTimeout[$a0]
FFFC348C 00008067		ret
                        	.atHead:
FFFC3490 32802303		ldt		$t1,TimeoutList
FFFC3494 02531063		bne		$t1,$t0,.notAtHead
FFFC3498 31052303		ldt		$t1,TCBNext[$a0]
FFFC349C FE0306E3		beqz	$t1,.atTail
FFFC34A0 32032E03		ldt		$t3,TCBTimeout[$t1]
FFFC34A4 32052E83		ldt		$t4,TCBTimeout[$a0]
FFFC34A8 41DE0E33		sub		$t3,$t3,$t4
FFFC34AC 33C32023		stt		$t3,TCBTimeout[$t1]
FFFC34B0 32602423		stt		$t1,TimeoutList
                        	.notAtHead:
FFFC34B4 32052023		stt		$x0,TCBTimeout[$a0]
FFFC34B8 00008067		ret
                        	.atTail2:
FFFC34BC 3002A823		stt		$x0,TCBNext[$t0]
FFFC34C0 32052023		stt		$x0,TCBTimeout[$a0]
FFFC34C4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
                        	DumpReadyQueue:
FFFC34C8 FE010113		sub		$sp,$sp,#32
FFFC34CC 00112023		stt		$ra,[$sp]
FFFC34D0 00A12223		stt		$a0,4[$sp]
FFFC34D4 00C12423		stt		$a2,8[$sp]
FFFC34D8 00D12623		stt		$a3,12[$sp]
FFFC34DC 00612823		stt		$t1,16[$sp]
FFFC34E0 00712A23		stt		$t2,20[$sp]
FFFC34E4 01C12C23		stt		$t3,24[$sp]
FFFC34E8 00912E23		stt		$s1,28[$sp]
FFFC34EC 00D06513	  ldi   $a0,#CR
FFFC34F0 EA1FC0EF	  call  Putch
FFFC34F4 00006513	  ldi   $a0,#LF
  call  Putch
FFFC34F8 E99FC0EF
                        	  ; Display PAM
FFFC34FC 00006313	  ldi   $t1,#0        ; $a1 = bit number
                        	.0006:
FFFC3500 02006513	  ldi   $a0,#32       ; Get PAM bit pair
FFFC3504 000365B3	  mov   $a1,$t1
FFFC3508 00000073	  ecall
FFFC350C 03058513	  add   $a0,$a1,#'0'
FFFC3510 E81FC0EF	  call  Putch
FFFC3514 00130313	  add   $t1,$t1,#1
FFFC3518 20032513	  slt   $a0,$t1,#MEMSZ
FFFC351C FE0512E3	  bnez  $a0,.0006
                        	
FFFC3520 FFFC3537		ldi		$a0,#msgReadyQueue
FFFC3524 75050513
FFFC3528 E28FD0EF		call	PutString
FFFC352C 00006313		ldi		$t1,#0
FFFC3530 3000F4F3		csrrc	$s1,#$300,#1
                        	.0002:
                        	;	call	SerialPeekCharDirect
                        	;	xor		$v0,$v0,#CTRLC
                        	;	beqz	$v0,.brk
FFFC3534 00D06513		ldi		$a0,#CR
FFFC3538 E59FC0EF		call	Putch
FFFC353C 05106513		ldi		$a0,#'Q'
FFFC3540 E51FC0EF		call	Putch
                        		;srl		$a0,$t1,#1
FFFC3544 00036533		mov   $a0,$t1
FFFC3548 DB8FD0EF		call	PutHexNybble
FFFC354C 03A06513		ldi		$a0,#':'
FFFC3550 E41FC0EF		call	Putch
FFFC3554 1A03060D		popq  $a2,$t1         ; get number of queue entries
	srl   $t2,$a2,#16
FFFC3558 01065393
FFFC355C 03F3F393		and   $t2,$t2,#63
FFFC3560 05B06513		ldi		$a0,#'['
FFFC3564 E2DFC0EF		call	Putch
FFFC3568 0003E533		mov		$a0,$t2
FFFC356C D74FD0EF		call	PutHexByte
FFFC3570 05D06513		ldi		$a0,#']'
FFFC3574 E1DFC0EF		call	Putch
FFFC3578 02006513		ldi		$a0,#' '
FFFC357C E15FC0EF		call	Putch
FFFC3580 1FF67613		and   $a2,$a2,#$1FF
FFFC3584 1866000D		pushq $a2,$t1         ; put the entry back on the queue
.0003:
FFFC3588 1A03060D		popq  $a2,$t1
	bltz  $a2,.nxt        ; if empty get next
FFFC358C 02064863
FFFC3590 01E65693		srl   $a3,$a2,#30     ; extract valid bit
FFFC3594 00068E63		beqz  $a3,.0005       ; valid entry ? no: get next
FFFC3598 1FF67613		and   $a2,$a2,#$1FF
FFFC359C 1866000D		pushq $a2,$t1         ; put the entry back on the queue
	mov		$a0,$a2
FFFC35A0 00066533
FFFC35A4 D1CFD0EF		call	PutHexHalf
FFFC35A8 02006513		ldi		$a0,#' '
FFFC35AC DE5FC0EF		call	Putch
                        	.0005:
FFFC35B0 FFF38393		sub   $t2,$t2,#1
FFFC35B4 FC704AE3		bgtz  $t2,.0003
FFFC35B8 00000E63		bra   .0001
                        	;	sll		$a3,$a3,#LOG_TCBSZ
                        	;	ldw		$a0,TCBNext[$a3]
                        	;	call	PutHexHalf
                        	;	ldi		$a0,#' '
                        	;	call	Putch
                        	;	ldw		$a0,TCBPrev[$a3]
                        	;	call	PutHexHalf
                        	.nxt:
FFFC35BC 00066533		mov		$a0,$a2
FFFC35C0 D20FD0EF		call	PutHexByte
FFFC35C4 02006513		ldi		$a0,#' '
FFFC35C8 DC9FC0EF		call	Putch
FFFC35CC 1FF67613		and   $a2,$a2,#$1FF
FFFC35D0 1866000D		pushq $a2,$t1         ; put the entry back on the queue
.0001:
FFFC35D4 00D06513		ldi		$a0,#CR
FFFC35D8 DB9FC0EF		call	Putch
                        	;	ldw		$a3,TCBNext[$a3]
                        	;	bne		$a2,$a3,.0001
FFFC35DC 00130313		add		$t1,$t1,#1
FFFC35E0 00832393		slt		$t2,$t1,#8
FFFC35E4 F40398E3		bnez	$t2,.0002
                        	.brk:
FFFC35E8 FFFC3537		ldi		$a0,#msgTaskInfo
FFFC35EC 77A50513
FFFC35F0 D60FD0EF		call	PutString
FFFC35F4 000042B7	  ldi   $t0,#$4000
FFFC35F8 00028293
                        	.0004:
FFFC35FC 0002A503	  ldt   $a0,[$t0]
FFFC3600 205448B7	  xor   $a0,$a0,#TCB_MAGIC
FFFC3604 34288893
FFFC3608 00A8C533
FFFC360C 06051463	  bnez  $a0,.nxtT
                        	;  ldi   $t2,#1
                        	;  sll   $t2,$t2,$t0
                        	;  ldt   $a0,TID_POOL
                        	;  and   $t2,$t2,$a0
                        	;  beqz  $t2,.nxtT
FFFC3610 000563B3	  mov   $t2,$a0
FFFC3614 0022D293	  srl   $t0,$t0,#2
FFFC3618 C88FD0EF	  call  PutHexWord
FFFC361C 02006513	  ldi   $a0,' '
FFFC3620 D71FC0EF	  call  Putch
FFFC3624 3383D503	  ldwu  $a0,TCBtid[$t2]
FFFC3628 C98FD0EF	  call  PutHexHalf
FFFC362C 02006513	  ldi   $a0,' '
FFFC3630 D61FC0EF	  call  Putch
FFFC3634 2C93C503	  ldbu  $a0,TCBPriority[$t2]
FFFC3638 CA8FD0EF	  call  PutHexByte
FFFC363C 02006513	  ldi   $a0,' '
FFFC3640 D51FC0EF	  call  Putch
FFFC3644 2C83C503	  ldbu  $a0,TCBStatus[$t2]
FFFC3648 C98FD0EF	  call  PutHexByte
FFFC364C 02006513	  ldi   $a0,' '
FFFC3650 D41FC0EF	  call  Putch
FFFC3654 3203A503	  ldt   $a0,TCBTimeout[$t2]
FFFC3658 C48FD0EF	  call  PutHexWord
FFFC365C 02006513	  ldi   $a0,' '
FFFC3660 D31FC0EF	  call  Putch
FFFC3664 0503A503	  ldt   $a0,TCBxSP[$t2]
FFFC3668 C38FD0EF	  call  PutHexWord
FFFC366C 00D06513		ldi		$a0,#CR
FFFC3670 D21FC0EF		call	Putch
                        	.nxtT:
FFFC3674 40028293	  add   $t0,$t0,#$400
FFFC3678 000808B7	  slt   $t1,$t0,#$80000
FFFC367C 00088893
FFFC3680 F6031EE3	  bnez  $t1,.0004
FFFC3684 30049073		csrrw	$x0,#$300,$s1
FFFC3688 00012083		ldt		$ra,[$sp]
FFFC368C 00412503		ldt		$a0,4[$sp]
FFFC3690 00812603		ldt		$a2,8[$sp]
FFFC3694 00C12683		ldt		$a3,12[$sp]
FFFC3698 01012303		ldt		$t1,16[$sp]
FFFC369C 01412383		ldt		$t2,20[$sp]
FFFC36A0 01812E03		ldt		$t3,24[$sp]
FFFC36A4 01C12483		ldt		$s1,28[$sp]
FFFC36A8 02010113		add		$sp,$sp,#32
FFFC36AC 00008067		ret
                        	
                        	DumpTimeoutList:
FFFC36B0 FE010113		sub		$sp,$sp,#32
FFFC36B4 00112023		stt		$ra,[$sp]
FFFC36B8 00A12223		stt		$a0,4[$sp]
FFFC36BC 00C12423		stt		$a2,8[$sp]
FFFC36C0 00D12623		stt		$a3,12[$sp]
FFFC36C4 00612823		stt		$t1,16[$sp]
FFFC36C8 00712A23		stt		$t2,20[$sp]
FFFC36CC 01C12C23		stt		$t3,24[$sp]
FFFC36D0 00912E23		stt		$s1,28[$sp]
FFFC36D4 FFFC3537		ldi		$a0,#msgTimeoutList
FFFC36D8 7A950513
FFFC36DC C74FD0EF		call	PutString
FFFC36E0 00006313		ldi		$t1,#0
FFFC36E4 3000F4F3		csrrc	$s1,#$300,#1
FFFC36E8 00006693		ldi		$a3,#0
                        	.0002:
FFFC36EC F08FE0EF		call	SerialPeekCharDirect
FFFC36F0 00354513		xor		$a0,$a0,#CTRLC
FFFC36F4 02050863		beqz	$a0,.brk
FFFC36F8 00D06513		ldi		$a0,#CR
FFFC36FC C95FC0EF		call	Putch
                        	;	ldw		$a2,TimeoutList
                        	;	bltz	$a2,.brk
                        	;	mov		$a3,$a2
                        	;.0001:
FFFC3700 0006E533		mov		$a0,$a3
FFFC3704 BBCFD0EF		call	PutHexHalf
FFFC3708 02D06513		ldi		$a0,#'-'
FFFC370C C85FC0EF		call	Putch
FFFC3710 1203050D		getto	$a0,$t1
;	sll		$a3,$a3,#LOG_TCBSZ
                        	;	ldt		$a0,TCBTimeout[$a3]
FFFC3714 B8CFD0EF		call	PutHexWord
                        	;	ldi		$a0,#CR
                        	;	call	Putch
FFFC3718 00168693		add		$a3,$a3,#1
FFFC371C 00F6F693		and		$a3,$a3,#15
FFFC3720 FCD046E3		bgt		$a3,$x0,.0002
                        	;	ldw		$a3,TCBNext[$a3]
                        	;	bge		$a3,$x0,.0001
                        	.brk:
FFFC3724 30049073		csrrw	$x0,#$300,$s1
FFFC3728 00012083		ldt		$ra,[$sp]
FFFC372C 00412503		ldt		$a0,4[$sp]
FFFC3730 00812603		ldt		$a2,8[$sp]
FFFC3734 00C12683		ldt		$a3,12[$sp]
FFFC3738 01012303		ldt		$t1,16[$sp]
FFFC373C 01412383		ldt		$t2,20[$sp]
FFFC3740 01812E03		ldt		$t3,24[$sp]
FFFC3744 01C12483		ldt		$s1,28[$sp]
FFFC3748 02010113		add		$sp,$sp,#32
FFFC374C 00008067		ret
                        	
                        	msgReadyQueue:
FFFC3750 6165520D		db	CR,"Ready Queue",CR
FFFC3754 51207964
FFFC3758 65756575
FFFC375C 6575510D
FFFC375D 3A657551		db	"Que: Tid List",CR
FFFC3761 64695420
FFFC3765 73694C20
FFFC3769 2D2D0D74
FFFC376B 2D2D2D2D		db	"-------------",CR,0
FFFC376F 2D2D2D2D
FFFC3773 2D2D2D2D
FFFC3777 0D000D2D
                        	msgTaskInfo:
FFFC377A 7361540D	  db  CR,"Task Info",CR
FFFC377E 6E49206B
FFFC3782 540D6F66
FFFC3785 20424354	  db  "TCB Ptr   Tid  Pr St Timeout    SP",CR
FFFC3789 20727450
FFFC378D 69542020
FFFC3791 50202064
FFFC3795 74532072
FFFC3799 6D695420
FFFC379D 74756F65
FFFC37A1 20202020
FFFC37A5 000D5053
FFFC37A8 69540D00	  db  0
                        	msgTimeoutList:
FFFC37A9 6D69540D		db	CR,"Timeout List",CR
FFFC37AD 74756F65
FFFC37B1 73694C20
FFFC37B5 54200D74
FFFC37B7 64695420		db	" Tid - Timeout",CR
FFFC37BB 54202D20
FFFC37BF 6F656D69
FFFC37C3 2D0D7475
FFFC37C6 2D2D2D2D		db	"--------------",CR,0
FFFC37CA 2D2D2D2D
FFFC37CE 2D2D2D2D
FFFC37D2 000D2D2D
                        	
FFFC37D6 15730000		align 
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;-----------------------------------------------------------------------------
                        	;-----------------------------------------------------------------------------
                        	
                        	.file "../fmtk/iofocus.r5a",28
                        		code
                        		align	4                        	
                        	
                        	;-----------------------------------------------------------------------------
                        	; Determine if the currently running app has the I/O focus.
                        	;
                        	; Stack Space:
                        	;		none
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$a0 = E_Ok
                        	;		$a1 = 1 if task has IO focus, 0 otherwise
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_HasIOFocus:
                        		
FFFC37D8 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC37DC 00A51513	sll   $a0,$a0,#LOG_PGSZ
FFFC37E0 34255503		ldwu  $a0,TCBappid[$a0]
FFFC37E4 00050E63		beqz  $a0,.hasFocus       ; startup appid = zero
FFFC37E8 00A51513		sll   $a0,$a0,#LOG_PGSZ   ; $a0 = ACB pointer
FFFC37EC 000018B7		ldt   $a1,IOFocusNdx
FFFC37F0 08088893
FFFC37F4 000888B3
FFFC37F8 0008A583
FFFC37FC 00A59863		bne   $a1,$a0,.notEqual
                        	.hasFocus:
FFFC3800 00106593		ldi   $a1,#1
FFFC3804 00006513		ldi		$a0,#E_Ok
FFFC3808 E99FE06F		jmp		OSExit
                        	.notEqual:
FFFC380C 00106593	  ldi   $a1,#1
FFFC3810 00006513		ldi		$a0,#E_Ok
FFFC3814 E8DFE06F		jmp		OSExit
                        	
                        	;-----------------------------------------------------------------------------
                        	; First check if it's even possible to switch the focus to another
                        	; app. The I/O focus list could be empty or there may be only a
                        	; single task in the list. In either case it's not possible to
                        	; switch.
                        	;
                        	;	Parameters:
                        	;		none
                        	;	Modifies:
                        	;		none
                        	;	Returns:
                        	;		a0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	SwitchIOFocusHelper:
FFFC3818 000018B7	  ldt   $t0,IOFocusNdx
FFFC381C 08088893
FFFC3820 000888B3
FFFC3824 0008A283
FFFC3828 3382A303	  ldt   $t1,ACBiofNext[$t0]
FFFC382C 00030C63	  beqz  $t1,.zeroAppid
FFFC3830 000018B7	  stt   $t1,IOFocusNdx
FFFC3834 08088893
FFFC3838 000888B3
FFFC383C 0068A023
FFFC3840 00629663	  bne   $t0,$t1,.notSame
                        	.zeroAppid:
FFFC3844 00006513		ldi		$a0,E_Ok
FFFC3848 00008067		ret
                        	.notSame:
                        		; swap virtual screens
                        		; set vidmem pointer
FFFC384C 00006513		ldi		$a0,E_Ok
FFFC3850 00008067		ret
                        	    
                        	FMTK_SwitchIOFocus:
FFFC3854 FC5FF0EF		call	SwitchIOFocusHelper
FFFC3858 E49FE06F		jmp		OSExit
                        	
                        	;-----------------------------------------------------------------------------
                        	; RequestIOFocus requests that the task receive the I/O focus. It does not
                        	; mean the task will receive the focus immediately. Instead it is placed
                        	; on a list of requesters. Which task has the I/O focus is determined from
                        	; user input.
                        	; The I/O focus list is an array indicating which apps are requesting the
                        	; I/O focus. The I/O focus is user controlled by pressing CNTRL-T on the
                        	; keyboard.
                        	;
                        	; Parameters:
                        	;		$a1 = app id requesting focus for
                        	; Returns:
                        	;   $a0 = E_Ok
                        	;   $a1 (unmodified)
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_RequestIOFocus:
FFFC385C 00106613		ldi   $a2,#1
FFFC3860 00A59393	  sll   $t2,$a1,#LOG_PGSZ
FFFC3864 3C238303		ldb		$t1,ACBHasFocus[$t2]  ; Is the task already included in the IO focus?
FFFC3868 04031463		bnez	$t1,.ret				      ; If so, don't add again
FFFC386C 000018B7		ldt	  $t0,IOFocusNdx			  ; get current index
FFFC3870 08088893
FFFC3874 000888B3
FFFC3878 0008A283
FFFC387C 02029063		bnez	$t0,.notEmpty		      ; is there one? (!= 0)
FFFC3880 000018B7		stt   $t2,IOFocusNdx
FFFC3884 08088893
FFFC3888 000888B3
FFFC388C 0078A023
FFFC3890 3273AC23		stt   $t2,ACBiofNext[$t2]
FFFC3894 3473A023		stt   $t2,ACBiofPrev[$t2]
FFFC3898 0180006F		jmp   .ret
                        	.notEmpty:
                        	  ; Insert just before head which is end of queue
FFFC389C 3402A303	  ldt   $t1,ACBiofPrev[$t0]
FFFC38A0 3472A023	  stt   $t2,ACBiofPrev[$t0]     ; head->prev = new
FFFC38A4 32732C23	  stt   $t2,ACBiofNext[$t1]     ; head->prev->next = new
FFFC38A8 3253AC23	  stt   $t0,ACBiofNext[$t2]     ; new->next = head
FFFC38AC 3463A023	  stt   $t1,ACBiofPrev[$t2]     ; new->prev = head->prev
                        	.ret:
FFFC38B0 3CC38123		stb   $a2,ACBHasFocus[$t2]  ; set has focus flag
FFFC38B4 00006513		ldi		$a0,#E_Ok
FFFC38B8 DE9FE06F		jmp		OSExit
                        	
                        	;-----------------------------------------------------------------------------
                        	; ReleaseIOFocus called when the app no longer desires to be on the I/O
                        	; focus list.
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ReleaseIOFocus:
                        		
FFFC38BC 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC38C0 00A51593	sll   $a1,$a0,#LOG_TCBSZ
FFFC38C4 3425D583		ldwu  $a1,TCBappid[$a1]
                        		; fall into ForceReleaseIOFocus
                        	
                        	;-----------------------------------------------------------------------------
                        	; Releasing the I/O focus causes the focus to switch if the running app
                        	; had the I/O focus.
                        	; ForceReleaseIOFocus forces the release of the IO focus for a app
                        	; different than the one currently running.
                        	; 
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		$a1 = app id to release
                        	; Returns:
                        	;		$a0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ForceReleaseIOFocus:
FFFC38C8 00A59293		sll		$t0,$a1,#LOG_PGSZ
FFFC38CC 3C228303		ldb		$t1,ACBHasFocus[$t0]
FFFC38D0 28030CE3		beqz	$t1,.noFocus	    ; does it even have the focus?
FFFC38D4 3C028123		stb   $x0,ACBHasFocus[$t0]
FFFC38D8 000018B7		ldt   $t1,IOFocusNdx
FFFC38DC 08088893
FFFC38E0 000888B3
FFFC38E4 0008A303
FFFC38E8 02629E63		bne   $t0,$t1,.notAtTop
FFFC38EC 3382A303		ldt   $t1,ACBiofNext[$t0]
FFFC38F0 02531263		bne   $t1,$t0,.0001
                        		; removing last entry
FFFC38F4 000018B7		stt   $x0,IOFocusNdx
FFFC38F8 08088893
FFFC38FC 000888B3
FFFC3900 0008A023
FFFC3904 3202AC23		stt   $x0,ACBiofNext[$t0]
FFFC3908 3402A023		stt   $x0,ACBiofPrev[$t0]
FFFC390C 00006513		ldi		$a0,#E_Ok
FFFC3910 D91FE06F		jmp		OSExit
                        	.0001:	
FFFC3914 000018B7		stt   $t1,IOFocusNdx
FFFC3918 08088893
FFFC391C 000888B3
FFFC3920 0068A023
                        	.notAtTop:
FFFC3924 3382A303		ldt   $t1,ACBiofNext[$t0]
FFFC3928 3402A383		ldt   $t2,ACBiofPrev[$t0]
FFFC392C 34732023		stt   $t2,ACBiofPrev[$t1]
FFFC3930 3263AC23		stt   $t1,ACBiofNext[$t2]
FFFC3934 3202AC23		stt   $x0,ACBiofNext[$t0]
FFFC3938 3402A023		stt   $x0,ACBiofPrev[$t0]
FFFC393C 00006513		ldi		$a0,#E_Ok
FFFC3940 D61FE06F		jmp		OSExit
                        	
                        	;------------------------------------------------------------------------------
                        	;     Wait for the IO Focus. Returns only when focus is present. This function
                        	; calls PeekChar() to see if there's a CTRL-T in the buffer which means to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;   a1 = device # to check, 5 = COM1 serial port, 1 = KBD keyboard
                        	;------------------------------------------------------------------------------
                        	
                        	_WaitForIOFocus:
                        	WaitForIOFocus:
FFFC3944 FF410113	  sub 	$sp,$sp,#12
FFFC3948 00A12023	  stt   $a0,[$sp]
FFFC394C 00B12223	  stt   $a1,4[$sp]
FFFC3950 00C12423	  stt   $a2,8[$sp]
                        	.WFF1:
FFFC3954 01406513		ldi		$a0,#20           ; FMTK Has Focus
FFFC3958 00000073		ecall
FFFC395C 04059663		bnez	$a1,.HasFocus
FFFC3960 01A06513		ldi   $a0,#26           ; FMTK_IO
FFFC3964 00506593		ldi   $a1,#5            ; hardcoded to serial port for now
FFFC3968 00906613		ldi   $a2,#9            ; peekchar function
FFFC396C 00000073		ecall
FFFC3970 0005C263		bltz  $a1,.0001
                        	.0001:
FFFC3974 01406513		ldi		$a0,#$14					; CTRL-T
FFFC3978 02A59063		bne		$a1,$a0,.WFF2
                        		; eat up the CTRL-T
FFFC397C 01A06513		ldi		$a0,#26						; FMTK_IO
FFFC3980 00506593		ldi   $a1,#5  ;4[$sp]        ; get back device #
FFFC3984 00806613		ldi		$a2,#8						; getchar function
FFFC3988 00000073		ecall
FFFC398C 01506513		ldi		$a0,#21						; switch IO Focus
FFFC3990 00000073		ecall
FFFC3994 FC0000E3		bra		.WFF1
                        	.WFF2:
FFFC3998 00506513		ldi		$a0,#5            ; FMTK Sleep() function
FFFC399C 00106593		ldi		$a1,#1
FFFC39A0 00000073		ecall
FFFC39A4 FA0008E3		bra		.WFF1
                        	.HasFocus:
FFFC39A8 00012503	  ldt   $a0,[$sp]
FFFC39AC 00412583	  ldt   $a1,4[$sp]
FFFC39B0 00812603	  ldt   $a2,8[$sp]
FFFC39B4 00C10113	  add   $sp,$sp,#12
FFFC39B8 00008067	  ret
                        	
                        	;------------------------------------------------------------------------------
                        	
                        	GetUIFlag:
FFFC39BC FF410113	  sub 	$sp,$sp,#12
FFFC39C0 00C12223	  stt   $a2,4[$sp]
FFFC39C4 00D12423	  stt   $a3,8[$sp]
FFFC39C8 01B06513	  ldi   $a0,#27           ; Get DCB Field
FFFC39CC 04206613	  ldi   $a2,#DCB_fUI      ; Get UI Flag
FFFC39D0 00106693	  ldi   $a3,#1            ; 1 byte
FFFC39D4 00000073	  ecall
FFFC39D8 00412603	  ldt   $a2,4[$sp]
FFFC39DC 00812683	  ldt   $a3,8[$sp]
FFFC39E0 00C10113	  add   $sp,$sp,#12
FFFC39E4 00008067	  ret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020-2021  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15   VIA							VIA1
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = function
                        	;		a3 = data
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_IO:
                        	;  mEI
FFFC39E8 02006513		ldi		$a0,#32
FFFC39EC 02A5FE63		bgeu	$a1,$a0,.badDev
FFFC39F0 02006393		ldi		$t2,#32
FFFC39F4 02767663		bgeu	$a2,$t2,.badFunc
FFFC39F8 00759E13		sll		$t3,$a1,#7					; each device allowed 32 functions (*128)
FFFC39FC 00261393		sll		$t2,$a2,#2					; function number *4
FFFC3A00 000028B7		add		$t3,$t3,#DVF_Base		; base address of function table
FFFC3A04 00088893
FFFC3A08 01C88E33
FFFC3A0C 007E0E33		add		$t3,$t3,$t2
FFFC3A10 000E2E03		ldt		$t3,[$t3]
FFFC3A14 000E0663		beqz	$t3,.badFunc
FFFC3A18 000E00E7		call	[$t3]
                        	.xit:
FFFC3A1C C85FE06F		jmp		OSExit
                        	.badFunc:
FFFC3A20 02206513		ldi		$a0,#E_BadDevOp
FFFC3A24 FE000CE3		bra		.xit
                        	.badDev:
FFFC3A28 02006513		ldi		$a0,#E_BadDevNum
FFFC3A2C FE0008E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = field offset
                        	;   a3 = 0 = get word, 1 = get byte
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_GetDCBField:
FFFC3A30 02006393		ldi		$t2,#32
FFFC3A34 0475F063		bgeu	$a1,$t2,.badDev
FFFC3A38 06006E13		ldi		$t3,#DCB_Size
FFFC3A3C 03C67863		bgeu	$a2,$t3,.badFunc
FFFC3A40 03C583B3		mul		$t2,$a1,$t3		      ; each device allowed (96 bytes)
FFFC3A44 000038B7		add		$t2,$t2,#DCB_Base		; base address of function table
FFFC3A48 00088893
FFFC3A4C 007883B3
FFFC3A50 00C383B3		add   $t2,$t2,$a2         ; add field offset
FFFC3A54 00068663		beqz  $a3,.ldWord
FFFC3A58 00038583		ldb   $a1,[$t2]
FFFC3A5C 00000463		bra   .ok
                        	.ldWord:
FFFC3A60 0003A583	  ldt   $a1,[$t2]
                        	.ok:
FFFC3A64 00006513	  ldi   $a0,#E_Ok
                        	.xit:
FFFC3A68 C39FE06F		jmp		OSExit
                        	.badFunc:
FFFC3A6C 01A06513		ldi		$a0,#E_BadDCBOffset
FFFC3A70 FE000CE3		bra		.xit
                        	.badDev:
FFFC3A74 02006513		ldi		$a0,#E_BadDevNum
FFFC3A78 FE0008E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = field offset
                        	;   a3 = 0 = get word, 1 = get byte
                        	;   a4 = value to set
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SetDCBField:
FFFC3A7C 02006393		ldi		$t2,#32
FFFC3A80 0475F063		bgeu	$a1,$t2,.badDev
FFFC3A84 06006E13		ldi		$t3,#DCB_Size
FFFC3A88 03C67863		bgeu	$a2,$t3,.badFunc
FFFC3A8C 03C583B3		mul		$t2,$a1,$t3		      ; each device allowed (96 bytes)
FFFC3A90 000038B7		add		$t2,$t2,#DCB_Base		; base address of function table
FFFC3A94 00088893
FFFC3A98 007883B3
FFFC3A9C 00C383B3		add   $t2,$t2,$a2         ; add field offset
FFFC3AA0 00068663		beqz  $a3,.stWord
FFFC3AA4 00E38023		stb   $a4,[$t2]
FFFC3AA8 00000463		bra   .ok
                        	.stWord:
FFFC3AAC 00E3A023	  stt   $a4,[$t2]
                        	.ok:
FFFC3AB0 00006513	  ldi   $a0,#E_Ok
                        	.xit:
FFFC3AB4 BEDFE06F		jmp		OSExit
                        	.badFunc:
FFFC3AB8 01A06513		ldi		$a0,#E_BadDCBOffset
FFFC3ABC FE000CE3		bra		.xit
                        	.badDev:
FFFC3AC0 02006513		ldi		$a0,#E_BadDevNum
FFFC3AC4 FE0008E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = I/O channel
                        	;		a1 = points to function table
                        	;------------------------------------------------------------------------------
                        	
                        	CopyDevFuncTbl:
FFFC3AC8 00751393		sll		$t2,$a0,#7					; each device allowed 32 functions (*128)
FFFC3ACC 000028B7		add		$t2,$t2,#DVF_Base		; base address of function table
FFFC3AD0 00088893
FFFC3AD4 007883B3
FFFC3AD8 02006293		ldi		$t0,#32							; 32 functions to copy
                        	.again:
FFFC3ADC 0005A683		ldt		$a3,[$a1]
FFFC3AE0 00D3A023		stt		$a3,[$t2]
FFFC3AE4 00458593		add		$a1,$a1,#4
FFFC3AE8 00438393		add		$t2,$t2,#4
FFFC3AEC FFF28293		sub		$t0,$t0,#1
FFFC3AF0 FE5046E3		bgtz	$t0,.again
FFFC3AF4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	
                        	CopyDevDCB:
FFFC3AF8 06006393	  ldi   $t2,#DCB_Size
FFFC3AFC 027503B3	  mul   $t2,$a0,$t2
FFFC3B00 000038B7	  add   $t2,$t2,#DCB_Base
FFFC3B04 00088893
FFFC3B08 007883B3
FFFC3B0C 01806293		ldi		$t0,#24							; 24 words to copy
                        	.again:
FFFC3B10 0005A683		ldt		$a3,[$a1]
FFFC3B14 00D3A023		stt		$a3,[$t2]
FFFC3B18 00458593		add		$a1,$a1,#4
FFFC3B1C 00438393		add		$t2,$t2,#4
FFFC3B20 FFF28293		sub		$t0,$t0,#1
FFFC3B24 FE5046E3		bgtz	$t0,.again
FFFC3B28 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;    Compare the current APPID against the device owner to see if the device
                        	; is owned.
                        	;------------------------------------------------------------------------------
                        	
                        	CheckDevOwner:
FFFC3B2C FFC10113	  sub   $sp,$sp,#4
FFFC3B30 00912023	  stt   $s1,[$sp]
FFFC3B34 0040E073		csrrs $x0,#$004,#1        ; enable gc interrupt
FFFC3B38 00E06513	  ldi   $a0,#14             ; FMTK: GetCurrentTid
FFFC3B3C 00000073	  ecall
FFFC3B40 0005E4B3	  mov   $s1,$a1
FFFC3B44 01B06513	  ldi   $a0,#27             ; FMTK Get DCB Field
FFFC3B48 04806613	  ldi   $a2,#DCB_hJob
FFFC3B4C 00006693	  ldi   $a3,#0              ; get word
FFFC3B50 00000073	  ecall
FFFC3B54 0FF5F593	  and   $a1,$a1,#$FF
FFFC3B58 0095C5B3	  xor   $a1,$a1,$s1
FFFC3B5C 00059A63	  bnez  $a1,.notOwner
FFFC3B60 00006513	  ldi   $a0,#E_Ok
                        	.xit:
FFFC3B64 00012483	  ldt   $s1,[$sp]
FFFC3B68 00410113	  add   $sp,$sp,#4
FFFC3B6C 00008067	  ret
                        	.notOwner:
FFFC3B70 01C06513	  ldi   $a0,#28             ; FMTK Set DCB field
FFFC3B74 0004E5B3	  mov   $a1,$s1
FFFC3B78 01806613	  ldi   $a2,#DCB_LastErc
FFFC3B7C 00006693	  ldi   $a3,#0              ; word
FFFC3B80 01206713	  ldi   $a4,#E_NotOwner
FFFC3B84 00000073	  ecall                     
FFFC3B88 00076533	  mov   $a0,$a4
FFFC3B8C FC000CE3	  bra   .xit
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/finalizer.r5a",1
                        	.file "../fmtk/finalizer.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; The Finalizer task examines the undead queue looking for tasks that haven't
                        	; been finalized yet. If there is no finalizer the task is marked dead, 
                        	; otherwise the task's execution point is changed to the task finalizer and
                        	; the task is placed back into the ready queue. The task finalizer should
                        	; exit by invoking the FinalizerExit routine of the OS.
                        	
                        	.file "../fmtk/finalizer.r5a",31
                        	  code  18 bits
                        	  align 4                        	
                        	Finalizer:
FFFC3B90 01806513	  ldi   $a0,#24               ; request I/O focus
FFFC3B94 00000073	  ecall
FFFC3B98 FFFC4537	  ldi   $a0,#msgFinalizerRunning
FFFC3B9C C8850513
FFFC3BA0 FB1FC0EF	  call  PutString
FFFC3BA4 01606513	  ldi   $a0,#22               ; release I/O focus
FFFC3BA8 00000073	  ecall
FFFC3BAC 00406513	  ldi   $a0,#4                ; set task priority
FFFC3BB0 00306593	  ldi   $a1,#PRI_LOW
FFFC3BB4 00000073	  ecall
                        	.yield:
FFFC3BB8 00506513	  ldi   $a0,#5                ; Sleep
FFFC3BBC 00006593	  ldi   $a1,#0                ; 0 to yeild
FFFC3BC0 00000073	  ecall
                        	.nxt2:
FFFC3BC4 01106513	  ldi   $a0,#17               ; RunAsOS
FFFC3BC8 FFFC45B7	  ldi   $a1,.oscode
FFFC3BCC BD858593
FFFC3BD0 00000073	  ecall
FFFC3BD4 FE0008E3	  bra   .nxt2
                        	.oscode:
FFFC3BD8 00706293	  ldi   $t0,#UNDEADQ
FFFC3BDC 1A02850D	  popq  $a0,$t0
  bge   $a0,$x0,.nxt2         ; valid entry?
FFFC3BE0 FE0552E3
FFFC3BE4 000048B7	  and   $t1,$a0,#$4000        ; queue empty?
FFFC3BE8 00088893
FFFC3BEC 00A8F333
FFFC3BF0 FC0314E3	  bnez  $t1,.yield            ; go back to yield
FFFC3BF4 0FF57313	  and   $t1,$a0,#$FF
FFFC3BF8 000008B7	  ldt   $a1,TidTcbMap[$t1]    ; get pointer to task
FFFC3BFC 34988893
FFFC3C00 006888B3
FFFC3C04 0008A583
FFFC3C08 FFF808B7	  and   $t1,$t1,#$FFF803FF    ; valid task pointer
FFFC3C0C 3FF88893
FFFC3C10 0068F333
FFFC3C14 FA0318E3	  bnez  $t1,.nxt2
FFFC3C18 0305A303	  ldt   $t1,OBJFinalizer[$a1] ; Finalizer code?
FFFC3C1C 00030A63	  beqz  $t1,.noFinalizer
                        	  ; If there is finalizer code to run, the task is placed back into the ready
                        	  ; queue with the operating address set to the finalizer code.
FFFC3C20 2C65A023	  stt   $t1,TCBepc[$a1]       ; Cause task to return to finalizer
FFFC3C24 00306313	  ldi   $t1,#PRI_LOW
FFFC3C28 3385C503	  ldbu  $a0,TCBtid[$a1]
FFFC3C2C 1865000D	  pushq $a0,$t1
.noFinalizer:
FFFC3C30 00206313	  ldi   $t1,#TS_DEAD
FFFC3C34 2C658423	  stb   $t1,TCBStatus[$a1]
FFFC3C38 08006313	  ldi   $t1,#OST_DEAD
FFFC3C3C 00658C23	  stb   $t1,OBJState[$a1]
FFFC3C40 00006513	  ldi   $a0,#E_Ok
FFFC3C44 A5DFE06F	  jmp   OSExit
FFFC3C48 F6000EE3	  bra   .nxt2
                        	
                        	FMTK_TCBFinalizerExit:
                        	  
FFFC3C4C 7C201573	  csrrw $a0,#CSR_TASKID,$x0
FFFC3C50 0FF57313	and   $t1,$a0,#$FF
FFFC3C54 000008B7	  ldt   $a1,TidTcbMap[$t1]    ; get pointer to task
FFFC3C58 34988893
FFFC3C5C 006888B3
FFFC3C60 0008A583
FFFC3C64 FFF808B7	  and   $t1,$t1,#$FFF803FF    ; valid task pointer
FFFC3C68 3FF88893
FFFC3C6C 0068F333
FFFC3C70 00031A63	  bnez  $t1,.0001
FFFC3C74 00206313	  ldi   $t1,#TS_DEAD
FFFC3C78 2C658423	  stb   $t1,TCBStatus[$a1]
FFFC3C7C 08006313	  ldi   $t1,#OST_DEAD
FFFC3C80 00658C23	  stb   $t1,OBJState[$a1]
                        	.0001:
FFFC3C84 A1DFE06F	  jmp   OSExit
                        	
                        	msgFinalizerRunning:
FFFC3C88 616E6946	  db  "Finalizer task running",CR,0
FFFC3C8C 657A696C
FFFC3C90 61742072
FFFC3C94 72206B73
FFFC3C98 696E6E75
FFFC3C9C 000D676E
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/gcIncremental.r5a",1
                        	.file "../fmtk/gcIncremental.r5a",1
                        	; Garbage Collector
                        	
                        	gcIncrement:
FFFC3CA0 00008067	  ret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "TinyBasic.r5a",1
                        	.file "TinyBasic.r5a",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x6C0
                        	FILEBUF		EQU		0x07F600
                        	OSSP		EQU		0x700
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	SRCHLN    EQU   CURRNT+4
                        	; Reserved four byte area before BUFFER in case line number stuffed into it
                        	; is less than four digits.
                        	BUFFER		EQU		SRCHLN+8
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x001800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x00F000	; end of available memory
                        	STACKOFFS	EQU		0x07FFFC	; stack offset
                        	
                        	
                        	.file "TinyBasic.r5a",86
                        			code
FFFC3CA4 00000000			align	25
FFFC3CA8 00000000
FFFC3CAC 00000000
FFFC3CB0 00000000
FFFC3CB4 00000000
FFFC3CB8 00000000
FFFC3CBC 00000000
FFFC3CC0 00000000
FFFC3CC4 00000000
FFFC3CC8 00000000
FFFC3CCC 00000000
FFFC3CD0 00000000
FFFC3CD4 00000000
FFFC3CD8 00000000
FFFC3CDC 00000000
FFFC3CE0 00000000
FFFC3CE4 00000000
FFFC3CE8 00000000
FFFC3CEC 00000000
FFFC3CF0 00000000
FFFC3CF4 00000000
FFFC3CF8 00000000
FFFC3CFC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC3D00 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC3D04 0C00006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC3D08 5750106F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC3D0C 5750106F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC3D10 000008B7			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC3D14 3B588067
                        	GOAUXI:	
FFFC3D18 000008B7			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC3D1C 3B788067
                        	GOBYE:	
FFFC3D20 5910106F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC3D24 00000000		align	1
FFFC3D28 00000000
FFFC3D2C 00000000
                        	
                        	//message "CSTART"
                        	public CSTART:
	; First save off the link register and OS sp value
FFFC3D30 70202023		stt		$sp,OSSP
FFFC3D34 00080137		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC3D38 FFC10113
FFFC3D3C 00E06513		ldi		$a0,#14							; Get current tid
FFFC3D40 00000073		ecall                     ; $a1 = task id
FFFC3D44 01206513		ldi   $a0,#18             ; Get task app id
FFFC3D48 00000073		ecall
FFFC3D4C 01806513		ldi		$a0,#24							; RequestIOFocus
FFFC3D50 00000073		ecall
                        	;	call	_DBGHomeCursor[pc]
FFFC3D54 00006533		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC3D58 FFFC6537		ldi		$a0,#msgInit  ;	tell who we are
FFFC3D5C AC450513
FFFC3D60 325010EF		call	PRMESG
FFFC3D64 00002537		ldi		$a0,#TXTBGN	;	init. end-of-program pointer
FFFC3D68 80050513
FFFC3D6C 70A02223		stt		$a0,TXTUNF
FFFC3D70 0000F537		ldi		$a0,#ENDMEM	;	get address of end of memory
FFFC3D74 00050513
FFFC3D78 00080537		ldi		$a0,#$7F800 ; 2k stack
FFFC3D7C 80050513
FFFC3D80 7AA02223		stt		$a0,STKBOT
FFFC3D84 0000F537		ldi		$a0,#ENDMEM
FFFC3D88 00050513
FFFC3D8C 70A02623		stt		$a0,VAREND
FFFC3D90 CE050513		sub		$a0,$a0,#800  ;   100 vars
FFFC3D94 70A02423		stt   $a0,VARBGN
FFFC3D98 4A8000EF		call  clearVars   ; clear the variable area
FFFC3D9C 7A002623		stt		$x0,IRQROUT
FFFC3DA0 70802503		ldt   $a0,VARBGN   ; calculate number of bytes free
FFFC3DA4 70402583		ldt		$a1,TXTUNF
FFFC3DA8 40B50533		sub   $a0,$a0,$a1
FFFC3DAC 00606593		ldi		$a1,#6		; max 6 digits
FFFC3DB0 00A06613		ldi		$a2,#10	  ; base 10
FFFC3DB4 7FC010EF		call  PRTNUM
FFFC3DB8 FFFC6537		ldi		$a0,#msgBytesFree
FFFC3DBC B6550513
FFFC3DC0 2C5010EF		call	PRMESG
                        	WSTART:
FFFC3DC4 70002823		stt		$x0,LOPVAR  ; initialize internal variables
FFFC3DC8 70002A23		stt		$x0,STKGOS
FFFC3DCC 70002C23		stt		$x0,CURRNT	;	current line number pointer = 0
FFFC3DD0 00080137		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC3DD4 FFC10113
FFFC3DD8 FFFC6537		ldi		$a0,#msgReady	;	display "Ready"
FFFC3DDC B7250513
FFFC3DE0 2A5010EF		call	PRMESG
                        	BASPRMPT:
FFFC3DE4 00E06513		ldi		$a0,#14		; get current tid
FFFC3DE8 00000073		ecall
FFFC3DEC 0005E533		mov		$a0,$a1   ;
FFFC3DF0 CF1FC0EF		call	PutHexByte
FFFC3DF4 03E06513		ldi		$a0,#'>'	; Prompt with a '>' and
FFFC3DF8 4B8010EF		call	GETLN		  ; read a line.
FFFC3DFC 1D9010EF		call	TOUPBUF 	; convert to upper case
FFFC3E00 72406393		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC3E04 129010EF		call	TSTNUM		; is there a number there?
FFFC3E08 195010EF		call	IGNBLK		; skip trailing blanks
FFFC3E0C 0003CB03		ldbu	$s6,[$t2]
FFFC3E10 00DB4B13		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC3E14 260C8E63		beqz	$s9,DIRECT		; if not, it's a direct statement ($s9 = num digits)
FFFC3E18 00100337		ldi		$t1,#$FFFFF
FFFC3E1C FFF30313
FFFC3E20 01837863		bleu	$s8,$t1,ST2	; see if line no. is <= 20 bits
FFFC3E24 FFFC6537		ldi		$a0,#msgLineRange	; if not, we've overflowed
FFFC3E28 B8D50513
FFFC3E2C 4400106F		jmp		ERROR
                        	ST2:
FFFC3E30 000C6533	  mov		$a0,$s8		; a0 = line number
FFFC3E34 0003EAB3	  mov		$s5,$t2			; save line buffer pointer
FFFC3E38 FFB38393		sub		$t2,$t2,#5
FFFC3E3C 00A3A0A3	  stt		$a0,1[$t2]  ;	This will end up in buffer (requires unaligned store capability)
FFFC3E40 560010EF		call	FNDLN		; find this line in save area
FFFC3E44 000E6BB3		mov		$s7,$t3		; $s7 = save possible line pointer
FFFC3E48 000C0663		beqz	$s8,INSLINE	; if not found, insert
FFFC3E4C 000E6533		mov		$a0,$t3
FFFC3E50 050000EF		call	DeleteLine
                        	INSLINE:
FFFC3E54 F80B08E3		beqz	$s6,BASPRMPT	; line was empty
FFFC3E58 000AE533		mov		$a0,$s5			; a0 = buffer pointer
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC3E5C 094000EF		call	GetBuflen
FFFC3E60 005C0A13		add		$s4,$s8,#5  ; update length, needed later
FFFC3E64 FF4A8DA3		stb   $s4,-5[$s5] ; put length into buffer
FFFC3E68 000BE533		mov		$a0,$s7
FFFC3E6C 000A65B3		mov		$a1,$s4
FFFC3E70 0AC000EF		call	OpenSpace
FFFC3E74 000C1863		bnez	$s8,.0001	  ; space available?
FFFC3E78 FFFC6537		ldi		$a0,#msgTooBig  ; no space available
FFFC3E7C C5F50513
FFFC3E80 3EC0106F		jmp		ERROR
                        	.0001:
FFFC3E84 000AE533	  mov   $a0,$s5
FFFC3E88 CC9FC0EF		call  PutString	
FFFC3E8C 000BE533		mov		$a0,$s7			; target
FFFC3E90 FFBA8593		sub		$a1,$s5,#5	; source (incl lineno)
FFFC3E94 000A6633		mov		$a2,$s4			; length
FFFC3E98 038000EF		call	InsertLine
FFFC3E9C F40004E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
FFFC3EA0 00054283		ldbu  $t0,[$a0]     ; $t0 = length
FFFC3EA4 00A282B3		add		$t0,$t0,$a0		; t0 = pointer to line past line number and length
FFFC3EA8 70402E03		ldt		$t3,TXTUNF		; last text address
                        		; pull text after eol overtop
                        	.0003:
FFFC3EAC 0002CE83		ldbu	$t4,[$t0]			; copy from next line
FFFC3EB0 01D50023		stb		$t4,[$a0]			; overtop deleted line
FFFC3EB4 00128293		add		$t0,$t0,#1		; increment pointers
FFFC3EB8 00150513		add		$a0,$a0,#1
FFFC3EBC FE5E78E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC3EC0 40A28533		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC3EC4 40AE0E33		sub		$t3,$t3,$a0		
FFFC3EC8 71C02223		stt		$t3,TXTUNF
FFFC3ECC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC3ED0 00060E63		beqz	$a2,.done		    ; zero length? Probably a SW error
                        	.0001:
FFFC3ED4 0005C303		ldbu	$t1,[$a1]				; get from source text
FFFC3ED8 00650023		stb		$t1,[$a0]				; store to insertion point
FFFC3EDC 00158593		add		$a1,$a1,#1			; increment pointers
FFFC3EE0 00150513		add		$a0,$a0,#1
FFFC3EE4 FFF60613		sub		$a2,$a2,#1			; decrement length
FFFC3EE8 FEC046E3		bgtz	$a2,.0001
                        	.done:
FFFC3EEC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		s8 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC3EF0 00006C13		ldi		$s8,#0
FFFC3EF4 00D06E13		ldi		$t3,#CR
FFFC3EF8 00056F33		mov		$t5,$a0
                        	.0002:
FFFC3EFC 000F4383		ldbu	$t2,[$t5]
FFFC3F00 001F0F13		add		$t5,$t5,#1
FFFC3F04 00038A63		beqz	$t2,.0001
FFFC3F08 01C38663		beq		$t2,$t3,.0004
FFFC3F0C 001C0C13		add		$s8,$s8,#1
FFFC3F10 FE0006E3		bra		.0002
                        	.0004:
FFFC3F14 001C0C13		add		$s8,$s8,#1
                        	.0001:
FFFC3F18 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		s8 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC3F1C 70402383		ldt		$t2,TXTUNF
FFFC3F20 0003EE33		mov		$t3,$t2				; t3 = old end of text
FFFC3F24 00B383B3		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC3F28 70802303		ldt		$t1,VARBGN		; compare to start of variables
FFFC3F2C 0263F263		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC3F30 70702223		stt		$t2,TXTUNF		; yes, set new end of text
                        	.0003:
FFFC3F34 000E4F03		ldbu	$t5,[$t3]			; copy old text
FFFC3F38 01E38023		stb		$t5,[$t2]			; to new text loc
FFFC3F3C FFFE0E13		sub		$t3,$t3,#1		; decrement pointers
FFFC3F40 FFF38393		sub		$t2,$t2,#1
FFFC3F44 FEAE78E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC3F48 00106C13		ldi		$s8,#1				; return success
FFFC3F4C 00008067		ret
                        	.noSpace:
FFFC3F50 00006C13		ldi		$s8,#0
FFFC3F54 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC3F58 D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC3F5C C4414F4C		db	"LOA",'D'+0x80
FFFC3F60 52D7454E		db	"NE",'W'+0x80
FFFC3F63 53CE5552		db	"RU",'N'+0x80
FFFC3F66 C5564153		db	"SAV",'E'+0x80
FFFC3F6A 45454C53		db  "SLEE",'P'+0x80
FFFC3F6E 58454ED0
                        	TAB2:
FFFC3F6F D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC3F73 49D4454C		db	"LE",'T'+0x80
FFFC3F76 4F47C649		db	"I",'F'+0x80
FFFC3F78 CF544F47		db	"GOT",'O'+0x80
FFFC3F7C 55534F47		db	"GOSU",'B'+0x80
FFFC3F80 544552C2
FFFC3F81 55544552		db	"RETUR",'N'+0x80
FFFC3F85 4552CE52
FFFC3F87 46CD4552		db	"RE",'M'+0x80
FFFC3F8A 49D24F46		db	"FO",'R'+0x80
FFFC3F8D 55504E49		db	"INPU",'T'+0x80
FFFC3F91 495250D4
FFFC3F92 4E495250		db	"PRIN",'T'+0x80
FFFC3F96 4B4F50D4
FFFC3F97 C54B4F50		db	"POK",'E'+0x80
FFFC3F9B 454B4F50		db	"POKE",'W'+0x80
FFFC3F9F 4B4F50D7
FFFC3FA0 454B4F50		db	"POKE",'H'+0x80
FFFC3FA4 454959C8
FFFC3FA5 4C454959		db	"YIEL",'D'+0x80
FFFC3FA9 4F5453C4
FFFC3FAA D04F5453		db	"STO",'P'+0x80
FFFC3FAE 53C55942		db	"BY",'E'+0x80
FFFC3FB1 43D35953		db	"SY",'S'+0x80
FFFC3FB4 43D34C43		db	"CL",'S'+0x80
FFFC3FB7 52D24C43	    db  "CL",'R'+0x80
FFFC3FBA C6434452	    db	"RDC",'F'+0x80
FFFC3FBE 52494E4F	    db	"ONIR",'Q'+0x80
FFFC3FC2 494157D1
FFFC3FC3 D4494157	    db	"WAI",'T'+0x80
FFFC3FC7 45455000		db	0
                        	TAB4:
FFFC3FC8 CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC3FCC 4B454550		db	"PEEK",'W'+0x80
FFFC3FD0 454550D7
FFFC3FD1 4B454550		db	"PEEK",'H'+0x80
FFFC3FD5 C44E52C8
FFFC3FD6 41C44E52		db	"RN",'D'+0x80
FFFC3FD9 53D34241		db	"AB",'S'+0x80
FFFC3FDC 54CE4753		db  "SG",'N'+0x80
FFFC3FDF CB434954		db	"TIC",'K'+0x80
FFFC3FE3 C55A4953		db	"SIZ",'E'+0x80
FFFC3FE7 41D25355		db  "US",'R'+0x80
FFFC3FEA 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC3FEE D8424D43
FFFC3FF2 444E4553	  db	"SENDMS",'G'+0x80
FFFC3FF6 57C7534D
FFFC3FF9 54494157	  db	"WAITMS",'G'+0x80
FFFC3FFD 00C7534D
FFFC4000 00CF5400		db	0
                        	TAB5:
FFFC4001 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC4003 45545300		db	0
                        	TAB6:
FFFC4004 D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC4008 3CBD3E00		db	0
                        	TAB8:
FFFC4009 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC400B BDBEBE3C		db	'<','>'+0x80
FFFC400D BD3CBDBE		db	'>'+0x80
FFFC400E BCBD3CBD		db	'='+0x80
FFFC400F 00BCBD3C		db	'<','='+0x80
FFFC4011 4E4100BC		db	'<'+0x80
FFFC4012 C44E4100		db	0
                        	TAB9:
FFFC4013 00C44E41	    db  "AN",'D'+0x80
FFFC4016 00D24F00	    db  0
                        	TAB10:
FFFC4017 B400D24F	    db  "O",'R'+0x80
FFFC4019 9442B400	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
                        		align	2                        	
                        	TAB1_1:
FFFC401A 479442B4		dh	LISTX			;Direct commands
FFFC401C 41104794		dh	LOAD3
FFFC401E 41684110		dh	NEW
FFFC4020 47FC4168		dh	RUN
FFFC4022 412C47FC		dh	SAVE3
FFFC4024 44B4412C		dh  SLEEP
                        	TAB2_1:
FFFC4026 464C44B4		dh	NEXT		;	Direct / statement
FFFC4028 452C464C		dh	LET
FFFC402A 4214452C		dh	IF0
FFFC402C 43A04214		dh	GOTO
FFFC402E 43E443A0		dh	GOSUB
FFFC4030 453843E4		dh	RETURN
FFFC4032 44284538		dh	IF2			; REM
FFFC4034 45804428		dh	FOR
FFFC4036 43004580		dh	INPUT
FFFC4038 49584300		dh	PRINT
FFFC403A 49844958		dh	POKE
FFFC403C 49B04984		dh	POKEW
FFFC403E 416049B0		dh	POKEH
FFFC4040 41244160		dh	YIELD0
FFFC4042 3D204124		dh	STOP
FFFC4044 49E83D20		dh	GOBYE
FFFC4046 03F949E8		dh	SYSX
FFFC4048 423803F9		dh	_cls
FFFC404A 03FB4238		dh  _clr
FFFC404C 427803FB		dh	_rdcf
FFFC404E 42A04278		dh  ONIRQ
FFFC4050 464042A0		dh	WAITIRQ
FFFC4052 50044640		dh	DEFLT
                        	TAB4_1:
FFFC4054 501C5004		dh	PEEK			;Functions
FFFC4056 5034501C		dh	PEEKW
FFFC4058 508C5034		dh	PEEKH
FFFC405A 0000508C		dh	RND
FFFC405C 51200000		dh	ABS
FFFC405E 510C5120		dh  SGN
FFFC4060 515C510C		dh	TICKX
FFFC4062 504C515C		dh	SIZEX
FFFC4064 589C504C		dh  USRX
FFFC4066 5908589C		dh	ALLOCMBX
FFFC4068 59A45908		dh	SENDMSG
FFFC406A 4DE059A4		dh	WAITMSG
FFFC406C 44484DE0		dh	XP40
                        	TAB5_1
FFFC406E 52644448		dh	FR1			;"TO" in "FOR"
FFFC4070 44645264		dh	QWHAT
                        	TAB6_1
FFFC4072 446C4464		dh	FR2			;"STEP" in "FOR"
FFFC4074 4B98446C		dh	FR3
                        	TAB8_1
FFFC4076 4BB04B98		dh	XP11	;>=		Relational operators
FFFC4078 4BC84BB0		dh	XP12	;<>
FFFC407A 4BF84BC8		dh	XP13	;>
FFFC407C 4BE04BF8		dh	XP15	;=
FFFC407E 4C104BE0		dh	XP14	;<=
FFFC4080 4C504C10		dh	XP16	;<
FFFC4082 4AA84C50		dh	XP17
                        	TAB9_1
FFFC4084 4ABC4AA8	    dh  XP_AND
FFFC4086 4A484ABC	    dh  XP_ANDX
                        	TAB10_1
FFFC4088 4A5C4A48	    dh  XP_OR
FFFC408A 00004A5C	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC408C 00000000		align	1
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC4090 FFFC4E37		ldi		$t3,#TAB1
FFFC4094 F58E0E13
FFFC4098 FFFC4EB7		ldi		$t4,#TAB1_1
FFFC409C 01AE8E93
                        	EXEC:
FFFC40A0 6FC010EF		call	IGNBLK		; ignore leading blanks
FFFC40A4 0003EF33		mov		$t5,$t2		; save the pointer
FFFC40A8 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC40AC 0003C503		ldbu	$a0,[$t2]		; get the program character
FFFC40B0 00138393		add		$t2,$t2,#1
FFFC40B4 000E4583		ldbu	$a1,[$t3]		; get the table character
FFFC40B8 00059663		bnez	$a1,EXNGO		; If end of table,
FFFC40BC 000F63B3		mov		$t2,$t5		;	restore the text pointer and...
FFFC40C0 02000E63		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC40C4 02350C63		beq		$a0,r3,EXGO	; Else check for period... if so, execute
FFFC40C8 07F5F593		and		$a1,$a1,#$7f  ; ignore the table's high bit
FFFC40CC 02A58063		beq		$a1,$a0,EXMAT	;		is there a match?
FFFC40D0 002E8E93		add		$t4,$t4,#2	;if not, try the next entry
FFFC40D4 000F63B3		mov		$t2,$t5		; reset the program pointer
FFFC40D8 000061B3		mov		r3,$x0		; sorry, no match
                        	EX1:
FFFC40DC 000E0503		ldb	  $a0,[$t3]		; get to the end of the entry
FFFC40E0 001E0E13		add		$t3,$t3,#1
FFFC40E4 FE055CE3		bge   $a0,$x0,EX1
                        	;	and		$t1,$a0,#$80
                        	;	beq		$t1,$r0,EX1	; test for bit 7 set
FFFC40E8 FC0002E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC40EC 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC40F0 000E0503		ldb	  $a0,[$t3]		; end of table entry?
FFFC40F4 001E0E13		add		$t3,$t3,#1
FFFC40F8 FA055AE3		bge   $a0,$x0,EXLP
                        	;	and		$t1,$a0,#$80
                        	;	beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC40FC 000ED503		ldwu	$a0,[$t4]	; get the low mid order byte
FFFC4100 FFFC08B7		or		$a0,$a0,#$FFFC0000  ; add in ROM base
FFFC4104 00088893
FFFC4108 00A8E533
FFFC410C 00050067		jmp		[$a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC4110 10C010EF		call	ENDCHK
FFFC4114 00002C37		ldi		$s8,#TXTBGN
FFFC4118 800C0C13
FFFC411C 71802223		stt		$s8,TXTUNF	;	set the end pointer
FFFC4120 120000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC4124 0F8010EF		call	ENDCHK
FFFC4128 C9DFF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SLEEP:
FFFC412C 0E9000EF		call	OREXPR		;evaluate the following expression
FFFC4130 000C64B3		mov   $s1,$s8
FFFC4134 0E8010EF	  call  ENDCHK
                        	SLEEP1:
FFFC4138 01606513	  ldi   $a0,#22   ; FMTK release I/O focus
FFFC413C 00000073	  ecall
FFFC4140 00506513	  ldi   $a0,#5    ; FMTK sleep function
FFFC4144 0004E5B3	  mov   $a1,$s1
FFFC4148 00000073	  ecall
FFFC414C 00E06513	  ldi   $a0,#14   ; FMTK get current tid
FFFC4150 00000073	  ecall
FFFC4154 01806513	  ldi   $a0,#24   ; FMTK request I/O focus
FFFC4158 00000073	  ecall
FFFC415C 23C0006F	  jmp   FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC4160 00006493	  ldi   $s1,#0
FFFC4164 FC000AE3	  bra   SLEEP1
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC4168 0B4010EF		call	ENDCHK
FFFC416C 000023B7		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC4170 80038393
FFFC4174 70702C23		stt		$t2,CURRNT
FFFC4178 0C8000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC417C 71802383		ldt		$t2,CURRNT	; executing a program?
FFFC4180 00039463		bnez	$t2,RUN3	  ; if not, we've finished a direct stat.
                        	RUN2:
FFFC4184 C41FF06F		jmp		WSTART
                        	RUN3:
FFFC4188 70702E23	  stt   $t2,SRCHLN
FFFC418C 0003CE03	  ldbu  $t3,[$t2]
FFFC4190 01C383B3	  add   $t2,$t2,$t3
FFFC4194 7AC02503		ldt		$a0,IRQROUT		; are we handling IRQ's ?
FFFC4198 04050463		beqz  $a0,RUN1
FFFC419C 02306513		ldi   $a0,#35       ; Get IRQ flag, was there an IRQ?
FFFC41A0 00000073		ecall
FFFC41A4 020C0E63		beqz	$s8,RUN1
FFFC41A8 02406513		ldi   $a0,#36       ; Set IRQ flag
FFFC41AC 00006593		ldi   $a1,#0        ; set the flag to zero
FFFC41B0 00000073		ecall
FFFC41B4 2BC010EF		call	PUSHA_		; the same code as a GOSUB
FFFC41B8 FF41310D		gcsub	$sp,$sp,#12
FFFC41BC 71402503		ldt		$a0,STKGOS
FFFC41C0 00A12023		stt		$a0,[$sp]
FFFC41C4 71802503		ldt		$a0,CURRNT
FFFC41C8 00A12223		stt		$a0,4[$sp]
FFFC41CC 00712423		stt		$t2,8[$sp]
FFFC41D0 70002823		stt		$x0,LOPVAR		; load new values
FFFC41D4 70202A23		stt		$sp,STKGOS
FFFC41D8 7AC02E03		ldt		$t3,IRQROUT
FFFC41DC 00000C63		bra		RUNTSL
                        	RUN1:
FFFC41E0 0003EE33		mov		$t3,$t2
FFFC41E4 00006533		mov		$a0,$x0
FFFC41E8 20C010EF		call	FNDNXT  		; else find the next line number
FFFC41EC 70402303		ldt		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC41F0 F86E7AE3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC41F4 71C02C23		stt		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC41F8 005E0393		add		$t2,$t3,#5	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC41FC 658010EF		call	CHKIO		; see if a control-C was pressed
FFFC4200 FFFC4E37		ldi		$t3,#TAB2		; find command in TAB2
FFFC4204 F6FE0E13
FFFC4208 FFFC4EB7		ldi		$t4,#TAB2_1
FFFC420C 026E8E93
FFFC4210 E91FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC4214 001000EF		call	OREXPR		;evaluate the following expression
FFFC4218 000C62B3		mov   $t0,$s8
FFFC421C 000010EF		call 	ENDCHK		;must find end of line
FFFC4220 0002E533		mov   $a0,$t0
FFFC4224 17C010EF		call 	FNDLN		; find the target line
FFFC4228 FC0C16E3		bnez	$s8,RUNTSL  ; go do it
FFFC422C FFFC6537		ldi		$a0,#msgBadGotoGosub
FFFC4230 C2D50513
FFFC4234 0380106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC4238 008000EF	    call    clearVars
FFFC423C 15C0006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC4240 FF81310D		gcsub	$sp,$sp,#8
FFFC4244 00612023		stt		r6,[$sp]
FFFC4248 00112223		stt		$ra,4[$sp]
FFFC424C 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC4250 70802C03	  ldt   s8,VARBGN
                        	.cv1:
FFFC4254 000C2023	  stt		x0,[$s8]		; variable name
FFFC4258 000C2223	  stt		x0,4[$s8]		; and value
FFFC425C 008C0C13	  add		s8,s8,#8
FFFC4260 FFF30313	  sub		r6,r6,#1
FFFC4264 FE6048E3		bgt		r6,x0,.cv1
FFFC4268 00012303	  ldt		r6,[$sp]
FFFC426C 00412083	  ldt		$ra,4[$sp]
FFFC4270 00810113	  add		$sp,$sp,#8
FFFC4274 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC4278 79C000EF		call	OREXPR		;evaluate the following expression
FFFC427C 000C62B3		mov   $t0,$s8
FFFC4280 79D000EF		call 	ENDCHK		;must find end of line
FFFC4284 0002E533		mov   $a0,$t0
FFFC4288 118010EF		call 	FNDLN		; find the target line
FFFC428C 000C1663		bnez	$s8,ONIRQ1
FFFC4290 7A002623		stt		$x0,IRQROUT
FFFC4294 1040006F		jmp		FINISH
                        	ONIRQ1:
FFFC4298 7BC02623		stt		$t3,IRQROUT
FFFC429C 0FC0006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC42A0 5B4010EF		call	CHKIO		; see if a control-C was pressed
FFFC42A4 02306513		ldi   $a0,#35
FFFC42A8 00000073		ecall
FFFC42AC FE050AE3		beqz	$a0,WAITIRQ
FFFC42B0 0E80006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC42B4 478010EF		call		TSTNUM		; see if there's a line no.
FFFC42B8 000C62B3		mov      r5,$s8
FFFC42BC 761000EF		call		ENDCHK		; if not, we get a zero
FFFC42C0 0002E533		mov      $a0,r5
FFFC42C4 0DC010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC42C8 000C1663		bnez		$s8,LS4
                        	LS5:
FFFC42CC 70402303		ldt		$t1,TXTUNF
FFFC42D0 AE6E7AE3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC42D4 000E6533		mov		$a0,$t3
FFFC42D8 3AC010EF		call	PRTLN		; print the line
FFFC42DC 00054E03		ldbu  $t3,[$a0]
FFFC42E0 00AE0E33		add   $t3,$t3,$a0 ; set pointer for next
                        	;	mov		$t3,$s8		
FFFC42E4 570010EF		call	CHKIO		; check for listing halt request
FFFC42E8 00050A63		beqz	$a0,LS3
FFFC42EC 01306313		ldi		$t1,#CTRLS
FFFC42F0 00651663		bne		$a0,$t1,LS3 ; pause the listing?
                        	LS2:
FFFC42F4 560010EF		call 	CHKIO		; if so, wait for another keypress
FFFC42F8 FE050EE3		beqz	$a0,LS2
                        	LS3:
                        	;	mov		$s8,$x0
FFFC42FC FC0008E3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC4300 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC4304 3DC010EF		call	TSTC		; if null list and ":"
FFFC4308 0000003A		dw		':'
FFFC430C 00000663		bra		PR2
FFFC4310 56C010EF		call	CRLF		; give CR-LF and continue
FFFC4314 EE9FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC4318 3C8010EF		call	TSTC		;if null list and <CR>
FFFC431C 0000000D		dw		CR
FFFC4320 00000663		bra		PR0
FFFC4324 558010EF		call	CRLF		;also give CR-LF and
FFFC4328 E55FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC432C 3B4010EF		call	TSTC		;else is it a format?
FFFC4330 00000023		dw		'#'
FFFC4334 00000863		bra		PR1
FFFC4338 6DC000EF		call	OREXPR		; yes, evaluate expression
FFFC433C 000C62B3		mov		r5,s8	; and save it as print width
FFFC4340 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC4344 39C010EF		call	TSTC	;	is character expression? (MRL)
FFFC4348 00000024		dw		'$'
FFFC434C 00000863		bra		PR4
FFFC4350 6C4000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC4354 9B5FF0EF		call	GOOUT	;	print low byte (MRL)
FFFC4358 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC435C 1C0010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC4360 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC4364 37C010EF		call		TSTC	;	if ",", go find next
FFFC4368 0000002C		dw		','
FFFC436C 00000663		bra		PR6
FFFC4370 671000EF		call		FIN		;in the list.
FFFC4374 FA000CE3		bra		PR0
                        	PR6:
FFFC4378 504010EF		call		CRLF		;list ends here
FFFC437C 01C0006F		jmp		FINISH
                        	PR8:
FFFC4380 694000EF		call	OREXPR		; evaluate the expression
FFFC4384 000C6533		mov		$a0,$s8
FFFC4388 00506593		ldi		$a1,#5		; set the width
FFFC438C 00A06613		ldi		$a2,#10
FFFC4390 220010EF		call	PRTNUM		; print its value
FFFC4394 FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC4398 649000EF		call	FIN		; Check end of command
FFFC439C 6C90006F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC43A0 0D0010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC43A4 670000EF		call	OREXPR		; get line number
FFFC43A8 000C6533		mov		$a0,$s8
FFFC43AC 7F5000EF		call	FNDLN		; find the target line
FFFC43B0 000C1863		bnez	$s8,gosub1
FFFC43B4 FFFC6537		ldi		a0,#msgBadGotoGosub
FFFC43B8 C2D50513
FFFC43BC 6B10006F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC43C0 FF410113		sub		$sp,$sp,#12
FFFC43C4 71402503		lw		a0,STKGOS	; 'STKGOS'
FFFC43C8 00A12023		sw		a0,[$sp]
FFFC43CC 71802503		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC43D0 00A12223		sw		a0,4[$sp]
FFFC43D4 00712423		sw		$t2,8[$sp]
FFFC43D8 70002823		sw		$x0,LOPVAR		; load new values
FFFC43DC 70202A23		sw		$sp,STKGOS
FFFC43E0 E15FF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC43E4 639000EF		call	ENDCHK		; there should be just a <CR>
FFFC43E8 71402583		lw		a1,STKGOS		; get old stack pointer
FFFC43EC 00059863		bne		a1,x0,return1
FFFC43F0 FFFC6537		ldi		a0,#msgRetWoGosub
FFFC43F4 C4950513
FFFC43F8 6750006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC43FC 0005E133		mov		$sp,a1		; else restore it
FFFC4400 00012503		lw		a0,[$sp]
FFFC4404 00410113		add		$sp,$sp,#4
FFFC4408 70A02A23		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC440C 00012503		lw		a0,[$sp]
FFFC4410 00410113		add		$sp,$sp,#4
FFFC4414 70A02C23		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC4418 00012383		lw		$t2,[$sp]	; and the old text pointer
FFFC441C 00410113		add		$sp,$sp,#4
FFFC4420 018010EF		call	POPA_		;and the old 'FOR' parameters
FFFC4424 F75FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC4428 048010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC442C 54D000EF		call	SETVAL		; set the control variable
FFFC4430 71802823		sw		s8,LOPVAR		; save its address
FFFC4434 FFFC4E37		ldi		$t3,#TAB5
FFFC4438 001E0E13
FFFC443C FFFC4EB7		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC4440 06EE8E93
FFFC4444 C5DFF06F		jmp		EXEC
                        	FR1:
FFFC4448 5CC000EF		call	OREXPR		; evaluate the limit
FFFC444C 79802223		sw		s8,LOPLMT	; save that
FFFC4450 FFFC4E37		ldi		$t3,#TAB6
FFFC4454 004E0E13
FFFC4458 FFFC4EB7		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC445C 072E8E93
FFFC4460 C41FF06F		jmp		EXEC
                        	FR2:
FFFC4464 5B0000EF		call	OREXPR		; found it, get the step value
FFFC4468 00000463		bra		FR4
                        	FR3:
FFFC446C 00106C13		ldi		s8,#1		; not found, step defaults to 1
                        	FR4:
FFFC4470 79802023		sw		s8,LOPINC	; save that too
                        	FR5:
FFFC4474 71802583		lw		a1,CURRNT
FFFC4478 76B02E23		sw		a1,LOPLN	; save address of current line number
FFFC447C 76702C23		sw		$t2,LOPPT	; and text pointer
FFFC4480 000161B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC4484 71002303		lw		r6,LOPVAR
FFFC4488 00000463		bra		FR7
                        	FR6:
FFFC448C 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC4490 0001A583		lw		a1,[r3]		; is it zero?
FFFC4494 00058E63		beq		a1,x0,FR8	; if so, we're done
FFFC4498 FE659AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC449C 0001E533	  mov		a0,r3	   ; Else remove 5 words from...
FFFC44A0 000165B3		mov		a1,$sp
FFFC44A4 01418613		add		a2,r3,#20  ; inside the stack.
FFFC44A8 789000EF		call	MVDOWN
FFFC44AC 01410113		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC44B0 EE9FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC44B4 00006533		mov		a0,x0		; don't allocate it
FFFC44B8 19D000EF		call	TSTV		; get address of variable
FFFC44BC 000C1863		bne		s8,x0,NX4
FFFC44C0 FFFC6537		ldi		a0,#msgNextVar
FFFC44C4 C0A50513
FFFC44C8 5A0002E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC44CC 000C6E33		mov		$t3,s8	; save variable's address
                        	NX0:
FFFC44D0 71002503		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC44D4 00051863		bne		a0,x0,NX5	; had a FOR loop
FFFC44D8 FFFC6537		ldi		a0,#msgNextFor
FFFC44DC BF850513
FFFC44E0 580006E3		bra		ERROR
                        	NX5:
FFFC44E4 01C50663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC44E8 751000EF		call	POPA_		; nope, let's see the next frame
FFFC44EC FE0002E3		bra		NX0
                        	NX2:
FFFC44F0 000E2503		lw		a0,[$t3]		; get control variable's value
FFFC44F4 78002583		lw		a1,LOPINC
FFFC44F8 00B50533		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC44FC 00AE2023		sw		a0,[$t3]		; save control variable's new value
FFFC4500 78402183		lw		r3,LOPLMT	; get loop's limit value
FFFC4504 0005D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC4508 00354E63		blt		a0,r3,NXPurge	; test against limit
FFFC450C 00000463		bra     NX3
                        	NX1:
FFFC4510 00A1CA63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC4514 77C02383		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC4518 70702C23		sw		$t2,CURRNT
FFFC451C 77802383		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC4520 E79FF06F		jmp		FINISH
                        	NXPurge:
FFFC4524 715000EF	  call    POPA_        ; purge this loop
FFFC4528 E71FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC452C 4E8000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC4530 000C0463	  beqz	$s8,IF2	; is it zero? if not, continue
FFFC4534 CC9FF06F	  jmp		RUNSML
                        	IF2:
FFFC4538 0003EE33	  mov		$t3,$t2	; set lookup pointer
FFFC453C 00006533		mov		$a0,$x0		; find line #0 (impossible)
FFFC4540 71802503		ldt   $a0,CURRNT  ; move to the next line
FFFC4544 00054583		ldbu  $a1,[$a0]
FFFC4548 00A585B3		add   $a1,$a1,$a0
FFFC454C 70B02C23		stt   $a1,CURRNT
FFFC4550 70402503		ldt   $a0,TXTUNF  ; do a warm start if past end
FFFC4554 00A5E463		bltu  $a1,$a0,IF3
FFFC4558 86DFF06F		jmp		WSTART
                        	IF3:
FFFC455C 0005EE33	  mov   $t3,$a1
FFFC4560 C95FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC4564 7A002103		ldt		$sp,STKINP		; restore the old stack pointer
FFFC4568 00012503		ldt		$a0,[$sp]
FFFC456C 00410113		add		$sp,$sp,#4
FFFC4570 70A02C23		stt		$a0,CURRNT		; and old 'CURRNT'
FFFC4574 00012383		ldt		$t2,[$sp]		; and old text pointer
FFFC4578 00410113		add		$sp,$sp,#4
FFFC457C 01410113		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC4580 FEC10113		sub		$sp,$sp,#20	; allocate five words on stack
FFFC4584 00512823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC4588 00712023		sw		$t2,[$sp]	; save in case of error
FFFC458C 791000EF		call	QTSTG		; is next item a string?
FFFC4590 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC4594 00106513		ldi		a0,#1		; allocate var
FFFC4598 0BD000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC459C 08050463		beq    a0,r0,IP4   ; if not, brnch
FFFC45A0 00056EB3		mov		$t4,a0		; put away the variable's address
FFFC45A4 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC45A8 00712223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC45AC 00106513		ldi		a0,#1
FFFC45B0 0A5000EF		call	TSTV		; must be a variable now
FFFC45B4 00051A63		bne		a0,r0,IP7
FFFC45B8 FFFC6537		ldi		a0,#msgInputVar
FFFC45BC BDC50513
FFFC45C0 01410113		add		$sp,$sp,#20	; cleanup stack
FFFC45C4 4A0004E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC45C8 00056EB3		mov		$t4,a0		; put away the variable's address
FFFC45CC 0003C283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC45D0 00038023		sb		x0,[$t2]
FFFC45D4 000065B3		mov		a1,x0
FFFC45D8 00412503		lw		a0,4[$sp]	; get back text pointer
FFFC45DC 6D9000EF		call	PRTSTG		; print string as prompt
FFFC45E0 00538023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC45E4 00712223		sw		$t2,4[$sp]	; save in case of error
FFFC45E8 71802503		lw		a0,CURRNT
FFFC45EC 00A12423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC45F0 FFF06513		ldi		a0,#-1
FFFC45F4 70A02C23		sw		a0,CURRNT	; flag that we are in INPUT
FFFC45F8 7A202023		sw		$sp,STKINP	; save the stack pointer too
FFFC45FC 01D12623		sw		$t4,12[$sp]	; save the variable address
FFFC4600 03A06513		ldi		a0,#':'		; print a colon first
FFFC4604 4AD000EF		call	GETLN		; then get an input line
FFFC4608 72406393		ldi		$t2,#BUFFER	; point to the buffer
FFFC460C 408000EF		call	OREXPR		; evaluate the input
FFFC4610 00C12E83		lw		$t4,12[$sp]	; restore the variable address
FFFC4614 00AEA023		sw		a0,[$t4]	; save value in variable
FFFC4618 00812503		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC461C 70A02C23		sw		a0,CURRNT
FFFC4620 00412383		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC4624 0BC010EF		call	TSTC
FFFC4628 0000002C		dw		','
FFFC462C 00000463		bra		IP5
FFFC4630 F4000CE3		bra		IP6			; yes, more items
                        	IP5:
FFFC4634 01012283		lw		r5,16[$sp]
FFFC4638 01410113		add		$sp,$sp,#20	; cleanup stack
FFFC463C D5DFF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC4640 0003C503	  lbu    	a0,[$t2]
FFFC4644 00D06313	  ldi			$t1,#CR
FFFC4648 D46508E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC464C 32D000EF	  call	SETVAL		; do the assignment
FFFC4650 090010EF		call	TSTC		; check for more 'LET' items
FFFC4654 0000002C		dw		','
FFFC4658 D41FF06F		jmp		FINISH
FFFC465C FE0008E3		bra	    LET
                        	LT1:
FFFC4660 D39FF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC4664 000023B7		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC4668 80038393
FFFC466C 00D06513		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC4670 EA0FF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC4674 EA4FF0EF		call	GOAUXI		; look for start of line
FFFC4678 FEA05EE3		ble		a0,r0,LOD1
FFFC467C 04006313		ldi		$t1,#'@'
FFFC4680 02650E63		beq		a0,$t1,LODEND	; end of program?
FFFC4684 01A06313		ldi		$t1,#$1A
FFFC4688 02650A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC468C 03A06313		ldi		$t1,#':'
FFFC4690 FE6512E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC4694 030000EF		call	GCHAR		; get line number
FFFC4698 00A3A023		sw		a0,[$t2]		; store it
FFFC469C 00438393		add		$t2,$t2,#4
                        	LOD2:
FFFC46A0 E78FF0EF		call	GOAUXI		; get another text char.
FFFC46A4 FEA05EE3		ble		a0,r0,LOD2
FFFC46A8 00A38023		sb		a0,[$t2]		; store it
FFFC46AC 00138393		add		$t2,$t2,#1
FFFC46B0 00D06313		ldi		$t1,#CR
FFFC46B4 FE6516E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC46B8 FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC46BC 70702223		sw		$t2,TXTUNF	; set end-of program pointer
FFFC46C0 F04FF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC46C4 FF410113		sub		$sp,$sp,#12
FFFC46C8 00512023		sw		r5,[$sp]
FFFC46CC 00612223		sw		r6,4[$sp]
FFFC46D0 00112423		sw		$ra,8[$sp]
FFFC46D4 00806313		ldi		r6,#8       ; repeat ten times
FFFC46D8 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC46DC E3CFF0EF		call	GOAUXI		; get a char
FFFC46E0 FEA05EE3		ble		a0,r0,GCHAR1
FFFC46E4 02C000EF		call	asciiToHex
FFFC46E8 00429293		sll		r5,r5,#4
FFFC46EC 00A2E2B3		or		r5,r5,a0
FFFC46F0 FFF30313		sub		r6,r6,#1
FFFC46F4 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC46F8 0002E533		mov		a0,r5
FFFC46FC 00012283		lw		r5,[$sp]
FFFC4700 00412303		lw		r6,4[$sp]
FFFC4704 00812083		lw		$ra,8[$sp]
FFFC4708 00C10113		add		$sp,$sp,#12
FFFC470C 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC4710 03906313		ldi		$t1,#'9'
FFFC4714 00A37463		bleu	a0,$t1,a2h1; less than '9'
FFFC4718 FF950513		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC471C FD050513		sub		a0,a0,#'0'
FFFC4720 00F57513		and		a0,a0,#15	; make sure a nybble
FFFC4724 00008067		ret
                        	
                        	GetFilename:
FFFC4728 FFC10113		sub		$sp,$sp,#4
FFFC472C 00112023		sw		$ra,[$sp]
FFFC4730 7B1000EF		call	TSTC
FFFC4734 00000022		dw		'"'
FFFC4738 04000C63		bra		gfn1
FFFC473C 000061B3		mov		r3,r0
                        	gfn2:
FFFC4740 0003C503		lbu		a0,[$t2]		; get text character
FFFC4744 00138393		add		$t2,$t2,#1
FFFC4748 02206313		ldi		$t1,#'"'
FFFC474C 02650263		beq		a0,$t1,gfn3
FFFC4750 02050063		beq		a0,r0,gfn3
FFFC4754 6CA18023		sb		a0,FILENAME[r3]
FFFC4758 00118193		add		r3,r3,#1
FFFC475C 04006313		ldi		$t1,#64
FFFC4760 FE61E0E3		bltu	r3,$t1,gfn2
FFFC4764 00012083		lw		$ra,[$sp]
FFFC4768 00410113		add		$sp,$sp,#4
FFFC476C 00008067		ret
                        	gfn3:
FFFC4770 02006513		ldi		a0,#' '
FFFC4774 6CA18023		sb		a0,FILENAME[r3]
FFFC4778 00118193		add		r3,r3,#1
FFFC477C 04006313		ldi		$t1,#64
FFFC4780 FE61E8E3		bltu	r3,$t1,gfn3
FFFC4784 00012083		lw		$ra,[$sp]
FFFC4788 00410113		add		$sp,$sp,#4
FFFC478C 00008067		ret
                        	gfn1:
FFFC4790 E34FF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC4794 F95FF0EF		call	GetFilename
FFFC4798 000008B7		call	AUXIN_INIT
FFFC479C 474880E7
FFFC47A0 EC5FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC47A4 000015B7		ldi		a1,#$E00
FFFC47A8 E0058593
FFFC47AC 000008B7		call	SDReadSector
FFFC47B0 475880E7
FFFC47B4 00150513		add		a0,a0,#1
FFFC47B8 000025B7		ldi		a1,#TXTBGN
FFFC47BC 80058593
                        	LOAD4:
FFFC47C0 FFC10113		sub		$sp,$sp,#4
FFFC47C4 00A12023		sw		a0,[$sp]
FFFC47C8 000008B7		call	SDReadSector
FFFC47CC 475880E7
FFFC47D0 20058593		add		a1,a1,#512
FFFC47D4 00012503		lw		a0,[$sp]
FFFC47D8 00410113		add		$sp,$sp,#4
FFFC47DC 00150513		add		a0,a0,#1
FFFC47E0 00002237		ldi		r4,#TXTBGN
FFFC47E4 80020213
FFFC47E8 000108B7		add		r4,r4,#65536
FFFC47EC 00088893
FFFC47F0 00488233
FFFC47F4 FC45C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC47F8 DC000663		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC47FC F2DFF0EF		call	GetFilename
FFFC4800 000008B7		call	AUXOUT_INIT
FFFC4804 478880E7
FFFC4808 0600006F		jmp		SAVE
                        	
FFFC480C 208000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC4810 000015B7		ldi		a1,#$E00	; starting address to write
FFFC4814 E0058593
FFFC4818 000008B7		call	SDWriteSector
FFFC481C 47A880E7
FFFC4820 00150513		add		a0,a0,#1
FFFC4824 000025B7		ldi		a1,#TXTBGN
FFFC4828 80058593
                        	SAVE4:
FFFC482C FFC10113		sub		$sp,$sp,#4
FFFC4830 00A12023		sw		a0,[$sp]
FFFC4834 000008B7		call	SDWriteSector
FFFC4838 47A880E7
FFFC483C 20058593		add		a1,a1,#512
FFFC4840 00012503		lw		a0,[$sp]
FFFC4844 00410113		add		$sp,$sp,#4
FFFC4848 00150513		add		a0,a0,#1
FFFC484C 00002237		ldi		r4,#TXTBGN
FFFC4850 80020213
FFFC4854 000108B7		add		r4,r4,#65536
FFFC4858 00088893
FFFC485C 00488233
FFFC4860 FC45C6E3		blt		a1,r4,SAVE4
FFFC4864 D6000063		bra		WSTART
                        	
                        	SAVE:
FFFC4868 000023B7		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC486C 80038393
FFFC4870 70402E03		lw		$t3,TXTUNF	;set pointer to end of prog. area
                        	SAVE1:
FFFC4874 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC4878 027E4863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC487C 03A06513		ldi		a0,#':'		; if not, start a line
FFFC4880 C90FF0EF		call	GOAUXO
FFFC4884 0003A503		lw		a0,[$t2]		; get line number
FFFC4888 00438393		add		$t2,$t2,#4
FFFC488C 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC4890 0003C503		lbu		a0,[$t2]		; get a text char.
FFFC4894 00138393		add		$t2,$t2,#1
FFFC4898 00D06313		ldi		$t1,#CR
FFFC489C FC650CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC48A0 C70FF0EF		call	GOAUXO		; send it out
FFFC48A4 FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC48A8 04006513		ldi		a0,#'@'		; send end-of-program indicator
FFFC48AC C64FF0EF		call	GOAUXO
FFFC48B0 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC48B4 01A06513		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC48B8 C58FF0EF		call	GOAUXO
FFFC48BC 000008B7		call	AUXOUT_FLUSH
FFFC48C0 481880E7
FFFC48C4 D0000063		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC48C8 FFC10113		sub		$sp,$sp,#4
FFFC48CC 00112023		sw		$ra,[$sp]
FFFC48D0 00D06513	  ldi		a0,#CR
FFFC48D4 C3CFF0EF	  call	GOAUXO
FFFC48D8 00A06513	  ldi		a0,#LINEFD
FFFC48DC C34FF0EF	  call	GOAUXO
FFFC48E0 00012083	  lw		$ra,[$sp]
FFFC48E4 00410113	  add		$sp,$sp,#4
FFFC48E8 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC48EC FF810113		sub		$sp,$sp,#8
FFFC48F0 00512023		sw		r5,[$sp]
FFFC48F4 00112223		sw		$ra,4[$sp]
FFFC48F8 7AA06293		ldi		r5,#NUMWKA+14
FFFC48FC 00056233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC4900 00026533	  mov   a0,r4	    ; a0 = value
FFFC4904 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC4908 038000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC490C 00A28023	  sb    a0,[r5]		; save in work area
FFFC4910 FFF28293	  sub		r5,r5,#1
FFFC4914 79C06313	  ldi		$t1,#NUMWKA
FFFC4918 FE62D4E3		bge		r5,$t1,pword1
                        	pword2:
FFFC491C 00128293	  add		r5,r5,#1
FFFC4920 0002C503	  lbu   a0,[r5]     ; get char to output
FFFC4924 BECFF0EF		call	GOAUXO		; send it
FFFC4928 7AA06313		ldi		$t1,#NUMWKA+14
FFFC492C FE62C8E3		blt		r5,$t1,pword2
FFFC4930 00012283		lw		r5,[$sp]
FFFC4934 00412083		lw		$ra,4[$sp]
FFFC4938 00810113		add		$sp,$sp,#8
FFFC493C 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC4940 00F57513		and		a0,a0,#15	; make sure it's a nybble
FFFC4944 00A06313		ldi		$t1,#10
FFFC4948 00654463		blt		a0,$t1,tah1	; > 10 ?
FFFC494C 00750513		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC4950 03050513		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC4954 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC4958 0BC000EF		call	OREXPR		; get the memory address
FFFC495C 585000EF		call	TSTC		; it must be followed by a comma
FFFC4960 0000002C		dw		','
FFFC4964 06000C63		bra		PKER
FFFC4968 FFC10113		sub		$sp,$sp,#4
FFFC496C 00A12023		sw		a0,[$sp]	; save the address
FFFC4970 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC4974 00012583		lw		a1,[$sp]	; get the address back
FFFC4978 00410113		add		$sp,$sp,#4
FFFC497C 00A58023		sb		a0,[a1]		; store the byte in memory
FFFC4980 A19FF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC4984 090000EF		call	OREXPR		; get the memory address
FFFC4988 559000EF		call	TSTC		; it must be followed by a comma
FFFC498C 0000002C		dw		','
FFFC4990 04000663		bra		PKER
FFFC4994 FFC10113		sub		$sp,$sp,#4
FFFC4998 00A12023		sw		a0,[$sp]	; save the address
FFFC499C 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC49A0 00012583		lw		a1,[$sp]	; get the address back
FFFC49A4 00410113		add		$sp,$sp,#4
FFFC49A8 00A5A023		sw		a0,[a1]		; store the byte in memory
FFFC49AC 9EDFF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC49B0 064000EF		call	OREXPR		; get the memory address
FFFC49B4 52D000EF		call	TSTC		; it must be followed by a comma
FFFC49B8 0000002C		dw		','
FFFC49BC 02000063		bra		PKER
FFFC49C0 FFC10113		sub		$sp,$sp,#4
FFFC49C4 00A12023		sw		a0,[$sp]	; save the address
FFFC49C8 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC49CC 00012583		lw		a1,[$sp]	; get the address back
FFFC49D0 00410113		add		$sp,$sp,#4
FFFC49D4 00A59023		sh		a0,[a1]		; store the byte in memory
FFFC49D8 9C1FF06F		jmp		FINISH
                        	
                        	PKER:
FFFC49DC FFFC6537		ldi		a0,#msgComma
FFFC49E0 B7A50513
FFFC49E4 0890006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC49E8 02C000EF		call	OREXPR		; get the subroutine's address
FFFC49EC 000C1863		bne		s8,r0,sysx1; make sure we got a valid address
FFFC49F0 FFFC6537		ldi		a0,#msgSYSBad
FFFC49F4 BCB50513
FFFC49F8 0750006F		jmp		ERROR
                        	sysx1:
FFFC49FC FFC10113		sub		$sp,$sp,#4
FFFC4A00 00712023		stt		$t2,[$sp]	; save the text pointer
FFFC4A04 000C00E7		call	[s8]			; jump to the subroutine
FFFC4A08 00012383		ldt		$t2,[$sp]	; restore the text pointer
FFFC4A0C 00410113		add		$sp,$sp,#4
FFFC4A10 989FF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC4A14 FF41310D		gcsub	$sp,$sp,#12
FFFC4A18 00112023		sw		$ra,[$sp]
FFFC4A1C 00312223		sw		r3,4[$sp]
FFFC4A20 00412423		sw		r4,8[$sp]
FFFC4A24 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC4A28 FF810113		sub		$sp,$sp,#8
FFFC4A2C 01812023		sw		$s8,[$sp]		; save <ANDEXPR> value
FFFC4A30 01912223		sw		$s9,4[$sp]	; save type
FFFC4A34 FFFC4E37		ldi		$t3,#TAB10	; look up a logical operator
FFFC4A38 017E0E13
FFFC4A3C FFFC4EB7		ldi		$t4,#TAB10_1
FFFC4A40 088E8E93
FFFC4A44 E5CFF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC4A48 034000EF	  call	ANDEXPR
FFFC4A4C 00012503	  lw		$a0,[$sp]
FFFC4A50 00810113	  add		$sp,$sp,#8
FFFC4A54 00AC6C33	  or    s8,s8,a0
FFFC4A58 FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC4A5C 00012C03	  lw		$s8,[$sp]
FFFC4A60 00412C83	  lw		$s9,4[$sp]
FFFC4A64 00810113	  add		$sp,$sp,#8
FFFC4A68 00012083		lw		$ra,[$sp]
FFFC4A6C 00412183		lw		r3,4[$sp]
FFFC4A70 00812203		lw		r4,8[$sp]
FFFC4A74 00C10113		add		$sp,$sp,#12
FFFC4A78 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC4A7C FFC10113		sub		$sp,$sp,#4
FFFC4A80 00112023		sw		$ra,[$sp]
FFFC4A84 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC4A88 FF810113		sub		$sp,$sp,#8
FFFC4A8C 01812023		sw		$s8,[$sp]		; save <EXPR> value
FFFC4A90 01912223		sw		$s9,4[$sp]	; save type
FFFC4A94 FFFC4E37		ldi		$t3,#TAB9		; look up a logical operator
FFFC4A98 013E0E13
FFFC4A9C FFFC4EB7		ldi		$t4,#TAB9_1
FFFC4AA0 084E8E93
FFFC4AA4 DFCFF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC4AA8 0C4000EF	  call	EXPR
FFFC4AAC 00012503	  lw		$a0,[$sp]
FFFC4AB0 00810113	  add		$sp,$sp,#8
FFFC4AB4 00AC7C33	  and   s8,s8,a0
FFFC4AB8 FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC4ABC 00012C03	  lw		$s8,[$sp]
FFFC4AC0 00412C83	  lw		$s9,4[$sp]
FFFC4AC4 00810113	  add		$sp,$sp,#8
FFFC4AC8 00012083		lw		$ra,[$sp]
FFFC4ACC 00410113		add		$sp,$sp,#4
FFFC4AD0 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC4AD4 03006313		ldi		$t1,#'0'
FFFC4AD8 00654A63		blt		$a0,$t1,isDigitFalse
FFFC4ADC 03906313		ldi		$t1,#'9'
FFFC4AE0 00A34663		bgt		$a0,$t1,isDigitFalse
FFFC4AE4 00106C13		ldi		$s8,#1
FFFC4AE8 00008067	  ret
                        	isDigitFalse:
FFFC4AEC 00006C33	  mov		$s8,$x0
FFFC4AF0 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC4AF4 04106313		ldi		$t1,#'A'
FFFC4AF8 02654263		blt		$a0,$t1,isAlphaFalse
FFFC4AFC 05A06313		ldi		$t1,#'Z'
FFFC4B00 00A35A63		ble		$a0,$t1,isAlphaTrue
FFFC4B04 06106313		ldi		$t1,#'a'
FFFC4B08 00654A63		blt		$a0,$t1,isAlphaFalse
FFFC4B0C 07A06313		ldi		$t1,#'z'
FFFC4B10 00A34663		bgt		$a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC4B14 00106C13	  ldi		$s8,#1
FFFC4B18 00008067	  ret
                        	isAlphaFalse:
FFFC4B1C 00006C33	  mov		$s8,$x0
FFFC4B20 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC4B24 FFC10113		sub		$sp,$sp,#4
FFFC4B28 00112023		sw		$ra,[$sp]
FFFC4B2C FA9FF0EF	  call	isDigit
FFFC4B30 000C1463		bne		s8,r0,isDigitx	; if it is a digit
FFFC4B34 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC4B38 00012083		lw		$ra,[$sp]
FFFC4B3C 00410113		add		$sp,$sp,#4
FFFC4B40 00008067	  ret
                        	
                        	FORCEFIT:
FFFC4B44 03958263		beq		a1,s9,.0001				; types match
FFFC4B48 00006293		ldi		$t0,#0
FFFC4B4C 00558663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$s8
FFFC4B50 00106513		ldi		a0,#1
FFFC4B54 00008067		ret
                        	.intAnd:
FFFC4B58 00106293		ldi		$t0,#1
FFFC4B5C 005C9663		bne		$s9,$t0,.0001
                        	;	itof	$f2,$a1
FFFC4B60 00106593		ldi		$a1,#1
FFFC4B64 00008067		ret
                        	.0001:
FFFC4B68 00008067		ret
                        	
                        	EXPR:
FFFC4B6C FFC10113		sub		$sp,$sp,#4
FFFC4B70 00112023		sw		$ra,[$sp]
FFFC4B74 11C000EF		call	ADDEXPR
FFFC4B78 FF810113		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC4B7C 01812023		sw		s8,[$sp]
FFFC4B80 01912223		sw		s9,4[$sp]					; save type
FFFC4B84 FFFC4E37		ldi		$t3,#TAB8		; look up a relational operator
FFFC4B88 009E0E13
FFFC4B8C FFFC4EB7		ldi		$t4,#TAB8_1
FFFC4B90 076E8E93
FFFC4B94 D0CFF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC4B98 00012503		lw		a0,[$sp]
FFFC4B9C 00412583		lw		a1,4[$sp]
FFFC4BA0 00810113		add		$sp,$sp,#8
FFFC4BA4 0C4000EF		call	XP18	; is it ">="?
FFFC4BA8 09855A63		bge		a0,s8,XPRT1	; no, return s8=1
FFFC4BAC 06000E63		bra		XPRT0	; else return s8=0
                        	XP12:
FFFC4BB0 00012503		lw		a0,[$sp]
FFFC4BB4 00412583		lw		a1,4[$sp]
FFFC4BB8 00810113		add		$sp,$sp,#8
FFFC4BBC 0AC000EF		call	XP18	; is it "<>"?
FFFC4BC0 07851E63		bne		a0,s8,XPRT1	; no, return a1=1
FFFC4BC4 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC4BC8 00012503		lw		a0,[$sp]
FFFC4BCC 00412583		lw		a1,4[$sp]
FFFC4BD0 00810113		add		$sp,$sp,#8
FFFC4BD4 094000EF		call	XP18	; is it ">"?
FFFC4BD8 06AC4263		bgt		a0,s8,XPRT1	; no, return a1=1
FFFC4BDC 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC4BE0 00012503		lw		a0,[$sp]
FFFC4BE4 00412583		lw		a1,4[$sp]
FFFC4BE8 00810113		add		$sp,$sp,#8
FFFC4BEC 07C000EF		call	XP18	; is it "<="?
FFFC4BF0 04AC5663		ble		a0,s8,XPRT1	; no, return a1=1
FFFC4BF4 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC4BF8 00012503		lw		a0,[$sp]
FFFC4BFC 00412583		lw		a1,4[$sp]
FFFC4C00 00810113		add		$sp,$sp,#8
FFFC4C04 064000EF		call	XP18	; is it "="?
FFFC4C08 03850A63		beq		a0,s8,XPRT1	; if not, return a1=1
FFFC4C0C 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC4C10 00012503		lw		a0,[$sp]
FFFC4C14 00412583		lw		a1,4[$sp]
FFFC4C18 00810113		add		$sp,$sp,#8
FFFC4C1C 04C000EF		call	XP18	; is it "<"?
FFFC4C20 01854E63		blt		a0,s8,XPRT1	; if not, return a1=1
FFFC4C24 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC4C28 00006C33		mov		s8,x0   ; return a0=0 (false)
FFFC4C2C 00006CB3		mov		s9,x0		; type = int
FFFC4C30 00012083		lw		$ra,[$sp]
FFFC4C34 00410113		add		$sp,$sp,#4
FFFC4C38 00008067		ret
                        	XPRT1:
FFFC4C3C 00106C13		ldi		s8,#1	; return a0=1 (true)
FFFC4C40 00006C93		ldi		s9,#0	; type = int
FFFC4C44 00012083		lw		$ra,[$sp]
FFFC4C48 00410113		add		$sp,$sp,#4
FFFC4C4C 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC4C50 00012C03		lw		s8,[$sp]; return a1=<ADDEXPR>
FFFC4C54 00412C83		lw		s9,4[$sp]
FFFC4C58 00810113		add		$sp,$sp,#8
FFFC4C5C 00012083		lw		$ra,[$sp]
FFFC4C60 00410113		add		$sp,$sp,#4
FFFC4C64 00008067		ret
                        	
                        	XP18:
FFFC4C68 FF410113		sub		$sp,$sp,#12
FFFC4C6C 00112023		sw		$ra,[$sp]
FFFC4C70 01812223		sw		s8,4[$sp]
FFFC4C74 01912423		sw		s9,8[$sp]
FFFC4C78 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC4C7C 00412503		lw		a0,4[$sp]
FFFC4C80 00812583		lw		a1,8[$sp]
FFFC4C84 00012083		lw		$ra,[$sp]
FFFC4C88 00C10113		add		$sp,$sp,#12
FFFC4C8C 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC4C90 FFC10113		sub		$sp,$sp,#4
FFFC4C94 00112023		sw		$ra,[$sp]
FFFC4C98 249000EF		call	TSTC		; negative sign?
FFFC4C9C 0000002D		dw		'-'
FFFC4CA0 00000C63		bra		XP21
FFFC4CA4 00006C33		mov		s8,r0		; yes, fake '0-'
FFFC4CA8 FF810113		sub		$sp,$sp,#8
FFFC4CAC 01812023		sw		s8,[$sp]
FFFC4CB0 01912223		sw		s9,4[$sp]
FFFC4CB4 04000863		bra		XP26
                        	XP21:
FFFC4CB8 229000EF		call	TSTC		; positive sign? ignore it
FFFC4CBC 0000002B		dw		'+'
FFFC4CC0 00000263		bra		XP22
                        	XP22:
FFFC4CC4 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC4CC8 FF810113		sub		$sp,$sp,#8; yes, save the value
FFFC4CCC 01812023		sw		s8,[$sp]
FFFC4CD0 01912223		sw		s9,4[$sp]	; and type
FFFC4CD4 20D000EF		call	TSTC		; add?
FFFC4CD8 0000002B		dw		'+'
FFFC4CDC 00000E63		bra		XP25
FFFC4CE0 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC4CE4 00012503		lw		a0,[$sp]
FFFC4CE8 00412583		lw		a1,4[$sp]
FFFC4CEC 00810113		add		$sp,$sp,#8
FFFC4CF0 00AC0C33		add		s8,s8,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC4CF4 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC4CF8 1E9000EF		call	TSTC		; subtract?
FFFC4CFC 0000002D		dw		'-'
FFFC4D00 00000863		bra		XP45
                        	XP26:
FFFC4D04 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC4D08 41800C33		sub		s8,r0,s8	; change its sign
FFFC4D0C FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC4D10 00012C03		lw		s8,[$sp]
FFFC4D14 00412C83		lw		s9,4[$sp]
FFFC4D18 00810113		add		$sp,$sp,#8
FFFC4D1C 00012083		lw		$ra,[$sp]
FFFC4D20 00410113		add		$sp,$sp,#4
FFFC4D24 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC4D28 FFC10113		sub		$sp,$sp,#4
FFFC4D2C 00112023		sw		$ra,[$sp]
FFFC4D30 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC4D34 FF810113		sub		$sp,$sp,#8
FFFC4D38 01812023		sw		s8,[$sp]; yes, save that first result
FFFC4D3C 01912223		sw		s9,4[$sp]
FFFC4D40 1A1000EF		call	TSTC		; multiply?
FFFC4D44 0000002A		dw		'*'
FFFC4D48 00000E63		bra		XP34
FFFC4D4C 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC4D50 00012503		lw		a0,[$sp]
FFFC4D54 00412583		lw		a1,4[$sp]
FFFC4D58 00810113		add		$sp,$sp,#8
FFFC4D5C 02AC0C33		mul		s8,s8,a0	; multiply the two
FFFC4D60 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC4D64 17D000EF		call	TSTC		; divide?
FFFC4D68 0000002F		dw		'/'
FFFC4D6C 00000E63		bra		XP35
FFFC4D70 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC4D74 00012503		lw		a0,[$sp]
FFFC4D78 00412583		lw		a1,4[$sp]
FFFC4D7C 00810113		add		$sp,$sp,#8
FFFC4D80 02AC4C33		div		s8,s8,a0	; do the division
FFFC4D84 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC4D88 159000EF		call	TSTC
FFFC4D8C 00000025		dw		'%'
FFFC4D90 00000E63		bra		XP47
FFFC4D94 030000EF		call	FUNCEXPR
FFFC4D98 00012503		lw		a0,[$sp]
FFFC4D9C 00412583		lw		a1,4[$sp]
FFFC4DA0 00810113		add		$sp,$sp,#8
FFFC4DA4 02AC6C33		rem		s8,s8,a0
FFFC4DA8 F80006E3		bra		XP31
                        	XP47:
FFFC4DAC 00012C03		lw		s8,[$sp]
FFFC4DB0 00412C83		lw		s9,4[$sp]
FFFC4DB4 00810113		add		$sp,$sp,#8
FFFC4DB8 00012083		lw		$ra,[$sp]
FFFC4DBC 00410113		add		$sp,$sp,#4
FFFC4DC0 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC4DC4 FFC1310D		gcsub	$sp,$sp,#4
FFFC4DC8 00112023		stt		$ra,[$sp]
FFFC4DCC FFFC4E37	  ldi		$t3,#TAB4		; find possible function
FFFC4DD0 FC8E0E13
FFFC4DD4 FFFC4EB7	  ldi		$t4,#TAB4_1
FFFC4DD8 054E8E93
FFFC4DDC AC4FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC4DE0 00006533		mov		$a0,$x0
FFFC4DE4 070000EF		call	TSTV
FFFC4DE8 000C0A63		beqz  $s8,XP41	  ; not a variable
FFFC4DEC 000C2C03		ldt		$s8,[$s8]		; if a variable, return its value in s8
FFFC4DF0 00012083		ldt		$ra,[$sp]
FFFC4DF4 00410113		add		$sp,$sp,#4
FFFC4DF8 00008067		ret
                        	XP41:
FFFC4DFC 131000EF		call	TSTNUM		; or is it a number?
FFFC4E00 000C9463		bnez	$s9,XP46	; (if not, # of digits will be zero) if so, return it in s8
FFFC4E04 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC4E08 00012083		ldt		$ra,[$sp]
FFFC4E0C 00410113		add		$sp,$sp,#4
FFFC4E10 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC4E14 FFC1310D		gcsub	$sp,$sp,#4
FFFC4E18 00112023		stt		$ra,[$sp]	
FFFC4E1C 0C5000EF		call	TSTC		; else look for ( OREXPR )
FFFC4E20 00000028		dw		'('
FFFC4E24 02000063		bra		XP43
FFFC4E28 BEDFF0EF		call	OREXPR
FFFC4E2C 0B5000EF		call	TSTC
FFFC4E30 00000029		dw		')'
FFFC4E34 00000863		bra		XP43
                        	XP42:
FFFC4E38 00012083		ldt		$ra,[$sp]
FFFC4E3C 00410113		add		$sp,$sp,#4
FFFC4E40 00008067		ret
                        	XP43:
FFFC4E44 00410113		add		$sp,$sp,#4		; get rid of return address
FFFC4E48 FFFC6537		ldi		$a0,#msgWhat
FFFC4E4C B0050513
FFFC4E50 41C0006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		s8 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC4E54 FF810113		sub		$sp,$sp,#8
FFFC4E58 00512023		sw		r5,[$sp]
FFFC4E5C 00112223		sw		$ra,4[$sp]
FFFC4E60 000562B3		mov		r5,a0		; r5=allocate flag
FFFC4E64 139000EF		call	IGNBLK
FFFC4E68 0003C503		lbu		a0,[$t2]		; look at the program text
FFFC4E6C 04006313		ldi		$t1,#'@'
FFFC4E70 06654263		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC4E74 02651E63		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC4E78 00138393		add		$t2,$t2,#1	; If it is, it should be
FFFC4E7C F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC4E80 00000263		bra		TV3
                        	TV3:
FFFC4E84 FFC10113		sub		$sp,$sp,#4	; save the index
FFFC4E88 01812023		sw		s8,[$sp]
FFFC4E8C 2D0000EF		call	SIZEX		; get amount of free memory
FFFC4E90 00012583		lw		a1,[$sp]
FFFC4E94 00410113		add		$sp,$sp,#4	; get back the index
FFFC4E98 0185C663		blt		a1,s8,TV2		; see if there's enough memory
FFFC4E9C 00810113		add		$sp,$sp,#8
FFFC4EA0 3B80006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC4EA4 70802503		lw		a0,VARBGN	; put address of array element...
FFFC4EA8 40B50C33		sub   s8,a0,a1    ; into a0 (neg. offset is used)
FFFC4EAC 00000C63		bra   TSTVRT
                        	TV1:	
FFFC4EB0 038000EF	  call	getVarName      ; get variable name
FFFC4EB4 000C0863	  beq   s8,x0,TSTVRT    ; if not, return s8=0
FFFC4EB8 000C6533	  mov		a0,s8
FFFC4EBC 0002E5B3	  mov		a1,r5
FFFC4EC0 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC4EC4 00012283		lw		r5,[$sp]
FFFC4EC8 00412083		lw		$ra,4[$sp]
FFFC4ECC 00810113		add		$sp,$sp,#8
FFFC4ED0 00008067		ret								; s8<>0 (if found)
                        	tstv_notfound:
FFFC4ED4 00012283		lw		r5,[$sp]
FFFC4ED8 00412083		lw		$ra,4[$sp]
FFFC4EDC 00810113		add		$sp,$sp,#8
FFFC4EE0 00006C33		mov		s8,x0				; s8=0 if not found
FFFC4EE4 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   s8 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC4EE8 FF41310D		gcsub	$sp,$sp,#12
FFFC4EEC 00512023		sw		r5,[$sp]
FFFC4EF0 00112223		sw		$ra,4[$sp]
FFFC4EF4 0003C503	  lbu   a0,[$t2]		; get first character
FFFC4EF8 00A12423	  sw		a0,8[$sp]		; save off current name
FFFC4EFC BF9FF0EF	  call	isAlpha
FFFC4F00 080C0063	  beq   s8,r0,gvn1
FFFC4F04 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC4F08 00138393		add		$t2,$t2,#1
FFFC4F0C 0003C503		lbu   a0,[$t2]		; do we have another char ?
FFFC4F10 C15FF0EF		call	isAlnum
FFFC4F14 020C0863		beq   s8,x0,gvn2	; nope
FFFC4F18 00812503		lw		a0,8[$sp]		; get varname
FFFC4F1C 00851513		sll		a0,a0,#8
FFFC4F20 0003C583		lbu   a1,[$t2]
FFFC4F24 00B56533		or    a0,a0,a1   	; add in new char
FFFC4F28 00A12423	  sw		a0,8[$sp]		; save off current name again
FFFC4F2C FFF28293	  sub		r5,r5,#1
FFFC4F30 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC4F34 00138393		add		$t2,$t2,#1
FFFC4F38 0003C503		lbu   a0,[$t2]		; do we have another char ?
FFFC4F3C BE9FF0EF	  call  isAlnum
FFFC4F40 FE0C1AE3	  bne   s8,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC4F44 0003C583		lbu   a1,[$t2]
FFFC4F48 02506313		ldi		$t1,#'%'
FFFC4F4C 00658A63		beq		a1,$t1,gvn3
FFFC4F50 02406313		ldi		$t1,#'$'
FFFC4F54 00658663		beq		a1,$t1,gvn3
FFFC4F58 FFF38393	  sub		$t2,$t2,#1
FFFC4F5C 02E06593	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC4F60 00138393		add		$t2,$t2,#1
FFFC4F64 00812503		lw		a0,8[$sp]		; get varname
FFFC4F68 00851513		sll		a0,a0,#8
FFFC4F6C 00B56C33	  or    s8,a0,a1    ; add in variable type
FFFC4F70 00012283	  lw		r5,[$sp]
FFFC4F74 00412083	  lw		$ra,4[$sp]
FFFC4F78 00C10113	  add		$sp,$sp,#12
FFFC4F7C 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC4F80 00012283		lw		r5,[$sp]
FFFC4F84 00412083	  lw		$ra,4[$sp]
FFFC4F88 00C10113		add		$sp,$sp,#12
FFFC4F8C 00006C33	  mov		s8,x0       ; return s8 = 0 if not a varname
FFFC4F90 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   s8 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC4F94 FF810113		sub		$sp,$sp,#8
FFFC4F98 00712023		sw		x7,[$sp]
FFFC4F9C 00312223		sw		x3,4[$sp]
FFFC4FA0 70802183	  lw    x3,VARBGN
                        	fv4:
FFFC4FA4 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC4FA8 02038663	  beq   x7,x0,fv3		; no more vars ?
FFFC4FAC 02750863	  beq   a0,x7,fv1		; match ?
FFFC4FB0 00818193		add		x3,x3,#8		; move to next var
FFFC4FB4 70C02383	  lw    x7,VAREND		; 
FFFC4FB8 FE71C6E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC4FBC 00012383	  lw		x7,[$sp]
FFFC4FC0 00412183	  lw		x3,4[$sp]
FFFC4FC4 00810113	  add		$sp,$sp,#8
FFFC4FC8 FFFC6537	  ldi		a0,#msgVarSpace
FFFC4FCC B4E50513
FFFC4FD0 29C0006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC4FD4 00058E63		beq		a1,x0,fv2
FFFC4FD8 00A1A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC4FDC 00418C13	  add		s8,x3,#4
FFFC4FE0 00012383	  lw		x7,[$sp]
FFFC4FE4 00412183	  lw		x3,4[$sp]
FFFC4FE8 00810113	  add		$sp,$sp,#8
FFFC4FEC 00008067	  ret			    			; s8 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC4FF0 00012383	  lw		x7,[$sp]
FFFC4FF4 00412183	  lw		x3,4[$sp]
FFFC4FF8 00810113	  add		$sp,$sp,#8
FFFC4FFC 00006C33		mov		s8,x0				; s8 = nullptr
FFFC5000 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC5004 E11FF0EF		call	PARN		; get the memory address
FFFC5008 000C0C03		ldb		$s8,[$s8]	; get the addressed byte
FFFC500C 00006CB3		mov		$s9,$x0		; type = int
FFFC5010 00012083		ldt		$ra,[$sp]
FFFC5014 00410113		add		$sp,$sp,#4
FFFC5018 00008067		ret
                        	PEEKW:
FFFC501C DF9FF0EF		call	PARN		; get the memory address
FFFC5020 000C2C03		ldt		$s8,[$s8]		; get the addressed word
FFFC5024 00006CB3		mov		$s9,$x0			; type = int
FFFC5028 00012083		ldt		$ra,[$sp]
FFFC502C 00410113		add		$sp,$sp,#4
FFFC5030 00008067		ret
                        	PEEKH:
FFFC5034 DE1FF0EF		call	PARN		; get the memory address
FFFC5038 000C1C03		ldw		$s8,[$s8]		; get the addressed byte
FFFC503C 00006CB3		mov		$s9,$x0			; type = int
FFFC5040 00012083		ldt		$ra,[$sp]
FFFC5044 00410113		add		$sp,$sp,#4
FFFC5048 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC504C FFC1310D		gcsub	$sp,$sp,#4
FFFC5050 00512023		stt		$t0,[$sp]
FFFC5054 DC1FF0EF		call	PARN		; get expression value
FFFC5058 000C6533		mov		$a0,$s8
FFFC505C 000CE5B3		mov		$a1,$s9
FFFC5060 FFC1310D		gcsub	$sp,$sp,#4	; save the text pointer
FFFC5064 00712023		stt		$t2,[$sp]
FFFC5068 7A802283		ldt		$t0,usrJmp
FFFC506C 000280E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC5070 00012383		ldt		$t2,[$sp]	; restore the text pointer
FFFC5074 00410113		add		$sp,$sp,#4
FFFC5078 00012283		ldt		$t0,[$sp]
FFFC507C 00410113		add		$sp,$sp,#4
FFFC5080 00012083		ldt		$ra,[$sp]
FFFC5084 00410113		add		$sp,$sp,#4
FFFC5088 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC508C D89FF0EF		call	PARN		; get the upper limit
FFFC5090 040C0063		beq		s8,r0,rnd2	; it must be positive and non-zero
FFFC5094 020C4663		blt		s8,r0,rnd1
FFFC5098 000C65B3		mov		a1,s8
FFFC509C 000C6CB3		mov		s9,s8
FFFC50A0 000008B7		call	gen_rand	; generate a random number
FFFC50A4 4C3880E7
FFFC50A8 039C6C33		rem		s8,s8,s9
FFFC50AC 001C0C13		add		s8,s8,#1
FFFC50B0 00006CB3		mov		s9,x0
FFFC50B4 00012083		lw		$ra,[$sp]
FFFC50B8 00410113		add		$sp,$sp,#4
FFFC50BC 00008067		ret
                        	rnd1:
FFFC50C0 FFFC6537		ldi		a0,#msgRNDBad
FFFC50C4 BB850513
FFFC50C8 00410113		add		$sp,$sp,#4
FFFC50CC 1A00006F		jmp		ERROR
                        	rnd2:
FFFC50D0 000008B7		call	gen_rand	; generate a random number
FFFC50D4 4C3880E7
FFFC50D8 00006CB3		mov		s9,x0
FFFC50DC 00012083		lw		$ra,[$sp]
FFFC50E0 00410113		add		$sp,$sp,#4
FFFC50E4 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC50E8 D2DFF0EF		call	PARN		; get the following expr.'s value
FFFC50EC 000C4863		blt		s8,r0,ABS1
FFFC50F0 00012083		lw		$ra,[$sp]
FFFC50F4 00410113		add		$sp,$sp,#4
FFFC50F8 00008067		ret
                        	ABS1:
FFFC50FC 41800C33		sub		s8,x0,s8
FFFC5100 00012083		lw		$ra,[$sp]
FFFC5104 00410113		add		$sp,$sp,#4
FFFC5108 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC510C C0001C73		csrrw	s8,#$C00,x0
FFFC5110 00006CB3		mov		s9,x0
FFFC5114 00012083		lw		$ra,[$sp]
FFFC5118 00410113		add		$sp,$sp,#4
FFFC511C 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC5120 CF5FF0EF		call	PARN		; get the following expr.'s value
FFFC5124 00006CB3		mov		s9,x0
FFFC5128 020C0463		beq		s8,r0,SGN1
FFFC512C 000C4A63		blt		s8,r0,SGN2
FFFC5130 00106C13		ldi		s8,#1
FFFC5134 00012083		lw		$ra,[$sp]
FFFC5138 00410113		add		$sp,$sp,#4
FFFC513C 00008067		ret
                        	SGN2:
FFFC5140 FFF06C13		ldi		s8,#-1
FFFC5144 00012083		lw		$ra,[$sp]
FFFC5148 00410113		add		$sp,$sp,#4
FFFC514C 00008067		ret
                        	SGN1:
FFFC5150 00012083		lw		$ra,[$sp]
FFFC5154 00410113		add		$sp,$sp,#4
FFFC5158 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in s8.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC515C 70802C03		lw		s8,VARBGN	; get the number of free bytes...
FFFC5160 70402C83		lw		s9,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC5164 419C0C33		sub		s8,s8,s9
FFFC5168 00006CB3		mov		s9,x0			; type = int
FFFC516C 00012083		lw		$ra,[$sp]
FFFC5170 00410113		add		$sp,$sp,#4
FFFC5174 00008067		ret					; return the number in s8
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC5178 FFC10113		sub		$sp,$sp,#4
FFFC517C 00112023		sw		$ra,[$sp]
FFFC5180 00106513	  ldi		a0,#1		; allocate var
FFFC5184 CD1FF0EF	  call	TSTV		; variable name?
FFFC5188 000C1A63	  bne		s8,x0,.sv2
FFFC518C FFFC6537	 	ldi		a0,#msgVar
FFFC5190 BA250513
FFFC5194 00410113		add		$sp,$sp,#4
FFFC5198 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC519C FFC10113		sub		$sp,$sp,#4
FFFC51A0 01812023		sw		s8,[$sp]	; save the variable's address
FFFC51A4 53C000EF		call	TSTC			; get past the "=" sign
FFFC51A8 0000003D		dw		'='
FFFC51AC 02000663		bra		SV1
FFFC51B0 865FF0EF		call	OREXPR		; evaluate the expression
FFFC51B4 00012583		lw		a1,[$sp]	; get back the variable's address
FFFC51B8 00410113		add		$sp,$sp,#4
FFFC51BC 0185A023		sw    s8,[a1]   ; and save value in the variable
FFFC51C0 0005EC33		mov		s8,a1			; return s8 = variable address
FFFC51C4 FFC5AC83		lw		s9,-4[a1]
FFFC51C8 0FFCFC93		and		s9,s9,#$FF
FFFC51CC 00012083		lw		$ra,[$sp]
FFFC51D0 00410113		add		$sp,$sp,#4
FFFC51D4 00008067		ret
                        	SV1:
FFFC51D8 00410113		add		$sp,$sp,#4
FFFC51DC 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC51E0 FFC1310D		gcsub	$sp,$sp,#4
FFFC51E4 00112023		stt		$ra,[$sp]
FFFC51E8 4F8000EF		call	TSTC		; *** FIN ***
FFFC51EC 0000003A		dw		':'
FFFC51F0 00000663		bra		FI1
FFFC51F4 00410113		add		$sp,$sp,#4	; if ":", discard return address
FFFC51F8 804FF06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC51FC 4E4000EF		call	TSTC		; not ":", is it a CR?
FFFC5200 0000000D		dw		CR
FFFC5204 00000663		bra		FI2
                        							; else return to the caller
FFFC5208 00410113		add		$sp,$sp,#4	; yes, purge return address
FFFC520C F71FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC5210 00012083		ldt		$ra,[$sp]
FFFC5214 00410113		add		$sp,$sp,#4
FFFC5218 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC521C FFC1310D		gcsub	$sp,$sp,#4
FFFC5220 00112023		stt		$ra,[$sp]
FFFC5224 578000EF		call	IGNBLK
FFFC5228 0003C503		ldbu	$a0,[$t2]
FFFC522C 00D06313		ldi		$t1,#CR
FFFC5230 00650863		beq		$a0,$t1,ec1	; does it end with a CR?
FFFC5234 FFFC6537		ldi		$a0,#msgExtraChars
FFFC5238 C7350513
FFFC523C 0300006F		jmp		ERROR
                        	ec1:
FFFC5240 00012083		ldt		$ra,[$sp]
FFFC5244 00410113		add		$sp,$sp,#4
FFFC5248 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC524C FFFC6537		ldi		a0,#msgTooBig
FFFC5250 C5F50513
FFFC5254 00000C63		bra		ERROR
                        	QSORRY:
FFFC5258 FFFC6537	  ldi		a0,#SRYMSG
FFFC525C B0750513
FFFC5260 00000663		bra	    ERROR
                        	QWHAT:
FFFC5264 FFFC6537		ldi		a0,#msgWhat
FFFC5268 B0050513
                        	ERROR:
FFFC526C 618000EF		call	PRMESG		; display the error message
FFFC5270 71802503		ldt		$a0,CURRNT	; get the current line pointer
FFFC5274 02050C63		beqz	$a0,ERROR1	; if zero, do a warm start
FFFC5278 FFF06313		ldi		$t1,#-1
FFFC527C AE650463		beq		$a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC5280 0003C283		ldbu	r5,[$t2]		; save the char. pointed to
FFFC5284 00038023		stb		$x0,[$t2]		; put a zero where the error is
FFFC5288 71802503		ldt		$a0,CURRNT	; point to start of current line
FFFC528C 3F8000EF		call	PRTLN		; display the line in error up to the 0
FFFC5290 00056333		mov     r6,$a0	    ; save off end pointer
FFFC5294 00538023		sb		r5,[$t2]		; restore the character
FFFC5298 03F06513		ldi		$a0,#'?'		; display a "?"
FFFC529C A6DFE0EF		call	GOOUT
FFFC52A0 000065B3		mov		$a1,$x0		; stop char = 0
FFFC52A4 FFF30513		sub		$a0,r6,#1	; point back to the error char.
FFFC52A8 20C000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC52AC B19FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC52B0 FF81310D		gcsub	$sp,$sp,#8
FFFC52B4 00512023		stt		r5,[$sp]
FFFC52B8 00112223		stt		$ra,4[$sp]
FFFC52BC A4DFE0EF		call	GOOUT		; display the prompt
FFFC52C0 00106513		ldi		$a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC52C4 02006513		ldi		$a0,#' '		; and a space
FFFC52C8 A41FE0EF		call	GOOUT
FFFC52CC 72406393		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
                        	.GL1:
FFFC52D0 584000EF		call	CHKIO		; check keyboard
FFFC52D4 FE050EE3		beqz	$a0,.GL1	; wait for a char. to come in
FFFC52D8 00806313		ldi		$t1,#CTRLH
FFFC52DC 04650463		beq		$a0,$t1,.GL3	; delete last character? if so
FFFC52E0 01806313		ldi		$t1,#CTRLX
FFFC52E4 06650463		beq		$a0,$t1,.GL4	; delete the whole line?
FFFC52E8 00D06313		ldi		$t1,#CR
FFFC52EC 00650663		beq		$a0,$t1,.GL2		; accept a CR
FFFC52F0 02006313		ldi		$t1,#' '
FFFC52F4 FC654EE3		blt		$a0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC52F8 00A38023		stb		$a0,[$t2]		; save the char.
FFFC52FC 00138393		add		$t2,$t2,#1
FFFC5300 FFC1310D		gcsub	$sp,$sp,#4
FFFC5304 00A12023		stt		$a0,[$sp]
FFFC5308 A01FE0EF		call	GOOUT		  ; echo the char back out
FFFC530C 00012503		ldt		$a0,[$sp] ; get char back (GOOUT destroys a0)
FFFC5310 00410113		add		$sp,$sp,#4
FFFC5314 00D06313		ldi		$t1,#CR
FFFC5318 06650663		beq		$a0,$t1,.GL7			; if it's a CR, end the line
FFFC531C 77706313		ldi		$t1,#BUFFER+BUFLEN-1
FFFC5320 FA63C8E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC5324 00806513		ldi		$a0,#CTRLH	; delete a char. if possible
FFFC5328 9E1FE0EF		call	GOOUT
FFFC532C 02006513		ldi		$a0,#' '
FFFC5330 9D9FE0EF		call	GOOUT
FFFC5334 72406313		ldi		$t1,#BUFFER
FFFC5338 F8735CE3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC533C 00806513		ldi		$a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC5340 9C9FE0EF		call	GOOUT
FFFC5344 FFF38393		sub		$t2,$t2,#1	; decrement the text pointer
FFFC5348 F80004E3		bra		.GL1		; back for more
                        	.GL4:
FFFC534C 0003E533		mov		$a0,$t2		; delete the whole line
FFFC5350 8DC50293		sub		r5,$a0,#BUFFER   ; figure out how many backspaces we need
FFFC5354 02028463		beqz	r5,.GL6		  ; if none needed, branch
FFFC5358 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC535C 00806513		ldi		$a0,#CTRLH		; and display BS-space-BS sequences
FFFC5360 9A9FE0EF		call	GOOUT
FFFC5364 02006513		ldi		$a0,#' '
FFFC5368 9A1FE0EF		call	GOOUT
FFFC536C 00806513		ldi		$a0,#CTRLH
FFFC5370 999FE0EF		call	GOOUT
FFFC5374 FFF28293		sub		r5,r5,#1
FFFC5378 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC537C 72406393		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC5380 F40008E3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC5384 00038023		stb		$x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC5388 00A06513		ldi		$a0,#LINEFD	; echo a LF for the CR
FFFC538C 97DFE0EF		call	GOOUT
FFFC5390 00012283		ldt		r5,[$sp]
FFFC5394 00412083		ldt		$ra,4[$sp]
FFFC5398 00810113		add		$sp,$sp,#8
FFFC539C 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $s8 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $s8 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $s8 = 0.
                        	; $s8=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC53A0 00100337		ldi		$t1,#$FFFFF
FFFC53A4 FFF30313
FFFC53A8 00654863		blt		$a0,$t1,fl1	; line no. must be < 1048576
FFFC53AC FFFC6537		ldi		$a0,#msgLineRange
FFFC53B0 B8D50513
FFFC53B4 EB9FF06F		jmp		ERROR
                        	fl1:
FFFC53B8 00002E37		ldi		$t3,#TXTBGN	; init. the text save pointer
FFFC53BC 800E0E13
FFFC53C0 71C02E23		stt   $t3,SRCHLN
FFFC53C4 00000663	  bra   FNDLNP
                        	FNDLNT:
FFFC53C8 71802E03	  ldt   $t3,CURRNT
FFFC53CC 71C02E23	  stt   $t3,SRCHLN
                        	FNDLNP:
FFFC53D0 70402E83		ldt		$t4,TXTUNF	; check if we passed the end
FFFC53D4 01DE7863		bgeu	$t3,$t4,FNDRET1 ; if so, return with r9=0,a0=0
                        		;call	LoadWord		; get line number
FFFC53D8 001E2C03		ldt   $s8,1[$t3]
                        	;	gcsub $sp,$sp,#8
                        	;	stt   $ra,[$sp]
                        	;	stt   $a0,4[$sp]
                        	;	mov   $a0,$s8
                        	;	call  PutHexWord
                        	;	ldt   $ra,[$sp]
                        	;	ldt   $a0,4[$sp]
                        	;	add   $sp,$sp,#8
FFFC53DC 00AC0863		beq		$s8,$a0,FNDRET2
FFFC53E0 00AC6A63		bltu	$s8,$a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET1:
FFFC53E4 00006C33		mov		$s8,$x0	; line not found, but $t3=next line pointer
FFFC53E8 00008067		ret
                        	FNDRET2:
FFFC53EC 00106C13		ldi		$s8,#1	; line found
FFFC53F0 00008067		ret
                        	
                        	; Move from the current line to the next one.
                        	FNDNXT:
FFFC53F4 71C02C03	  ldt   $s8,SRCHLN
FFFC53F8 000C4C83		ldbu	$s9,[$s8]
FFFC53FC 019C0E33		add		$t3,$s8,$s9
FFFC5400 71C02E23		stt   $t3,SRCHLN
FFFC5404 FC0006E3		bra   FNDLNP
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC5408 00050203		lb		r4,[a0]
FFFC540C 00458023		sb		r4,[a1]
FFFC5410 00150513		add		a0,a0,#1
FFFC5414 00158593		add		a1,a1,#1
                        	MVUP:
FFFC5418 FEC518E3		bne		a0,a2,MVUP1
FFFC541C 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC5420 FFF50513		sub		a0,a0,#1
FFFC5424 FFF58593		sub		a1,a1,#1
FFFC5428 00050203		lb		r4,[a0]
FFFC542C 00458023		sb		r4,[a1]
                        	MVDOWN:
FFFC5430 FEC518E3		bne		a0,a2,MVDOWN1
FFFC5434 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC5438 00012503		ldt		$a0,[$sp]
FFFC543C 00410113		add		$sp,$sp,#4
FFFC5440 70A02823		stt		$a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC5444 02050463		beqz	$a0,PP1
FFFC5448 00012503		ldt		$a0,[$sp]
FFFC544C 76A02C23		stt		$a0,LOPPT
FFFC5450 00412503		ldt		$a0,4[$sp]
FFFC5454 76A02E23		stt		$a0,LOPLN
FFFC5458 00812503		ldt		$a0,8[$sp]
FFFC545C 78A02223		stt		$a0,LOPLMT
FFFC5460 00C12503		ldt		$a0,12[$sp]
FFFC5464 78A02023		stt		$a0,LOPINC
FFFC5468 01010113		add		$sp,$sp,#16
                        	PP1:
FFFC546C 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC5470 7A402503		ldt		$a0,STKBOT	; Are we running out of stack room?
FFFC5474 01450513		add		$a0,$a0,#20	; we might need this many bytes
FFFC5478 DEA140E3		blt		$sp,$a0,QSORRY	; out of stack space
FFFC547C 71002583		ldt		$a1,LOPVAR		; save loop variables
FFFC5480 02058463		beqz	$a1,PU1		; if LOPVAR is zero, that's all
FFFC5484 FF010113		sub		$sp,$sp,#16
FFFC5488 77802503		ldt		$a0,LOPPT
FFFC548C 00A12023		stt		$a0,[$sp]
FFFC5490 77C02503		ldt		$a0,LOPLN
FFFC5494 00A12223		stt		$a0,4[$sp]
FFFC5498 78402503		ldt		$a0,LOPLMT
FFFC549C 00A12423		stt		$a0,8[$sp]
FFFC54A0 78002503		ldt		$a0,LOPINC
FFFC54A4 00A12623		stt		$a0,12[$sp]
                        	PU1:
FFFC54A8 FFC10113		sub		$sp,$sp,#4
FFFC54AC 00B12023		stt		a1,[$sp]
FFFC54B0 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return s8 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC54B4 FEC1310D		gcsub	$sp,$sp,#20
FFFC54B8 00512023		stt		x5,[$sp]
FFFC54BC 00612223		stt		x6,4[$sp]
FFFC54C0 00712423		stt		x7,8[$sp]
FFFC54C4 00112623		stt		$ra,12[$sp]
FFFC54C8 00A12823		stt		$a0,16[$sp]
FFFC54CC 000562B3		mov   x5,a0	    ; r5 = pointer
FFFC54D0 0005E333		mov   x6,a1	    ; r6 = stop char
                        	.PS1:
FFFC54D4 0002C383	  ldbu  x7,[x5]     ; get a text character
FFFC54D8 00128293		add		x5,x5,#1
FFFC54DC 00638E63		beq	  x7,x6,.PRTRET	; same as stop character? if so, return
FFFC54E0 0003E533		mov   $a0,x7
FFFC54E4 825FE0EF		call	GOOUT		; display the char.
FFFC54E8 00D06313		ldi		$t1,#CR
FFFC54EC FE6394E3		bne   x7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC54F0 00A06513		ldi		$a0,#LINEFD  ; yes, add a L.F.
FFFC54F4 815FE0EF		call	GOOUT
                        	.PRTRET:
FFFC54F8 0003ECB3	  mov   $s9,x7	    ; return a1 = stop char
FFFC54FC 0002EC33		mov		$s8,x5		; return a0 = line pointer
FFFC5500 00012283		ldt		$x5,[$sp]
FFFC5504 00412303		ldt		$x6,4[$sp]
FFFC5508 00812383		ldt		$x7,8[$sp]
FFFC550C 00C12083		ldt		$ra,12[$sp]
FFFC5510 01012503		ldt		$a0,16[$sp]
FFFC5514 01410113		add		$sp,$sp,#20
FFFC5518 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC551C FFC1310D		gcsub	$sp,$sp,#4
FFFC5520 00112023		stt		$ra,[$sp]
FFFC5524 1BC000EF		call	TSTC		; *** QTSTG ***
FFFC5528 00000022		dw		'"'
FFFC552C 02000063		bra		QT3
FFFC5530 02206593		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC5534 0003E533		mov		a0,$t2
FFFC5538 F7DFF0EF		call	PRTSTG		; print until another
FFFC553C 000C63B3		mov		$t2,s8
FFFC5540 00D06313		ldi		$t1,#CR
FFFC5544 026C9863		bne		s9,$t1,QT2	; was last one a CR?
FFFC5548 C35FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC554C 194000EF		call	TSTC		; is it a single quote?
FFFC5550 0000005C		dw		'\''
FFFC5554 00000663		bra		QT4
FFFC5558 02706593		ldi		a1,#'\''	; if so, do same as above
FFFC555C FC000CE3		bra		QT1
                        	QT4:
FFFC5560 180000EF		call	TSTC		; is it an underline?
FFFC5564 0000005F		dw		'_'
FFFC5568 00000C63		bra		QT5
FFFC556C 00D06513		ldi		a0,#CR		; if so, output a CR without LF
FFFC5570 F98FE0EF		call	GOOUT
                        	QT2:
FFFC5574 00012083		lw		$ra,[$sp]		; get return address
FFFC5578 00410113		add		$sp,$sp,#4
FFFC557C 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC5580 00012083		lw		$ra,[$sp]		; get return address
FFFC5584 00410113		add		$sp,$sp,#4
FFFC5588 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC558C FFC1310D		gcsub	$sp,$sp,#4
FFFC5590 00112023		stt		$ra,[$sp]
FFFC5594 00D06513		ldi		$a0,#CR
FFFC5598 F70FE0EF		call	GOOUT
FFFC559C 00A06513		ldi		$a0,#LINEFD
FFFC55A0 F68FE0EF		call	GOOUT
FFFC55A4 00012083		ldt		$ra,[$sp]
FFFC55A8 00410113		add		$sp,$sp,#4
FFFC55AC 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
                        	
FFFC55B0 FEC1310D	public PRTNUM:
	gcsub	$sp,$sp,#20
FFFC55B4 00912023		stt		$s1,[$sp]
FFFC55B8 01212223		stt		$s2,4[$sp]
FFFC55BC 01312423		stt		$s3,8[$sp]
FFFC55C0 01412623		stt		$s4,12[$sp]
FFFC55C4 00112823		stt		$ra,16[$sp]
FFFC55C8 79C06A13		ldi		$s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC55CC 000569B3		mov		$s3,$a0		; save number for later
FFFC55D0 0005E933		mov		$s2,$a1		; s2 = min number of chars
FFFC55D4 00055663		bge		$a0,$x0,.PN2	; is it negative? if not
FFFC55D8 40A00533		sub		$a0,$x0,$a0	; else make it positive
FFFC55DC FFF90913		sub		$s2,$s2,#1	; one less for width count
                        	.PN2:
FFFC55E0 00A06313		ldi		$t1,#10
                        	.PN1:
FFFC55E4 02C565B3		rem		$a1,$a0,$a2	; a1 = a0 mod base
FFFC55E8 02C54533		div		$a0,$a0,$a2	; a0 /= divide by base
FFFC55EC 00B67463		bleu	$a1,$a2,.PN7
FFFC55F0 00758593		add		$a1,$a1,#'A'-10-'0'
                        	.PN7:
FFFC55F4 03058593		add		$a1,$a1,#'0'	; convert remainder to ascii
FFFC55F8 00BA0023		stb		$a1,[$s4]		; and store in buffer
FFFC55FC 001A0A13		add		$s4,$s4,#1
FFFC5600 FFF90913		sub		$s2,$s2,#1	; decrement width
FFFC5604 FE0510E3		bnez	$a0,.PN1
FFFC5608 01205A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC560C 02006513		ldi		$a0,#' '		; display the required leading spaces
FFFC5610 EF8FE0EF		call	GOOUT
FFFC5614 FFF90913		sub		$s2,$s2,#1
FFFC5618 FF204AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC561C 0009D663		bge		$s3,$x0,.PN5	; is number negative?
FFFC5620 02D06513		ldi		$a0,#'-'		; if so, display the sign
FFFC5624 EE4FE0EF		call	GOOUT
                        	.PN5:
FFFC5628 79C06313		ldi		$t1,#NUMWKA
                        	.PN6:
FFFC562C FFFA0A13		sub		$s4,$s4,#1
FFFC5630 000A4503		ldbu	$a0,[$s4]		; now unstack the digits and display
FFFC5634 ED4FE0EF		call	GOOUT
FFFC5638 FF436AE3		bgtu	$s4,$t1,.PN6
                        	
FFFC563C 00012483		ldt		$s1,[$sp]
FFFC5640 00412903		ldt		$s2,4[$sp]
FFFC5644 00812983		ldt		$s3,8[$sp]
FFFC5648 00C12A03		ldt		$s4,12[$sp]
FFFC564C 01012083		ldt		$ra,16[$sp]
FFFC5650 01410113		add		$sp,$sp,#20
FFFC5654 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		s8 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC5658 00054C03	  lbu		$s8,[$a0]	
FFFC565C 00154C83	  lbu		$s9,1[$a0]
FFFC5660 008C9C93	  sll		$s9,$s9,#8
FFFC5664 019C6C33	  or		$s8,$s8,$s9
FFFC5668 00254C83	  lbu		$s9,2[$a0]
FFFC566C 010C9C93	  sll		$s9,$s9,#16
FFFC5670 019C6C33	  or		$s8,$s8,$s9
FFFC5674 00354C83	  lbu		$s9,3[$a0]
FFFC5678 018C9C93	  sll		$s9,$s9,#24
FFFC567C 019C6C33	  or		$s8,$s8,$s9
FFFC5680 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	$a0 = pointer to line
                        	; Returns:
                        	;		$s8 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC5684 FF01310D		gcsub	$sp,$sp,#16
FFFC5688 00512023		stt		$t0,[$sp]
FFFC568C 00112223		stt		$ra,4[$sp]
FFFC5690 00A12423		stt		$a0,8[$sp]
FFFC5694 00B12623		stt		$a1,12[$sp]
FFFC5698 000562B3	  mov		$t0,$a0		; $t0 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
                        	  ;call	LoadWord
FFFC569C 0012AC03	  ldt   $s8,1[$t0]    ; we can do unaligned loads
FFFC56A0 00528293		add		$t0,$t0,#5
FFFC56A4 000C6533	  mov		$a0,$s8
FFFC56A8 00506593	  ldi		$a1,#5       ; display a 0 or more digit line no.
FFFC56AC 00A06613	  ldi		$a2,#10
FFFC56B0 F01FF0EF		call	PRTNUM
FFFC56B4 02006513		ldi		$a0,#' '     ; followed by a blank
FFFC56B8 E50FE0EF		call	GOOUT
FFFC56BC 000065B3		mov		$a1,$x0     ; stop char. is a zero
FFFC56C0 0002E533		mov		$a0,$t0
FFFC56C4 DF1FF0EF		call  PRTSTG		  ; display the rest of the line
FFFC56C8 00012283		ldt		$t0,[$sp]
FFFC56CC 00412083		ldt		$ra,4[$sp]
FFFC56D0 00812503		ldt		$a0,8[$sp]
FFFC56D4 00C12583		ldt		$a1,12[$sp]
FFFC56D8 01010113		add		$sp,$sp,#16
FFFC56DC 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC56E0 FF41310D		gcsub	$sp,$sp,#12
FFFC56E4 00A12023		stt		$a0,[$sp]
FFFC56E8 00112223		stt		$ra,4[$sp]
FFFC56EC 00B12423		stt		$a1,8[$sp]
FFFC56F0 0AC000EF		call	IGNBLK		; ignore leading blanks
FFFC56F4 00412083		ldt		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC56F8 0003C503		ldbu	$a0,[$t2]
FFFC56FC 0000C583		ldbu	$a1,[$ra]
FFFC5700 00A58A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC5704 00012503		ldt		$a0,[$sp]		; restore a0
FFFC5708 00812583		ldt		$a1,8[$sp]
FFFC570C 00C10113		add		$sp,$sp,#12	;
FFFC5710 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC5714 00138393		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC5718 00012503		ldt		$a0,[$sp]
FFFC571C 00412083		ldt		$ra,4[$sp]
FFFC5720 00812583		ldt		$a1,8[$sp]
FFFC5724 00C10113		add		$sp,$sp,#12
FFFC5728 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $s8 and the number of digits in $s9,
                        	;	else return zero in $s8 and $s9.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	s8 = number
                        	;		s9 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC572C FF81310D		gcsub	$sp,$sp,#8
FFFC5730 00112223		stt		$ra,4[$sp]
FFFC5734 00512023		stt		$t0,[$sp]
FFFC5738 064000EF		call	IGNBLK		; skip over blanks
FFFC573C 00006C33		mov		$s8,$x0		; initialize return parameters
FFFC5740 00006CB3		mov		$s9,$x0
                        	TN1:
FFFC5744 0003C283		ldbu	$t0,[$t2]
FFFC5748 03006313		ldi		$t1,#'0'
FFFC574C 0462C063		blt		$t0,$t1,TSNMRET; is it less than zero?
FFFC5750 03906313		ldi		$t1,#'9'
FFFC5754 02534C63		bgt		$t0,$t1,TSNMRET; is it greater than nine?
FFFC5758 08000337		ldi		$t1,#$7FFFFFF
FFFC575C FFF30313
FFFC5760 01837863		bleu	$s8,$t1,TN2; see if there's room for new digit
FFFC5764 FFFC6537		ldi		$a0,#msgNumTooBig
FFFC5768 B2950513
FFFC576C B01FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC5770 00138393		add		$t2,$t2,#1	; adjust text pointer
FFFC5774 00A06E13		ldi   $t3,#10
FFFC5778 03CC0C33		mul   $s8,$s8,$t3 ; quickly multiply result by 10
FFFC577C FD028293		sub   $t0,$t0,#'0'  ; convert ascii to binary
FFFC5780 005C0C33		add		$s8,$s8,$t0 ; add in the new digit
FFFC5784 001C8C93		add		$s9,$s9,#1	; increment the no. of digits
FFFC5788 FA000EE3		bra		TN1
                        	TSNMRET:
FFFC578C 00012283		ldt		$t0,[$sp]
FFFC5790 00412083		ldt		$ra,4[$sp]
FFFC5794 00810113		add		$sp,$sp,#8
FFFC5798 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC579C FF81310D		gcsub	$sp,$sp,#8
FFFC57A0 00A12023		stt		$a0,[$sp]
FFFC57A4 00612223		stt   $t1,4[$sp]
                        	IGB2:
FFFC57A8 0003C503		ldbu	$a0,[$t2]			; get char
FFFC57AC 02006313		ldi		$t1,#' '
FFFC57B0 00650663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC57B4 00906313		ldi		$t1,#'\t'
FFFC57B8 00651663		bne		$a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC57BC 00138393		add		$t2,$t2,#1		; increment the text pointer
FFFC57C0 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC57C4 00012503		ldt		$a0,[$sp]
FFFC57C8 00412303		ldt   $t1,4[$sp]
FFFC57CC 00810113		add		$sp,$sp,#8
FFFC57D0 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC57D4 FFC10113		sub		$sp,$sp,#4
FFFC57D8 00112023		stt		$ra,[$sp]
FFFC57DC 72406393		ldi		$t2,#BUFFER	; set up text pointer
FFFC57E0 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC57E4 0003C503		lbu		$a0,[$t2]		; get the next text char.
FFFC57E8 00138393		add		$t2,$t2,#1
FFFC57EC 00D06313		ldi		$t1,#CR
FFFC57F0 02650E63		beq		$a0,$t1,TOUPBRT		; is it end of line?
FFFC57F4 02206313		ldi		$t1,#'"'
FFFC57F8 00650E63		beq		$a0,$t1,DOQUO	; a double quote?
FFFC57FC 02706313		ldi		$t1,#'\''     ; '
FFFC5800 00650A63		beq		$a0,$t1,DOQUO	; or a single quote?
FFFC5804 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC5808 030000EF		call	toUpper 	; convert to upper case
FFFC580C FEA38FA3		stb		$a0,-1[$t2]	; store it
FFFC5810 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC5814 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC5818 000561B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC581C FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC5820 FCA192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC5824 000061B3		mov		r3,r0		; else clear quote flag
FFFC5828 FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC582C 00012083		ldt		$ra,[$sp]
FFFC5830 00410113		add		$sp,$sp,#4
FFFC5834 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	;toUpper:
                        	;  sge     $cr0,$a0,#'a'
                        	;  sle.and $cr0,$a0,#'z'
                        	;  asl     $t1,$cr0.C,#5
                        	;  sub     $a0,$a0,$t1
                        	;  ret
                        	
                        	toUpper:
FFFC5838 06152313		slt		$t1,$a0,#'a'
FFFC583C 00031A63		bnez  $t1,TOUPRET	    ; is it < 'a'?
FFFC5840 07B06313		ldi		$t1,#'z'+1
FFFC5844 00652333		slt   $t1,$a0,$t1     ; >= 'a' and <= 'z'?
FFFC5848 00531313		sll   $t1,$t1,#5
FFFC584C 40650533		sub		$a0,$a0,$t1	    ; if not, make it upper case
                        	TOUPRET:
FFFC5850 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC5854 FFC1310D		gcsub	$sp,$sp,#4
FFFC5858 00112023		stt		$ra,[$sp]
FFFC585C 224000EF		call	INCH		    ; get input if possible
FFFC5860 00050863		beqz	$a0,CHKRET  ; if Zero, no input
FFFC5864 00354C93		xor		$s9,$a0,#CTRLC
FFFC5868 000C9463		bnez	$s9,CHKRET  ; is it control-C?
FFFC586C D58FE06F		jmp		WSTART		  ; if so, do a warm start
                        	CHKRET:
FFFC5870 00012083		ldt		$ra,[$sp]
FFFC5874 00410113		add		$sp,$sp,#4
FFFC5878 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC587C FFFC6537		ldi		a0,#CLMSG
FFFC5880 B0D50513
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC5884 FFC10113		sub	  $sp,$sp,#4
FFFC5888 00112023		stt		$ra,[$sp]
FFFC588C AC4FB0EF		call	PutString
FFFC5890 00012083		ldt		$ra,[$sp]
FFFC5894 00410113		add		$sp,$sp,#4
FFFC5898 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC589C E45FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC58A0 00000028		dw		'('
FFFC58A4 04000C63		bra		.paren
FFFC58A8 00106513		ldi		a0,#1
FFFC58AC DA8FF0EF		call	TSTV
FFFC58B0 000C1863		bne		s8,x0,.0001
FFFC58B4 FFFC6537		ldi		a0,#msgVar
FFFC58B8 BA250513
FFFC58BC 9B1FF06F		jmp		ERROR
                        	.0001:
FFFC58C0 E21FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC58C4 00000029		dw		')'
FFFC58C8 02000A63		bra		.paren
FFFC58CC 000C64B3		mov		s1,s8
FFFC58D0 00E06513		ldi		a0,#14			; get current tid
FFFC58D4 00000073		ecall
FFFC58D8 0004E633		mov		a2,s1
FFFC58DC 00606513		ldi		a0,#6
FFFC58E0 00000073		ecall
FFFC58E4 00051463		bne		a0,x0,.0002
FFFC58E8 0194A023		sw		s9,[s1]				; save handle in variable
                        	.0002:
FFFC58EC 00006CB3		mov		s9,x0
FFFC58F0 00012083		lw		$ra,[$sp]
FFFC58F4 00410113		add		$sp,$sp,#4
FFFC58F8 00008067		ret
                        	.paren:
FFFC58FC FFFC6537		ldi		a0,#msgParen
FFFC5900 CAF50513
FFFC5904 969FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC5908 DD9FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC590C 00000028		dw		'('
FFFC5910 08000463		bra		.paren
FFFC5914 900FF0EF		call	OREXPR	; get the mailbox handle
FFFC5918 000C64B3		mov		s1,s8
FFFC591C DC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC5920 0000002C		dw		','
FFFC5924 06000463		bra		.err
FFFC5928 8ECFF0EF		call	OREXPR	; get the memory address
FFFC592C 000C6933		mov		s2,s8
FFFC5930 DB1FF0EF		call	TSTC		; it must be followed by a comma
FFFC5934 0000002C		dw		','
FFFC5938 04000A63		bra		.err
FFFC593C 8D8FF0EF		call	OREXPR	; get the memory address
FFFC5940 000C69B3		mov		s3,s8
FFFC5944 D9DFF0EF		call	TSTC		; it must be followed by a comma
FFFC5948 0000002C		dw		','
FFFC594C 04000063		bra		.err
FFFC5950 8C4FF0EF		call	OREXPR	; get the memory address
FFFC5954 000C6A33		mov		s4,s8
FFFC5958 D89FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC595C 00000029		dw		')'
FFFC5960 02000C63		bra		.paren
FFFC5964 00906513		ldi		a0,#9		; SendMsg
FFFC5968 0004E5B3		mov		a1,s1
FFFC596C 00096633		mov		a2,s2
FFFC5970 0009E6B3		mov		a3,s3
FFFC5974 000A6733		mov		a4,s4
FFFC5978 00000073		ecall
FFFC597C 00006CB3		mov		s9,x0
FFFC5980 00012083		lw		$ra,[$sp]
FFFC5984 00410113		add		$sp,$sp,#4
FFFC5988 00008067		ret
                        	.err:
FFFC598C FFFC6537		ldi		a0,#msgComma
FFFC5990 B7A50513
FFFC5994 8D9FF06F		jmp		ERROR
                        	.paren:
FFFC5998 FFFC6537		ldi		a0,#msgParen
FFFC599C CAF50513
FFFC59A0 8CDFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC59A4 D3DFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC59A8 00000028		dw		'('
FFFC59AC 0C000263		bra		.paren
FFFC59B0 864FF0EF		call	OREXPR	; get the mailbox handle
FFFC59B4 000C64B3		mov		s1,s8
FFFC59B8 D29FF0EF		call	TSTC		; it must be followed by a comma
FFFC59BC 0000002C		dw		','
FFFC59C0 0A000263		bra		.err
FFFC59C4 00106513		ldi		a0,#1
FFFC59C8 C8CFF0EF		call	TSTV
FFFC59CC 000C1863		bne		s8,x0,.0001
                        	.0002:
FFFC59D0 FFFC6537		ldi		a0,#msgVar
FFFC59D4 BA250513
FFFC59D8 895FF06F		jmp		ERROR
                        	.0001:
FFFC59DC D05FF0EF		call	TSTC		; it must be followed by a comma
FFFC59E0 0000002C		dw		','
FFFC59E4 08000063		bra		.err
FFFC59E8 000C6933		mov		s2,s8
FFFC59EC 00106513		ldi		a0,#1
FFFC59F0 C64FF0EF		call	TSTV
FFFC59F4 FC0C0EE3		beq		s8,x0,.0002
FFFC59F8 CE9FF0EF		call	TSTC		; it must be followed by a comma
FFFC59FC 0000002C		dw		','
FFFC5A00 06000263		bra		.err
FFFC5A04 000C69B3		mov		s3,s8
FFFC5A08 00106513		ldi		a0,#1
FFFC5A0C C48FF0EF		call	TSTV
FFFC5A10 FC0C00E3		beq		s8,x0,.0002
FFFC5A14 000C6A33		mov		s4,s8
FFFC5A18 CC9FF0EF		call	TSTC		; it must be followed by a comma
FFFC5A1C 0000002C		dw		','
FFFC5A20 04000263		bra		.err
FFFC5A24 FF1FE0EF		call	OREXPR	; get queue remove flag
FFFC5A28 000C67B3		mov		a5,s8
FFFC5A2C 000C6A33		mov		s4,s8
FFFC5A30 CB1FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC5A34 00000029		dw		')'
FFFC5A38 02000C63		bra		.paren
FFFC5A3C 00A06513		ldi		a0,#10		; WaitMsg
FFFC5A40 0004E5B3		mov		a1,s1
FFFC5A44 00096633		mov		a2,s2
FFFC5A48 0009E6B3		mov		a3,s3
FFFC5A4C 000A6733		mov		a4,s4
FFFC5A50 00000073		ecall
FFFC5A54 00006CB3		mov		s9,x0
FFFC5A58 00012083		lw		$ra,[$sp]
FFFC5A5C 00410113		add		$sp,$sp,#4
FFFC5A60 00008067		ret
                        	.err:
FFFC5A64 FFFC6537		ldi		a0,#msgComma
FFFC5A68 B7A50513
FFFC5A6C 801FF06F		jmp		ERROR
                        	.paren:
FFFC5A70 FFFC6537		ldi		a0,#msgParen
FFFC5A74 CAF50513
FFFC5A78 FF4FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC5A7C 915FA06F		jmp		Putch
                        	
                        	; ===== Input a character from the console into register s8 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC5A80 FFC10113		sub		$sp,$sp,#4
FFFC5A84 00112023		sw		$ra,[$sp]
FFFC5A88 8D9FA0EF		call	Getch
FFFC5A8C 00150513		add		$a0,$a0,#1			; prepare test -1
FFFC5A90 00050A63		beqz	$a0,INCH1			  ; was = -1
FFFC5A94 FFF50513		sub		$a0,$a0,#1			; get char back
FFFC5A98 00012083		ldt		$ra,[$sp]
FFFC5A9C 00410113		add		$sp,$sp,#4
FFFC5AA0 00008067		ret
                        	INCH1:
FFFC5AA4 00012083		ldt		$ra,[$sp]		; return a zero for no-char
FFFC5AA8 00410113		add		$sp,$sp,#4
FFFC5AAC 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	;message "BYEBYE"
                        	BYEBYE:
                        	;	call	ReleaseIOFocus
FFFC5AB0 01606513	  ldi   $a0,#22     ; release I/O focus
FFFC5AB4 00000073	  ecall
FFFC5AB8 70002103		ldt		$sp,OSSP
FFFC5ABC 02206513		ldi   $a0,#34     ; activate Monitor
FFFC5AC0 00000073		ecall
                        	 
                        	
FFFC5AC4 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.3",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,CR,0
FFFC5AC8 54203130
FFFC5ACC 20796E69
FFFC5AD0 49534142
FFFC5AD4 31762043
FFFC5AD8 0A0D332E
FFFC5ADC 20294328
FFFC5AE0 37313032
FFFC5AE4 3230322D
FFFC5AE8 52202030
FFFC5AEC 7265626F
FFFC5AF0 69462074
FFFC5AF4 0D68636E
FFFC5AF8 0A0D000D
FFFC5AFA 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC5AFE 6857000D
FFFC5B00 74616857	msgWhat	db	"What?",CR,0
FFFC5B04 53000D3F
FFFC5B07 72726F53	SRYMSG	db	"Sorry."
FFFC5B0B 000D2E79
FFFC5B0D 6F43000D	CLMSG	db	CR,0
FFFC5B0F 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC5B13 20746361
FFFC5B17 53414C46
FFFC5B1B 65722048
FFFC5B1F 65206461
FFFC5B23 726F7272
FFFC5B27 754E000D
FFFC5B29 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC5B2D 69207265
FFFC5B31 6F742073
FFFC5B35 6962206F
FFFC5B39 44000D67
FFFC5B3C 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC5B40 6E6F6973
FFFC5B44 20796220
FFFC5B48 6F72657A
FFFC5B4C 754F000D
FFFC5B4E 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC5B52 7620666F
FFFC5B56 61697261
FFFC5B5A 20656C62
FFFC5B5E 63617073
FFFC5B62 20000D65
FFFC5B65 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC5B69 66207365
FFFC5B6D 0D656572
FFFC5B71 65520D00
FFFC5B72 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC5B76 000D7964
FFFC5B7A 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC5B7E 6E697463
FFFC5B82 20612067
FFFC5B86 6D6D6F63
FFFC5B8A 4C000D61
FFFC5B8D 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC5B91 6D756E20
FFFC5B95 20726562
FFFC5B99 206F6F74
FFFC5B9D 0D676962
FFFC5BA1 70784500
FFFC5BA2 65707845	msgVar			db "Expecting a variable",CR,0
FFFC5BA6 6E697463
FFFC5BAA 20612067
FFFC5BAE 69726176
FFFC5BB2 656C6261
FFFC5BB6 4E52000D
FFFC5BB8 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC5BBC 20646162
FFFC5BC0 61726170
FFFC5BC4 6574656D
FFFC5BC8 53000D72
FFFC5BCB 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC5BCF 20646162
FFFC5BD3 72646461
FFFC5BD7 0D737365
FFFC5BDB 504E4900
FFFC5BDC 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC5BE0 78652054
FFFC5BE4 74636570
FFFC5BE8 20676E69
FFFC5BEC 61762061
FFFC5BF0 62616972
FFFC5BF4 000D656C
FFFC5BF8 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC5BFC 74697720
FFFC5C00 74756F68
FFFC5C04 524F4620
FFFC5C08 454E000D
FFFC5C0A 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC5C0E 70786520
FFFC5C12 69746365
FFFC5C16 6120676E
FFFC5C1A 66656420
FFFC5C1E 64656E69
FFFC5C22 72617620
FFFC5C26 6C626169
FFFC5C2A 47000D65
FFFC5C2D 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC5C31 534F472F
FFFC5C35 62204255
FFFC5C39 6C206461
FFFC5C3D 20656E69
FFFC5C41 626D756E
FFFC5C45 000D7265
FFFC5C49 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC5C4D 77204E52
FFFC5C51 6F687469
FFFC5C55 47207475
FFFC5C59 4255534F
FFFC5C5D 7250000D
FFFC5C5F 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC5C63 206D6172
FFFC5C67 74207369
FFFC5C6B 62206F6F
FFFC5C6F 000D6769
FFFC5C73 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC5C77 68632061
FFFC5C7B 63617261
FFFC5C7F 73726574
FFFC5C83 206E6F20
FFFC5C87 656E696C
FFFC5C8B 6E676920
FFFC5C8F 6465726F
FFFC5C93 4520000D
FFFC5C95 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC5C99 6E6F7269
FFFC5C9D 746E656D
FFFC5CA1 6C616320
FFFC5CA5 6166206C
FFFC5CA9 64656C69
FFFC5CAD 7845000D
FFFC5CAF 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC5CB3 6E697463
FFFC5CB7 61702067
FFFC5CBB 746E6572
FFFC5CBF 69736568
FFFC5CC3 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
1303 symbols
  Symbol Name                              seg     address bits
  ABS                                        code  fffc50e8 18
  ABS1                                       code  fffc50fc 18
  ACBCommandLine                            const  00034e 11
  ACBCursorCol                              const  000363 11
  ACBCursorRow                              const  000362 11
  ACBDataSize                               const  000048 8
  ACBEnd                                    const  001000 14
  ACBExitRunFile                            const  00034c 11
  ACBGCMarkingQue                           const  000078 8
  ACBGCMarkingQueEmpty                      const  000081 9
  ACBGCMarkingQueFull                       const  000080 9
  ACBGCNdx                                  const  000070 8
  ACBGCOverflow                             const  000082 9
  ACBGCRootCnt                              const  000068 8
  ACBGCRoots                                const  000060 8
  ACBGarbageList                            const  000098 9
  ACBHasFocus                               const  0003c2 11
  ACBHeap                                   const  0000a0 9
  ACBKeyState1                              const  000368 11
  ACBKeyState2                              const  00036a 11
  ACBKeybdBuffer                            const  000370 11
  ACBKeybdHead                              const  00036e 11
  ACBKeybdTail                              const  00036f 11
  ACBKeybdWaitFlag                          const  00036c 11
  ACBNext                                   const  0003b8 11
  ACBNormAttr                               const  000364 11
  ACBObject                                 const  000000 1
  ACBObjectList                             const  000090 9
  ACBPad                                    const  000bc8 13
  ACBPath                                   const  00034a 11
  ACBPtrs                                   const  000280 11
  ACBStatus                                 const  0003c6 11
  ACBStrings                                const  000c00 13
  ACBTask                                   const  0003c0 11
  ACBTemplates                              const  0003c8 11
  ACBUIDataSize                             const  000058 8
  ACBUserName                               const  000348 11
  ACBVideoCols                              const  000361 11
  ACBVideoRows                              const  000360 11
  ACB_MAGIC                                 const  20414342 31
  ACBiofNext                                const  000338 11
  ACBiofPrev                                const  000340 11
  ACBmid                                    const  0003c4 11
  ACBnumber                                 const  0003b0 11
  ACBpCode                                  const  000086 9
  ACBpData                                  const  000040 8
  ACBpUIData                                const  000050 8
  ACBpVidMem                                const  000350 11
  ACBpVirtVidMem                            const  000358 11
  ADDEXPR                                    code  fffc4c90 18
  ALLOCMBX                                   code  fffc589c 18
  ALLOCMBX.0001                              code  fffc58c0 18
  ALLOCMBX.0002                              code  fffc58ec 18
  ALLOCMBX.paren                             code  fffc58fc 18
  ANDEXPR                                    code  fffc4a7c 18
  APPID_POOL                                const  0002f0 11
  ASRAffinity                               const  000004 4
  ASRCodeSize                               const  000008 5
  ASRDataSize                               const  000010 6
  ASRHeapSize                               const  000020 7
  ASRIUDataSize                              code  8000000000000341 32
  ASRPageSize                               const  000000 1
  ASRPriority                               const  000001 2
  ASRRegset                                 const  000002 3
  ASRStackSize                              const  000028 7
  ASRUIDataSize                             const  000018 6
  ASR_SIZE                                  const  000048 8
  ASRmid                                    const  000003 3
  ASRpCode                                  const  000030 7
  ASRpData                                  const  000038 7
  ASRpUIData                                const  000040 8
  AS_DEAD                                   const  000002 3
  AS_LIVE                                   const  000001 2
  AS_NONE                                   const  000000 1
  AS_UNDEAD                                 const  000004 4
  AUXIN                                      code  80000000000003b7 32
  AUXIN_INIT                                 code  8000000000000474 32
  AUXOCRLF                                   code  fffc48c8 18
  AUXOUT                                     code  80000000000003b5 32
  AUXOUT_FLUSH                               code  8000000000000481 32
  AUXOUT_INIT                                code  8000000000000478 32
  AccountTime                                code  fffc26e0 18
  AccountTime.again                          code  fffc26e0 18
  Alloc                                      code  fffc14b0 18
  Alloc.0001                                 code  fffc150c 18
  Alloc.allocZero                            code  fffc1574 18
  Alloc.enough                               code  fffc14e4 18
  Alloc.noRun                                code  fffc1554 18
  Alloc.noRun2                               code  fffc14dc 18
  Alloc.xit                                  code  fffc1558 18
  Alloc.zm                                   code  fffc153c 18
  AllocAppId                                 code  fffc3130 18
  AllocAppId.0001                            code  fffc3150 18
  AllocAppId.0002                            code  fffc3138 18
  AllocMsg                                   code  fffc2dd0 18
  AllocMsg.0001                              code  fffc2e3c 18
  AllocMsg.gotMsg                            code  fffc2e54 18
  AllocMsg.outOfMem                          code  fffc2e7c 18
  AllocStack                                 code  fffc1580 18
  AllocStack.0001                            code  fffc15c0 18
  AllocStack.xit                             code  fffc15d8 18
  BASPRMPT                                   code  fffc3de4 18
  BS                                        const  000008 5
  BUFFER                                    const  000724 12
  BUFLEN                                    const  000054 8
  BYEBYE                                     code  fffc5ab0 18
  CHAINA0                                   const  000378 11
  CHAINA1                                   const  000380 11
  CHAINA2                                   const  000388 11
  CHAINA3                                   const  000390 11
  CHAINA4                                   const  000398 11
  CHAINA5                                   const  0003a0 11
  CHKIO                                      code  fffc5854 18
  CHKRET                                     code  fffc5870 18
  CLMSG                                      code  fffc5b0d 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc587c 18
  CSR_IMSTACK                               const  0007c5 12
  CSR_MEPC                                  const  000341 11
  CSR_MSEMA                                 const  0007c1 12
  CSR_MSTATUS                               const  000300 11
  CSR_PMSTACK                               const  0007c4 12
  CSR_REGSET                                const  0007c0 12
  CSR_RSSTACK                               const  0007c3 12
  CSR_SATP                                  const  000180 10
  CSR_TASKID                                const  0007c2 12
  CSR_TRACECTRL                             const  0007a0 12
  CSR_UIE                                   const  000004 4
  CSTART                                     code  fffc3d30 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLT                                     const  000014 6
  CTRLX                                     const  000018 6
  CURIN                                     const  000370 11
  CUROUT                                    const  000371 11
  CURRNT                                    const  000718 12
  CheckDevOwner                              code  fffc3b2c 18
  CheckDevOwner.notOwner                     code  fffc3b70 18
  CheckDevOwner.xit                          code  fffc3b64 18
  CopyDevDCB                                 code  fffc3af8 18
  CopyDevDCB.again                           code  fffc3b10 18
  CopyDevFuncTbl                             code  fffc3ac8 18
  CopyDevFuncTbl.again                       code  fffc3adc 18
  CurrentTid                                const  000210 11
  CursorFlash                               const  0007b8 12
  DCB_Base                                  const  003000 15
  DCB_LastErc                               const  000018 6
  DCB_Limit                                 const  003c00 15
  DCB_Mbx                                   const  000050 8
  DCB_Name                                  const  000000 1
  DCB_ReentCount                            const  000040 8
  DCB_Resv1                                 const  000060 8
  DCB_Size                                  const  000060 8
  DCB_StartBlock                            const  000020 7
  DCB_Type                                  const  00000c 5
  DCB_fSingleUser                           const  000041 8
  DCB_fUI                                   const  000042 8
  DCB_hJob                                  const  000048 8
  DCB_nBPB                                  const  000010 6
  DCB_nBlocks                               const  000028 7
  DCB_pCmdProc                              const  000030 7
  DCB_pIRQProc                              const  000038 7
  DCB_pSema                                 const  000058 8
  DEFLT                                      code  fffc4640 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc4090 18
  DOQUO                                      code  fffc5814 18
  DOQUO1                                     code  fffc5820 18
  DRSP_DONE                                 const  000001 2
  DVC_BuildBPB                              const  000005 4
  DVC_Close                                 const  000007 4
  DVC_FlushInput                            const  000014 6
  DVC_FlushOutput                           const  000015 6
  DVC_GetChar                               const  000008 5
  DVC_GetCharDirect                         const  00000a 5
  DVC_IOCTRL_READ                           const  000018 6
  DVC_IOCTRL_WRITE                          const  000019 6
  DVC_IRQ                                   const  000016 6
  DVC_Initialize                            const  000002 3
  DVC_InputStatus                           const  00000c 5
  DVC_IsRemoveable                          const  000017 6
  DVC_IsUI                                  const  00001b 6
  DVC_MediaCheck                            const  000004 4
  DVC_Nop                                   const  000000 1
  DVC_Open                                  const  000006 4
  DVC_OutputStatus                          const  000013 6
  DVC_OutputUntilBusy                       const  00001a 6
  DVC_PeekChar                              const  000009 5
  DVC_PeekCharDirect                        const  00000b 5
  DVC_PutChar                               const  00000d 5
  DVC_ReadBlock                             const  000010 6
  DVC_SetPosition                           const  00000f 5
  DVC_Setup                                 const  000001 2
  DVC_Status                                const  000003 3
  DVC_VerifyBlock                           const  000012 6
  DVC_WriteBlock                            const  000011 6
  DVF_Base                                  const  002000 15
  DVF_Limit                                 const  003000 15
  DeleteLine                                 code  fffc3ea0 18
  DeleteLine.0003                            code  fffc3eac 18
  DumpReadyQueue                             code  fffc34c8 18
  DumpReadyQueue.0001                        code  fffc35d4 18
  DumpReadyQueue.0002                        code  fffc3534 18
  DumpReadyQueue.0003                        code  fffc3588 18
  DumpReadyQueue.0004                        code  fffc35fc 18
  DumpReadyQueue.0005                        code  fffc35b0 18
  DumpReadyQueue.0006                        code  fffc3500 18
  DumpReadyQueue.brk                         code  fffc35e8 18
  DumpReadyQueue.nxt                         code  fffc35bc 18
  DumpReadyQueue.nxtT                        code  fffc3674 18
  DumpTimeoutList                            code  fffc36b0 18
  DumpTimeoutList.0002                       code  fffc36ec 18
  DumpTimeoutList.brk                        code  fffc3724 18
  DumpTraceQueue                             code  fffc0b84 18
  DumpTraceQueue.dmpTrace                    code  fffc0b90 18
  DumpTraceQueue.dmpTraceEmpty               code  fffc0bc0 18
  DumpTraceQueue.inf                         code  fffc0bc8 18
  ENDCHK                                     code  fffc521c 18
  ENDMEM                                    const  00f000 17
  EOF                                       const  00001a 6
  ERETx2                                     code  fffc0dc0 18
  ERROR                                      code  fffc526c 18
  ERROR1                                     code  fffc52ac 18
  EX1                                        code  fffc40dc 18
  EXEC                                       code  fffc40a0 18
  EXGO                                       code  fffc40fc 18
  EXLP                                       code  fffc40ac 18
  EXMAT                                      code  fffc40ec 18
  EXNGO                                      code  fffc40c4 18
  EXPR                                       code  fffc4b6c 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadBlockNum                             const  000025 7
  E_BadDCBOffset                            const  00001a 6
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_BadTcbPointer                           const  000027 7
  E_BadTid                                  const  000028 7
  E_Busy                                    const  00001b 6
  E_DCBInUse                                const  000019 6
  E_Func                                    const  000002 3
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  000047 8
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreAppIds                            const  000046 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc07e0 18
  FI1                                        code  fffc51fc 18
  FI2                                        code  fffc5210 18
  FILEBUF                                   const  07f600 20
  FILENAME                                  const  0006c0 12
  FIN                                        code  fffc51e0 18
  FINISH                                     code  fffc4398 18
  FMTKInit                                   code  fffc2268 18
  FMTKInit.0001                              code  fffc2380 18
  FMTKInit.0003                              code  fffc2314 18
  FMTK_AllocMbx                              code  fffc2ba4 18
  FMTK_AllocMbx.0001                         code  fffc2c50 18
  FMTK_AllocMbx.gotMbx                       code  fffc2c68 18
  FMTK_AllocMbx.outOfMem                     code  fffc2cb8 18
  FMTK_AllocMbx_Old                          code  fffc2b30 18
  FMTK_AllocMbx_Old.badArg                   code  fffc2b9c 18
  FMTK_AllocMbx_Old.noOwner                  code  fffc2b64 18
  FMTK_AllocMbx_Old.nxt                      code  fffc2b44 18
  FMTK_ExitApp                               code  fffc3338 18
  FMTK_ExitTask                              code  fffc2a70 18
  FMTK_ForceReleaseIOFocus                   code  fffc38c8 18
  FMTK_ForceReleaseIOFocus.0001              code  fffc3914 18
  FMTK_ForceReleaseIOFocus.noFocus           code  8000000000000369 32
  FMTK_ForceReleaseIOFocus.notAtTop          code  fffc3924 18
  FMTK_FreeMbx                               code  fffc2ce0 18
  FMTK_FreeMbx_Old                           code  fffc2cc0 18
  FMTK_FreeMbx_Old.badMbx                    code  800000000000031f 32
  FMTK_GetAppTaskId                          code  fffc2420 18
  FMTK_GetCurrentTid                         code  fffc23b0 18
  FMTK_GetDCBField                           code  fffc3a30 18
  FMTK_GetDCBField.badDev                    code  fffc3a74 18
  FMTK_GetDCBField.badFunc                   code  fffc3a6c 18
  FMTK_GetDCBField.ldWord                    code  fffc3a60 18
  FMTK_GetDCBField.ok                        code  fffc3a64 18
  FMTK_GetDCBField.xit                       code  fffc3a68 18
  FMTK_GetTaskAppId                          code  fffc23fc 18
  FMTK_HasIOFocus                            code  fffc37d8 18
  FMTK_HasIOFocus.hasFocus                   code  fffc3800 18
  FMTK_HasIOFocus.notEqual                   code  fffc380c 18
  FMTK_IO                                    code  fffc39e8 18
  FMTK_IO.badDev                             code  fffc3a28 18
  FMTK_IO.badFunc                            code  fffc3a20 18
  FMTK_IO.xit                                code  fffc3a1c 18
  FMTK_Initialize                            code  fffc239c 18
  FMTK_KillApp                               code  fffc3350 18
  FMTK_KillApp.immortal                      code  fffc3374 18
  FMTK_KillTask                              code  fffc2a80 18
  FMTK_KillTask.immortal                     code  fffc2a98 18
  FMTK_MapOSVars                             code  fffc2478 18
  FMTK_MapOSVars.mapMore                     code  fffc2490 18
  FMTK_MapOSVars.noMem                       code  fffc24b4 18
  FMTK_PeekMsg                               code  fffc3080 18
  FMTK_PostMsg                               code  80000000000002cc 32
  FMTK_ReleaseIOFocus                        code  fffc38bc 18
  FMTK_RequestIOFocus                        code  fffc385c 18
  FMTK_RequestIOFocus.notEmpty               code  fffc389c 18
  FMTK_RequestIOFocus.ret                    code  fffc38b0 18
  FMTK_RunAsOS                               code  fffc2468 18
  FMTK_RunAsOS.badFunc                       code  fffc2470 18
  FMTK_SendMsg                               code  fffc2fb0 18
  FMTK_SetDCBField                           code  fffc3a7c 18
  FMTK_SetDCBField.badDev                    code  fffc3ac0 18
  FMTK_SetDCBField.badFunc                   code  fffc3ab8 18
  FMTK_SetDCBField.ok                        code  fffc3ab0 18
  FMTK_SetDCBField.stWord                    code  fffc3aac 18
  FMTK_SetDCBField.xit                       code  fffc3ab4 18
  FMTK_SetTaskAppId                          code  fffc240c 18
  FMTK_SetTaskId                             code  fffc2430 18
  FMTK_SetTaskPriority                       code  fffc243c 18
  FMTK_SetTaskPriority.badPtr                code  fffc2458 18
  FMTK_SetTaskPriority.badTid                code  fffc2450 18
  FMTK_Sleep                                 code  fffc280c 18
  FMTK_StartApp                              code  fffc3170 18
  FMTK_StartApp.0001                         code  fffc3208 18
  FMTK_StartApp.0002                         code  fffc3270 18
  FMTK_StartApp.0003                         code  fffc322c 18
  FMTK_StartApp.0004                         code  fffc3224 18
  FMTK_StartApp.0005                         code  fffc3288 18
  FMTK_StartApp.0006                         code  fffc32a0 18
  FMTK_StartApp.0007                         code  fffc32b4 18
  FMTK_StartApp.noMem                        code  fffc3334 18
  FMTK_StartApp.noMoreApps                   code  fffc3330 18
  FMTK_StartApp.tskErr                       code  fffc3324 18
  FMTK_StartTask                             code  fffc2a68 18
  FMTK_SwitchIOFocus                         code  fffc3854 18
  FMTK_TCBFinalizerExit                      code  fffc3c4c 18
  FMTK_TCBFinalizerExit.0001                 code  fffc3c84 18
  FMTK_WaitMsg                               code  fffc3090 18
  FMTK_WaitMsg.qempty                        code  fffc30f8 18
  FMTK_WaitMsg.qt                            code  fffc30a8 18
  FMTK_WaitMsg.setA                          code  fffc3100 18
  FNDLN                                      code  fffc53a0 18
  FNDLNP                                     code  fffc53d0 18
  FNDLNT                                     code  fffc53c8 18
  FNDNXT                                     code  fffc53f4 18
  FNDRET1                                    code  fffc53e4 18
  FNDRET2                                    code  fffc53ec 18
  FOR                                        code  fffc4428 18
  FORCEFIT                                   code  fffc4b44 18
  FORCEFIT.0001                              code  fffc4b68 18
  FORCEFIT.intAnd                            code  fffc4b58 18
  FR1                                        code  fffc4448 18
  FR2                                        code  fffc4464 18
  FR3                                        code  fffc446c 18
  FR4                                        code  fffc4470 18
  FR5                                        code  fffc4474 18
  FR6                                        code  fffc448c 18
  FR7                                        code  fffc4490 18
  FR8                                        code  fffc44b0 18
  FUNCEXPR                                   code  fffc4dc4 18
  FetchMemoryWord                            code  fffc16c4 18
  FillMem                                    code  fffc08a0 18
  FillMem.0001                               code  fffc08bc 18
  Finalizer                                  code  fffc3b90 18
  Finalizer.noFinalizer                      code  fffc3c30 18
  Finalizer.nxt2                             code  fffc3bc4 18
  Finalizer.oscode                           code  fffc3bd8 18
  Finalizer.yield                            code  fffc3bb8 18
  Find                                       code  fffc08d0 18
  Find.0001                                  code  fffc0928 18
  Find.endOfWord                             code  fffc0908 18
  Find.found                                 code  fffc0964 18
  Find.fwe                                   code  fffc08e8 18
  Find.loop                                  code  fffc0918 18
  Find.next                                  code  fffc0944 18
  Find.notFound                              code  fffc097c 18
  FindRun                                    code  fffc1450 18
  FindRun.0001                               code  fffc146c 18
  FindRun.0002                               code  fffc147c 18
  FindRun.empty0                             code  fffc1484 18
  FindRun.empty1                             code  fffc1488 18
  FindRun.foundEnough                        code  fffc14a8 18
  FreeAll                                    code  fffc15ec 18
  FreeAll.0001                               code  fffc1638 18
  FreeAll.nxt                                code  fffc15fc 18
  FreeMbx                                   const  000c08 13
  FreeMbx1                                   code  fffc2d34 18
  FreeMbx1.0001                              code  fffc2d84 18
  FreeMbx1.0002                              code  fffc2d40 18
  FreeMbx1.0003                              code  fffc2d60 18
  FreeMbx1.badMbx                            code  fffc2dc4 18
  FreeMsg                                   const  000c00 13
  FreeMsgRout                                code  fffc2e90 18
  FreeTID                                    code  80000000000002eb 32
  GCHAR                                      code  fffc46c4 18
  GCHAR1                                     code  fffc46dc 18
  GETLN                                      code  fffc52b0 18
  GETLN.GL1                                  code  fffc52d0 18
  GETLN.GL2                                  code  fffc52f8 18
  GETLN.GL3                                  code  fffc5324 18
  GETLN.GL4                                  code  fffc534c 18
  GETLN.GL5                                  code  fffc535c 18
  GETLN.GL6                                  code  fffc537c 18
  GETLN.GL7                                  code  fffc5384 18
  GOAUXI                                     code  fffc3d18 18
  GOAUXO                                     code  fffc3d10 18
  GOBYE                                      code  fffc3d20 18
  GOIN                                       code  fffc3d0c 18
  GOOUT                                      code  fffc3d08 18
  GOSTART                                    code  fffc3d00 18
  GOSUB                                      code  fffc43a0 18
  GOTO                                       code  fffc4214 18
  GOWARM                                     code  fffc3d04 18
  GetBuflen                                  code  fffc3ef0 18
  GetBuflen.0001                             code  fffc3f18 18
  GetBuflen.0002                             code  fffc3efc 18
  GetBuflen.0004                             code  fffc3f14 18
  GetCurrentTid                              code  fffc23a8 18
  GetDecNum                                  code  fffc0a50 18
  GetDecNum.0001                             code  fffc0a74 18
  GetDecNum.isDigit                          code  fffc0a80 18
  GetDecNum.next                             code  fffc0a60 18
  GetFilename                                code  fffc4728 18
  GetHexNum                                  code  fffc09b0 18
  GetHexNum.0001                             code  fffc09f4 18
  GetHexNum.isDigit                          code  fffc0a30 18
  GetHexNum.isHexLower                       code  fffc0a18 18
  GetHexNum.isHexUpper                       code  fffc0a00 18
  GetHexNum.next                             code  fffc09c0 18
  GetIRQFlag                                 code  fffc23c4 18
  GetPamBit                                  code  fffc19f4 18
  GetUIFlag                                  code  fffc39bc 18
  Getch                                      code  fffc0360 18
  HEADRDY                                   const  000400 12
  HEADRDY0                                  const  000400 12
  HEADRDY1                                  const  000404 12
  HEADRDY2                                  const  000408 12
  HEADRDY3                                  const  00040c 12
  HEADRDY4                                  const  000410 12
  IF0                                        code  fffc452c 18
  IF1                                        code  fffc4530 18
  IF2                                        code  fffc4538 18
  IF3                                        code  fffc455c 18
  IGB1                                       code  fffc57bc 18
  IGB2                                       code  fffc57a8 18
  IGBRET                                     code  fffc57c4 18
  IGNBLK                                     code  fffc579c 18
  INBUF                                     const  000100 10
  INCH                                       code  fffc5a80 18
  INCH1                                      code  fffc5aa4 18
  INPERR                                     code  fffc4564 18
  INPPTR                                    const  0007b4 12
  INPUT                                      code  fffc4580 18
  INSLINE                                    code  fffc3e54 18
  INSLINE.0001                               code  fffc3e84 18
  IOF_NEXT                                   code  800000000000030e 32
  IOF_PREV                                   code  800000000000030f 32
  IOFocusNdx                                const  001080 14
  IOFocusTbl                                const  001088 14
  IP2                                        code  fffc45a8 18
  IP3                                        code  fffc45e4 18
  IP4                                        code  fffc4624 18
  IP5                                        code  fffc4634 18
  IP6                                        code  fffc4588 18
  IP7                                        code  fffc45c8 18
  IRQCause                                  const  001098 14
  IRQFlag                                   const  001090 14
  IRQROUT                                   const  0007ac 12
  IRQRout                                    code  fffc0c60 18
  IRQRout.InitDev                            code  fffc0d68 18
  IRQRout.devAgain                           code  fffc0d3c 18
  IRQRout.ecall                              code  fffc0ca4 18
  IRQRout.gcIrq                              code  fffc0dbc 18
  IRQRout.illegal                            code  fffc0c7c 18
  IRQRout.isIRQ                              code  fffc0cc4 18
  IRQRout.noIRQ                              code  fffc0d5c 18
  IRQRout.notSerial                          code  fffc0d90 18
  IRQRout.notVia                             code  fffc0db8 18
  IRQRout.soc                                code  fffc0ca0 18
  IRQRout.softwareIrq                        code  fffc0d64 18
  IRQRout.timerIrq                           code  fffc0d64 18
  ISendMsg                                   code  fffc2ed0 18
  ISendMsg.badMbx                            code  fffc2f98 18
  ISendMsg.mbxEmpty                          code  fffc2f80 18
  ISendMsg.noMsg                             code  fffc2f90 18
  ISendMsg.noWaiters                         code  fffc2f54 18
  ISendMsg.xit                               code  fffc2f9c 18
  ISleep                                     code  fffc2760 18
  ISleep.0001                                code  fffc278c 18
  ISleep.noCtxSwitch                         code  fffc27e8 18
  ISleep.noException                         code  fffc27d8 18
  ISleep.xit                                 code  fffc27f4 18
  IStartTask                                 code  fffc28f0 18
  IStartTask.appidZero                       code  fffc2948 18
  IStartTask.err                             code  fffc2a60 18
  IStartTask.notIdleTask                     code  fffc2a34 18
  IStartTask.xit                             code  fffc2a40 18
  IdleTask                                   code  fffc0290 18
  IdleTask.IdleCode                          code  fffc0310 18
  IdleTask.loop                              code  fffc02b8 18
  IdleTask.loop2                             code  fffc02ac 18
  IdleTask.noAnnounce                        code  fffc02e8 18
  IdleTask.noMsg                             code  fffc02e8 18
  IdleTask.nxtObj                            code  80000000000001a2 32
  IdleTaskId                                const  000c2a 13
  IdleTaskMbx                               const  000c10 13
  IdleTaskMsgD1                             const  000c18 13
  IdleTaskMsgD2                             const  000c20 13
  IdleTaskMsgD3                             const  000c28 13
  InsertIntoReadyQueue                       code  fffc337c 18
  InsertIntoReadyQueue.qempty                code  fffc33a8 18
  InsertIntoTimeoutList                      code  fffc33c8 18
  InsertIntoTimeoutList.atHead               code  fffc344c 18
  InsertIntoTimeoutList.lessThan             code  fffc3424 18
  InsertIntoTimeoutList.listEmpty            code  fffc340c 18
  InsertIntoTimeoutList.loop                 code  fffc33dc 18
  InsertLine                                 code  fffc3ed0 18
  InsertLine.0001                            code  fffc3ed4 18
  InsertLine.done                            code  fffc3eec 18
  LET                                        code  fffc464c 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc42b4 18
  LOAD                                       code  fffc4664 18
  LOAD3                                      code  fffc4794 18
  LOAD4                                      code  fffc47c0 18
  LOAD5                                      code  fffc47f8 18
  LOD1                                       code  fffc4674 18
  LOD2                                       code  fffc46a0 18
  LODEND                                     code  fffc46bc 18
  LOG_ACBSZ                                 const  00000c 5
  LOG_PGSZ                                  const  00000a 5
  LOG_TCBSZ                                 const  00000a 5
  LOPINC                                    const  000780 12
  LOPLMT                                    const  000784 12
  LOPLN                                     const  00077c 12
  LOPPT                                     const  000778 12
  LOPVAR                                    const  000710 12
  LS1                                        code  fffc42c8 18
  LS2                                        code  fffc42f4 18
  LS3                                        code  fffc42fc 18
  LS4                                        code  fffc42d4 18
  LS5                                        code  fffc42cc 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc4660 18
  LoadWord                                   code  fffc5658 18
  MAX_DEV_OP                                const  00001f 6
  MAX_TID                                   const  00000f 5
  MBX_BLOCKPTR_BUFSZ                        const  000008 5
  MBX_LINK                                  const  000004 4
  MBX_MAGIC                                 const  204d4258 31
  MBX_MQHEAD                                const  00000c 5
  MBX_MQTAIL                                const  000010 6
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000014 6
  MBX_TQHEAD                                const  000004 4
  MBX_TQTAIL                                const  000008 5
  MEMSZ                                     const  000200 11
  MEPC0                                     const  000350 11
  MEPC1                                     const  000358 11
  MEPC2                                     const  000360 11
  MEPC3                                     const  000368 11
  MMUInit                                    code  fffc1380 18
  MMUInit.0001                               code  fffc13b0 18
  MMUInit.0002                               code  fffc1418 18
* MMUInit.0003                               code  fffc1430 18
  MMUInit.0004                               code  fffc13a4 18
  MMUInit.0005                               code  fffc13cc 18
  MSG_D1                                    const  000008 5
  MSG_D2                                    const  00000c 5
  MSG_D3                                    const  000010 6
  MSG_LINK                                  const  000000 1
  MSG_MAGIC                                 const  204d5347 31
  MSG_RETADR                                const  000004 4
  MSG_SIZE                                  const  000014 6
  MSG_TGTADR                                const  000005 4
  MSG_TYPE                                  const  000006 4
  MT_ANNOUNCE                               const  000010 6
  MT_IRQ                                    const  ffffffff 33
  MULEXPR                                    code  fffc4d28 18
  MVDOWN                                     code  fffc5430 18
  MVDOWN1                                    code  fffc5420 18
  MVUP                                       code  fffc5418 18
  MVUP1                                      code  fffc5408 18
  MachineStart                               code  fffc0100 18
  MbxBlockCounter                           const  0010e0 14
  MbxBlockPtr                               const  0010a0 14
  MbxBlockPtrEnd                            const  0010c0 14
  MbxFinalizer                               code  800000000000031c 32
  MbxRemoveTask                              code  fffc2aa0 18
  MbxRemoveTask.atHead                       code  fffc2ad4 18
  MbxRemoveTask.tqEmpty                      code  fffc2afc 18
  MbxRemoveTask.xit                          code  fffc2b0c 18
  MonEntry                                   code  fffc04c8 18
  Monitor                                    code  fffc04d0 18
  Monitor.0001                               code  fffc04ec 18
  Monitor.0002                               code  fffc052c 18
  Monitor.0003                               code  fffc055c 18
  Monitor.0004                               code  fffc059c 18
  Monitor.0005                               code  fffc06e4 18
  Monitor.0006                               code  fffc0648 18
  Monitor.0007                               code  fffc066c 18
  Monitor.0008                               code  fffc0678 18
  Monitor.0009                               code  fffc0698 18
  Monitor.0010                               code  fffc06b0 18
  Monitor.0011                               code  fffc06cc 18
  Monitor.0012                               code  fffc06e4 18
  Monitor.basSize                            code  fffc05ec 18
  Monitor.doBackspace                        code  fffc054c 18
  Monitor.doDelete                           code  fffc0524 18
  Monitor.getFocus                           code  fffc04d0 18
  Monitor.hasFocus                           code  fffc04d0 18
  Monitor.noT                                code  fffc0664 18
  Monitor.notFind                            code  fffc0694 18
  Monitor.notX                               code  fffc05bc 18
  Monitor.procLine                           code  fffc057c 18
  Monitor.skip                               code  fffc0584 18
  Monitor.skip2                              code  fffc0594 18
  MsgFinalizer                               code  fffc3128 18
  NEW                                        code  fffc4110 18
  NEXT                                       code  fffc44b4 18
  NPAGES                                    const  000300 11
  NR_DCB                                    const  000020 7
  NR_DCB.done                                code  000000 18
  NR_DCB.noWait                              code  000000 18
  NR_TCB                                    const  000020 7
  NTASK                                     const  000020 7
  NUMWKA                                    const  00079c 12
  NX0                                        code  fffc44d0 18
  NX1                                        code  fffc4510 18
  NX2                                        code  fffc44f0 18
  NX3                                        code  fffc4514 18
  NX4                                        code  fffc44cc 18
  NX5                                        code  fffc44e4 18
  NXPurge                                    code  fffc4524 18
  OBJCollectionIndex                        const  00001c 6
  OBJFWAddr                                 const  000028 7
  OBJFinalizer                              const  000030 7
  OBJID                                     const  000014 6
  OBJMagic                                  const  000000 1
  OBJOwningMap                              const  00001a 6
  OBJPad1                                   const  00001b 6
  OBJPad3                                   const  000024 7
  OBJScavcnt                                const  000019 6
  OBJSize                                   const  000008 5
  OBJState                                  const  000018 6
  OBJTypenum                                const  000010 6
  OBJUsedInMap                              const  000020 7
  OBJ_SIZE                                  const  000040 8
  OKMSG                                      code  fffc5afa 18
  ONIRQ                                      code  fffc4278 18
  ONIRQ1                                     code  fffc4298 18
  OREXPR                                     code  fffc4a14 18
  OSCallTbl                                  code  fffc21e0 18
  OSECALL                                    code  fffc2620 18
  OSECALL.badFunc                            code  fffc2694 18
  OSEcallTbl                                 code  fffc21e8 18
  OSExit                                     code  fffc26a0 18
  OSOCall                                    code  fffc25e0 18
  OSOCall.badFunc                            code  fffc2610 18
  OSPAGES                                   const  000010 6
  OSSP                                      const  000700 12
  OST_BLACK                                 const  000002 3
  OST_DEAD                                  const  000080 9
  OST_GREY                                  const  000001 2
  OST_UNDEAD                                const  000040 8
  OST_WHITE                                 const  000000 1
  OUTC                                       code  fffc5a7c 18
  OUTPTR                                    const  0007b0 12
  OpenSpace                                  code  fffc3f1c 18
  OpenSpace.0003                             code  fffc3f34 18
  OpenSpace.noSpace                          code  fffc3f50 18
  PAGESZ                                    const  000400 12
  PAM                                       const  001000 14
  PAMAlloc                                   code  fffc1780 18
  PAMAlloc.markNext                          code  fffc17c8 18
  PAMAlloc.outOfMem                          code  fffc1800 18
  PAMAlloc.xit                               code  fffc17e8 18
  PAMAlloc.xit2                              code  fffc1808 18
  PAMDump                                    code  fffc1a08 18
  PAMDump.0001                               code  fffc1a14 18
  PAMFindRun                                 code  fffc16d0 18
  PAMFindRun.foundRun                        code  fffc1760 18
  PAMFindRun.nextPage                        code  fffc1700 18
  PAMFindRun.notAvailable                    code  fffc174c 18
  PAMFindRun.outOfMem                        code  fffc1758 18
  PAMFindRun.runInc                          code  fffc1714 18
  PAMFindRun.xit                             code  fffc1764 18
  PAMFree                                    code  fffc1818 18
  PAMFree.endOfRun                           code  fffc187c 18
  PAMFree.lastPage                           code  fffc186c 18
  PAMFree.nextPage                           code  fffc1840 18
  PAMFree.xit                                code  fffc1888 18
  PAMGetbitPair                              code  fffc194c 18
  PAMInit                                    code  fffc1978 18
  PAMInit.0001                               code  fffc19a8 18
  PAMInit.0002                               code  fffc1984 18
  PAMMarkPage                                code  fffc1898 18
  PAMMarkPage.0001                           code  fffc18ac 18
  PAMMarkPage.gotFree                        code  fffc18cc 18
  PAMMarkPage.xit                            code  fffc18d8 18
  PAMPtr                                    const  000ff8 13
  PAMSetbitPair                              code  fffc18fc 18
  PAMUnmarkPage                              code  fffc18e8 18
  PAMend                                    const  001080 14
  PAMxit                                     code  fffc1948 18
  PARN                                       code  fffc4e14 18
  PEEK                                       code  fffc5004 18
  PEEKH                                      code  fffc5034 18
  PEEKW                                      code  fffc501c 18
  PKER                                       code  fffc49dc 18
  POKE                                       code  fffc4958 18
  POKEH                                      code  fffc49b0 18
  POKEW                                      code  fffc4984 18
  POPA_                                      code  fffc5438 18
  PP1                                        code  fffc546c 18
  PR0                                        code  fffc432c 18
  PR1                                        code  fffc4344 18
  PR2                                        code  fffc4318 18
  PR3                                        code  fffc4364 18
  PR4                                        code  fffc435c 18
  PR6                                        code  fffc4378 18
  PR8                                        code  fffc4380 18
  PRINT                                      code  fffc4300 18
  PRI_LOW                                   const  000003 3
  PRI_NORMAL                                const  000002 3
  PRMESG                                     code  fffc5884 18
  PRTLN                                      code  fffc5684 18
  PRTNUM                                     code  fffc55b0 32
  PRTNUM.PN1                                 code  fffc55e4 18
  PRTNUM.PN2                                 code  fffc55e0 18
  PRTNUM.PN3                                 code  fffc560c 18
  PRTNUM.PN4                                 code  fffc561c 18
  PRTNUM.PN5                                 code  fffc5628 18
  PRTNUM.PN6                                 code  fffc562c 18
  PRTNUM.PN7                                 code  fffc55f4 18
  PRTSTG                                     code  fffc54b4 18
  PRTSTG.PRTRET                              code  fffc54f8 18
  PRTSTG.PS1                                 code  fffc54d4 18
  PU1                                        code  fffc54a8 18
  PUSHA_                                     code  fffc5470 18
  PWORD                                      code  fffc48ec 18
  PeekMsg                                    code  fffc2fc0 18
  PeekMsg.badMbx                             code  fffc306c 18
  PeekMsg.noMsg                              code  fffc3064 18
  PeekMsg.nod1                               code  fffc3034 18
  PeekMsg.nod2                               code  fffc3048 18
  PeekMsg.nod3                               code  fffc305c 18
  PeekMsg.nodq                               code  fffc3014 18
  PeekMsg.ret                                code  fffc3070 18
  PutHexByte                                 code  fffc0ae0 18
  PutHexHalf                                 code  fffc0ac0 18
  PutHexNybble                               code  fffc0b00 18
  PutHexNybble.0001                          code  fffc0b34 18
  PutHexNybble.lt10                          code  fffc0b2c 18
  PutHexWord                                 code  fffc0aa0 18
  PutString                                  code  fffc0b50 18
  PutString.0001                             code  fffc0b60 18
  PutString.done                             code  fffc0b74 18
  Putch                                      code  fffc0390 18
  QNDX                                      const  000304 11
  QSORRY                                     code  fffc5258 18
  QT1                                        code  fffc5534 18
  QT2                                        code  fffc5574 18
  QT3                                        code  fffc554c 18
  QT4                                        code  fffc5560 18
  QT5                                        code  fffc5580 18
  QTSTG                                      code  fffc551c 18
  QWHAT                                      code  fffc5264 18
  RDYQ1                                     const  000500 12
  RDYQ2                                     const  000600 12
  RDYQ3                                     const  000700 12
  READYQ                                    const  000400 12
  RETURN                                     code  fffc43e4 18
  RND                                        code  fffc508c 18
  RUN                                        code  fffc4168 18
  RUN1                                       code  fffc41e0 18
  RUN2                                       code  fffc4184 18
  RUN3                                       code  fffc4188 18
  RUNNXL                                     code  fffc417c 18
  RUNSML                                     code  fffc41fc 18
  RUNTSL                                     code  fffc41f4 18
  RegsetTid                                 const  0010f0 14
  RemoveFromReadyQueue                       code  fffc33b8 18
  RemoveFromTimeoutList                      code  fffc3458 18
  RemoveFromTimeoutList.atHead               code  fffc3490 18
  RemoveFromTimeoutList.atTail               code  fffc3488 18
  RemoveFromTimeoutList.atTail2              code  fffc34bc 18
  RemoveFromTimeoutList.notAtHead            code  fffc34b4 18
  SAVE                                       code  fffc4868 18
  SAVE1                                      code  fffc4874 18
  SAVE2                                      code  fffc4890 18
  SAVE3                                      code  fffc47fc 18
  SAVE4                                      code  fffc482c 18
  SAVEND                                     code  fffc48a8 18
  SDReadSector                               code  8000000000000475 32
  SDWriteSector                              code  800000000000047a 32
  SENDMSG                                    code  fffc5908 18
  SENDMSG.err                                code  fffc598c 18
  SENDMSG.paren                              code  fffc5998 18
  SETVAL                                     code  fffc5178 18
  SETVAL.sv2                                 code  fffc519c 18
  SGN                                        code  fffc5120 18
  SGN1                                       code  fffc5150 18
  SGN2                                       code  fffc5140 18
  SIZEX                                      code  fffc515c 18
  SLEEP                                      code  fffc412c 18
  SLEEP1                                     code  fffc4138 18
  SRCHLN                                    const  00071c 12
  SRYMSG                                     code  fffc5b07 18
  ST2                                        code  fffc3e30 18
  STACKOFFS                                 const  07fffc 20
  STKBOT                                    const  0007a4 12
  STKGOS                                    const  000714 12
  STKINP                                    const  0007a0 12
  STOP                                       code  fffc4124 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc51d8 18
  SYSX                                       code  fffc49e8 18
  SchedulerIRQ                               code  fffc2820 18
  SchedulerIRQ.0001                          code  fffc2840 18
  SchedulerIRQ.noCtxSwitch                   code  fffc28d0 18
  SchedulerIRQ.noException                   code  fffc28c8 18
  SchedulerIRQ.noOS                          code  fffc2830 18
  SchedulerIRQ.rmvFromTol                    code  fffc285c 18
  SchedulerIRQ.toDone                        code  fffc2884 18
  SelectTaskToRun                            code  fffc24c0 18
  SelectTaskToRun.checkAgain                 code  fffc24c8 18
  SelectTaskToRun.dq                         code  fffc253c 18
  SelectTaskToRun.mod                        code  fffc2514 18
  SelectTaskToRun.nxtQ                       code  fffc24f0 18
  SelectTaskToRun.xit                        code  fffc2554 18
  SerHeadRcv                                const  001c00 14
  SerHeadXmit                               const  001c08 14
  SerRcvBuf                                 const  001400 14
  SerRcvXoff                                const  001c11 14
  SerRcvXon                                 const  001c10 14
  SerTailRcv                                const  001c04 14
  SerTailXmit                               const  001c0c 14
  SerXmitBuf                                const  001800 14
  SerialDCB                                  code  fffc1ac0 18
  SerialFinishCmd                            code  fffc1c74 18
  SerialFinishCmd.0001                       code  fffc1ca8 18
  SerialFuncTbl                              code  fffc1a40 18
  SerialGetChar                              code  fffc1cac 18
  SerialGetChar.0001                         code  fffc1d64 18
  SerialGetChar.0002                         code  fffc1d14 18
  SerialGetChar.noChars                      code  fffc1d64 18
  SerialGetChar.xit                          code  fffc1d68 18
  SerialGetUI                                code  fffc1ff4 18
  SerialIRQ                                  code  fffc1f0c 18
  SerialIRQ.0001                             code  fffc1f48 18
  SerialIRQ.notRxInt                         code  fffc1ff0 18
  SerialIRQ.nxtByte                          code  fffc1f0c 18
  SerialIRQ.rxFull                           code  fffc1ff0 18
  SerialInit                                 code  fffc1b20 18
  SerialNOP                                  code  fffc1bf0 18
  SerialPeekChar                             code  fffc1d8c 18
  SerialPeekChar.0001                        code  fffc1dd4 18
  SerialPeekChar.noChars                     code  fffc1dd4 18
  SerialPeekChar.xit                         code  fffc1dd8 18
  SerialPeekCharDirect                       code  fffc1df4 18
  SerialPeekCharDirect.0001                  code  fffc1e30 18
  SerialPeekCharDirect.xit                   code  fffc1e34 18
  SerialPutChar                              code  fffc1e50 18
  SerialPutChar.0001                         code  fffc1e6c 18
  SerialPutChar.0002                         code  fffc1e64 18
  SerialPutChar.goSleep                      code  fffc1ebc 18
  SerialRcvCount                             code  fffc1ed0 18
  SerialRcvCount.xit                         code  fffc1f04 18
  SerialService                              code  fffc1c0c 18
  SerialServiceInit                          code  fffc1bf4 18
  SerialServiceLoop                          code  fffc1c28 18
  SerialServiceLoop.0001                     code  fffc1c28 18
  SetIRQFlag                                 code  fffc23e0 18
  SkipSpaces                                 code  fffc0990 18
  SkipSpaces.skip1                           code  fffc09a8 18
  SkipSpaces.skip2                           code  fffc0990 18
  StackTbl                                   code  fffc0be0 18
  SwapContext                                code  fffc2560 18
  SwitchIOFocusHelper                        code  fffc3818 18
  SwitchIOFocusHelper.notSame                code  fffc384c 18
  SwitchIOFocusHelper.zeroAppid              code  fffc3844 18
  SysHeapEnd                                const  020000 19
  SysHeapStart                              const  004000 16
  SysSema                                   const  000340 11
  SystemASR                                  code  fffc0ddc 18
  TAB                                       const  000009 5
  TAB1                                       code  fffc3f58 18
  TAB10                                      code  fffc4017 18
  TAB10_1                                    code  fffc4088 18
  TAB1_1                                     code  fffc401a 18
  TAB2                                       code  fffc3f6f 18
  TAB2_1                                     code  fffc4026 18
  TAB4                                       code  fffc3fc8 18
  TAB4_1                                     code  fffc4054 18
  TAB5                                       code  fffc4001 18
  TAB5_1                                     code  fffc406e 18
  TAB6                                       code  fffc4004 18
  TAB6_1                                     code  fffc4072 18
  TAB8                                       code  fffc4009 18
  TAB8_1                                     code  fffc4076 18
  TAB9                                       code  fffc4013 18
  TAB9_1                                     code  fffc4084 18
  TAILRDY                                   const  000420 12
  TAILRDY0                                  const  000420 12
  TAILRDY1                                  const  000424 12
  TAILRDY2                                  const  000428 12
  TAILRDY3                                  const  00042c 12
  TAILRDY4                                  const  000430 12
  TBASR                                      code  80000000000001cb 32
  TC1                                        code  fffc5714 18
  TCBEndTick                                const  0002d8 11
  TCBException                              const  000308 11
  TCBFltRegs                                const  000140 10
  TCBHasFocus                               const  0002cc 11
  TCBIntRegs                                const  000040 8
  TCBMbxNext                                const  000348 11
  TCBMbxPrev                                const  000350 11
  TCBMsgD1                                  const  0002d8 11
  TCBMsgD2                                  const  0002e0 11
  TCBMsgD3                                  const  0002e8 11
  TCBName                                   const  000360 11
  TCBNext                                   const  000310 11
  TCBObject                                 const  000000 1
  TCBOpMode                                 const  000344 11
  TCBPTR_MASK                               const  fff803ff 33
  TCBPrev                                   const  000318 11
  TCBPriority                               const  0002c9 11
  TCBRegsEnd                                const  000240 11
  TCBRegset                                 const  0002cb 11
  TCBStackBot                               const  0002d0 11
  TCBStartTick                              const  0002d0 11
  TCBStatus                                 const  0002c8 11
  TCBTaskNum                                const  000358 11
  TCBTicks                                  const  000300 11
  TCBTimeout                                const  000320 11
  TCBWaitMbx                                const  0002ca 11
  TCB_MAGIC                                 const  20544342 31
  TCBappid                                  const  000342 11
  TCBbases                                  const  000240 11
  TCBepc                                    const  0002c0 11
  TCBmid                                    const  000340 11
  TCBtid                                    const  000338 11
  TCBxA0                                    const  000090 9
  TCBxA1                                    const  000098 9
  TCBxA2                                    const  0000a0 9
  TCBxA3                                    const  0000a8 9
  TCBxA4                                    const  0000b0 9
  TCBxA5                                    const  0000b8 9
  TCBxA6                                    const  0000c0 9
  TCBxA7                                    const  0000c8 9
  TCBxFP                                    const  000080 9
  TCBxGP                                    const  000058 8
  TCBxRA                                    const  000048 8
  TCBxS1                                    const  000088 9
  TCBxS10                                   const  000110 10
  TCBxS11                                   const  000118 10
  TCBxS2                                    const  0000d0 9
  TCBxS3                                    const  0000d8 9
  TCBxS4                                    const  0000e0 9
  TCBxS5                                    const  0000e8 9
  TCBxS6                                    const  0000f0 9
  TCBxS7                                    const  0000f8 9
  TCBxS8                                    const  000100 10
  TCBxS9                                    const  000108 10
  TCBxSP                                    const  000050 8
  TCBxT0                                    const  000068 8
  TCBxT1                                    const  000070 8
  TCBxT2                                    const  000078 8
  TCBxT3                                    const  000120 10
  TCBxT4                                    const  000128 10
  TCBxT5                                    const  000130 10
  TCBxT6                                    const  000138 10
  TCBxTP                                    const  000060 8
  TICKX                                      code  fffc510c 18
  TID_POOL                                  const  000310 11
  TN1                                        code  fffc5744 18
  TN2                                        code  fffc5770 18
  TOOBIG                                     code  fffc524c 18
  TOUPB1                                     code  fffc57e4 18
  TOUPBRT                                    code  fffc582c 18
  TOUPBUF                                    code  fffc57d4 18
  TOUPRET                                    code  fffc5850 18
  TSNMRET                                    code  fffc578c 18
  TSTC                                       code  fffc56e0 18
  TSTNUM                                     code  fffc572c 18
  TSTV                                       code  fffc4e54 18
  TSTVRT                                     code  fffc4ec4 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_UNDEAD                                 const  000040 8
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc4eb0 18
  TV2                                        code  fffc4ea4 18
  TV3                                        code  fffc4e84 18
  TXTBGN                                    const  001800 14
  TXTUNF                                    const  000704 12
  TaskNum                                   const  000220 11
  Tick                                      const  000330 11
  TidTcbMap                                  code  8000000000000349 32
  TimeoutList                               const  000328 11
  TinyBasic                                  code  fffc3d00 18
  TinyBasicASR                               code  fffc0e24 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  UNDEADQ                                   const  000007 4
  USRX                                       code  fffc504c 18
  UpdateMsgFields                            code  fffc2700 18
  UpdateMsgFields.noMsg                      code  fffc2748 18
  UpdateMsgFields.notWaiting                 code  fffc2750 18
  UserStart                                  code  fffc0198 18
  UserStart2                                 code  fffc01a8 18
  UserStart2.appBad                          code  fffc01b8 18
  UserStart3                                 code  fffc0234 18
  UserStart3.0002                            code  fffc0270 18
  UserStart3.0003                            code  fffc0284 18
  UserStart3.0004                            code  fffc0264 18
  UserStart3.noMbx                           code  fffc0270 18
  VARBGN                                    const  000708 12
  VAREND                                    const  00070c 12
  VIA                                       const  ffdc0600 33
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IER                                   const  000038 7
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  VIA_T2CH                                  const  000024 7
  VIA_T2CL                                  const  000020 7
  ViaDCB                                     code  fffc2088 18
  ViaFuncTbl                                 code  fffc2008 18
  ViaIRQ                                     code  fffc2180 18
  ViaIRQ.0001                                code  fffc2194 18
  ViaIRQ.timer2irq                           code  fffc21c8 18
  ViaIRQ.timer3irq                           code  fffc21a0 18
  ViaInit                                    code  fffc2120 18
  ViaNOP                                     code  fffc211c 18
  ViaSetup                                   code  fffc20e8 18
  VirtToLinear                               code  fffc1644 18
  VirtToPhys                                 code  fffc1668 18
  VirtToPhys.notMapped                       code  fffc16a0 18
  VirtToPhys2                                code  fffc16b0 18
  VirtToPhys2.notMapped                      code  fffc16b8 18
  WAITIRQ                                    code  fffc42a0 18
  WAITMSG                                    code  fffc59a4 18
  WAITMSG.0001                               code  fffc59dc 18
  WAITMSG.0002                               code  fffc59d0 18
  WAITMSG.err                                code  fffc5a64 18
  WAITMSG.paren                              code  fffc5a70 18
  WSTART                                     code  fffc3dc4 18
  WaitForIOFocus                             code  fffc3944 18
  WaitForIOFocus.0001                        code  fffc3974 18
  WaitForIOFocus.HasFocus                    code  fffc39a8 18
  WaitForIOFocus.WFF1                        code  fffc3954 18
  WaitForIOFocus.WFF2                        code  fffc3998 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc4b98 18
  XP12                                       code  fffc4bb0 18
  XP13                                       code  fffc4bc8 18
  XP14                                       code  fffc4be0 18
  XP15                                       code  fffc4bf8 18
  XP16                                       code  fffc4c10 18
  XP17                                       code  fffc4c50 18
  XP18                                       code  fffc4c68 18
  XP21                                       code  fffc4cb8 18
  XP22                                       code  fffc4cc4 18
  XP23                                       code  fffc4cc8 18
  XP24                                       code  fffc4ce4 18
  XP25                                       code  fffc4cf8 18
  XP26                                       code  fffc4d04 18
  XP31                                       code  fffc4d34 18
  XP34                                       code  fffc4d64 18
  XP35                                       code  fffc4d88 18
  XP40                                       code  fffc4de0 18
  XP41                                       code  fffc4dfc 18
  XP42                                       code  fffc4e38 18
  XP43                                       code  fffc4e44 18
  XP45                                       code  fffc4d10 18
  XP46                                       code  fffc4e08 18
  XP47                                       code  fffc4dac 18
  XPRT0                                      code  fffc4c28 18
  XPRT1                                      code  fffc4c3c 18
  XP_AND                                     code  fffc4aa8 18
  XP_AND1                                    code  fffc4a88 18
  XP_ANDX                                    code  fffc4abc 18
  XP_OR                                      code  fffc4a48 18
  XP_OR1                                     code  fffc4a28 18
  XP_ORX                                     code  fffc4a5c 18
  YIELD0                                     code  fffc4160 18
  _WaitForIOFocus                            code  fffc3944 18
  _clr                                       code  fffc4238 18
  _cls                                       code  80000000000003f9 32
  _end_init_data                           rodata  fffc6000 32
  _rdcf                                      code  80000000000003fb 32
  a2h1                                       code  fffc471c 18
  asciiToHex                                 code  fffc4710 18
  begin_init_data                          rodata  fffc6000 32
  clearVars                                  code  fffc4240 18
  clearVars.cv1                              code  fffc4254 18
  doMem                                      code  fffc06f0 18
  doMem.0001                                 code  fffc0708 18
  doMem.0002                                 code  fffc0788 18
  doMem.0003                                 code  fffc07cc 18
  doMem.0004                                 code  fffc07b0 18
  doMem.loop                                 code  fffc0764 18
  doMem.loop2                                code  fffc073c 18
  doMem.unprintable                          code  fffc07c4 18
  doMem.userMem                              code  fffc0784 18
  doPStat                                    code  fffc0860 18
  doPStat.0001                               code  fffc0874 18
  doVMem                                     code  fffc0800 18
  doVMem.0001                                code  fffc0810 18
  doVMem.notLF                               code  fffc0828 18
  ec1                                        code  fffc5240 18
  end_init_data                            rodata  fffc6000 32
  fgetc                                      code  fffc0450 18
  fgetc.0001                                 code  fffc0494 18
  fgetc.0002                                 code  fffc04a8 18
  fgetc.checkOwner                           code  fffc0488 18
  fgetc.notOwner                             code  fffc04c0 18
  findVar                                    code  fffc4f94 18
  fl1                                        code  fffc53b8 18
  flt10                                      code  fffc0fa5 18
  flt20                                      code  fffc0f95 18
  flt50                                      code  fffc0f85 18
  fltMillion                                 code  fffc137c 18
  fltOne                                     code  fffc1374 18
  fltTen                                     code  fffc1378 18
  fltToString                                code  fffc0fb5 18
  fltToString.0001                           code  fffc1016 18
  fltToString.0002                           code  fffc1096 18
  fltToString.0003                           code  fffc1082 18
  fltToString.0004                           code  fffc10e2 18
  fltToString.0005                           code  fffc10da 18
  fltToString.0006                           code  fffc10c2 18
  fltToString.0007                           code  fffc10fe 18
  fltToString.0008                           code  fffc1112 18
  fltToString.0009                           code  fffc110e 18
  fltToString.0010                           code  fffc1132 18
  fltToString.0011                           code  fffc11be 18
  fltToString.0012                           code  fffc1176 18
  fltToString.0013                           code  fffc1162 18
  fltToString.0014                           code  fffc1192 18
  fltToString.0015                           code  fffc11ae 18
  fltToString.0016                           code  fffc114a 18
  fltToString.0017                           code  fffc11b6 18
  fltToString.0018                           code  fffc11be 18
  fltToString.0019                           code  fffc11f2 18
  fltToString.0020                           code  fffc11fe 18
  fltToString.0021                           code  fffc1222 18
  fltToString.0022                           code  fffc122e 18
  fltToString.0023                           code  fffc123e 18
  fltToString.0024                           code  fffc124a 18
  fltToString.0025                           code  fffc1236 18
  fltToString.0026                           code  fffc125e 18
  fltToString.0027                           code  fffc1266 18
  fltToString.0028                           code  fffc126e 18
  fltToString.0029                           code  fffc127a 18
  fltToString.0030                           code  fffc1286 18
  fltToString.0031                           code  fffc1292 18
  fltToString.0032                           code  fffc129a 18
  fltToString.0034                           code  fffc12a2 18
  fltToString.0035                           code  fffc12ae 18
  fltToString.0036                           code  fffc12be 18
  fltToString.0037                           code  fffc12ca 18
  fltToString.0038                           code  fffc12d2 18
  fltToString.0039                           code  fffc12e6 18
  fltToString.0040                           code  fffc12da 18
  fltToString.0041                           code  fffc1342 18
  fltToString.0042                           code  fffc1306 18
  fltToString.0043                           code  fffc1316 18
  fltToString.0044                           code  fffc132a 18
  fltToString.0045                           code  fffc130e 18
  fltToString.0046                           code  fffc1336 18
  fltToString.0047                           code  fffc1342 18
  fltToString.0048                           code  fffc132e 18
  fltToString.0050                           code  fffc1362 18
  fltToString.0051                           code  fffc135e 18
  fltToString.0052                           code  fffc134e 18
  fltToString.inf                            code  fffc0ffe 18
  fltToString.notZero                        code  fffc1052 18
  fltToString.pos                            code  fffc103e 18
  fltToString.prt                            code  fffc12f6 18
  fputc                                      code  fffc03c0 18
  fputc.0001                                 code  fffc0414 18
  fputc.checkOwner                           code  fffc040c 18
  fputc.noBypass                             code  fffc03e4 18
  fputc.notOwner                             code  fffc0440 18
  fputc.xit                                  code  fffc0428 18
  fv1                                        code  fffc4fdc 18
  fv2                                        code  fffc4ff0 18
  fv3                                        code  fffc4fd4 18
  fv4                                        code  fffc4fa4 18
  gcIncrement                                code  fffc3ca0 18
  gen_rand                                   code  80000000000004c3 32
  getVarName                                 code  fffc4ee8 18
  gfn1                                       code  fffc4790 18
  gfn2                                       code  fffc4740 18
  gfn3                                       code  fffc4770 18
  gosub1                                     code  fffc43c0 18
  gvn1                                       code  fffc4f80 18
  gvn2                                       code  fffc4f44 18
  gvn3                                       code  fffc4f60 18
  gvn4                                       code  fffc4f08 18
  gvn6                                       code  fffc4f34 18
  isAlnum                                    code  fffc4b24 18
  isAlpha                                    code  fffc4af4 18
  isAlphaFalse                               code  fffc4b1c 18
  isAlphaTrue                                code  fffc4b14 18
  isDigit                                    code  fffc4ad4 18
  isDigitFalse                               code  fffc4aec 18
  isDigitx                                   code  fffc4b38 18
  mInsertIntoReadyQueue                      code  fffc0334 18
  mInsertIntoReadyQueue.nxtObj               code  fffc0338 18
  mbxs                                      const  000800 13
  mbxs_end                                  const  000c00 13
  milliseconds                              const  000208 11
  missed_ticks                              const  000320 11
  msgBadGotoGosub                            code  fffc5c2d 18
  msgBytesFree                               code  fffc5b65 18
  msgCRLF                                    code  fffc0f82 18
  msgComma                                   code  fffc5b7a 18
  msgDivZero                                 code  fffc5b3c 18
  msgEnvFail                                 code  fffc5c95 18
  msgExtraChars                              code  fffc5c73 18
  msgFinalizerRunning                        code  fffc3c88 18
  msgIdleAnnounce                            code  fffc0340 18
  msgInf                                     code  fffc136c 18
  msgInit                                    code  fffc5ac4 18
  msgInputVar                                code  fffc5bdc 18
  msgLineRange                               code  fffc5b8d 18
  msgMonHelp                                 code  fffc0e82 18
  msgNan                                     code  fffc1370 18
  msgNextFor                                 code  fffc5bf8 18
  msgNextVar                                 code  fffc5c0a 18
  msgNumTooBig                               code  fffc5b29 18
  msgParen                                   code  fffc5caf 18
  msgRNDBad                                  code  fffc5bb8 18
  msgReadError                               code  fffc5b0f 18
  msgReady                                   code  fffc5b72 18
  msgReadyQueue                              code  fffc3750 18
  msgRetWoGosub                              code  fffc5c49 18
  msgSYSBad                                  code  fffc5bcb 18
  msgStart                                   code  fffc0e6c 18
  msgTaskInfo                                code  fffc377a 18
  msgTaskStart                               code  fffc0f74 18
  msgTimeoutList                             code  fffc37a9 18
  msgTooBig                                  code  fffc5c5f 18
  msgVar                                     code  fffc5ba2 18
  msgVarSpace                                code  fffc5b4e 18
  msgWhat                                    code  fffc5b00 18
  nmeSerial                                  code  fffc2000 18
  prCRLF                                     code  fffc558c 18
  pword1                                     code  fffc4900 18
  pword2                                     code  fffc491c 18
  qToChk                                     code  fffc2248 18
  return1                                    code  fffc43fc 18
  rnd1                                       code  fffc50c0 18
  rnd2                                       code  fffc50d0 18
  switchflag                                const  000200 11
  sysx1                                      code  fffc49fc 18
  tah1                                       code  fffc4950 18
  toAsciiHex                                 code  fffc4940 18
  toUpper                                    code  fffc5838 18
  tstv_notfound                              code  fffc4ed4 18
  usrJmp                                    const  0007a8 12

Undefined Symbols
  ASRIUDataSize                              code  8000000000000341 32
  AUXIN                                      code  80000000000003b7 32
  AUXIN_INIT                                 code  8000000000000474 32
  AUXOUT                                     code  80000000000003b5 32
  AUXOUT_FLUSH                               code  8000000000000481 32
  AUXOUT_INIT                                code  8000000000000478 32
  FMTK_ForceReleaseIOFocus.noFocus           code  8000000000000369 32
  FMTK_FreeMbx_Old.badMbx                    code  800000000000031f 32
  FMTK_PostMsg                               code  80000000000002cc 32
  FreeTID                                    code  80000000000002eb 32
  IOF_NEXT                                   code  800000000000030e 32
  IOF_PREV                                   code  800000000000030f 32
  IdleTask.nxtObj                            code  80000000000001a2 32
  MbxFinalizer                               code  800000000000031c 32
  SDReadSector                               code  8000000000000475 32
  SDWriteSector                              code  800000000000047a 32
  TBASR                                      code  80000000000001cb 32
  TidTcbMap                                  code  8000000000000349 32
  _cls                                       code  80000000000003f9 32
  _rdcf                                      code  80000000000003fb 32
  gen_rand                                   code  80000000000004c3 32

  Macro Name
 mDI                                       -842150451

  csrrc $x0,#CSR_PMSTACK,#1        ; disable interrupts

 mEI                                       -842150451

  csrrs $x0,#CSR_PMSTACK,#1        ; enable interrupts

 mGetAppMid                                -842150451

  sll   $a0,$a0,#LOG_PGSZ
  ldb   $a0,ACBmid[$a0]

 mGetCurrentTid                            -842150451

  csrrw $a0,#CSR_TASKID,$x0

 mHasFocus                                 -842150451

	ldi		$a0,#20
	ecall

 mMbxHandleToPointer                       -842150451

  srl   $t0,$a0,#8    ; extract collection index
  sll   $t0,$t0,#2
  ldt   $t0,MbxBlockPtr[$t0]
  and   $a0,$a0,#$FF
  sll   $a0,$a0,#2
  or    $a0,$a0,$t0

 mSleep                                    1

	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#0
	ecall

 mTimeSliceDI                              -842150451

	ldi		$t0,#$100						; disable timer3 (time slice) interrupts
	stt		$t0,VIA_IER+VIA
	nop                   ; make sure disable has time for effect
	nop

 mTimeSliceEI                              -842150451

	ldi		$t0,#$1A000180			; enable timer3 interrupts after 26 cycles
	stt		$t0,VIA_IER+VIA

 mUnlockSemaphore                          1

	ldi		a0,#-1
	stt		a0,0

 mWaitForFocus                             -842150451

.WFF1@:
  mov   $t2,$a1
	
	ldi		$a0,#20
	ecall
bnez	$a1,.HasFocus@
	ldi   $a0,#26             ; FMTK_IO
	mov   $a1,$t2
	ldi   $a2,#9              ; peekchar function
	ecall
	ldi		$t3,#$14						; CTRL-T
	bne		$a0,$t3,.WFF2@
	; eat up the CTRL-T
	ldi		$a0,#26							; FMTK_IO
	mov   $a1,$t2
	ldi		$a2,#8							; getchar function
	ecall
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		$a0,#5            ; FMTK Sleep() function
	ldi		$a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:

0 compressable instructions
The top 1024 are:
Comp  Opcode  Count

number of bytes: 20780.000000
number of instructions: 5195
number of compressed instructions: 0
4.000000 bytes (32 bits) per instruction
Compression ratio: 0.000000%
Number of long branches: 0
