# Welcome to the FT64v8 core

## Overview
FT64v8 is a revision of the FT64 core with support for three different lengths of instructions. FT64v7 offers 16 bit compressed instructions and 48 bit extended instructions in addition to a 32 bit instruction size. The author desired to get the benefits of code dense 16 bit instructions.
FT64v8 is a superscalar core with the following features:
- many features are configurable
- 32 general purpose registers
- 32 vector registers of 63 elements
- 16/32/48 bit size instruction set
- 64 bit data width
- branch prediction with branch target buffer (BTB)
- return address prediction (RSB)
- register renaming
- out-of-order instruction execution
- 4 to 16 entry instruction queue (ROB)
- precise exception handling
- speculative loading (off by default)
- bus interface unit
- write buffering
- instruction (L1, L2) and data caches
- Functional Units (configurable):
	- one to three instruction decoders
	- one or two ALU's,
	- one flow control unit
	- zero to two floating point units
	- one memory unit (handles 3 loads one store)
	- one or two commit busses
- vector instructions
- SIMD instructions
- bus randomizer on exceptions

FT64v8 can issue up to eight instructions in a single cycle (2 alu, 1 flow control, 2 floating point, 3 memory) and is capable of committing up to three instructions in a single cycle. Fetch and queue are limited to two instructions per cycle however.
Currently in the works is a version that can fetch and queue four instructions at a time.

# History
FT64v8 is a work-in-progress beginning in December 2018. It is a significant revision of the v7 core. FT64 originated from RiSC-16 by Dr. Bruce Jacob. RiSC-16 evolved from the Little Computer (LC-896) developed by Peter Chen at the University of Michigan. See the comment in FT64.v. FT64 is the author's fourth attempt at a 64 bit ISA. Other attempts including Raptor64, FISA64, and DSD9. The author has tried to be innovative with this design borrowing ideas from a number of other processing cores.

# Software
There is an assembler and 'CC64' compiler for FT64. The assembler does not yet fully support all the instructions for the core.

# Status
Current focus is on getting the base integer instruction set working including the most common operations.
Floating point is largely untested.
There is an off by one error in the vector processing instructions. The core tries to process too many elements sometimes.
The RSB doesn't work very well, causing most returns to be multi-cycle operations instead of single cycle.
An attempt is being made to get the core to run a BIOS demo program. The core is able to run a small monitor program with some glitches still remaining. Work is being done getting a hex dowmloader working.

# Issues with the v7 Core
All the opcodes were used up at the root level and it was desirable to add additional instructions. As encoded in the v7 core unaligned memory access was not possible to generate. To be able to encode more instruction the size of the immediate field was reduce by a bit. As this affected many instructions and required a lot of changes the core was given a new version number.

# Configurability
FT64v8 is configurable to allow tuning of performance and core size. If desired the core may be used effectively as an OoO scalar processor by reducing the number of commit busses and functional units. This is how the author usually configures the core.
Functional units within the core may also be disabled for power management.

# Power Management
One recently added feature is the ability of the core to disable functional units to reduce power requirements.

# Security Features
a) When an exceptional condition occurs during instruction execution dummy data generated by a randomizer is propagated forward during speculative execution rather than the actual valid data.
b) Speculative loading of data is disabled by default. It may be enabled to increase performance at a cost of higher security risk. There is no load bypass on the write buffer.
c) Functionality of units at risk may be disabled. Branch prediction may be disabled. The data cache may be disabled.
These features help mitigate the risk of Meltdown and Spectre attacks.

# Instruction Set
The instruction set allows for up to three register read ports and a single register write port for a single instruction. The primary motivations for this being the desire for indexed addressing and branch-to-register. Three read ports are also handy for multiply-accumulate instructions. While the ISA probably does not offer leading edge performance, it's designed to be more programmer friendly in the author's opinion, while still offering good performance.
Excepting vector operations the design is limited to one memory access per instruction in a load / store architecture.
Instructions are executed independently of each other and there is no flags register.
Most recently added instructions were loads that bypass the data cache.
Most recently removed instructions were increment/decrement and branch.
A number of instructions support SIMD operation.
The base instruction set is 32 bit, but 16 bit compressed instruction forms are also supported. There are also 48 bit long forms of instructions. The 48 bit long form is handy for extended immediates and allows absolute addressing within a 29 bit address space.
Two bits (bits 6 and 7) of the instruction are used to determine the instruction size.
Many instructions directly support operations of less than a word in size including:
ADD/SUB - support 8,16,32, and 64 bit operations
LOADS/STORES - support 8,16,32, and 64 bit operations
Loading a 64 bit constant into a register may be done using only two instructions. LUI (load upper immediate) and ORI (or immediate).

  