                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; First 256 bytes are for integer register set
                        	; Second 256 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBsegs			EQU		$200		; segment register storage
                        	TCBepc			EQU		$280
                        	TCBStatus		EQU		$288
                        	TCBPriority	EQU		$289
                        	TCBContextSaved	EQU		$28A
                        	TCBAffinity	EQU		$28B
                        	TCBWaitMbx	EQU		$28C
                        	TCBStackBot	EQU		$290
                        	TCBMsgD1		EQU		$298
                        	TCBMsgD2		EQU		$2A0
                        	TCBMsgD3		EQU		$2A8
                        	TCBStartTime	EQU		$2B0
                        	TCBEndTime		EQU		$2B8
                        	TCBElapsedTime		EQU		$2C0
                        	TCBException	EQU	$2C8
                        	TCBNext			EQU		$2D0
                        	TCBPrev			EQU		$2D8
                        	TCBTimeout	EQU		$2E0
                        	IOF_NEXT		EQU		$2E8
                        	IOF_PREV		EQU		$2F0
                        	TCBName			EQU		$2F8
                        	TCBKbdHead	EQU		$300
                        	TCBKbdTail	EQU		$301
                        	TCBKbdBuf		EQU		$308
                        	; 328 end of keyboard buffer
                        	TCBResource	EQU		$328
                        	TCBVideoMem	EQU		$330
                        	TCBpVideo		EQU		$338
                        	TCBxra			EQU		$340
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_RUNNING	EQU		128
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_Busy	= 	0x02
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadCallno	=  0x1A
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	=0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMem		= 12
                        	
                        	CSR_REGSET	equ		$790
                        	SYS_MUTEX		equ		$FFDBFF00
                        	BIOS_MUTEX		equ		$FFDBFF08
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	MAX_TID		EQU		63
                        	MAX_MID		EQU		31
                        	MAX_ASID	EQU		31
                        	NR_TCB		EQU		32
                        	NR_MBX		EQU		256
                        	NR_MSG		EQU		2048
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		16
                        	PAGESZ		EQU		65536
                        	PAGES_PER_TASK	EQU		4096	; maximum number of pages per task
                        	PAGES_PER_MAP		EQU		4096
                        	OSPAGES		EQU		3			; pages of memory dedicated to OS
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_ReentCount		EQU		0x38		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x39
                        	DCB_hJob			EQU		0x40		; handle to associated job
                        	DCB_Mbx				EQU		0x48
                        	DCB_pSema			EQU		0x50		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x58		; reserved
                        	DCB_Resv2			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x68
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		v0,#-1
	sw		v0,adr
endm
                        	
                        	; Look at the asid register for task id
                        	macro mGetCurrentTid
	csrrw	$v0,#$181,$x0
;	csrrw	$v1,#$F10,$x0
;	and		$v1,$v1,#$FFFFFF80
;	and		$v0,$v0,#31
;	or		$v0,$v0,$v1
endm
                        	
                        	macro	mHasFocus
	ldi		$a0,#20
	ecall
endm
                        	
                        	macro mSleep(tm)
	ldi		$a0,#5
	ldi		$a1,#tm
	ecall
endm
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
	
	ldi		$a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		$a0,#5
	ldi		$a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list entry tid
                        	;------------------------------------------------------------------------------
                        	
                        	macro mPopTimeoutList
	sll		$t0,$v0,#LOG_TCBSZ		; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
	beqz	$t1,.noWait@
	mMbxRemoveTask							; remove task from mailbox list
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	stb		$v1,TCBStatus[$t0]
	ldw		$v1,TCBNext[$t0]			; get next task on timeout list
	stw		$v1,TimeoutList				; update list head
	ldi		$t1,#NR_TCB						; check valid handle
	bgeu	$v1,$t1,.done@
	ldi		$t1,#-1								;
	sll		$v1,$v1,#LOG_TCBSZ		; v1 = tid to pointer
	stw		$t1,TCBPrev[$v1]			; TimeoutList->prev = -1
.done@:
	ldi		$t1,#-1								; reset next and prev indexes
	stw		$t1,TCBNext[$t0]			; on popped task
	stw		$t1,TCBPrev[$t0]
endm
                        	
                        	
                        	macro mGetVideoPtr:
	
	csrrw	$v0,#$181,$x0
;	csrrw	$v1,#$F10,$x0
;	and		$v1,$v1,#$FFFFFF80
;	and		$v0,$v0,#31
;	or		$v0,$v0,$v1
sll		$v0,$v0,#LOG_TCBSZ
	ldo		$v0,TCBpVideo[$v0]
	ldi		$v0,#$FFD00000
endm
                        	
                        	macro mDispIRQLive
	ldo      $v0,$FFD00000+440
	add     	$v0,$v0,#1
	sto      $v0,$FFD00000+440
endm
                        	
                        	macro mLockSysMutex
	
	csrrw	$v0,#$181,$x0
;	csrrw	$v1,#$F10,$x0
;	and		$v1,$v1,#$FFFFFF80
;	and		$v0,$v0,#31
;	or		$v0,$v0,$v1
sll		$v0,$v0,#1
	or		$v0,$v0,#1
	ldi		$t0,#$FFDBFF00
.lock@:
	sto		$v0,[$t0]
	ldo		$v1,[$t0]
	bne		$v0,$v1,.lock@
endm
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/global.r5a",1
                        	.file "../fmtk/global.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	; 00000000	+-----------------------------------
                        	;						| Task Control Blocks (64 x 1kB)
                        	; 00010000	+-----------------------------------
                        	;						| Message Array (2048 x 32b)
                        	; 00020000	+-----------------------------------
                        	;						| Mailbox Array (256 x 32b)
                        	; 00022000	+-----------------------------------
                        	;						| Device Control Blocks (32 x 256b)
                        	; 00024000	+-----------------------------------
                        	
                        	msgs		EQU		$10000
                        	mbxs		EQU		$20000
                        	mbxs_end	EQU	$22000
                        	; The following must be at least 256 byte aligned
                        	DVF_Base		EQU		$22000
                        	DVF_Limit		EQU		$24000
                        	QNDX		EQU		$24304
                        	READYQ	EQU		$24308
                        	PIDMAP	EQU		$24310
                        	missed_ticks	equ		$24320
                        	TimeoutList		equ		$24328
                        	Tick		EQU		$24330
                        	SysSema	EQU		$24340
                        	FreeMsg	EQU		$24350
                        	RDYQ0		EQU		$24400
                        	RDYQ1		EQU		$24500
                        	RDYQ2		EQU		$24600
                        	RDYQ3		EQU		$24700
                        	CursorX		equ		$24800
                        	CursorY		equ		$24801
                        	DispAttr	equ		$24808
                        	IOFocusNdx		EQU		$24810
                        	IOFocusTbl		EQU		$24818
                        	SwitchIOFocus	EQU		$24820
                        	hKeybdMbx	equ		$24822
                        	_KeyState1	equ		$24824
                        	_KeyState2 equ		$24825
                        	_KeyLED			equ		$24826
                        	NPAGES	equ		$24828
                        	_randStream	equ		$24830
                        	
                        	SerRcvBuf		EQU		$25000
                        	SerXmitBuf	EQU		$25400
                        	SerHeadRcv	EQU		$25800
                        	SerTailRcv	EQU		$25804
                        	SerHeadXmit	EQU		$25808
                        	SerTailXmit	EQU		$2580C
                        	SerRcvXon		EQU		$25810
                        	SerRcvXoff	EQU		$25811
                        	
                        	
                        	
                        	
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	
                        	CTRLC				equ		$03
                        	BS					equ		$08
                        	LNFD				equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	DEL					equ		$7F
                        	LEDS				equ		$FFDC0600
                        	BUTTONS			equ		$FFDC0600
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        			; First 16kB is for TCB's
                        	INBUF				equ		$14100
                        	switchflag	equ		$14200
                        	milliseconds	equ		$14208
                        	
                        	
                        	.file "boot.r5a",32
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0000				; user mode exception
FFFC0000 2550006F		jmp		IRQRout
FFFC0004 00000000		org		$FFFC0040				; supervisor mode exception (not possible)
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 2150006F		jmp		IRQRout
FFFC0044 00000000		org		$FFFC0080				; hypervisor mode exception (not possible)
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 1D50006F		jmp		IRQRout
FFFC0084 00000000		org 	$FFFC00C0				; machine mode exception
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 1950006F		jmp		IRQRout
FFFC00C4 00000000		org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F		jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0100
                        	MachineStart:
FFFC0100 F1001673		csrrw	$s9,#$F10,$x0			; get hartid
FFFC0104 02067613		and		$s9,$s9,#$20
FFFC0108 00061863		bnez	$s9,.hart20
FFFC010C 1FFFC737		ldi		$sp,#$1FFFBFF8		; setup machine mode stack pointer
FFFC0110 FF870713
FFFC0114 00000663		bra		.hart00:
                        	.hart20:
FFFC0118 1FFF8737		ldi		$sp,#$1FFF7FF8
FFFC011C FF870713
                        	.hart00:
FFFC0120 FFFC0D37		ldi		$t0,#$FFFC0000
FFFC0124 000D0D13
FFFC0128 301D1073		csrrw $x0,#$301,$t0			; set tvec
FFFC012C 01D06D13		ldi		$t0,#$1D
FFFC0130 181D1073		csrrw	$x0,#$181,$t0			; set ASID
                        		; The dram needs a bit of time before it's ready for access. along with
                        		; the video screen which also needs some time. So the first thing done is
                        		; to delay for about 3 seconds.
FFFC0134 08061063		bnez	$s9,.skipInit
FFFC0138 FFDC0DB7		ldi		$t1,#VIA
FFFC013C 600D8D93
FFFC0140 0FF06D13		ldi		$t0,#$000000FF		; set via so we can see output on LEDs
FFFC0144 01ADA623		stt		$t0,VIA_DDRA[$t1]
FFFC0148 03938937		ldi		$a0,#60000000			; 3s in 50ns intervals
FFFC014C 70090913
FFFC0150 10300073		pfi
FFFC0154 035000EF		call	_MicroDelay
FFFC0158 370010EF		call	MMUInit					; initialize MMU for address space zero.
FFFC015C 51C020EF		call	FMTKInit
FFFC0160 7D1010EF		call	VideoInit
FFFC0164 5FD010EF		call	ViaInit
FFFC0168 049010EF		call	SerialInit
FFFC016C 0E4040EF		call	_KeybdInit
FFFC0170 70C010EF		call	PicInit
FFFC0174 580040EF		call	_PRNGInit
                        	
                        	;	call	_ramtest
FFFC0178 10300073		pfi
FFFC017C 00106913		ldi		$a0,#1
FFFC0180 000069B7		ldi		$a1,#24000
FFFC0184 DC098993
FFFC0188 FFFC0A37		ldi		$a2,#UserStart2
FFFC018C 228A0A13
FFFC0190 00006A93		ldi		$a3,#0					; run on processor #0
FFFC0194 00000073		ecall
FFFC0198 00106913		ldi		$a0,#1					; start TinyBasic
FFFC019C 000089B7		ldi		$a1,#32000
FFFC01A0 D0098993
FFFC01A4 FFFC5A37		ldi		$a2,#CSTART
FFFC01A8 630A0A13
FFFC01AC 00106A93		ldi		$a3,#1					; run on processor #1
FFFC01B0 00000073		ecall
                        	.skipInit:
                        	; Idle (system) task begins here, simply wait for interrupt.
                        	.0001:
FFFC01B4 F1001673		csrrw	$s9,#$F10,$x0			; get hartid
FFFC01B8 02067613		and		$s9,$s9,#$20
FFFC01BC 02061863		bnez	$s9,.skip1
FFFC01C0 FFD00637		ldo		$a0,$FFD00000
FFFC01C4 00060613
FFFC01C8 00060633
FFFC01CC 00063903
FFFC01D0 00010637		add		$a0,$a0,#$10001
FFFC01D4 00160613
FFFC01D8 01260933
FFFC01DC FFD00637		sto		$a0,$FFD00000
FFFC01E0 00060613
FFFC01E4 00060633
FFFC01E8 01263023
                        	.skip1:
FFFC01EC FFD00637		ldo		$a0,$FFD00008
FFFC01F0 00860613
FFFC01F4 00060633
FFFC01F8 00063903
FFFC01FC 00010637		add		$a0,$a0,#$10001
FFFC0200 00160613
FFFC0204 01260933
FFFC0208 FFD00637		sto		$a0,$FFD00008
FFFC020C 00860613
FFFC0210 00060633
FFFC0214 01263023
FFFC0218 00000263		bra		.skip2
                        	.skip2:
FFFC021C 10300073		pfi
FFFC0220 10100073		wfi
FFFC0224 F80008E3		bra		.0001
                        	
                        	UserStart2:
FFFC0228 F1001673		csrrw	$s9,#$F10,$x0			; get hartid
FFFC022C 02067613		and		$s9,$s9,#$20
FFFC0230 00061463		bnez	$s9,.skip1
FFFC0234 24D070EF		call	_SpriteDemo
                        	.skip1:
FFFC0238 03938937		ldi		$a0,#60000000				; 3s in 50ns intervals
FFFC023C 70090913
FFFC0240 10300073		pfi
FFFC0244 744000EF		call	_MicroDelay
FFFC0248 40006913		ldi		$a0,#$400						; clear screen
FFFC024C 00000073		ecall
FFFC0250 10300073		pfi
FFFC0254 40106913		ldi		$a0,#$401						; home cursor
FFFC0258 00000073		ecall
FFFC025C 00E06913		ldi		$a0,#14							; Get current tid
FFFC0260 00000073		ecall
FFFC0264 10300073		pfi
FFFC0268 0008E9B3		mov		$a1,$v1
FFFC026C 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC0270 00000073		ecall
                        	;	ldi		$sp,#$1FFF7FF8			; setup user mode stack pointer
                        	;	ldi		$sp,#$AFFFFFFC
FFFC0274 00406D13		ldi		$t0,#$04						; turn on the LED
FFFC0278 FFDC0637		stt		$t0,VIA+VIA_PARAW
FFFC027C 63C60613
FFFC0280 00060633
FFFC0284 01A62023
FFFC0288 01006E13		ldi		$t2,#16							; send an XON just in case
                        	;	ldi		$a3,#XON
                        	;.0004:
                        	;	call	SerialPutChar
                        	;	sub		$t2,$t2,#1
                        	;	bnez	$t2,.0004
                        	.0002:
                        	;	ldi		$a0,#msgStart				; spit out a startup message
                        	;	ldi		$t0,#$FFD00000
                        	;	ldo		$t1,datAttr
                        	.0005:
                        	;	ldbu	$a1,[$a0]
                        	;	add		$a0,$a0,#1
                        	;	beqz	$a1,.0004
                        	;	or		$a1,$a1,$t1
                        	;	sto		$a1,[$t0]
                        	;	add		$t0,$t0,#8
                        	;	bra		.0005
                        	.0004:
FFFC028C 10300073		pfi
FFFC0290 40306913		ldi		$a0,#$403						; video putstring()
FFFC0294 FFFC19B7		ldi		$a1,#msgStart
FFFC0298 B7C98993
FFFC029C 00000073		ecall
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		ecall
FFFC02A0 10300073		pfi
FFFC02A4 00F06913		ldi		$a0,#15							; dump ready list
FFFC02A8 00000073		ecall
FFFC02AC 10000C63		bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
FFFC02B0 14D010EF		call	SerialPeekChar
FFFC02B4 FE084EE3		blt		$v0,$x0,.0003
FFFC02B8 00086933		mov		$a0,$v0
FFFC02BC 10300073		pfi
FFFC02C0 201010EF		call	SerialPutChar
FFFC02C4 FE0006E3		bra		.0003
                        	
                        		align	8                        	
                        	datAttr:
FFFC02C8 001F0000		dco		$FFFF001F0000
FFFC02CC 0000FFFF
                        	
                        		align	8                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	IdleTask:
FFFC02D0 00000063		bra		IdleTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		v0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	
                        	Getch:
FFFC02D4 FE870713		sub		$sp,$sp,#24
FFFC02D8 00173023		sto		$ra,[$sp]
FFFC02DC 01273423		sto		$a0,8[$sp]
FFFC02E0 01373823		sto		$a1,16[$sp]
                        	;	mWaitForFocus
                        	;	call	SerialGetChar
FFFC02E4 10300073		pfi
FFFC02E8 00006913		ldi		$a0,#0					; don't block
FFFC02EC 504040EF		call	_DBGGetKey
FFFC02F0 00073083		ldo		$ra,[$sp]
FFFC02F4 00873903		ldo		$a0,8[$sp]
FFFC02F8 01073983		ldo		$a1,16[$sp]
FFFC02FC 01870713		add		$sp,$sp,#24
FFFC0300 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	_putch:
                        	Putch:
FFFC0304 FA870713		sub		$sp,$sp,#88
FFFC0308 00173023		sto		$ra,[$sp]
FFFC030C 01073423		sto		$v0,8[$sp]
FFFC0310 01573823		sto		$a3,16[$sp]
FFFC0314 01173C23		sto		$v1,24[$sp]
FFFC0318 03373023		sto		$a1,32[$sp]
FFFC031C 03A73423		sto		$t0,40[$sp]
FFFC0320 03B73823		sto		$t1,48[$sp]
FFFC0324 03C73C23		sto		$t2,56[$sp]
FFFC0328 05D73023		sto		$t3,64[$sp]
FFFC032C 05E73423		sto		$t4,72[$sp]
FFFC0330 05F73823		sto		$t5,80[$sp]
FFFC0334 00096AB3		mov		$a3,$a0
                        	;	call	SerialPutChar
                        	;	call	VideoPutChar
FFFC0338 10300073		pfi
FFFC033C 40206913		ldi		$a0,#$402
FFFC0340 00000073		ecall
                        	;	ldi		$a1,#5							; serial port = 5
                        	;	call	fputc
                        	;	ldi		$a1,#2							; video = 2
                        	;	call	fputc
FFFC0344 00073083		ldo		$ra,[$sp]
FFFC0348 00873803		ldo		$v0,8[$sp]
FFFC034C 01073A83		ldo		$a3,16[$sp]
FFFC0350 01873883		ldo		$v1,24[$sp]
FFFC0354 02073983		ldo		$a1,32[$sp]
FFFC0358 02873D03		ldo		$t0,40[$sp]
FFFC035C 03073D83		ldo		$t1,48[$sp]
FFFC0360 03873E03		ldo		$t2,56[$sp]
FFFC0364 04073E83		ldo		$t3,64[$sp]
FFFC0368 04873F03		ldo		$t4,72[$sp]
FFFC036C 05073F83		ldo		$t5,80[$sp]
FFFC0370 05870713		add		$sp,$sp,#88
FFFC0374 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	fputc:
FFFC0378 FD070713		sub		$sp,$sp,#48
FFFC037C 00173023		sto		$ra,[$sp]
FFFC0380 01073423		sto		$v0,8[$sp]
FFFC0384 01273823		sto		$a0,16[$sp]
FFFC0388 01173C23		sto		$v1,24[$sp]
FFFC038C 03373023		sto		$a1,32[$sp]
FFFC0390 03473423		sto		$a2,40[$sp]
                        	;	mWaitForFocus
FFFC0394 10300073		pfi
FFFC0398 01A06913		ldi		$a0,#26							; FMTK_IO
FFFC039C 00D06A13		ldi		$a2,#13							; putchar function
FFFC03A0 00000073		ecall
FFFC03A4 00073083		ldo		$ra,[$sp]
FFFC03A8 00873803		ldo		$v0,8[$sp]
FFFC03AC 01073903		ldo		$a0,16[$sp]
FFFC03B0 01873883		ldo		$v1,24[$sp]
FFFC03B4 02073983		ldo		$a1,32[$sp]
FFFC03B8 02873A03		ldo		$a2,40[$sp]
FFFC03BC 03070713		add		$sp,$sp,#48
FFFC03C0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC03C4 00A06913			ldi		$a0,#10
FFFC03C8 00606A13			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	Monitor:
FFFC03CC B0000737		ldi		$sp,#$AFFFFFFC
FFFC03D0 FFC70713
FFFC03D4 10300073		pfi
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFC03D8 00006213		ldi		$s1,#0					; s1 = input pointer
FFFC03DC 00D06913		ldi		$a0,#CR
FFFC03E0 F25FF0EF		call	Putch
FFFC03E4 10300073		pfi
FFFC03E8 00A06913		ldi		$a0,#LNFD
FFFC03EC F19FF0EF		call	Putch
FFFC03F0 03E06913		ldi		$a0,#'>'
FFFC03F4 F11FF0EF		call	Putch
                        	.0001:
FFFC03F8 10300073		pfi
FFFC03FC ED9FF0EF		call	Getch						; wait until character pressed
FFFC0400 FE084CE3		blt		$v0,$x0,.0001
FFFC0404 00A84D13		xor		$t0,$v0,#LNFD			; ignore line feed
FFFC0408 100D0663		beq		$t0,$x0,.procLine
FFFC040C 00D84D13		xor		$t0,$v0,#CR
FFFC0410 100D0263		beq		$t0,$x0,.procLine
FFFC0414 00884D13		xor		$t0,$v0,#BS
FFFC0418 080D0863		beq		$t0,$x0,.doBackspace
FFFC041C 10300073		pfi
FFFC0420 07F84D13		xor		$t0,$v0,#DEL
FFFC0424 020D0263		beq		$t0,$x0,.doDelete
FFFC0428 00014637		sb		$v0,INBUF[$s1]
FFFC042C 10060613
FFFC0430 00460633
FFFC0434 01060023
FFFC0438 00120213		add		$s1,$s1,#1
FFFC043C 00086933		mov		$a0,$v0
FFFC0440 EC5FF0EF		call	Putch
FFFC0444 FA000AE3		bra		.0001
                        	.doDelete:
FFFC0448 10300073		pfi
FFFC044C 000262B3		mov		$s2,$s1
FFFC0450 00128293		add		$s2,$s2,#1
                        	.0002:
FFFC0454 10300073		pfi
FFFC0458 00014637		lb		$t0,INBUF[$s2]
FFFC045C 10060613
FFFC0460 00560633
FFFC0464 00060D03
FFFC0468 00014637		sb		$t0,INBUF-1[$s2]
FFFC046C 0FF60613
FFFC0470 00560633
FFFC0474 01A60023
FFFC0478 00128293		add		$s2,$s2,#1
FFFC047C 00014637		add		$t0,$s2,#INBUF
FFFC0480 10060613
FFFC0484 00560D33
FFFC0488 00014637		slt		$t0,$t0,#INBUF+$7F
FFFC048C 17F60613
FFFC0490 FC0D12E3		bne		$t0,$x0,.0002
FFFC0494 00014637		sb		$x0,INBUF[$s2]
FFFC0498 10060613
FFFC049C 00560633
FFFC04A0 00060023
FFFC04A4 F4000AE3		bra		.0001
                        	.doBackspace:
FFFC04A8 10300073		pfi
FFFC04AC F40206E3		beq		$s1,$x0,.0001		; can't backspace anymore
FFFC04B0 00086933		mov		$a0,$v0					; show the backspace
FFFC04B4 E51FF0EF		call	Putch
FFFC04B8 FFF20213		sub		$s1,$s1,#1
FFFC04BC 000262B3		mov		$s2,$s1
                        	.0003:
FFFC04C0 10300073		pfi
FFFC04C4 00014637		lb		$t0,INBUF+1[$s2]
FFFC04C8 10160613
FFFC04CC 00560633
FFFC04D0 00060D03
FFFC04D4 00014637		sb		$t0,INBUF[$s2]
FFFC04D8 10060613
FFFC04DC 00560633
FFFC04E0 01A60023
FFFC04E4 00128293		add		$s2,$s2,#1
FFFC04E8 00014637		add		$t0,$s2,#INBUF
FFFC04EC 10060613
FFFC04F0 00560D33
FFFC04F4 00014637		slt		$t0,$t0,#INBUF+$7F
FFFC04F8 17F60613
FFFC04FC FC0D12E3		bne		$t0,$x0,.0003
FFFC0500 00014637		sb		$x0,INBUF[$s2]
FFFC0504 10060613
FFFC0508 00560633
FFFC050C 00060023
FFFC0510 EE0004E3		bra		.0001
                        	.procLine:
FFFC0514 10300073		pfi
FFFC0518 00014637		sb		$x0,INBUF[$s1]
FFFC051C 10060613
FFFC0520 00460633
FFFC0524 00060023
FFFC0528 00006213		ldi		$s1,#0
                        	.skip:
FFFC052C 10300073		pfi
FFFC0530 00014637		lb		$t0,INBUF[$s1]
FFFC0534 10060613
FFFC0538 00460633
FFFC053C 00060D03
FFFC0540 140D0263		beq		$t0,$x0,.0005
FFFC0544 03ED4D93		xor		$t1,$t0,#'>'
FFFC0548 000D9863		bne		$t1,$x0,.0004
                        	.skip2:
FFFC054C 10300073		pfi
FFFC0550 00120213		add		$s1,$s1,#1
FFFC0554 FC000CE3		bra		.skip
                        	.0004:
FFFC0558 10300073		pfi
FFFC055C 020D4D93		xor		$t1,$t0,#' '
FFFC0560 FE0D86E3		beq		$t1,$x0,.skip2
FFFC0564 009D4D93		xor		$t1,$t0,#'\t'
FFFC0568 FE0D82E3		beq		$t1,$x0,.skip2
FFFC056C 04DD4D93		xor		$t1,$t0,#'M'
FFFC0570 100D8C63		beq		$t1,$x0,doMem
FFFC0574 10300073		pfi
FFFC0578 04206D93		ldi		$t1,#'B'
FFFC057C 05BD1C63		bne		$t0,$t1,.0006
FFFC0580 00106913		ldi		$a0,#1					; Start task
FFFC0584 000089B7		ldi		$a1,#32000			; 32 kB
FFFC0588 D0098993
FFFC058C FFFC5A37		ldi		$a2,#CSTART			; start address
FFFC0590 630A0A13
FFFC0594 00106A93		ldi		$a3,#1
FFFC0598 00000073		ecall
FFFC059C 10300073		pfi
FFFC05A0 0008E233		mov		$s1,$v1					; save v1
FFFC05A4 FFFC1937		ldi		$a0,#msgCRLF
FFFC05A8 C4E90913
FFFC05AC 3A4000EF		call	PutString
FFFC05B0 10300073		pfi
FFFC05B4 00026933		mov		$a0,$s1					; get back v1
FFFC05B8 328000EF		call	PutHexByte
FFFC05BC FFFC1937		ldi		$a0,#msgTaskStart
FFFC05C0 C4090913
FFFC05C4 10300073		pfi
FFFC05C8 388000EF		call	PutString
FFFC05CC 3B4030EF		call  DumpReadyList
                        		;ldi		$a0,#5					; Reschedule task
                        		;ldi		$a1,#1					; sleep(0)
                        		;ecall
FFFC05D0 DFDFF06F		jmp		Monitor
                        	.0006:
FFFC05D4 10300073		pfi
FFFC05D8 04406D93		ldi		$t1,#'D'
FFFC05DC 03BD1863		bne		$t0,$t1,.0007
FFFC05E0 00014637		lb		$t0,INBUF+1[$s1]
FFFC05E4 10160613
FFFC05E8 00460633
FFFC05EC 00060D03
FFFC05F0 05406D93		ldi		$t1,#'T'
FFFC05F4 01BD1663		bne		$t0,$t1,.noT
FFFC05F8 454030EF		call	DumpTimeoutList
FFFC05FC DD1FF06F		jmp		Monitor
                        	.noT:
FFFC0600 10300073		pfi
FFFC0604 37C030EF		call 	DumpReadyList
                        		;ldi		$a0,#15
                        		;ecall
FFFC0608 DC5FF06F		jmp		Monitor
                        	.0007:
FFFC060C 10300073		pfi
FFFC0610 04506D93		ldi		$t1,#'E'
FFFC0614 01BD1463		bne		$t0,$t1,.0008
FFFC0618 1140006F		jmp		EditMem
                        	.0008:
FFFC061C 10300073		pfi
FFFC0620 04606D93		ldi		$t1,#'F'
FFFC0624 01BD1463		bne		$t0,$t1,.0009
FFFC0628 1240006F		jmp		FillMem
                        	.0009:
FFFC062C 10300073		pfi
FFFC0630 05306D93		ldi		$t1,#'S'
FFFC0634 01BD1A63		bne		$t0,$t1,.0010
FFFC0638 00506913		ldi		$a0,#5					; sleep(0)
FFFC063C 00106993		ldi		$a1,#1
FFFC0640 00000073		ecall
FFFC0644 D89FF06F		jmp		Monitor
                        	.0010:
FFFC0648 10300073		pfi
FFFC064C 04B06D93		ldi		$t1,#'K'
FFFC0650 01BD1C63		bne		$t0,$t1,.0011
FFFC0654 168000EF		call	GetHexNum
FFFC0658 00306913		ldi		$a0,#3					; kill task
FFFC065C 000869B3		mov		$a1,$v0					; a0 = pid
FFFC0660 00000073		ecall
FFFC0664 D69FF06F		jmp		Monitor
                        	.0011:
FFFC0668 10300073		pfi
FFFC066C 03F06D93		ldi		$t1,#'?'
FFFC0670 01BD1A63		bne		$t0,$t1,.0012
FFFC0674 FFFC1937		ldi		$a0,#msgMonHelp
FFFC0678 B9690913
FFFC067C 2D4000EF		call	PutString
FFFC0680 D4DFF06F		jmp		Monitor
                        	.0012:
                        	.0005:
FFFC0684 D40004E3		bra		Monitor
                        	
                        	doMem:
FFFC0688 FF870713		sub		$sp,$sp,#8
FFFC068C 00120213		add		$s1,$s1,#1
FFFC0690 00473023		sto		$s1,[$sp]
FFFC0694 10300073		pfi
FFFC0698 00D06913		ldi		$a0,#CR
FFFC069C C69FF0EF		call	Putch
FFFC06A0 00014937		ldi		$a0,INBUF
FFFC06A4 10090913
FFFC06A8 10300073		pfi
FFFC06AC 2A4000EF		call	PutString
FFFC06B0 00073203		ldo		$s1,[$sp]
FFFC06B4 00870713		add		$sp,$sp,#8
FFFC06B8 10300073		pfi
FFFC06BC 100000EF		call	GetHexNum
FFFC06C0 00086333		mov		$s3,$v0
FFFC06C4 00120213		add		$s1,$s1,#1
FFFC06C8 10300073		pfi
FFFC06CC 0F0000EF		call	GetHexNum
FFFC06D0 006803B3		add		$s4,$v0,$s3
                        	.loop2:
FFFC06D4 10300073		pfi
FFFC06D8 BFDFF0EF		call	Getch						; check for ctrl-c
FFFC06DC 00384813		xor		$v0,$v0,#3
FFFC06E0 CE0806E3		beq		$v0,$x0,Monitor
FFFC06E4 00D06913		ldi		$a0,#CR
FFFC06E8 C1DFF0EF		call	Putch
FFFC06EC 00036933		mov		$a0,$s3
FFFC06F0 10300073		pfi
FFFC06F4 1A4000EF		call	PutHexWord
FFFC06F8 03A06913		ldi		$a0,#':'
FFFC06FC C09FF0EF		call	Putch
FFFC0700 00706293		ldi		$s2,#7
                        	.loop:
FFFC0704 02006913		ldi		$a0,#' '
FFFC0708 BFDFF0EF		call	Putch
FFFC070C 00030903		ldb		$a0,[$s3]
FFFC0710 10300073		pfi
FFFC0714 1CC000EF		call	PutHexByte
FFFC0718 00130313		add		$s3,$s3,#1
FFFC071C FFF28293		sub		$s2,$s2,#1
FFFC0720 FE02D2E3		bge		$s2,$x0,.loop
FFFC0724 FA7368E3		bltu	$s3,$s4,.loop2
FFFC0728 CA0002E3		bra		Monitor		
                        	
                        	EditMem:
FFFC072C 10300073		pfi
FFFC0730 08C000EF		call	GetHexNum			; get address to edit
FFFC0734 00086333		mov		$s3,$v0
FFFC0738 00120213		add		$s1,$s1,#1
FFFC073C 10300073		pfi
FFFC0740 07C000EF		call	GetHexNum			; get value to set
FFFC0744 00680023		stb		$s3,[$v0]			; update mem
FFFC0748 C85FF06F		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	FillMem:
FFFC074C 10300073		pfi
FFFC0750 06C000EF		call	GetHexNum			; get address
FFFC0754 00086333		mov		$s3,$v0
FFFC0758 00120213		add		$s1,$s1,#1
FFFC075C 10300073		pfi
FFFC0760 05C000EF		call	GetHexNum			; get length
FFFC0764 000863B3		mov		$s4,$v0
FFFC0768 00120213		add		$s1,$s1,#1
FFFC076C 10300073		pfi
FFFC0770 04C000EF		call	GetHexNum			; get byte to use
                        	.0001:
FFFC0774 01030023		stb		$v0,[$s3]
FFFC0778 FFF38393		sub		$s4,$s4,#1
FFFC077C 10300073		pfi
FFFC0780 FE704AE3		bgt		$s4,$x0,.0001
FFFC0784 C49FF06F		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC0788 10300073		pfi
FFFC078C 00014637		ldb		$t0,INBUF[$s1]
FFFC0790 10060613
FFFC0794 00460633
FFFC0798 00060D03
FFFC079C 020D4D93		xor		$t1,$t0,#' '
FFFC07A0 000D8863		beq		$t1,$x0,.skip1
FFFC07A4 009D4D93		xor		$t1,$t0,#'\t'
FFFC07A8 000D8463		beq		$t1,$x0,.skip1
FFFC07AC 00008067		ret
                        	.skip1:
FFFC07B0 00120213		add		$s1,$s1,#1
FFFC07B4 10300073		pfi
FFFC07B8 FC0008E3		bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	GetHexNum:
FFFC07BC 00006813		ldi		$v0,#0							; v0 = num
FFFC07C0 FF870713		sub		$sp,$sp,#8
FFFC07C4 00173023		sto		$ra,[$sp]
FFFC07C8 10300073		pfi
FFFC07CC FBDFF0EF		call	SkipSpaces
                        	.next:
FFFC07D0 00014637		ldb		$t0,INBUF[$s1]
FFFC07D4 10060613
FFFC07D8 00460633
FFFC07DC 00060D03
FFFC07E0 03006E13		ldi		$t2,#'0'
FFFC07E4 03CD4863		blt		$t0,$t2,.0001
FFFC07E8 03A06E13		ldi		$t2,#'9'+1
FFFC07EC 07CD4863		blt		$t0,$t2,.isDigit
FFFC07F0 10300073		pfi
FFFC07F4 04106E13		ldi		$t2,#'A'
FFFC07F8 01CD4E63		blt		$t0,$t2,.0001
FFFC07FC 04706E13		ldi		$t2,#'F'+1
FFFC0800 03CD4263		blt		$t0,$t2,.isHexUpper
FFFC0804 06106E13		ldi		$t2,#'a'
FFFC0808 01CD4663		blt		$t0,$t2,.0001
FFFC080C 06706E13		ldi		$t2,#'f'+1
FFFC0810 03CD4863		blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC0814 10300073		pfi
FFFC0818 00073083		ldo		$ra,[$sp]
FFFC081C 00870713		add		$sp,$sp,#8
FFFC0820 00008067		ret
                        	.isHexUpper:
FFFC0824 10300073		pfi
FFFC0828 00481813		sll		$v0,$v0,#4
FFFC082C FBFD0D13		sub		$t0,$t0,#'A'
FFFC0830 00AD0D13		add		$t0,$t0,#10
FFFC0834 01A86833		or		$v0,$v0,$t0
FFFC0838 00120213		add		$s1,$s1,#1
FFFC083C F8000AE3		bra		.next
                        	.isHexLower:
FFFC0840 10300073		pfi
FFFC0844 00481813		sll		$v0,$v0,#4
FFFC0848 F9FD0D13		sub		$t0,$t0,#'a'
FFFC084C 00AD0D13		add		$t0,$t0,#10
FFFC0850 01A86833		or		$v0,$v0,$t0
FFFC0854 00120213		add		$s1,$s1,#1
FFFC0858 F6000CE3		bra		.next
                        	.isDigit:
FFFC085C 10300073		pfi
FFFC0860 00481813		sll		$v0,$v0,#4
FFFC0864 FD0D0D13		sub		$t0,$t0,#'0'
FFFC0868 01A86833		or		$v0,$v0,$t0
FFFC086C 00120213		add		$s1,$s1,#1
FFFC0870 F60000E3		bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	_PutHexDword:
                        	PutHexDword:
FFFC0874 FF070713		sub		$sp,$sp,#16
FFFC0878 00173023		sto		$ra,[$sp]
FFFC087C 01273423		sto		$a0,8[$sp]
FFFC0880 10300073		pfi
FFFC0884 00095913		srl		$a0,$a0,#32
FFFC0888 010000EF		call	PutHexWord
FFFC088C 00073083		ldo		$ra,[$sp]
FFFC0890 00873903		ldo		$a0,8[$sp]
FFFC0894 01070713		add		$sp,$sp,#16	; fall through to PutHexWord
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	_PutHexWord:
                        	PutHexWord:
FFFC0898 FF070713		sub		$sp,$sp,#16
FFFC089C 00173023		sto		$ra,[$sp]
FFFC08A0 01273423		sto		$a0,8[$sp]
FFFC08A4 10300073		pfi
FFFC08A8 01095913		srl		$a0,$a0,#16
FFFC08AC 010000EF		call	PutHexHalf
FFFC08B0 00073083		ldo		$ra,[$sp]
FFFC08B4 00873903		ldo		$a0,8[$sp]
FFFC08B8 01070713		add		$sp,$sp,#16	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	_PutHexHalf:
                        	PutHexHalf:
FFFC08BC FF070713		sub		$sp,$sp,#16
FFFC08C0 00173023		sto		$ra,[$sp]
FFFC08C4 01273423		sto		$a0,8[$sp]
FFFC08C8 10300073		pfi
FFFC08CC 00895913		srl		$a0,$a0,#8
FFFC08D0 010000EF		call	PutHexByte
FFFC08D4 00073083		ldo		$ra,[$sp]
FFFC08D8 00873903		ldo		$a0,8[$sp]		
FFFC08DC 01070713		add		$sp,$sp,#16	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	_PutHexByte:
                        	PutHexByte:
FFFC08E0 FF070713		sub		$sp,$sp,#16
FFFC08E4 00173023		sto		$ra,[$sp]
FFFC08E8 01273423		sto		$a0,8[$sp]
FFFC08EC 10300073		pfi
FFFC08F0 00495913		srl		$a0,$a0,#4		; put the high order nybble first
FFFC08F4 010000EF		call	PutHexNybble
FFFC08F8 00073083		ldo		$ra,[$sp]
FFFC08FC 00873903		ldo		$a0,8[$sp]
FFFC0900 01070713		add		$sp,$sp,#16		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	_PutHexNybble:
                        	PutHexNybble:
FFFC0904 FF070713		sub		$sp,$sp,#16
FFFC0908 00173023		sto		$ra,[$sp]
FFFC090C 01273423		sto		$a0,8[$sp]
FFFC0910 10300073		pfi
FFFC0914 00F97913		and		$a0,$a0,#15		; strip off high order bits
FFFC0918 00A06D13		ldi		$t0,#10
FFFC091C 10300073		pfi
FFFC0920 01A94A63		blt		$a0,$t0,.lt10
FFFC0924 FF690913		sub		$a0,$a0,#10
FFFC0928 04190913		add		$a0,$a0,#'A'
FFFC092C 9D9FF0EF		call	Putch
FFFC0930 00000863		bra		.0001
                        	.lt10:
FFFC0934 10300073		pfi
FFFC0938 03090913		add		$a0,$a0,#'0'
FFFC093C 9C9FF0EF		call	Putch
                        	.0001:
FFFC0940 00073083		ldo		$ra,[$sp]
FFFC0944 00873903		ldo		$a0,8[$sp]
FFFC0948 01070713		add		$sp,$sp,#16
FFFC094C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to output device. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	
                        	_PutString:
                        	PutString:
FFFC0950 FF070713		sub		$sp,$sp,#16				; save link register
FFFC0954 00173023		sto		$ra,[$sp]
FFFC0958 01273423		sto		$a0,8[$sp]				; and argument
FFFC095C 00096DB3		mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0960 000DC903		ldbu	$a0,[$t1]
FFFC0964 001D8D93		add		$t1,$t1,#1				; advance pointer to next byte
FFFC0968 00090863		beqz	$a0,.done			; branch if done
FFFC096C 10300073		pfi
FFFC0970 995FF0EF		call	Putch							; output character
FFFC0974 FE0006E3		bra		.0001
                        	.done:
FFFC0978 00073083		ldo		$ra,[$sp]					; restore return address
FFFC097C 00873903		ldo		$a0,8[$sp]				; and argument
FFFC0980 01070713		add		$sp,$sp,#16
FFFC0984 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; MicroDelay - delay for a few clock ticks
                        	;
                        	; Parameters:
                        	;		a0 = wait in ticks (50 ns intervals)
                        	;------------------------------------------------------------------------------
                        	
                        	_MicroDelay:
FFFC0988 C0001EF3		csrrw	$t3,#$C00,$x0
                        	.0001:
FFFC098C C0001F73		csrrw	$t4,#$C00,$x0
FFFC0990 41DF0F33		sub		$t4,$t4,$t3
FFFC0994 011F5F93		srl		$t5,$t4,#17
FFFC0998 FFDC0637		stt		$t5,VIA+VIA_PARAW
FFFC099C 63C60613
FFFC09A0 00060633
FFFC09A4 01F62023
FFFC09A8 10300073		pfi
FFFC09AC 012F2F33		slt		$t4,$t4,$a0
FFFC09B0 FC0F1EE3		bnez	$t4,.0001
FFFC09B4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	DumpMemmap:
FFFC09B8 FE870713		sub			$sp,$sp,#24
FFFC09BC 00173023		sto			$ra,[$sp]
FFFC09C0 01073823		sto			$v0,16[$sp]
FFFC09C4 10300073		pfi
                        		;mGetCurrentTid
FFFC09C8 00096833		mov			$v0,$a0
FFFC09CC 01081D93		sll			$t1,$v0,#16
                        	.again:
FFFC09D0 10300073		pfi
FFFC09D4 000DE933		mov			$a0,$t1
FFFC09D8 01B73423		sto			$t1,8[$sp]
FFFC09DC EBDFF0EF		call		PutHexWord
FFFC09E0 02006913		ldi			$a0,#' '
FFFC09E4 921FF0EF		call		Putch
FFFC09E8 03B0090D		mvmap		$a0,$x0,$t1
FFFC09EC ED1FF0EF		call		PutHexHalf
FFFC09F0 00D06913		ldi			$a0,#CR
FFFC09F4 10300073		pfi
FFFC09F8 90DFF0EF		call		Putch
FFFC09FC 00A06913		ldi			$a0,#LNFD
FFFC0A00 905FF0EF		call		Putch
FFFC0A04 10300073		pfi
FFFC0A08 00873D83		ldo			$t1,8[$sp]
FFFC0A0C 001D8D93		add			$t1,$t1,#1
FFFC0A10 00FDFD13		and			$t0,$t1,#$F
FFFC0A14 FA0D1EE3		bnez		$t0,.again
FFFC0A18 00001637		or			$t1,$t1,#$FFF
FFFC0A1C FFF60613
FFFC0A20 01B66DB3
FFFC0A24 10300073		pfi
FFFC0A28 03B0090D		mvmap		$a0,$x0,$t1
FFFC0A2C E91FF0EF		call		PutHexHalf
FFFC0A30 00D06913		ldi			$a0,#CR
FFFC0A34 8D1FF0EF		call		Putch
FFFC0A38 00A06913		ldi			$a0,#LNFD
FFFC0A3C 10300073		pfi
FFFC0A40 8C5FF0EF		call		Putch
FFFC0A44 00073083		ldo			$ra,[$sp]
FFFC0A48 01073803		ldo			$v0,16[$sp]
FFFC0A4C 01870713		add			$sp,$sp,#24
FFFC0A50 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;------------------------------------------------------------------------------
                        	.file "boot.r5a",815
                        		code
                        		align	4                        	
                        	IRQRout:
FFFC0A54 790FED73		csrrs	$t0,#CSR_REGSET,#$1F	; get regset,  ensure current regset is selected for all
FFFC0A58 005D5D13		srl		$t0,$t0,#5
FFFC0A5C 003D7D13		and		$t0,$t0,#3
FFFC0A60 00AD1D13		sll		$t0,$t0,#10				; 1k stack area
FFFC0A64 20000737		ldi		$sp,#$20000000-8	; setup machine mode stack pointer (top of ram)
FFFC0A68 FF870713
FFFC0A6C 41A70733		sub		$sp,$sp,$t0				; set stack pointer for register set
FFFC0A70 34201D73		csrrw	$t0,#$342,$x0			; get cause code
FFFC0A74 000D4C63		blt		$t0,$x0,.isIRQ		; irq or ecall?
FFFC0A78 00806D93		ldi		$t1,#8
FFFC0A7C 0DBD6263		bltu	$t0,$t1,.cause0to7
FFFC0A80 00B06D93		ldi		$t1,#11
FFFC0A84 0FADEA63		bgtu	$t0,$t1,.cause12plus
FFFC0A88 0100206F		jmp		OSCALL						; goto operating system call dispatcher
                        	.isIRQ:
FFFC0A8C FFD00637		ldo		$v0,$FFD00000+432	; Display IRQ live indicator
FFFC0A90 1B060613
FFFC0A94 00060633
FFFC0A98 00063803
FFFC0A9C 00010637		add		$v0,$v0,#$10001
FFFC0AA0 00160613
FFFC0AA4 01060833
FFFC0AA8 FFD00637		sto		$v0,$FFD00000+432
FFFC0AAC 1B060613
FFFC0AB0 00060633
FFFC0AB4 01063023
FFFC0AB8 792168F3		csrrs	$v1,#$792,#2			; check and set interrupt semaphore
FFFC0ABC 0028F893		and		$v1,$v1,#2
FFFC0AC0 00088463		beqz	$v1,.doIRQ
FFFC0AC4 10000073		eret
                        	.doIRQ:
                        		; See if the interrupted instruction was a pfi. If so, then prepare to return
                        		; to the next instruction, not the pfi.
FFFC0AC8 34101DF3		csrrw	$t1,#$341,$x0
FFFC0ACC 000DEE03		ldtu	$t2,[$t1]					; get the instruction at the return address
FFFC0AD0 10300637		xor		$t2,$t2,#$10300073	; pfi?
FFFC0AD4 07360613
FFFC0AD8 01C64E33
FFFC0ADC 000E1663		bnez	$t2,.notPfi
FFFC0AE0 004D8D93		add		$t1,$t1,#4				; update return address to point past pfi
FFFC0AE4 341D9073		csrrw	$x0,#$341,$t1
                        	.notPfi:
FFFC0AE8 01FD7D93		and		$t1,$t0,#31				; interrupting device # is low order 5 bits of cause code
FFFC0AEC 008D9D93		sll		$t1,$t1,#8				; 256 bytes per device func table
FFFC0AF0 00022637		add		$t1,$t1,#DVF_Base+22*8	; load IRQ routine vector from device func table
FFFC0AF4 0B060613
FFFC0AF8 01B60DB3
FFFC0AFC 000DBD83		ldo		$t1,[$t1]
FFFC0B00 000D8463		beq		$t1,$x0,.noIRQ		; make sure there's an address to go to
FFFC0B04 000D8067		jmp		[$t1]							; call to the IRQ routine
                        	.noIRQ:
                        		; For now, clear all interrupt sources
                        		; Otherwise the system will hang on an unknown interrupt.
FFFC0B08 FFDC0637		stt		$t0,VIA+VIA_PARAW
FFFC0B0C 63C60613
FFFC0B10 00060633
FFFC0B14 01A62023
FFFC0B18 FFDC1637		ldt		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC0B1C A0060613
FFFC0B20 00060633
FFFC0B24 00062983
FFFC0B28 FFDC0637		ldt		$t0,VIA+VIA_T1CL		; clear interrupt
FFFC0B2C 61060613
FFFC0B30 00060633
FFFC0B34 00062D03
FFFC0B38 79217073		csrrc	$x0,#$792,#2			; clear interrupt semaphore
FFFC0B3C 10000073		eret
                        	.cause0to7:
FFFC0B40 003D1913		sll		$a0,$t0,#3
FFFC0B44 FFFC1637		ldo		$a0,tblCauseMsg[$a0]
FFFC0B48 C8860613
FFFC0B4C 01260633
FFFC0B50 00063903
FFFC0B54 00090A63		beqz	$a0,.doMsgReserved
FFFC0B58 DF9FF0EF		call	PutString
FFFC0B5C 34301973		csrrw	$a0,#$343,$x0
FFFC0B60 D39FF0EF		call	PutHexWord
FFFC0B64 10000073		eret
                        	.doMsgReserved:
FFFC0B68 FFFC1937		ldi		$a0,#msgReserved
FFFC0B6C D4190913
FFFC0B70 DE1FF0EF		call	PutString
FFFC0B74 10000073		eret
                        	.cause12plus:
FFFC0B78 FE0008E3		bra		.doMsgReserved
                        	
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC0B7C 61746550			db		"Petajon System Starting.",13,10
FFFC0B80 206E6F6A
FFFC0B84 74737953
FFFC0B88 53206D65
FFFC0B8C 74726174
FFFC0B90 2E676E69
FFFC0B94 6F4D0A0D
                        	msgMonHelp:
FFFC0B96 696E6F4D			db		"Monitor Commands",13,10
FFFC0B9A 20726F74
FFFC0B9E 6D6D6F43
FFFC0BA2 73646E61
FFFC0BA6 20420A0D
FFFC0BA8 202D2042			db		"B - start tiny basic",13,10
FFFC0BAC 72617473
FFFC0BB0 69742074
FFFC0BB4 6220796E
FFFC0BB8 63697361
FFFC0BBC 20440A0D
FFFC0BBE 202D2044			db		"D - dump ready que",13,10
FFFC0BC2 706D7564
FFFC0BC6 61657220
FFFC0BCA 71207964
FFFC0BCE 0A0D6575
FFFC0BD2 202D2045			db		"E - edit memory",13,10
FFFC0BD6 74696465
FFFC0BDA 6D656D20
FFFC0BDE 0D79726F
FFFC0BE2 2D20460A
FFFC0BE3 202D2046			db		"F - fill memory",13,10
FFFC0BE7 6C6C6966
FFFC0BEB 6D656D20
FFFC0BEF 0D79726F
FFFC0BF3 3C204B0A
FFFC0BF4 743C204B			db		"K <tid> - kill task", 13,10
FFFC0BF8 203E6469
FFFC0BFC 696B202D
FFFC0C00 74206C6C
FFFC0C04 0D6B7361
FFFC0C08 3C204D0A
FFFC0C09 733C204D			db		"M <start> <length>	- dump memory",13,10
FFFC0C0D 74726174
FFFC0C11 6C3C203E
FFFC0C15 74676E65
FFFC0C19 2D093E68
FFFC0C1D 6D756420
FFFC0C21 656D2070
FFFC0C25 79726F6D
FFFC0C29 20530A0D
FFFC0C2B 202D2053			db		"S - switch task",13,10
FFFC0C2F 74697773
FFFC0C33 74206863
FFFC0C37 0D6B7361
FFFC0C3B 0000000A
FFFC0C3C 00000000			db		0
FFFC0C3D 20000000			align 
                        	
                        	msgTaskStart:
FFFC0C40 73617420			db		" task started."
FFFC0C44 7473206B
FFFC0C48 65747261
FFFC0C4C 0A0D2E64
                        	msgCRLF:
FFFC0C4E 00000A0D			db		13,10,0
FFFC0C51 00000000			align		
FFFC0C55 00000000
                        	
                        	flt50:
FFFC0C58 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC0C5C 00000000
FFFC0C60 00000000
FFFC0C64 40049000
                        	flt20:
FFFC0C68 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC0C6C 00000000
FFFC0C70 00000000
FFFC0C74 40034000
                        	flt10:
FFFC0C78 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC0C7C 00000000
FFFC0C80 00000000
FFFC0C84 40024000
                        	
                        		align 	8                        	
                        	tblCauseMsg:
FFFC0C88 00000000		dco		0
FFFC0C8C 00000000
FFFC0C90 FFFC0CE8		dco		msgInsnAccessFault
FFFC0C94 00000000
FFFC0C98 FFFC0D03		dco		msgIllegalInsn
FFFC0C9C 00000000
FFFC0CA0 00000000		dco		0
FFFC0CA4 00000000
FFFC0CA8 00000000		dco		0
FFFC0CAC 00000000
FFFC0CB0 FFFC0D18		dco		msgLoadAccessFault
FFFC0CB4 00000000
FFFC0CB8 00000000		dco		0
FFFC0CBC 00000000
FFFC0CC0 FFFC0D2C		dco		msgStoreAccessFault
FFFC0CC4 00000000
FFFC0CC8 00000000		dco		0,0,0,0
FFFC0CCC 00000000
FFFC0CD0 00000000
FFFC0CD4 00000000
FFFC0CD8 00000000
FFFC0CDC 00000000
FFFC0CE0 00000000
FFFC0CE4 00000000
                        	
                        	msgInsnAccessFault:
FFFC0CE8 74736E49		db		"Instruction access fault",13,10,0
FFFC0CEC 74637572
FFFC0CF0 206E6F69
FFFC0CF4 65636361
FFFC0CF8 66207373
FFFC0CFC 746C7561
FFFC0D00 49000A0D
                        	msgIllegalInsn:
FFFC0D03 656C6C49		db		"Illegal instruction",13,0
FFFC0D07 206C6167
FFFC0D0B 74736E69
FFFC0D0F 74637572
FFFC0D13 0D6E6F69
FFFC0D17 616F4C00
                        	msgLoadAccessFault:
FFFC0D18 64616F4C		db		"Load access fault",13,10,0
FFFC0D1C 63636120
FFFC0D20 20737365
FFFC0D24 6C756166
FFFC0D28 000A0D74
                        	msgStoreAccessFault:
FFFC0D2C 726F7453		db		"Store access fault",13,10,0
FFFC0D30 63612065
FFFC0D34 73736563
FFFC0D38 75616620
FFFC0D3C 0A0D746C
FFFC0D40 73655200
                        	msgReserved:
FFFC0D41 65736552		db		"Reserved",13,10,0
FFFC0D45 64657672
FFFC0D49 00000A0D
                        	
FFFC0D4C 00000000			align		
                        	
                        	
                        	.file "fltToString.r5a",1
                        	.file "fltToString.r5a",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC0D50 00006E13			ldi		$t2,#0				; $t2 = 0
FFFC0D54 E0090953			fmv		$a0,$f18
FFFC0D58 7F800637			and		$t0,$a0,#$7F800000
FFFC0D5C 00060613
FFFC0D60 01267D33
FFFC0D64 7F800DB7			ldi		$t1,#$7F800000
FFFC0D68 000D8D93
FFFC0D6C 05BD1263			bne		$t0,$t1,.0001
FFFC0D70 00800637			and		$t0,$a0,#$007FFFFF
FFFC0D74 FFF60613
FFFC0D78 01267D33
FFFC0D7C 000D0E63			beq		$t0,$x0,.inf
FFFC0D80 FFFC1637			ldt		$t0,msgNan
FFFC0D84 10860613
FFFC0D88 00060633
FFFC0D8C 00062D03
FFFC0D90 21A02023			stt		$t0,STRTMP
FFFC0D94 2E000E63			bra		.prt
                        	.inf:
FFFC0D98 FFFC1637			ldt		$t0,msgInf
FFFC0D9C 10460613
FFFC0DA0 00060633
FFFC0DA4 00062D03
FFFC0DA8 21A02023			stt		$t0,STRTMP
FFFC0DAC 2E000263			bra		.prt
                        	.0001:
FFFC0DB0 80000637			and		$t0,$a0,#$80000000
FFFC0DB4 00060613
FFFC0DB8 01267D33
FFFC0DBC 000D0E63			beq		$t0,$x0,.pos
FFFC0DC0 02D06D13			ldi		$t0,#'-'
FFFC0DC4 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0DC8 001E0E13			add		$t2,$t2,#1
FFFC0DCC 80000637			and		$a0,$a0,#$7FFFFFFF
FFFC0DD0 FFF60613
FFFC0DD4 01267933
                        	.pos:
FFFC0DD8 00091A63			bne		$a0,$x0,.notZero
FFFC0DDC 03006D13			ldi		$t0,#'0'
FFFC0DE0 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0DE4 200E00A3			stb		$x0,STRTMP+1[$t2]
FFFC0DE8 2A000463			bra		.prt		
                        	.notZero:
FFFC0DEC 00006633			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC0DF0 FFFC1637			flw		$f3,fltOne
FFFC0DF4 10C60613
FFFC0DF8 00060633
FFFC0DFC 00062187
FFFC0E00 F0090053			fmv		$f0,$a0
FFFC0E04 A0391D53			flt		$t0,$f18,$f3
FFFC0E08 020D0463			beq		$t0,$x0,.0002
FFFC0E0C FFFC1637			flw		$f4,fltMillion
FFFC0E10 11460613
FFFC0E14 00060633
FFFC0E18 00062207
                        	.0003:
FFFC0E1C A0391D53			flt		$t0,$f18,$f3
FFFC0E20 000D0863			beq		$t0,$x0,.0002
FFFC0E24 10490953			fmul	$f18,$f18,$f4
FFFC0E28 FFA60613			sub		$s9,$s9,#6
FFFC0E2C FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC0E30 FFFC1637			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC0E34 10C60613
FFFC0E38 00060633
FFFC0E3C 00062087
FFFC0E40 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC0E44 A1209D53			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC0E48 020D0A63			beq		$t0,$x0,.0004
FFFC0E4C FFFC1637			flw		$f5,fltTen				; $f5 = 10.0
FFFC0E50 11060613
FFFC0E54 00060633
FFFC0E58 00062287
                        	.0006:
FFFC0E5C A1208D53			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC0E60 000D0A63			beq		$t0,$x0,.0005
FFFC0E64 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC0E68 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC0E6C 00160613			add		$s9,$s9,#1				; exp++;
FFFC0E70 FE0006E3			bra		.0006
                        	.0005:
FFFC0E74 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC0E78 FFF60613			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC0E7C 00064E63			blt		$s9,$x0,.0007
FFFC0E80 00606413			ldi		$s5,#6
FFFC0E84 00865A63			bge		$s9,$s5,.0007
FFFC0E88 FFFFE233			mov		$s1,#s0						; s1 = digits before decpt
FFFC0E8C 00120213			add		$s1,$s1,#1
FFFC0E90 00006613			ldi		$s9,#0						; exp = 0
FFFC0E94 00000C63			bra		.0008
                        	.0007:
FFFC0E98 FF906413			ldi		$s5,#-7
FFFC0E9C 00864663			blt		$s9,$s5,.0009
FFFC0EA0 00106213			ldi		$s1,#1
FFFC0EA4 00000463			bra		.0008
                        	.0009:
FFFC0EA8 FFF06213			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC0EAC FFA06413			ldi		$s5,#-6
FFFC0EB0 00865E63			bge		$s9,$s5,.0010
FFFC0EB4 03006D13			ldi		$t0,#'0'
FFFC0EB8 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0EBC 001E0E13			add		$t2,$t2,#1
FFFC0EC0 02E06D13			ldi		$t0,#'.'
FFFC0EC4 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0EC8 001E0E13			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC0ECC 00006313			ldi		$s3,#0						; s3 = nn = 0
FFFC0ED0 01E06413			ldi		$s5,#30
FFFC0ED4 FFFC1637			flw		$f7,fltTen				; f7 = 10.0
FFFC0ED8 11060613
FFFC0EDC 00060633
FFFC0EE0 00062387
                        	.0016:
FFFC0EE4 00832D33			slt		$t0,$s3,$s5
FFFC0EE8 060D0863			beq		$t0,$x0,.0011
FFFC0EEC 00006413			ldi		$s5,#0
FFFC0EF0 07445463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC0EF4 00006393			ldi		$s4,#0						; s4 = digit = 0
FFFC0EF8 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC0EFC A1208D53			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC0F00 000D0863			beq		$t0,$x0,.0012
FFFC0F04 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC0F08 00138393			add		$s4,$s4,#1						; digit++
FFFC0F0C FE0008E3			bra		.0013
                        	.0012:
FFFC0F10 03038413			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC0F14 208E0023			stb		$s5,STRTMP[$t2]
FFFC0F18 00206413			ldi		$s5,#2						; if (2 < digit)
FFFC0F1C 00745863			bge		$s5,$s4,.0014
FFFC0F20 D00382D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC0F24 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC0F28 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC0F2C 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0F30 FFF20213			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC0F34 00021A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC0F38 02E06D13			ldi		$t0,#'.'
FFFC0F3C 21AE0023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC0F40 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0F44 00000663			bra		.0017
                        	.0015:
FFFC0F48 00025463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC0F4C FFFA0A13			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC0F50 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC0F54 F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC0F58 FFFE0E13			sub		$t2,$t2,#1				; ndx--
FFFC0F5C 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0F60 030D4D13			xor		$t0,$t0,#'0'
FFFC0F64 FE0D0AE3			beq		$t0,$x0,.0018
FFFC0F68 001E0E13			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC0F6C 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0F70 02ED4D13			xor		$t0,$t0,#'.'
FFFC0F74 000D1C63			bne		$t0,$x0,.0019
FFFC0F78 001E0E13			add		$t2,$t2,#1
FFFC0F7C 03006D13			ldi		$t0,#'0'
FFFC0F80 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0F84 001E0E13			add		$t2,$t2,#1
FFFC0F88 200E0023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC0F8C 00061663			bne		$s9,$x0,.0020
FFFC0F90 200E0023			stb		$x0,STRTMP[$t2]
FFFC0F94 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC0F98 04506D13			ldi		$t0,#'E'
FFFC0F9C 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0FA0 001E0E13			add		$t2,$t2,#1
FFFC0FA4 00065C63			bge		$s9,$x0,.0021
FFFC0FA8 02D06D13			ldi		$t0,#'-'
FFFC0FAC 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0FB0 001E0E13			add		$t2,$t2,#1
FFFC0FB4 40C00633			sub		$s9,$x0,$s9			; exp = -exp
FFFC0FB8 00000863			bra		.0022
                        	.0021:
FFFC0FBC 02B06D13			ldi		$t0,#'+'
FFFC0FC0 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0FC4 001E0E13			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC0FC8 00006393			ldi		$s4,#0
FFFC0FCC 3E806D13			ldi		$t0,#1000
                        	.0025:
FFFC0FD0 01A65463			bge		$s9,$t0,.0023
FFFC0FD4 00000863			bra		.0024
                        	.0023:
FFFC0FD8 41A60633			sub		$s9,$s9,$t0
FFFC0FDC 00138393			add		$s4,$s4,#1
FFFC0FE0 FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0FE4 0003E4B3			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC0FE8 00039863			bne		$s4,$x0,.0026
FFFC0FEC 03038D13			add		$t0,$s4,#'0'
FFFC0FF0 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0FF4 001E0E13			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC0FF8 00006393			ldi		$s4,#0
FFFC0FFC 06406D13			ldi		$t0,#100
                        	.0027:
FFFC1000 01A65463			bge		$s9,$t0,.0028
FFFC1004 00000863			bra		.0029
                        	.0028:
FFFC1008 41A60633			sub		$s9,$s9,$t0
FFFC100C 00138393			add		$s4,$s4,#1
FFFC1010 FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC1014 0003E533			mov		$s7,$s4				; $s7 = d2
FFFC1018 00049463			bne		$s6,$x0,.0030
FFFC101C 00038863			beq		$s4,$x0,.0031
                        	.0030:
FFFC1020 03038D13			add		$t0,$s4,#'0'
FFFC1024 21AE0023			stb		$t0,STRTMP[$t2]
FFFC1028 001E0E13			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC102C 00006393			ldi		$s4,#0
FFFC1030 00A06D13			ldi		$t0,#10
                        	.0032:
FFFC1034 01A65463			bge		$s9,$t0,.0034
FFFC1038 00000863			bra		.0035
                        	.0034:
FFFC103C 41A60633			sub		$s9,$s9,$t0
FFFC1040 00138393			add		$s4,$s4,#1
FFFC1044 FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC1048 0003E5B3			mov		$s8,$s4
FFFC104C 00039663			bne		$s4,$x0,.0036
FFFC1050 00049463			bne		$s6,$x0,.0036
FFFC1054 00050863			beq		$s7,$x0,.0037
                        	.0036:
FFFC1058 03038D13			add		$t0,$s4,#'0'
FFFC105C 21AE0023			stb		$t0,STRTMP[$t2]
FFFC1060 001E0E13			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC1064 00006393			ldi		$s4,#0
FFFC1068 00106D13			ldi		$t0,#1
                        	.0038:
FFFC106C 01A65463			bge		$s9,$t0,.0040
FFFC1070 00000863			bra		.0039
                        	.0040:
FFFC1074 41A60633			sub		$s9,$s9,$t0
FFFC1078 00138393			add		$s4,$s4,#1
FFFC107C FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC1080 03038D13			add		$t0,$s4,#'0'
FFFC1084 21AE0023			sb		$t0,STRTMP[$t2]
FFFC1088 001E0E13			add		$t2,$t2,#1
FFFC108C 200E0023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC1090 0409C663			blt		$a1,$x0,.0041
FFFC1094 04098463			beq		$a1,$x0,.0041
FFFC1098 013E4463			blt		$t2,$a1,.0042
FFFC109C 04000063			bra		.0041
                        	.0042:
FFFC10A0 02706313			ldi		$s3,#39					; s3 = nn
FFFC10A4 41C98D33			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC10A8 01A35463			bge		$s3,$t0,.0043
FFFC10AC 00000C63			bra		.0044
                        	.0043:
FFFC10B0 41A304B3			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC10B4 20030D83			ldb		$t1,STRTMP[$s3]
FFFC10B8 21B48023			stb		$t1,STRTMP[$s6]
FFFC10BC FFF30313			sub		$s3,$s3,#1
FFFC10C0 FE0004E3			bra		.0045
                        	.0044:
FFFC10C4 02006D13			ldi		$t0,#' '
                        	.0048:
FFFC10C8 00035463			bge		$s3,$x0,.0046
FFFC10CC 00000863			bra		.0047
                        	.0046:
FFFC10D0 21A30023			stb		$t0,STRTMP[$s3]
FFFC10D4 FFF30313			sub		$s3,$s3,#1
FFFC10D8 FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC10DC 0209D063			bge		$a1,$x0,.0050
FFFC10E0 413009B3			sub		$a1,$x0,$a1
FFFC10E4 02006D13			ldi		$t0,#' '
                        	.0052:
FFFC10E8 013E5863			bge		$t2,$a1,.0051
FFFC10EC 21AE0023			stb		$t0,STRTMP[$t2]
FFFC10F0 001E0E13			add		$t2,$t2,#1
FFFC10F4 FE000AE3			bra		.0052
                        	.0051:
FFFC10F8 200E0023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC10FC 000E6833			mov		$v0,$t2
FFFC1100 00008067			ret
                        	
                        			align	4                        	
                        	msgInf:
FFFC1104 00666E49			db	"Inf",0
                        	msgNan:
FFFC1108 006E614E			db	"Nan",0
                        	fltOne:
FFFC110C 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC1110 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC1114 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "ramtest.s",1
                        	.file "ramtest.s",1
                        	.file "ramtest.s",2
                        		code
FFFC1118 00000000		align	1
FFFC111C 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
                        	ramtest_TwoSpaces:
FFFC1120 FE070713		      	sub      	$sp,$sp,#32
FFFC1124 00273023		      	sto      	$fp,[$sp]
FFFC1128 00073423		      	sto      	$x0,8[$sp]
FFFC112C 00173C23		      	sto      	$ra,24[$sp]
FFFC1130 00076133		      	mov      	$fp,$sp
FFFC1134 10300073		      	pfi      
FFFC1138 02006913		      	ldi      	$a0,#32
FFFC113C 9C8FF0EF		      	call     	_putch
FFFC1140 02006913		      	ldi      	$a0,#32
FFFC1144 9C0FF0EF		      	call     	_putch
                        	ramtest_10:
                        	ramtest_11:
FFFC1148 00016733		      	mov      	$sp,$fp
FFFC114C 00073103		      	ldo      	$fp,[$sp]
FFFC1150 01873083		      	ldo      	$ra,24[$sp]
FFFC1154 02070713		      	add      	$sp,$sp,#32
FFFC1158 00008067		      	ret      
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC115C FE070713	public code _dumpaddr:
	      	sub      	$sp,$sp,#32
FFFC1160 00273023		      	sto      	$fp,[$sp]
FFFC1164 00073423		      	sto      	$x0,8[$sp]
FFFC1168 00173C23		      	sto      	$ra,24[$sp]
FFFC116C 00076133		      	mov      	$fp,$sp
FFFC1170 FF870713		      	sub      	$sp,$sp,#8
FFFC1174 00473023		      	sto      	$s1,0[$sp]
FFFC1178 10300073		      	pfi      
FFFC117C 02013203		      	ldo      	$s1,32[$fp]
                        	; 	TwoSpaces();
FFFC1180 FA1FF0EF		      	call     	ramtest_TwoSpaces
                        	; 	PutHexWord((int)p);
FFFC1184 00026933		      	mov      	$a0,$s1
FFFC1188 F10FF0EF		      	call     	_PutHexWord
                        	; 	putch(' ');
FFFC118C 02006913		      	ldi      	$a0,#32
FFFC1190 974FF0EF		      	call     	_putch
                        	; 	PutHexWord(p[0]);
FFFC1194 00023903		      	ldo      	$a0,[$s1]
FFFC1198 F00FF0EF		      	call     	_PutHexWord
                        	; 	putch('\r');
FFFC119C 10300073		      	pfi      
FFFC11A0 00D06913		      	ldi      	$a0,#13
FFFC11A4 960FF0EF		      	call     	_putch
                        	; 	putch('\n');
FFFC11A8 00A06913		      	ldi      	$a0,#10
FFFC11AC 958FF0EF		      	call     	_putch
                        	ramtest_20:
                        	ramtest_21:
FFFC11B0 00073203		      	ldo      	$s1,0[$sp]
FFFC11B4 00016733		      	mov      	$sp,$fp
FFFC11B8 00073103		      	ldo      	$fp,[$sp]
FFFC11BC 01873083		      	ldo      	$ra,24[$sp]
FFFC11C0 02070713		      	add      	$sp,$sp,#32
FFFC11C4 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
                        	ramtest_SetMem:
FFFC11C8 FE070713		      	sub      	$sp,$sp,#32
FFFC11CC 00273023		      	sto      	$fp,[$sp]
FFFC11D0 00073423		      	sto      	$x0,8[$sp]
FFFC11D4 00173C23		      	sto      	$ra,24[$sp]
FFFC11D8 00076133		      	mov      	$fp,$sp
FFFC11DC FDE70713		      	sub      	$sp,$sp,#34
FFFC11E0 00473023		      	sto      	$s1,0[$sp]
FFFC11E4 00573423		      	sto      	$s2,8[$sp]
FFFC11E8 00673823		      	sto      	$s3,16[$sp]
FFFC11EC 10300073		      	pfi      
FFFC11F0 FF813203		      	ldo      	$s1,-8[$fp]
FFFC11F4 1FFF82B7		      	ldi      	$s2,#536838144
FFFC11F8 00028293
FFFC11FC 00030337		      	ldi      	$s3,#196608
FFFC1200 00030313
                        	; 	for (p = (__int32 *)0x30000; p < (__int32 *)0x1FFF8000; p+=2) {
FFFC1204 00036233		      	mov      	$s1,$s3
FFFC1208 08527463		      	bgeu     	$s1,$s2,ramtest_46
                        	ramtest_45:
                        	; 		if ((p & 0xFFF)==0) {
FFFC120C 10300073		      	pfi      
FFFC1210 00001637		      	and      	$t0,$s1,#4095
FFFC1214 FFF60613
FFFC1218 00467D33
FFFC121C 040D1C63		      	bne      	$t0,$x0,ramtest_48
                        	; 			TwoSpaces();
FFFC1220 F01FF0EF		      	call     	ramtest_TwoSpaces
                        	; 			PutHexWord((int)p>>12);
FFFC1224 20C25913		      	sra      	$a0,$s1,#12
FFFC1228 E70FF0EF		      	call     	_PutHexWord
                        	; 			putch('\r');
FFFC122C 10300073		      	pfi      
FFFC1230 00D06913		      	ldi      	$a0,#13
FFFC1234 8D0FF0EF		      	call     	_putch
                        	; 	asm {
                        		      	;asm     	
FFFC1238 FFDC0637				ldtu	$v0,BUTTONS
FFFC123C 60060613
FFFC1240 00060633
FFFC1244 00066803
                        	; 	}
FFFC1248 00086D33		      	mov      	$t0,$v0
FFFC124C 004D4D93		      	xor      	$t1,$t0,#4
FFFC1250 020D9263		      	bnez     	$t1,ramtest_50
                        	ramtest_44:
FFFC1254 00073203		      	ldo      	$s1,0[$sp]
FFFC1258 00873283		      	ldo      	$s2,8[$sp]
FFFC125C 01073303		      	ldo      	$s3,16[$sp]
FFFC1260 00016733		      	mov      	$sp,$fp
FFFC1264 00073103		      	ldo      	$fp,[$sp]
FFFC1268 01873083		      	ldo      	$ra,24[$sp]
FFFC126C 02070713		      	add      	$sp,$sp,#32
FFFC1270 00008067		      	ret      
                        	ramtest_50:
                        	ramtest_48:
                        	; 		p[0] = (__int32)n1;
FFFC1274 10300073		      	pfi      
FFFC1278 02012D03		      	ldt      	$t0,32[$fp]
FFFC127C 01A22023		      	stt      	$t0,[$s1]
                        	; 		p[1] = (__int32)n2;
FFFC1280 02A12D03		      	ldt      	$t0,42[$fp]
FFFC1284 01A22223		      	stt      	$t0,4[$s1]
FFFC1288 00820213		      	add      	$s1,$s1,#8
FFFC128C F85260E3		      	bltu     	$s1,$s2,ramtest_45
                        	ramtest_46:
                        	ramtest_43:
FFFC1290 FC0002E3		      	bra      	ramtest_44
                        	.file "ramtest.s",132
                        		code
FFFC1294 00000000		align	1
FFFC1298 00000000
FFFC129C 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
                        	ramtest_CheckMem:
FFFC12A0 FE070713		      	sub      	$sp,$sp,#32
FFFC12A4 00273023		      	sto      	$fp,[$sp]
FFFC12A8 00073423		      	sto      	$x0,8[$sp]
FFFC12AC 00173C23		      	sto      	$ra,24[$sp]
FFFC12B0 00076133		      	mov      	$fp,$sp
FFFC12B4 FC270713		      	sub      	$sp,$sp,#62
FFFC12B8 00473023		      	sto      	$s1,0[$sp]
FFFC12BC 00573423		      	sto      	$s2,8[$sp]
FFFC12C0 00673823		      	sto      	$s3,16[$sp]
FFFC12C4 00773C23		      	sto      	$s4,24[$sp]
FFFC12C8 10300073		      	pfi      
FFFC12CC FF813203		      	ldo      	$s1,-8[$fp]
FFFC12D0 FEE13283		      	ldo      	$s2,-18[$fp]
FFFC12D4 00030337		      	ldi      	$s3,#196608
FFFC12D8 00030313
FFFC12DC 1FFF83B7		      	ldi      	$s4,#536838144
FFFC12E0 00038393
                        	; 	__int32 *p;
FFFC12E4 000062B3		      	mov      	$s2,$x0
                        	; 	for (p = (__int32 *)0x30000; p < (__int32 *)0x1FFF8000; p+=2) {
FFFC12E8 00036233		      	mov      	$s1,$s3
FFFC12EC 10300073		      	pfi      
FFFC12F0 0C727863		      	bgeu     	$s1,$s4,ramtest_87
                        	ramtest_86:
                        	; 		if ((p & 0xFFF)==0) {
FFFC12F4 00001637		      	and      	$t0,$s1,#4095
FFFC12F8 FFF60613
FFFC12FC 00467D33
FFFC1300 040D1E63		      	bne      	$t0,$x0,ramtest_89
                        	; 			TwoSpaces();
FFFC1304 E1DFF0EF		      	call     	ramtest_TwoSpaces
                        	; 			PutHexWord((int)p>>12);
FFFC1308 20C25913		      	sra      	$a0,$s1,#12
FFFC130C D8CFF0EF		      	call     	_PutHexWord
                        	; 			putch('\r');
FFFC1310 10300073		      	pfi      
FFFC1314 00D06913		      	ldi      	$a0,#13
FFFC1318 FEDFE0EF		      	call     	_putch
                        	; 	asm {
                        		      	;asm     	
FFFC131C FFDC0637				ldtu	$v0,BUTTONS
FFFC1320 60060613
FFFC1324 00060633
FFFC1328 00066803
                        	; 	}
FFFC132C 00086D33		      	mov      	$t0,$v0
FFFC1330 004D4D93		      	xor      	$t1,$t0,#4
FFFC1334 020D9463		      	bnez     	$t1,ramtest_91
                        	ramtest_85:
FFFC1338 00073203		      	ldo      	$s1,0[$sp]
FFFC133C 00873283		      	ldo      	$s2,8[$sp]
FFFC1340 01073303		      	ldo      	$s3,16[$sp]
FFFC1344 01873383		      	ldo      	$s4,24[$sp]
FFFC1348 00016733		      	mov      	$sp,$fp
FFFC134C 00073103		      	ldo      	$fp,[$sp]
FFFC1350 01873083		      	ldo      	$ra,24[$sp]
FFFC1354 02070713		      	add      	$sp,$sp,#32
FFFC1358 00008067		      	ret      
                        	ramtest_91:
                        	ramtest_89:
                        	; 		if (p[0] != (__int32)n1) {
FFFC135C 10300073		      	pfi      
FFFC1360 00022D03		      	ldt      	$t0,[$s1]
FFFC1364 02012D83		      	ldt      	$t1,32[$fp]
FFFC1368 01BD0A63		      	beq      	$t0,$t1,ramtest_98
                        	; 			badcount++;
FFFC136C 00128293		      	add      	$s2,$s2,#1
                        	; 			dumpaddr(p);
FFFC1370 00473423		      	sto      	$s1,8[$sp]
FFFC1374 DE9FF0EF		      	call     	_dumpaddr
FFFC1378 00870713		      	add      	$sp,$sp,#8
                        	ramtest_98:
                        	; 		if (p[1] != (__int32)n2) {
FFFC137C 10300073		      	pfi      
FFFC1380 00422D03		      	ldt      	$t0,4[$s1]
FFFC1384 02A12D83		      	ldt      	$t1,42[$fp]
FFFC1388 01BD0C63		      	beq      	$t0,$t1,ramtest_100
                        	; 			badcount++;
FFFC138C 10300073		      	pfi      
FFFC1390 00128293		      	add      	$s2,$s2,#1
                        	; 			dumpaddr(p);
FFFC1394 00473423		      	sto      	$s1,8[$sp]
FFFC1398 DC5FF0EF		      	call     	_dumpaddr
FFFC139C 00870713		      	add      	$sp,$sp,#8
                        	ramtest_100:
                        	; 		if (badcount > 10)
FFFC13A0 10300073		      	pfi      
FFFC13A4 00A06D13		      	ldi      	$t0,#10
FFFC13A8 01A2AD33		      	slt      	$t0,$s2,$t0
FFFC13AC 000D1463		      	bnez     	$t0,ramtest_102
                        	; 			break;
FFFC13B0 00000863		      	bra      	ramtest_87
                        	ramtest_102:
FFFC13B4 10300073		      	pfi      
FFFC13B8 00820213		      	add      	$s1,$s1,#8
FFFC13BC F2726CE3		      	bltu     	$s1,$s4,ramtest_86
                        	ramtest_87:
                        	; 	putch('\r');
FFFC13C0 00D06913		      	ldi      	$a0,#13
FFFC13C4 F41FE0EF		      	call     	_putch
                        	; 	putch('\n');
FFFC13C8 10300073		      	pfi      
FFFC13CC 00A06913		      	ldi      	$a0,#10
FFFC13D0 F35FE0EF		      	call     	_putch
                        	ramtest_84:
FFFC13D4 F60002E3		      	bra      	ramtest_85
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC13D8 FE070713	public code _ramtest:
	      	sub      	$sp,$sp,#32
FFFC13DC 00273023		      	sto      	$fp,[$sp]
FFFC13E0 00073423		      	sto      	$x0,8[$sp]
FFFC13E4 00173C23		      	sto      	$ra,24[$sp]
FFFC13E8 00076133		      	mov      	$fp,$sp
FFFC13EC FE670713		      	sub      	$sp,$sp,#26
FFFC13F0 00473023		      	sto      	$s1,0[$sp]
FFFC13F4 00573423		      	sto      	$s2,8[$sp]
FFFC13F8 10300073		      	pfi      
FFFC13FC 55555237		      	ldi      	$s1,#1431655765
FFFC1400 55520213
FFFC1404 AAAAB2B7		      	ldi      	$s2,#2863311530
FFFC1408 AAA28293
                        	; 	DBGHideCursor(1);
FFFC140C 00106D13		      	ldi      	$t0,#1
FFFC1410 01A73423		      	sto      	$t0,8[$sp]
FFFC1414 0B4040EF		      	call     	_DBGHideCursor
FFFC1418 00870713		      	add      	$sp,$sp,#8
                        	; 	PutString(B"  RAM Test\r\n");
FFFC141C 10300073		      	pfi      
FFFC1420 FFFC9937		      	ldi      	$a0,#ramtest_105
FFFC1424 00090913
FFFC1428 D28FF0EF		      	call     	_PutString
                        	; 	SetMem(0xAAAAAAAA,0x55555555);
FFFC142C 00473823		      	sto      	$s1,16[$sp]
FFFC1430 00573823		      	sto      	$s2,16[$sp]
FFFC1434 D95FF0EF		      	call     	ramtest_SetMem
FFFC1438 01070713		      	add      	$sp,$sp,#16
                        	; 	CheckMem(0xAAAAAAAA,0x55555555);
FFFC143C 10300073		      	pfi      
FFFC1440 00473823		      	sto      	$s1,16[$sp]
FFFC1444 00573823		      	sto      	$s2,16[$sp]
FFFC1448 E59FF0EF		      	call     	ramtest_CheckMem
FFFC144C 01070713		      	add      	$sp,$sp,#16
                        	; 	putch('\r');
FFFC1450 00D06913		      	ldi      	$a0,#13
FFFC1454 EB1FE0EF		      	call     	_putch
                        	; 	putch('\n');
FFFC1458 00A06913		      	ldi      	$a0,#10
FFFC145C EA9FE0EF		      	call     	_putch
                        	; 	SetMem(0x55555555,0xAAAAAAAA);
FFFC1460 10300073		      	pfi      
FFFC1464 00573823		      	sto      	$s2,16[$sp]
FFFC1468 00473823		      	sto      	$s1,16[$sp]
FFFC146C D5DFF0EF		      	call     	ramtest_SetMem
FFFC1470 01070713		      	add      	$sp,$sp,#16
                        	; 	CheckMem(0x55555555,0xAAAAAAAA);
FFFC1474 00573823		      	sto      	$s2,16[$sp]
FFFC1478 00473823		      	sto      	$s1,16[$sp]
FFFC147C E25FF0EF		      	call     	ramtest_CheckMem
FFFC1480 01070713		      	add      	$sp,$sp,#16
                        	; 	DBGHideCursor(0);
FFFC1484 10300073		      	pfi      
FFFC1488 00073423		      	sto      	$x0,8[$sp]
FFFC148C 03C040EF		      	call     	_DBGHideCursor
FFFC1490 00870713		      	add      	$sp,$sp,#8
                        	ramtest_113:
                        	ramtest_114:
FFFC1494 00073203		      	ldo      	$s1,0[$sp]
FFFC1498 00873283		      	ldo      	$s2,8[$sp]
FFFC149C 00016733		      	mov      	$sp,$fp
FFFC14A0 00073103		      	ldo      	$fp,[$sp]
FFFC14A4 01873083		      	ldo      	$ra,24[$sp]
FFFC14A8 02070713		      	add      	$sp,$sp,#32
FFFC14AC 00008067		      	ret      
                        	endpublic
                        	
                        	.file "../bios/bios.r5a",25
                        		code
                        		align	2                        	
                        	BIOSCallTbl:
FFFC14B0 14BC14B8		dh		BIOS_ClearScreen
FFFC14B2 14C014BC		dh		BIOS_HomeCursor
FFFC14B4 14C414C0		dh		BIOS_VideoPutChar
FFFC14B6 006F14C4		dh		BIOS_VideoPutString
                        	
                        		align	4                        	
                        	BIOS_ClearScreen:
FFFC14B8 4F90006F		jmp		VideoClearScreen
                        	BIOS_HomeCursor:
FFFC14BC 5390006F		jmp		VideoHomeCursor
                        	BIOS_VideoPutChar:
FFFC14C0 5990006F		jmp		VideoPutChar
                        	BIOS_VideoPutString:
FFFC14C4 10C0106F		jmp		VideoPutString
                        	
                        	
                        	
                        	
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../bios/mem.r5a",1
                        	.file "../bios/mem.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../bios/mem.r5a",25
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC14C8 FF870713			sub		$sp,$sp,#8
FFFC14CC 00173023			sto		$ra,[$sp]
FFFC14D0 00002D37			ldi		$t0,#8192				; set number of available pages in system
FFFC14D4 000D0D13
FFFC14D8 00025637			stw		$t0,NPAGES
FFFC14DC 82860613
FFFC14E0 00060633
FFFC14E4 01A61023
                        			; Free all memory for all maps
FFFC14E8 00006D13			ldi		$t0,#$00
FFFC14EC 01F06F13			ldi		$t4,#MAX_MID		; map id
                        	.0004:
FFFC14F0 10300073			pfi
FFFC14F4 00006D93			ldi		$t1,#$000				; regno
FFFC14F8 00001E37			ldi		$t2,#PAGES_PER_MAP	; number of registers to update
FFFC14FC 000E0E13
                        	.0001:
FFFC1500 10300073			pfi
FFFC1504 010F1213			sll		$s1,$t4,#16			; put mid in place
FFFC1508 01B26233			or		$s1,$s1,$t1			; or in page number
FFFC150C 024D000D			mvmap	$x0,$t0,$s1
FFFC1510 001D8D93			add		$t1,$t1,#$01		; increment page number
FFFC1514 FFFE0E13			sub		$t2,$t2,#1
FFFC1518 FE0E14E3			bnez	$t2,.0001
FFFC151C FFFF0F13			sub		$t4,$t4,#1
FFFC1520 FC0F58E3			bge		$t4,$x0,.0004
                        			; Now ensure all pages in PAM are marked free
FFFC1524 00002D37			ldi		$t0,#8191
FFFC1528 FFFD0D13
                        	.0006:
FFFC152C 10300073			pfi
FFFC1530 0A0D000D			pfree	$t0
FFFC1534 FFFD0D13			sub		$t0,$t0,#1
FFFC1538 FE0D5AE3			bge		$t0,$x0,.0006
                        			; Allocate three pages for OS data.
                        			; These will end up being the first three pages of memory
FFFC153C 0800000D			palloc	$x0,$x0
FFFC1540 0800000D			palloc	$x0,$x0
FFFC1544 0800000D			palloc	$x0,$x0
                        			; allocate last page for system stack
FFFC1548 00001DB7			ldi		$t1,#$FFF				
FFFC154C FFFD8D93
FFFC1550 00002D37			ldi		$t0,#$1FFF
FFFC1554 FFFD0D13
FFFC1558 080D000D			palloc	$x0,$t0				; specifically allocate page 8191
FFFC155C 03BD000D			mvmap	$x0,$t0,$t1
FFFC1560 10300073			pfi
                        	
                        			; Now setup segment registers
FFFC1564 00006D13			ldi		$t0,#$0
FFFC1568 00706D93			ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC156C 10300073			pfi
FFFC1570 01AD800D			mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC1574 001D0D13			add		$t0,$t0,#1			; pick next segment register
FFFC1578 010D2E13			slt		$t2,$t0,#16			; 16 segment regs
FFFC157C FE0E18E3			bne		$t2,$x0,.0002
FFFC1580 00073083			ldo		$ra,[$sp]
FFFC1584 00870713			add		$sp,$sp,#8
FFFC1588 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindRun:
FFFC158C 01F97E93		and			$t3,$a0,#MAX_MID	; t3 = mid
FFFC1590 010E9E93		sll			$t3,$t3,#16				; shift into usable position
FFFC1594 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC1598 003E6E13		or			$t2,$t2,#OSPAGES	; start looking at page 3 (others are for OS)
FFFC159C 00002FB7		ldi			$t5,#8191					; max number of pages - 1
FFFC15A0 FFFF8F93
FFFC15A4 01DFEFB3		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0003:
FFFC15A8 10300073		pfi
FFFC15AC 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
                        	.0001:
FFFC15B0 10300073		pfi
FFFC15B4 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC15B8 00080A63		beqz		$v0,.empty0				; is it empty?
FFFC15BC 001E0E13		add			$t2,$t2,#1
FFFC15C0 FFFE68E3		bltu		$t2,$t5,.0001
                        	.0002:
FFFC15C4 FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC15C8 00008067		ret
                        	.empty0:
FFFC15CC 000E6EB3		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC15D0 10300073		pfi
FFFC15D4 FFFE78E3		bgeu		$t2,$t5,.0002
FFFC15D8 001D8D93		add			$t1,$t1,#1
FFFC15DC 013DFA63		bgeu		$t1,$a1,.foundEnough
FFFC15E0 001E0E13		add			$t2,$t2,#1				; next bucket
FFFC15E4 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC15E8 FE0804E3		beqz		$v0,.empty1
FFFC15EC FA000EE3		bra			.0003							; go back and find another run
                        	.foundEnough:
FFFC15F0 10300073		pfi
FFFC15F4 000EE833		mov			$v0,$t3						; v0 = start of run
FFFC15F8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	; This search starts at the top of the virtual address space and works its
                        	; way downwards. This is usually used for allocating stack space.
                        	;
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindStackRun:
FFFC15FC 01F97E93		and			$t3,$a0,#MAX_MID	; t3 = mid
FFFC1600 010E9E93		sll			$t3,$t3,#16				; shift into usable position
FFFC1604 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC1608 00001637		or			$t2,$t2,#PAGES_PER_MAP-1	; start looking at last page
FFFC160C FFF60613
FFFC1610 01C66E33
FFFC1614 000EEFB3		mov			$t5,$t3						; t5 = min in ASID
FFFC1618 10300073		pfi
                        	.0003:
FFFC161C 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
                        	.0001:
FFFC1620 10300073		pfi
FFFC1624 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC1628 00080A63		beqz		$v0,.empty0				; is it empty?
FFFC162C FFFE0E13		sub			$t2,$t2,#1
FFFC1630 FFFE78E3		bgeu		$t2,$t5,.0001
                        	.0002:
FFFC1634 FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC1638 00008067		ret
                        	.empty0:
                        	.empty1:
FFFC163C 10300073		pfi
FFFC1640 FFFE6AE3		bltu		$t2,$t5,.0002
FFFC1644 001D8D93		add			$t1,$t1,#1
FFFC1648 013DFA63		bgeu		$t1,$a1,.foundEnough
FFFC164C FFFE0E13		sub			$t2,$t2,#1				; next bucket
FFFC1650 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC1654 FE0804E3		beqz		$v0,.empty1
FFFC1658 FC0002E3		bra			.0003							; go back and find another run
                        	.foundEnough:
FFFC165C 10300073		pfi
FFFC1660 000E6833		mov			$v0,$t2						; v0 = start of run
FFFC1664 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = amount of memory to allocate
                        	; Modifies:
                        	;		a1,t0
                        	; Returns:
                        	;		v1 = pointer to allocated memory in virtual address space.
                        	;		v0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        	;
                        	AllocInCurrentAS:
                        		
FFFC1668 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC166C 00086933	mov			$a0,$v0
                        	Alloc:
FFFC1670 FD870713		sub			$sp,$sp,#40
FFFC1674 00173023		sto			$ra,[$sp]
FFFC1678 00473423		sto			$s1,8[$sp]				; these regs must be saved
FFFC167C 00573823		sto			$s2,16[$sp]
FFFC1680 00673C23		sto			$s3,24[$sp]
FFFC1684 10300073		pfi
                        		; First check if there are enough pages available in the system.
FFFC1688 00010637		add			$v0,$a1,#PAGESZ-1	; v0 = round memory request
FFFC168C FFF60613
FFFC1690 01360833
FFFC1694 01085813		srl			$v0,$v0,#LOG_PGSZ	; v0 = convert to pages required
FFFC1698 00025637		ldwu		$t0,NPAGES				; check number of pages available
FFFC169C 82860613
FFFC16A0 00060633
FFFC16A4 00065D03
FFFC16A8 010D7663		bleu		$v0,$t0,.enough
                        	.noRun2:
FFFC16AC 00006893		ldi			$v1,#0						; not enough, return null
FFFC16B0 06000E63		bra			.noRun
                        	.enough:
FFFC16B4 10300073		pfi
                        		; There are enough pages, but is there a run long enough in map space?
FFFC16B8 000862B3		mov			$s2,$v0						; save required # pages
FFFC16BC 000869B3		mov			$a1,$v0
FFFC16C0 ECDFF0EF		call		FindRun						; find a run of available slots
FFFC16C4 FE0844E3		blt			$v0,$x0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC16C8 00086233		mov			$s1,$v0						; s1 = start of run
FFFC16CC 00025637		ldwu		$s3,NPAGES				; decrease number of pages available in system
FFFC16D0 82860613
FFFC16D4 00060633
FFFC16D8 00065303
FFFC16DC 40530333		sub			$s3,$s3,$s2
FFFC16E0 00025637		stw			$s3,NPAGES
FFFC16E4 82860613
FFFC16E8 00060633
FFFC16EC 00661023
FFFC16F0 00086333		mov			$s3,$v0						; s3 = start of run
                        	.0001:
FFFC16F4 10300073		pfi
FFFC16F8 0800080D		palloc	$v0,$x0						; allocate a page (cheat and use hardware)
FFFC16FC 02080863		beqz		$v0,.noRun
FFFC1700 0268000D		mvmap		$x0,$v0,$s3				; map the page
FFFC1704 03273023		sto			$a0,32[$sp]
FFFC1708 04D06913		ldi			$a0,#'M'
FFFC170C BF9FE0EF		call		Putch
FFFC1710 02073903		ldo			$a0,32[$sp]
FFFC1714 00130313		add			$s3,$s3,#1				; next bucket
FFFC1718 FFF28293		sub			$s2,$s2,#1
FFFC171C FC504CE3		bgt			$s2,$x0,.0001
FFFC1720 01021893		sll			$v1,$s1,#LOG_PGSZ	; v1 = virtual address of allocated mem.
FFFC1724 00006813		ldi			$v0,#E_Ok
FFFC1728 00000663		bra			.xit
                        	.noRun:
FFFC172C 10300073		pfi
FFFC1730 00906813		ldi			$v0,#E_NotAlloc
                        	.xit
FFFC1734 10300073		pfi
FFFC1738 00073083		ldo			$ra,[$sp]					; restore saved regs
FFFC173C 00873203		ldo			$s1,8[$sp]
FFFC1740 01073283		ldo			$s2,16[$sp]
FFFC1744 01873303		ldo			$s3,24[$sp]
FFFC1748 02870713		add			$sp,$sp,#40
FFFC174C 00008067		ret
                        	
                        	_Alloc:
FFFC1750 FF870713		sub			$sp,$sp,#8
FFFC1754 00173023		sto			$ra,[$sp]
FFFC1758 F19FF0EF		call		Alloc
FFFC175C 00080463		beqz		$v0,.ok
FFFC1760 000068B3		mov			$v1,$x0
                        	.ok:
FFFC1764 10300073		pfi
FFFC1768 0008E833		mov			$v0,$v1
FFFC176C 00073083		ldo			$ra,[$sp]
FFFC1770 00870713		add			$sp,$sp,#8
FFFC1774 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a map. The stack is located at the highest
                        	; virtual address ($7FC00).
                        	;
                        	; Parameters:
                        	;		a0 = mid to allocate for
                        	;	Returns:
                        	;		v0 = physical address, 0 if unsuccessful
                        	;		v1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        	
                        	AllocStack:
FFFC1778 FF870713		sub			$sp,$sp,#8
FFFC177C 00173023		sto			$ra,[$sp]
FFFC1780 01091893		sll			$v1,$a0,#16			; 
FFFC1784 00001637		or			$v1,$v1,#PAGES_PER_MAP-1	; last page of memory is for stack
FFFC1788 FFF60613
FFFC178C 011668B3
FFFC1790 10300073		pfi
FFFC1794 0310080D		mvmap		$v0,$x0,$v1			; check if stack already allocated
FFFC1798 00081863		bnez		$v0,.0001
FFFC179C 0800080D		palloc	$v0,$x0					; allocate a page
FFFC17A0 02080063		beqz		$v0,.xit				; success?
FFFC17A4 0318000D		mvmap		$x0,$v0,$v1
                        	.0001:
FFFC17A8 10300073		pfi
FFFC17AC 00001637		and			$v1,$v1,#4095
FFFC17B0 FFF60613
FFFC17B4 011678B3
FFFC17B8 01081813		sll			$v0,$v0,#LOG_PGSZ			; convert pages to addresses
FFFC17BC 01089893		sll			$v1,$v1,#LOG_PGSZ
                        	.xit:
FFFC17C0 10300073		pfi
FFFC17C4 00073083		ldo			$ra,[$sp]
FFFC17C8 00870713		add			$sp,$sp,#8
FFFC17CC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a map including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		a0 = mid to free memory for
                        	;	Modifies:
                        	;		t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FreeAll:
FFFC17D0 00006E93		ldi			$t3,#0
FFFC17D4 01091F13		sll			$t4,$a0,#16
                        	.nxt:
FFFC17D8 10300073		pfi
FFFC17DC 00001637		slt			$t1,$t3,#PAGES_PER_MAP		; number of buckets to check
FFFC17E0 00060613
FFFC17E4 040D8A63		beqz		$t1,.0001
FFFC17E8 003F0637		and			$t4,$t4,#$3F0000
FFFC17EC 00060613
FFFC17F0 01E67F33
FFFC17F4 01DF6F33		or			$t4,$t4,$t3			; combine mid and bucket number
FFFC17F8 00006D13		ldi			$t0,#0					; new page number to set (indicates free)
FFFC17FC 03ED0D0D		mvmap		$t0,$t0,$t4			; get page mapping and set to zero
FFFC1800 001E8E93		add			$t3,$t3,#1			; advance to next bucket
FFFC1804 FC0D0AE3		beqz		$t0,.nxt				; 0 = no map in this bucket
FFFC1808 10300073		pfi
FFFC180C 0A0D000D		pfree		$t0							; free the page
FFFC1810 00025637		ldwu		$t0,NPAGES			; update the number of available pages
FFFC1814 82860613
FFFC1818 00060633
FFFC181C 00065D03
FFFC1820 001D0D13		add			$t0,$t0,#1
FFFC1824 00025637		stw			$t0,NPAGES
FFFC1828 82860613
FFFC182C 00060633
FFFC1830 01A61023
FFFC1834 FA0002E3		bra			.nxt
                        	.0001:
FFFC1838 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		a0 = map id
                        	;		a1 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v0 = physical address
                        	;------------------------------------------------------------------------------
                        	
                        	_VirtToPhys:
                        	VirtToPhys:
FFFC183C FF000837		ldi		$v0,#$FF000000
FFFC1840 00080813
FFFC1844 0309F863		bgeu	$a1,$v0,.notMapped
FFFC1848 0109DD13		srl		$t0,$a1,#LOG_PGSZ		; convert virt to page
FFFC184C 01091813		sll		$v0,$a0,#16
FFFC1850 01A86833		or		$v0,$v0,$t0					; and in mid
FFFC1854 10300073		pfi
FFFC1858 0300080D		mvmap	$v0,$x0,$v0					; get the translation
FFFC185C 01081813		sll		$v0,$v0,#LOG_PGSZ		; convert page to address
FFFC1860 00010637		and		$t0,$a1,#$FFFF			; insert LSB's
FFFC1864 FFF60613
FFFC1868 01367D33
FFFC186C 01A86833		or		$v0,$v0,$t0
FFFC1870 00008067		ret
                        	.notMapped:
FFFC1874 0009E833		mov		$v0,$a1
FFFC1878 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/pic.r5a",1
                        	.file "../fmtk/pic.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	;  0x80    - irq control for irq #0
                        	;  0x84    - irq control for irq #1
                        	;            bits 0 to 7  = cause code to issue
                        	;						 bit 8 to 9   = CPU select
                        	;            bits 13 to 15 = irq level to issue
                        	;            bit 16 = irq enable
                        	;            bit 17 = edge sensitivity
                        	
                        	PIC				equ		$FFDC0F00
                        	PIC_CH16	equ		$C0				; UART
                        	PIC_CH28	equ		$F0				; KBD
                        	PIC_CH31	equ		$FC				; VIA
                        	
                        	PicInit:
FFFC187C FFDC1DB7		ldi		$t1,#PIC					; t1 = address of pic
FFFC1880 F00D8D93
FFFC1884 0001ED37		ldi		$t0,#$0001E125		; level sensitive cause 37, interrupt enabled
FFFC1888 125D0D13
FFFC188C 0DADA023		stt		$t0,PIC_CH16[$t1]
FFFC1890 10300073		pfi
FFFC1894 0001ED37		ldi		$t0,#$0001E121		; level sensitive cause 33, interrupt enabled
FFFC1898 121D0D13
FFFC189C 0FADA823		stt		$t0,PIC_CH28[$t1]
FFFC18A0 0001ED37		ldi		$t0,#$0001E32F		; level sensitive cause 47, interrupt enabled, both CPU's notified
FFFC18A4 32FD0D13
FFFC18A8 0FADAE23		stt		$t0,PIC_CH31[$t1]
FFFC18AC 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        	.file "../fmtk/serial.r5a",29
                        		code
                        		align	8                        	
                        	SerialFuncTbl:
FFFC18B0 00000000		dco		0							; no operation
FFFC18B4 00000000
FFFC18B8 00000000		dco		0							; setup
FFFC18BC 00000000
FFFC18C0 00000000		dco		0							; initialize
FFFC18C4 00000000
FFFC18C8 00000000		dco		0							; status
FFFC18CC 00000000
FFFC18D0 00000000		dco		0							; media check
FFFC18D4 00000000
FFFC18D8 00000000		dco		0							; build BPB
FFFC18DC 00000000
FFFC18E0 00000000		dco		0							; open
FFFC18E4 00000000
FFFC18E8 00000000		dco		0							; close
FFFC18EC 00000000
FFFC18F0 FFFC1B1C		dco		SerialGetChar	; get char
FFFC18F4 00000000
FFFC18F8 FFFC1BFC		dco		SerialPeekChar
FFFC18FC 00000000
FFFC1900 00000000		dco		0							; get char direct
FFFC1904 00000000
FFFC1908 FFFC1C64		dco		SerialPeekCharDirect	; peek char direct
FFFC190C 00000000
FFFC1910 00000000		dco		0							; input status
FFFC1914 00000000
FFFC1918 FFFC1CC0		dco		SerialPutChar
FFFC191C 00000000
FFFC1920 00000000		dco		0							; reserved
FFFC1924 00000000
FFFC1928 00000000		dco		0							; set position
FFFC192C 00000000
FFFC1930 00000000		dco		0							; read block
FFFC1934 00000000
FFFC1938 00000000		dco		0							; write block
FFFC193C 00000000
FFFC1940 00000000		dco		0							; verify block
FFFC1944 00000000
FFFC1948 00000000		dco		0							; output status
FFFC194C 00000000
FFFC1950 00000000		dco		0							; flush input
FFFC1954 00000000
FFFC1958 00000000		dco		0							; flush output
FFFC195C 00000000
FFFC1960 FFFC1D88		dco		SerialIRQ			; IRQ routine
FFFC1964 00000000
FFFC1968 00000000		dco		0							; Is removable
FFFC196C 00000000
FFFC1970 00000000		dco		0							; ioctrl read
FFFC1974 00000000
FFFC1978 00000000		dco		0							; ioctrl write
FFFC197C 00000000
FFFC1980 00000000		dco		0							; output until busy
FFFC1984 00000000
FFFC1988 00000000		dco		0							; 27
FFFC198C 00000000
FFFC1990 00000000		dco		0
FFFC1994 00000000
FFFC1998 00000000		dco		0
FFFC199C 00000000
FFFC19A0 00000000		dco		0
FFFC19A4 00000000
FFFC19A8 00000000		dco		0							; 31
FFFC19AC 00000000
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC19B0 FF870713		sub		$sp,$sp,#8
FFFC19B4 00173023		sto		$ra,[$sp]
FFFC19B8 00506913		ldi		$a0,#5							; serial device
FFFC19BC FFFC29B7		ldi		$a1,#SerialFuncTbl
FFFC19C0 8B098993
FFFC19C4 10300073		pfi
FFFC19C8 458020EF		call	CopyDevFuncTbl
FFFC19CC 00026637		stt		$x0,SerHeadRcv
FFFC19D0 80060613
FFFC19D4 00060633
FFFC19D8 00062023
FFFC19DC 00026637		stt		$x0,SerTailRcv
FFFC19E0 80460613
FFFC19E4 00060633
FFFC19E8 00062023
FFFC19EC 00026637		stt		$x0,SerHeadXmit
FFFC19F0 80860613
FFFC19F4 00060633
FFFC19F8 00062023
FFFC19FC 00026637		stt		$x0,SerTailXmit
FFFC1A00 80C60613
FFFC1A04 00060633
FFFC1A08 00062023
FFFC1A0C 10300073		pfi
FFFC1A10 00026637		stb		$x0,SerRcvXon
FFFC1A14 81060613
FFFC1A18 00060633
FFFC1A1C 00060023
FFFC1A20 00026637		stb		$x0,SerRcvXoff
FFFC1A24 81160613
FFFC1A28 00060633
FFFC1A2C 00060023
FFFC1A30 00906D13		ldi		$t0,#$09						; dtr,rts active, rxint enabled, no parity
FFFC1A34 FFDC1637		stt		$t0,UART+8
FFFC1A38 A0860613
FFFC1A3C 00060633
FFFC1A40 01A62023
FFFC1A44 00060D37		ldi		$t0,#$0006001E			; reset the fifo's
FFFC1A48 01ED0D13
FFFC1A4C 10300073		pfi
FFFC1A50 FFDC1637		stt		$t0,UART+12
FFFC1A54 A0C60613
FFFC1A58 00060633
FFFC1A5C 01A62023
FFFC1A60 01E06D13		ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC1A64 FFDC1637		stt		$t0,UART+12
FFFC1A68 A0C60613
FFFC1A6C 00060633
FFFC1A70 01A62023
FFFC1A74 10300073		pfi
FFFC1A78 00073083		ldo		$ra,[$sp]
FFFC1A7C 00870713		add		$sp,$sp,#8
FFFC1A80 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialServiceInit:
FFFC1A84 00106913		ldi		$a0,#1			; start task
FFFC1A88 40006993		ldi		$a1,#1024		; memory required
FFFC1A8C FFFC2A37		ldi		$a2,#SerialService
FFFC1A90 A9CA0A13
FFFC1A94 00000073		ecall
FFFC1A98 00008067		ret
                        	SerialService:
FFFC1A9C DE870713		sub		$sp,$sp,#512+24
FFFC1AA0 00E06913		ldi		$a0,#14			; get current tid
FFFC1AA4 00000073		ecall
FFFC1AA8 20470A13		add		$a2,$sp,#516
FFFC1AAC 000869B3		mov		$a1,$v0
FFFC1AB0 00606913		ldi		$a0,#6			; alloc mailbox
FFFC1AB4 00000073		ecall
                        	
                        	SerialServiceLoop:
FFFC1AB8 00A06913		ldi		$a0,#10			; waitmsg
FFFC1ABC 20470993		add		$a1,$sp,#516
FFFC1AC0 20870A13		add		$a2,$sp,#520
FFFC1AC4 20C70A93		add		$a3,$sp,#524
FFFC1AC8 21070B13		add		$a4,$sp,#528
FFFC1ACC FFF06B93		ldi		$a5,#-1
FFFC1AD0 00000073		ecall
                        	
FFFC1AD4 00072D03		lw		$t0,[$sp]
FFFC1AD8 01FD7D13		and		$t0,$t0,#31
FFFC1ADC 001D1D13		sll		$t0,$t0,#1
FFFC1AE0 FFFC2637		lw		$t0,SerialFuncTbl[$t0]
FFFC1AE4 8B060613
FFFC1AE8 01A60633
FFFC1AEC 00062D03
FFFC1AF0 000D0067		jmp		[$t0]
                        	
                        	SerialFinishCmd:
FFFC1AF4 00C72983		lw		$a1,12[$sp]		; reply mbx
FFFC1AF8 00198993		add		$a1,$a1,#1		; -1 = no reply requested
FFFC1AFC 01298E63		beq		$a1,$a0,.0001
FFFC1B00 FFF98993		sub		$a1,$a1,#1
FFFC1B04 00906913		ldi		$a0,#9				; sendmsg
FFFC1B08 FFF06A13		ldi		$a2,#-1
FFFC1B0C FFF06A93		ldi		$a3,#-1
FFFC1B10 FFF06B13		ldi		$a4,#-1
FFFC1B14 00000073		ecall
                        	.0001:
FFFC1B18 FA1FF06F		jmp		SerialServiceLoop
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialGetChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. If the buffer is almost empty then send an
                        	; XON.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialGetChar:
FFFC1B1C FE870713			sub		$sp,$sp,#24
FFFC1B20 00173023			sto		$ra,[$sp]
FFFC1B24 01173423			sto		$v1,8[$sp]
FFFC1B28 00473823			sto		$s1,16[$sp]
FFFC1B2C 10300073			pfi
FFFC1B30 00026637			lb		$s1,SerRcvXon				; skip sending XON if already sent
FFFC1B34 81060613
FFFC1B38 00060633
FFFC1B3C 00060203
FFFC1B40 04021463			bne		$s1,$x0,.0002
FFFC1B44 208000EF			call	SerialRcvCount			; check number of chars in receive buffer
FFFC1B48 10300073			pfi
FFFC1B4C 00882813			slt		$v0,$v0,#8					; less than 8?
FFFC1B50 02080C63			beq		$v0,$x0,.0002
FFFC1B54 01106813			ldi		$v0,#XON						; if <8 send an XON
FFFC1B58 00026637			sb		$x0,SerRcvXoff			; clear XOFF status
FFFC1B5C 81160613
FFFC1B60 00060633
FFFC1B64 00060023
FFFC1B68 00026637			sb		$v0,SerRcvXon				; flag so we don't send it multiple times
FFFC1B6C 81060613
FFFC1B70 00060633
FFFC1B74 01060023
FFFC1B78 FFDC1637			sb		$v0,UART+UART_TRB
FFFC1B7C A0060613
FFFC1B80 00060633
FFFC1B84 01060023
                        	.0002:
FFFC1B88 10300073			pfi
FFFC1B8C 00026637			lbu		$v1,SerHeadRcv			; check if anything is in buffer
FFFC1B90 80060613
FFFC1B94 00060633
FFFC1B98 00064883
FFFC1B9C 00026637			lbu		$v0,SerTailRcv
FFFC1BA0 80460613
FFFC1BA4 00060633
FFFC1BA8 00064803
FFFC1BAC 03180863			beq		$v0,$v1,.noChars		; no?
FFFC1BB0 00025637			lb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC1BB4 00060613
FFFC1BB8 01160633
FFFC1BBC 00060803
FFFC1BC0 00188893			add		$v1,$v1,#1					; update head index
FFFC1BC4 10300073			pfi
FFFC1BC8 00026637			sb		$v1,SerHeadRcv				
FFFC1BCC 80060613
FFFC1BD0 00060633
FFFC1BD4 01160023
FFFC1BD8 00000663			bra		.xit
                        	.noChars:
                        	.0001:
FFFC1BDC 10300073			pfi
FFFC1BE0 FFF06813			ldi		$v0,#-1
                        	.xit
FFFC1BE4 10300073			pfi
FFFC1BE8 00073083			ldo		$ra,[$sp]
FFFC1BEC 00873883			ldo		$v1,8[$sp]
FFFC1BF0 01073203			ldo		$s1,16[$sp]
FFFC1BF4 01870713			add		$sp,$sp,#24
FFFC1BF8 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. But don't update the buffer indexes. No need
                        	; to send an XON here.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC1BFC FE870713		sub		$sp,$sp,#24
FFFC1C00 00173023		sto		$ra,[$sp]
FFFC1C04 01173423		sto		$v1,8[$sp]
FFFC1C08 00473823		sto		$s1,16[$sp]
FFFC1C0C 10300073		pfi
FFFC1C10 00026637		ldbu	$v1,SerHeadRcv			; check if anything is in buffer
FFFC1C14 80060613
FFFC1C18 00060633
FFFC1C1C 00064883
FFFC1C20 00026637		ldbu	$v0,SerTailRcv
FFFC1C24 80460613
FFFC1C28 00060633
FFFC1C2C 00064803
FFFC1C30 01180C63		beq		$v0,$v1,.noChars		; no?
FFFC1C34 00025637		ldb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC1C38 00060613
FFFC1C3C 01160633
FFFC1C40 00060803
FFFC1C44 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC1C48 FFF06813		ldi		$v0,#-1
                        	.xit
FFFC1C4C 10300073		pfi
FFFC1C50 00073083		ldo		$ra,[$sp]
FFFC1C54 00873883		ldo		$v1,8[$sp]
FFFC1C58 01073203		ldo		$s1,16[$sp]
FFFC1C5C 01870713		add		$sp,$sp,#24
FFFC1C60 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;		Get a character directly from the I/O port. This bypasses the input
                        	; buffer.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekCharDirect:
FFFC1C64 FE870713		sub		$sp,$sp,#24
FFFC1C68 00173023		sto		$ra,[$sp]
FFFC1C6C 01173423		sto		$v1,8[$sp]
FFFC1C70 00473823		sto		$s1,16[$sp]
FFFC1C74 10300073		pfi
FFFC1C78 FFDC1637		ldb		$v0,UART+UART_STAT
FFFC1C7C A0460613
FFFC1C80 00060633
FFFC1C84 00060803
FFFC1C88 00887813		and		$v0,$v0,#8					; look for Rx not empty
FFFC1C8C 00080C63		beq		$v0,$x0,.0001
FFFC1C90 FFDC1637		ldb		$v0,UART+UART_TRB
FFFC1C94 A0060613
FFFC1C98 00060633
FFFC1C9C 00060803
FFFC1CA0 00000463		bra		.xit
                        	.0001:
FFFC1CA4 FFF06813		ldi		$v0,#-1
                        	.xit:
FFFC1CA8 10300073		pfi
FFFC1CAC 00073083		ldo		$ra,[$sp]
FFFC1CB0 00873883		ldo		$v1,8[$sp]
FFFC1CB4 01073203		ldo		$s1,16[$sp]
FFFC1CB8 01870713		add		$sp,$sp,#24
FFFC1CBC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty. The routine will attempt to transmit the char up to 
                        	; 10 times. If it still can't transmit the char then sleep is called and the
                        	; task is put to sleep for a tick. When it wakes up the routine continues to
                        	; try and send a character.
                        	;
                        	; Stack Space
                        	;		5 words
                        	; Parameters:
                        	;		$a3 = character to put
                        	; Modifies:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
FFFC1CC0 FE870713		sub		$sp,$sp,#24
FFFC1CC4 01073023		sto		$v0,[$sp]
FFFC1CC8 00173423		sto		$ra,8[$sp]
FFFC1CCC 01173823		sto		$v1,16[$sp]
FFFC1CD0 10300073		pfi
                        	.0002:
FFFC1CD4 00A06893		ldi		$v1,#10
                        	.0001:
                        	;	sub		$v1,$v1,#1
                        	;	beq		$v1,$x0,.goSleep
FFFC1CD8 10300073		pfi
FFFC1CDC FFDC1637		ldb		$v0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC1CE0 A0460613
FFFC1CE4 00060633
FFFC1CE8 00060803
FFFC1CEC 01087813		and		$v0,$v0,#16					; bit #4 of the status reg
FFFC1CF0 FE0804E3		beqz	$v0,.0001						; branch if transmitter is not empty
FFFC1CF4 FFDC1637		stb		$a3,UART+UART_TRB		; send the byte
FFFC1CF8 A0060613
FFFC1CFC 00060633
FFFC1D00 01560023
FFFC1D04 00073803		ldo		$v0,[$sp]
FFFC1D08 00873083		ldo		$ra,8[$sp]
FFFC1D0C 01073883		ldo		$v1,16[$sp]
FFFC1D10 10300073		pfi
FFFC1D14 01870713		add		$sp,$sp,#24
FFFC1D18 00008067		ret
                        	.goSleep:
FFFC1D1C 10300073		pfi
FFFC1D20 FF070713		sub		$sp,$sp,#16
FFFC1D24 01273023		sto		$a0,[$sp]
FFFC1D28 01373423		sto		$a1,8[$sp]
FFFC1D2C 00506913		ldi		$a0,#5							; sleep function
FFFC1D30 00106993		ldi		$a1,#1							; 1 tick
FFFC1D34 00000073		ecall
FFFC1D38 10300073		pfi
FFFC1D3C 00073903		ldo		$a0,[$sp]
FFFC1D40 00873983		ldo		$a1,8[$sp]
FFFC1D44 01070713		add		$sp,$sp,#16
FFFC1D48 F80006E3		bra		.0002
                        	
                        	;------------------------------------------------------------------------------
                        	; Calculate number of character in input buffer
                        	;------------------------------------------------------------------------------
                        	
                        	SerialRcvCount:
FFFC1D4C 00026637		ldbu	$v0,SerTailRcv	; v0 = tail index
FFFC1D50 80460613
FFFC1D54 00060633
FFFC1D58 00064803
FFFC1D5C 00026637		ldbu	$v1,SerHeadRcv	; v1 = head index
FFFC1D60 80060613
FFFC1D64 00060633
FFFC1D68 00064883
FFFC1D6C 41180D33		sub		$t0,$v0,$v1
FFFC1D70 000D5863		bge		$t0,$x0,.xit
FFFC1D74 10006D13		ldi		$t0,#256
FFFC1D78 411D0D33		sub		$t0,$t0,$v1
FFFC1D7C 010D0D33		add		$t0,$t0,$v0
                        	.xit:
FFFC1D80 000D6833		mov		$v0,$t0
FFFC1D84 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialIRQ:
                        	.nxtByte:
FFFC1D88 00897D13		and		$t0,$a0,#$08				; bit 3 = rx full
FFFC1D8C 0C0D0063		beq		$t0,$x0,.notRxInt
FFFC1D90 FFDC1637		ldt		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC1D94 A0060613
FFFC1D98 00060633
FFFC1D9C 00062983
FFFC1DA0 00026637		ldbu	$t2,SerHeadRcv			; get buffer indexes
FFFC1DA4 80060613
FFFC1DA8 00060633
FFFC1DAC 00064E03
FFFC1DB0 00026637		ldbu	$t3,SerTailRcv
FFFC1DB4 80460613
FFFC1DB8 00060633
FFFC1DBC 00064E83
FFFC1DC0 001E8E93		add		$t3,$t3,#1					; see if buffer full
FFFC1DC4 0FFEFE93		and		$t3,$t3,#255
FFFC1DC8 09DE0263		beq		$t2,$t3,.rxFull
FFFC1DCC 00026637		stb		$t3,SerTailRcv			; update tail pointer
FFFC1DD0 80460613
FFFC1DD4 00060633
FFFC1DD8 01D60023
FFFC1DDC FFFE8E93		sub		$t3,$t3,#1
FFFC1DE0 0FFEFE13		and		$t2,$t3,#255
FFFC1DE4 00025637		stb		$a1,SerRcvBuf[$t2]	; store recieved byte in buffer
FFFC1DE8 00060613
FFFC1DEC 01C60633
FFFC1DF0 01360023
FFFC1DF4 00026637		ldb		$v0,SerRcvXoff			; check if xoff already sent
FFFC1DF8 81160613
FFFC1DFC 00060633
FFFC1E00 00060803
FFFC1E04 02081A63		bne		$v0,$x0,.0001
FFFC1E08 F45FF0EF		call	SerialRcvCount			; if more than 240 chars in buffer
FFFC1E0C 0F082813		slt		$v0,$v0,#240				; send an XOFF
FFFC1E10 02081463		bne		$v0,$x0,.0001
FFFC1E14 01306913		ldi		$a0,#XOFF
FFFC1E18 00026637		stb		$x0,SerRcvXon				; clear XON status
FFFC1E1C 81060613
FFFC1E20 00060633
FFFC1E24 00060023
FFFC1E28 00026637		stb		$a0,SerRcvXoff			; set XOFF status
FFFC1E2C 81160613
FFFC1E30 00060633
FFFC1E34 01260023
                        		stb		UART+UART_TRB
                        	.0001:
FFFC1E38 FFDC1637		ldt		$a0,UART+UART_STAT	; check the status for another byte
FFFC1E3C A0460613
FFFC1E40 00060633
FFFC1E44 00062903
FFFC1E48 F40000E3		bra		.nxtByte
                        	;	ldi		$a0,#$0B						; dtr,rts active, rxint disabled, no parity
                        	;	sw		$a0,UART+UART_CMD
                        	.rxFull:
                        	.notRxInt:
FFFC1E4C 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC1E50 10000073		eret
                        	
                        	nmeSerial:
FFFC1E54 69726553		db		"Serial",0
FFFC1E58 00006C61
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC1E5B 00000000		align	
FFFC1E5F 00000000
                        	
                        	ViaFuncTbl:
FFFC1E60 00000000		dco		0							; no operation
FFFC1E64 00000000
FFFC1E68 00000000		dco		0							; setup
FFFC1E6C 00000000
FFFC1E70 00000000		dco		0							; initialize
FFFC1E74 00000000
FFFC1E78 00000000		dco		0							; status
FFFC1E7C 00000000
FFFC1E80 00000000		dco		0							; media check
FFFC1E84 00000000
FFFC1E88 00000000		dco		0							; build BPB
FFFC1E8C 00000000
FFFC1E90 00000000		dco		0							; open
FFFC1E94 00000000
FFFC1E98 00000000		dco		0							; close
FFFC1E9C 00000000
FFFC1EA0 00000000		dco		0							; get char
FFFC1EA4 00000000
FFFC1EA8 00000000		dco		0							; Peek char
FFFC1EAC 00000000
FFFC1EB0 00000000		dco		0							; get char direct
FFFC1EB4 00000000
FFFC1EB8 00000000		dco		0							; peek char direct
FFFC1EBC 00000000
FFFC1EC0 00000000		dco		0							; input status
FFFC1EC4 00000000
FFFC1EC8 00000000		dco		0							; Put char
FFFC1ECC 00000000
FFFC1ED0 00000000		dco		0							; reserved
FFFC1ED4 00000000
FFFC1ED8 00000000		dco		0							; set position
FFFC1EDC 00000000
FFFC1EE0 00000000		dco		0							; read block
FFFC1EE4 00000000
FFFC1EE8 00000000		dco		0							; write block
FFFC1EEC 00000000
FFFC1EF0 00000000		dco		0							; verify block
FFFC1EF4 00000000
FFFC1EF8 00000000		dco		0							; output status
FFFC1EFC 00000000
FFFC1F00 00000000		dco		0							; flush input
FFFC1F04 00000000
FFFC1F08 00000000		dco		0							; flush output
FFFC1F0C 00000000
FFFC1F10 FFFC1FC8		dco		ViaIRQ				; IRQ routine
FFFC1F14 00000000
FFFC1F18 00000000		dco		0							; Is removable
FFFC1F1C 00000000
FFFC1F20 00000000		dco		0							; ioctrl read
FFFC1F24 00000000
FFFC1F28 00000000		dco		0							; ioctrl write
FFFC1F2C 00000000
FFFC1F30 00000000		dco		0							; output until busy
FFFC1F34 00000000
FFFC1F38 00000000		dco		0							; 27
FFFC1F3C 00000000
FFFC1F40 00000000		dco		0
FFFC1F44 00000000
FFFC1F48 00000000		dco		0
FFFC1F4C 00000000
FFFC1F50 00000000		dco		0
FFFC1F54 00000000
FFFC1F58 00000000		dco		0							; 31
FFFC1F5C 00000000
                        	
                        	;------------------------------------------------------------------------------
                        	; ViaInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	ViaInit:
FFFC1F60 FF870713		sub		$sp,$sp,#8
FFFC1F64 00173023		sto		$ra,[$sp]
FFFC1F68 00F06913		ldi		$a0,#15							; VIA device
FFFC1F6C FFFC29B7		ldi		$a1,#ViaFuncTbl
FFFC1F70 E6098993
FFFC1F74 10300073		pfi
FFFC1F78 6A9010EF		call	CopyDevFuncTbl
                        		; Initialize port A low order eight bits as output, the remaining bits as
                        		; input.
FFFC1F7C FFDC0DB7		ldi		$t1,#VIA
FFFC1F80 600D8D93
FFFC1F84 0FF06D13		ldi		$t0,#$000000FF
FFFC1F88 01ADA623		stt		$t0,VIA_DDRA[$t1]
FFFC1F8C 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC1F90 10300073		pfi
FFFC1F94 03AD88A3		stb		$t0,VIA_PCR+1[$t1]
FFFC1F98 01F06D13		ldi		$t0,#$1F
FFFC1F9C 03AD86A3		stb		$t0,VIA_ACR+1[$t1]		; set timer 3 mode, timer 1/2 = 64 bit
FFFC1FA0 0016ED37		ldi		$t0,#$0016E360			;	divider value for 33.333Hz (30 ms)
FFFC1FA4 360D0D13
FFFC1FA8 01ADA823		stt		$t0,VIA_T1CL[$t1]
FFFC1FAC 000DAA23		stt		$x0,VIA_T1CH[$t1]		; trigger transfer to count registers
FFFC1FB0 10300073		pfi
FFFC1FB4 18006D13		ldi		$t0,#$180						; enable timer3 interrupts
FFFC1FB8 03ADAC23		stt		$t0,VIA_IER[$t1]
FFFC1FBC 00073083		ldo		$ra,[$sp]
FFFC1FC0 00870713		add		$sp,$sp,#8
FFFC1FC4 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Only one cpu need reset the VIA timer.
                        	; Both cpus are notified of a VIA timer interrupt in order to allow the
                        	; scheduler to run for both cpus.
                        	;------------------------------------------------------------------------------
                        	
                        	ViaIRQ:
FFFC1FC8 F1001DF3		csrrw	$t1,#$F10,$x0
FFFC1FCC 020DFD93		and		$t1,$t1,#$20
FFFC1FD0 040D9A63		bnez	$t1,.hart20
                        		; Was it the VIA that caused the interrupt?
FFFC1FD4 FFDC0DB7		ldi		$t1,#VIA
FFFC1FD8 600D8D93
FFFC1FDC 034D8D03		ldb		$t0,VIA_IFR[$t1]
FFFC1FE0 040D5463		bge		$t0,$x0,.0003				; no
FFFC1FE4 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC1FE8 03AD88A3		stb		$t0,VIA_PCR+1[$t1]
FFFC1FEC 010DAD03		ldt		$t0,VIA_T1CL[$t1]		; yes, clear interrupt
FFFC1FF0 00014637		ldo		$t0,milliseconds
FFFC1FF4 20860613
FFFC1FF8 00060633
FFFC1FFC 00063D03
FFFC2000 01ED0D13		add		$t0,$t0,#30
FFFC2004 00014637		sto		$t0,milliseconds
FFFC2008 20860613
FFFC200C 00060633
FFFC2010 01A63023
FFFC2014 00014637		stt		$t0,switchflag
FFFC2018 20060613
FFFC201C 00060633
FFFC2020 01A62023
                        	.hart20:
FFFC2024 459000EF		call	FMTK_SchedulerIRQ
                        	.0003:
FFFC2028 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC202C 10000073		eret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/video.r5a",1
                        	.file "../fmtk/video.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TC64CursorAddr	equ		$FFD1DF1C
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        		align	8                        	
                        	VideoFuncTbl:
FFFC2030 00000000		dco		0							; no operation
FFFC2034 00000000
FFFC2038 00000000		dco		0							; setup
FFFC203C 00000000
FFFC2040 00000000		dco		0							; initialize
FFFC2044 00000000
FFFC2048 00000000		dco		0							; status
FFFC204C 00000000
FFFC2050 00000000		dco		0							; media check
FFFC2054 00000000
FFFC2058 00000000		dco		0							; build BPB
FFFC205C 00000000
FFFC2060 00000000		dco		0							; open
FFFC2064 00000000
FFFC2068 00000000		dco		0							; close
FFFC206C 00000000
FFFC2070 00000000		dco		0							; get char
FFFC2074 00000000
FFFC2078 00000000		dco		0							; Peek char
FFFC207C 00000000
FFFC2080 00000000		dco		0							; get char direct
FFFC2084 00000000
FFFC2088 00000000		dco		0							; peek char direct
FFFC208C 00000000
FFFC2090 00000000		dco		0							; input status
FFFC2094 00000000
FFFC2098 FFFC2258		dco		VideoPutChar	; Put char
FFFC209C 00000000
FFFC20A0 00000000		dco		0							; reserved
FFFC20A4 00000000
FFFC20A8 00000000		dco		0							; set position
FFFC20AC 00000000
FFFC20B0 00000000		dco		0							; read block
FFFC20B4 00000000
FFFC20B8 00000000		dco		0							; write block
FFFC20BC 00000000
FFFC20C0 00000000		dco		0							; verify block
FFFC20C4 00000000
FFFC20C8 00000000		dco		0							; output status
FFFC20CC 00000000
FFFC20D0 00000000		dco		0							; flush input
FFFC20D4 00000000
FFFC20D8 00000000		dco		0							; flush output
FFFC20DC 00000000
FFFC20E0 FFFC2614		dco		VideoIRQ			; IRQ routine
FFFC20E4 00000000
FFFC20E8 00000000		dco		0							; Is removable
FFFC20EC 00000000
FFFC20F0 00000000		dco		0							; ioctrl read
FFFC20F4 00000000
FFFC20F8 00000000		dco		0							; ioctrl write
FFFC20FC 00000000
FFFC2100 00000000		dco		0							; output until busy
FFFC2104 00000000
FFFC2108 00000000		dco		0							; 27
FFFC210C 00000000
FFFC2110 00000000		dco		0
FFFC2114 00000000
FFFC2118 00000000		dco		0
FFFC211C 00000000
FFFC2120 00000000		dco		0
FFFC2124 00000000
FFFC2128 00000000		dco		0							; 31
FFFC212C 00000000
                        	
                        	;------------------------------------------------------------------------------
                        	; VideoInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	VideoInit:
FFFC2130 FF870713		sub		$sp,$sp,#8
FFFC2134 00173023		sto		$ra,[$sp]
FFFC2138 00206913		ldi		$a0,#2							; Video device
FFFC213C FFFC29B7		ldi		$a1,#VideoFuncTbl
FFFC2140 03098993
FFFC2144 10300073		pfi
FFFC2148 4D9010EF		call	CopyDevFuncTbl
FFFC214C 00025637		stb		$x0,CursorX
FFFC2150 80060613
FFFC2154 00060633
FFFC2158 00060023
FFFC215C 00025637		stb		$x0,CursorY
FFFC2160 80160613
FFFC2164 00060633
FFFC2168 00060023
FFFC216C 000F0D37		ldi		$t0,#$000F0000
FFFC2170 000D0D13
FFFC2174 00025637		stt		$t0,DispAttr
FFFC2178 80860613
FFFC217C 00060633
FFFC2180 01A62023
FFFC2184 00210D37		ldi		$t0,#$0020FFFF
FFFC2188 FFFD0D13
FFFC218C 00025637		stt		$t0,DispAttr+4
FFFC2190 80C60613
FFFC2194 00060633
FFFC2198 01A62023
FFFC219C 10300073		pfi
FFFC21A0 010000EF		call	VideoClearScreen
FFFC21A4 00073083		ldo		$ra,[$sp]
FFFC21A8 00870713		add		$sp,$sp,#8
FFFC21AC 00008067		ret
                        	
                        	VideoClearScreen:
                        	;	csrrs	$x0,#$300,#1				; interrupts on
FFFC21B0 65806D13		ldi		$t0,#56*29
FFFC21B4 00025637		ldo		$t1,DispAttr
FFFC21B8 80860613
FFFC21BC 00060633
FFFC21C0 00063D83
FFFC21C4 020DED93		or		$t1,$t1,#' '
                        		
                        		
FFFC21C8 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC21CC 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC21D0 33883803		ldo		$v0,TCBpVideo[$v0]
FFFC21D4 FFD00837		ldi		$v0,#$FFD00000
FFFC21D8 00080813
                        	.0001:
FFFC21DC 10300073		pfi
FFFC21E0 01B83023		sto		$t1,[$v0]	
FFFC21E4 00880813		add		$v0,$v0,#8
FFFC21E8 FFFD0D13		sub		$t0,$t0,#1
FFFC21EC FFA048E3		bgt		$t0,$x0,.0001
FFFC21F0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoHomeCursor:
FFFC21F4 00025637		stb		$x0,CursorX
FFFC21F8 80060613
FFFC21FC 00060633
FFFC2200 00060023
FFFC2204 00025637		stb		$x0,CursorY
FFFC2208 80160613
FFFC220C 00060633
FFFC2210 00060023
                        		; fall through into update cursor pos.
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	UpdateCursorPos:
FFFC2214 00025637		ldbu	$t0,CursorY
FFFC2218 80160613
FFFC221C 00060633
FFFC2220 00064D03
FFFC2224 03806D93		ldi		$t1,#56
FFFC2228 10300073		pfi
FFFC222C 03BD0D33		mul		$t0,$t0,$t1
FFFC2230 00025637		ldbu	$t1,CursorX
FFFC2234 80060613
FFFC2238 00060633
FFFC223C 00064D83
FFFC2240 01BD0D33		add		$t0,$t0,$t1
FFFC2244 FFD1E637		stw		$t0,TC64CursorAddr
FFFC2248 F1C60613
FFFC224C 00060633
FFFC2250 01A61023
FFFC2254 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a3 = character to display
                        	;------------------------------------------------------------------------------
                        	
                        	VideoPutChar:
FFFC2258 FF070713		sub		$sp,$sp,#16
FFFC225C 00173023		sto		$ra,[$sp]
FFFC2260 00473423		sto		$s1,8[$sp]
FFFC2264 00D06D13		ldi		$t0,#CR
FFFC2268 10300073		pfi
FFFC226C 1BAA8063		beq		$a3,$t0,.doCR
FFFC2270 00A06D13		ldi		$t0,#$0A				; line feed
FFFC2274 1BAA8A63		beq		$a3,$t0,.doLF
FFFC2278 00C06D13		ldi		$t0,#$0C				; CTRL-L
FFFC227C 29AA8263		beq		$a3,$t0,.doCls
FFFC2280 09106D13		ldi		$t0,#$91
FFFC2284 10300073		pfi
FFFC2288 1BAA8A63		beq		$a3,$t0,.cursorRight
FFFC228C 09306D13		ldi		$t0,#$93
FFFC2290 1FAA8463		beq		$a3,$t0,.cursorLeft
FFFC2294 09006D13		ldi		$t0,#$90
FFFC2298 21AA8663		beq		$a3,$t0,.cursorUp
FFFC229C 09206D13		ldi		$t0,#$92
FFFC22A0 10300073		pfi
FFFC22A4 23AA8663		beq		$a3,$t0,.cursorDown
FFFC22A8 00806D13		ldi		$t0,#BS
FFFC22AC 27AA8463		beq		$a3,$t0,.backspace
FFFC22B0 09906D13		ldi		$t0,#$99
FFFC22B4 31AA8263		beq		$a3,$t0,.delete
FFFC22B8 10300073		pfi
                        		
                        		
FFFC22BC 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC22C0 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC22C4 33883803		ldo		$v0,TCBpVideo[$v0]
FFFC22C8 FFD00837		ldi		$v0,#$FFD00000
FFFC22CC 00080813
FFFC22D0 00086D33	mov		$t0,$v0
FFFC22D4 00025637		ldbu	$t1,CursorX
FFFC22D8 80060613
FFFC22DC 00060633
FFFC22E0 00064D83
FFFC22E4 003D9D93		sll		$t1,$t1,#3						; *8 bytes per display cell
FFFC22E8 01BD6D33		or		$t0,$t0,$t1						; add in base address
FFFC22EC 00025637		ldbu	$t1,CursorY
FFFC22F0 80160613
FFFC22F4 00060633
FFFC22F8 00064D83
FFFC22FC 10300073		pfi
FFFC2300 1C006E13		ldi		$t2,#56*8
FFFC2304 03CD8DB3		mul		$t1,$t1,$t2
FFFC2308 01BD0D33		add		$t0,$t0,$t1
FFFC230C 00025637		ldo		$t1,DispAttr
FFFC2310 80860613
FFFC2314 00060633
FFFC2318 00063D83
FFFC231C 10300073		pfi
FFFC2320 015DEDB3		or		$t1,$t1,$a3
FFFC2324 01BD3023		sto		$t1,[$t0]							; store to screen memory
FFFC2328 00025637		ldbu	$t0,CursorX						; increment cursor position
FFFC232C 80060613
FFFC2330 00060633
FFFC2334 00064D03
FFFC2338 001D0D13		add		$t0,$t0,#1
FFFC233C 03806D93		ldi		$t1,#56
FFFC2340 10300073		pfi
FFFC2344 0BBD4663		blt		$t0,$t1,.saveX
FFFC2348 00006D13		ldi		$t0,#0
                        	.doLF1:
FFFC234C 10300073		pfi
FFFC2350 00025637		ldbu	$t2,CursorY
FFFC2354 80160613
FFFC2358 00060633
FFFC235C 00064E03
FFFC2360 001E0E13		add		$t2,$t2,#1
FFFC2364 01D06D93		ldi		$t1,#29
FFFC2368 07BE4C63		blt		$t2,$t1,.saveY
                        		; scroll up
FFFC236C 62006E93		ldi		$t3,#56*28
                        		
                        		
FFFC2370 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC2374 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC2378 33883803		ldo		$v0,TCBpVideo[$v0]
FFFC237C FFD00837		ldi		$v0,#$FFD00000
FFFC2380 00080813
                        	;	ldi		$t4,#$FFD00000
FFFC2384 00086F33		mov		$t4,$v0
                        	.0001:
FFFC2388 10300073		pfi
FFFC238C 1C0F3F83		ldo		$t5,56*8[$t4]
FFFC2390 01FF3023		sto		$t5,[$t4]
FFFC2394 008F0F13		add		$t4,$t4,#8
FFFC2398 FFFE8E93		sub		$t3,$t3,#1
FFFC239C FFD046E3		bgt		$t3,$x0,.0001
                        		; blank last line
FFFC23A0 00025637		ldo		$t5,DispAttr
FFFC23A4 80860613
FFFC23A8 00060633
FFFC23AC 00063F83
FFFC23B0 020FEF93		or		$t5,$t5,#' '
FFFC23B4 03806E93		ldi		$t3,#56
                        	.bll1:
FFFC23B8 10300073		pfi
FFFC23BC 01FF3023		sto		$t5,[$t4]
FFFC23C0 008F0F13		add		$t4,$t4,#8
FFFC23C4 FFFE8E93		sub		$t3,$t3,#1
FFFC23C8 FFD048E3		bgt		$t3,$x0,.bll1
                        	.xit:
FFFC23CC 10300073		pfi
FFFC23D0 00073083		ldo		$ra,[$sp]
FFFC23D4 00873203		ldo		$s1,8[$sp]
FFFC23D8 01070713		add		$sp,$sp,#16
FFFC23DC 00008067		ret
                        	.saveY:
FFFC23E0 00025637		stb		$t2,CursorY
FFFC23E4 80160613
FFFC23E8 00060633
FFFC23EC 01C60023
                        	.saveX:
FFFC23F0 10300073		pfi
FFFC23F4 00025637		stb		$t0,CursorX
FFFC23F8 80060613
FFFC23FC 00060633
FFFC2400 01A60023
FFFC2404 E11FF0EF		call	UpdateCursorPos
FFFC2408 FC0002E3		bra		.xit
                        	.doCR:
FFFC240C 00025637		stb		$x0,CursorX
FFFC2410 80060613
FFFC2414 00060633
FFFC2418 00060023
FFFC241C 10300073		pfi
FFFC2420 DF5FF0EF		call	UpdateCursorPos
FFFC2424 FA0004E3		bra		.xit
                        	.doLF:
FFFC2428 00025637		ldbu	$t0,CursorX
FFFC242C 80060613
FFFC2430 00060633
FFFC2434 00064D03
FFFC2438 F0000AE3		bra		.doLF1
                        	.cursorRight:
FFFC243C 10300073		pfi
FFFC2440 00025637		ldbu	$t0,CursorX
FFFC2444 80060613
FFFC2448 00060633
FFFC244C 00064D03
FFFC2450 001D0D13		add		$t0,$t0,#1
FFFC2454 03706D93		ldi		$t1,#55
FFFC2458 01BD5E63		bge		$t0,$t1,.cr1
FFFC245C 00025637		stb		$t0,CursorX
FFFC2460 80060613
FFFC2464 00060633
FFFC2468 01A60023
                        	.cr2:
FFFC246C 10300073		pfi
FFFC2470 DA5FF0EF		call	UpdateCursorPos
                        	.cr1:
FFFC2474 F4000CE3		bra		.xit
                        	.cursorLeft:
FFFC2478 00025637		ldbu	$t0,CursorX
FFFC247C 80060613
FFFC2480 00060633
FFFC2484 00064D03
FFFC2488 FFFD0D13		sub		$t0,$t0,#1
FFFC248C FE0D44E3		blt		$t0,$x0,.cr1
FFFC2490 00025637		stb		$t0,CursorX
FFFC2494 80060613
FFFC2498 00060633
FFFC249C 01A60023
FFFC24A0 FC0006E3		bra		.cr2
                        	.cursorUp:
FFFC24A4 00025637		ldbu	$t0,CursorY
FFFC24A8 80160613
FFFC24AC 00060633
FFFC24B0 00064D03
FFFC24B4 FFFD0D13		sub		$t0,$t0,#1
FFFC24B8 FA0D4EE3		blt		$t0,$x0,.cr1
FFFC24BC 00025637		stb		$t0,CursorY
FFFC24C0 80160613
FFFC24C4 00060633
FFFC24C8 01A60023
FFFC24CC FA0000E3		bra		.cr2
                        	.cursorDown:
FFFC24D0 00025637		ldbu	$t0,CursorY
FFFC24D4 80160613
FFFC24D8 00060633
FFFC24DC 00064D03
FFFC24E0 001D0D13		add		$t0,$t0,#1
FFFC24E4 01D06D93		ldi		$t1,#29
FFFC24E8 F9BD56E3		bge		$t0,$t1,.cr1
FFFC24EC 00025637		stb		$t0,CursorY
FFFC24F0 80160613
FFFC24F4 00060633
FFFC24F8 01A60023
FFFC24FC F60008E3		bra		.cr2
                        	.doCls:
FFFC2500 10300073		pfi
FFFC2504 CADFF0EF		call	VideoClearScreen
FFFC2508 CEDFF0EF		call	VideoHomeCursor
FFFC250C 10300073		pfi
FFFC2510 F60002E3		bra		.cr1
                        	.backspace:
FFFC2514 00025637		ldbu	$t0,CursorX
FFFC2518 80060613
FFFC251C 00060633
FFFC2520 00064D03
FFFC2524 F40D08E3		beqz	$t0,.cr1
FFFC2528 FFFD0D13		sub		$t0,$t0,#1
FFFC252C 00025637		stb		$t0,CursorX
FFFC2530 80060613
FFFC2534 00060633
FFFC2538 01A60023
                        	.del0001:
FFFC253C 10300073		pfi
FFFC2540 03706213		ldi		$s1,#55
FFFC2544 41A20233		sub		$s1,$s1,$t0
FFFC2548 CCDFF0EF		call	UpdateCursorPos
FFFC254C 10300073		pfi
FFFC2550 00025637		ldbu	$t1,CursorY
FFFC2554 80160613
FFFC2558 00060633
FFFC255C 00064D83
FFFC2560 1C006E93		ldi		$t3,#56*8
FFFC2564 03DD8DB3		mul		$t1,$t1,$t3
FFFC2568 003D1D13		sll		$t0,$t0,#3
FFFC256C 01AD8EB3		add		$t3,$t1,$t0
FFFC2570 FFD00637		add		$t3,$t3,#$FFD00000
FFFC2574 00060613
FFFC2578 01D60EB3
FFFC257C 00020E63		beqz	$s1,.bs0001
                        	.bs0002:
FFFC2580 10300073		pfi
FFFC2584 008EBF03		ldo		$t4,8[$t3]
FFFC2588 01EEB023		sto		$t4,[$t3]
FFFC258C 008E8E93		add		$t3,$t3,#8
FFFC2590 FFF20213		sub		$s1,$s1,#1
FFFC2594 FFFFC6E3		bgt		$s1,.bs0002
                        	.bs0001:
FFFC2598 10300073		pfi
FFFC259C 00025637		ldo		$t4,DispAttr
FFFC25A0 80860613
FFFC25A4 00060633
FFFC25A8 00063F03
FFFC25AC 020F6F13		or		$t4,$t4,#' '
FFFC25B0 01EEB423		sto		$t4,8[$t3]
FFFC25B4 E0000CE3		bra		.xit
                        	.delete:
FFFC25B8 00025637		ldbu	$t0,CursorX
FFFC25BC 80060613
FFFC25C0 00060633
FFFC25C4 00064D03
FFFC25C8 10300073		pfi
FFFC25CC F60008E3		bra		.del0001	
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1  = pointer to null terminated string
                        	;------------------------------------------------------------------------------
                        	
                        	VideoPutString:
FFFC25D0 FF870713		sub		$sp,$sp,#8
FFFC25D4 00173023		sto		$ra,[$sp]
                        	.again:
FFFC25D8 10300073		pfi
FFFC25DC 00010D37		ldi		$t0,#$10000
FFFC25E0 000D0D13
FFFC25E4 300D2073		csrrs	$x0,#$300,$t0		; set mprv
FFFC25E8 0009CA83		ldbu	$a3,[$a1]				; access using passed in memory space
FFFC25EC 300D3073		csrrc	$x0,#$300,$t0		; clear mprv
FFFC25F0 00198993		add		$a1,$a1,#1
FFFC25F4 000A8863		beqz	$a3,.done
FFFC25F8 10300073		pfi
FFFC25FC C5DFF0EF		call	VideoPutChar
FFFC2600 FC000CE3		bra		.again
                        	.done:
FFFC2604 10300073		pfi
FFFC2608 00073083		ldo		$ra,[$sp]
FFFC260C 00870713		add		$sp,$sp,#8
FFFC2610 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoIRQ:
                        		; Was it the Video that caused the interrupt?
                        	.0003:
FFFC2614 10000073		eret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/task.r5a",25
                        		code
                        		align	2                        	
                        	OSCallTbl:
FFFC2618 2E8801F8		dh		FMTK_Initialize					; 0
FFFC261A 30502E88		dh		FMTK_StartTask					; 1
FFFC261C 307C3050		dh		FMTK_ExitTask
FFFC261E 01FC307C		dh		FMTK_KillTask
FFFC2620 2BC001FC		dh		FMTK_SetTaskPriority
FFFC2622 321C2BC0		dh		FMTK_Sleep							; 5
FFFC2624 331C321C		dh		FMTK_AllocMbx
FFFC2626 0200331C		dh		FMTK_FreeMbx
FFFC2628 34200200		dh		FMTK_PostMsg
FFFC262A 36FC3420		dh		FMTK_SendMsg
FFFC262C 35B436FC		dh		FMTK_WaitMsg						; 10
FFFC262E 020435B4		dh		FMTK_PeekMsg
FFFC2630 28A40204		dh		FMTK_StartApp
FFFC2632 27E428A4		dh		FMTK_SaveContext				; 13
FFFC2634 398027E4		dh		FMTK_GetCurrentTid
FFFC2636 00003980		dh		DumpReadyList
FFFC2638 00000000		dh		0
FFFC263A 00000000		dh		0
FFFC263C 00000000		dh		0
FFFC263E 3B480000		dh		0
FFFC2640 3BA43B48		dh		FMTK_HasIOFocus					; 20
FFFC2642 3CF43BA4		dh		FMTK_SwitchIOFocus			; 21
FFFC2644 3CFC3CF4		dh		FMTK_ReleaseIOFocus			; 22
FFFC2646 3C5C3CFC		dh		FMTK_ForceReleaseIOFocus	; 23
FFFC2648 00003C5C		dh		FMTK_RequestIOFocus			; 24
FFFC264A 3DD80000		dh		0
FFFC264C 00003DD8		dh		FMTK_IO									; 26
                        	
                        	qToChk:
FFFC264E 01000000		db	0,0,0,1,0,0,2,1
FFFC2652 01020000
FFFC2656 01030000		db	0,0,3,1,0,0,2,1
FFFC265A 01020000
FFFC265E 01000000		db	0,0,0,1,0,0,2,1
FFFC2662 01020000
FFFC2666 01030000		db	0,0,3,1,0,0,2,1
FFFC266A 01020000
                        	
FFFC266E 00010000		align	
                        	
                        	
                        	InitialPidmap:
FFFC2670 F0000001		dco		$F0000001F0000001
FFFC2674 F0000001
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTKInit:
FFFC2678 00024637		stt		$x0,QNDX
FFFC267C 30460613
FFFC2680 00060633
FFFC2684 00062023
FFFC2688 FFFC2637		ldo		$t0,InitialPidmap
FFFC268C 67060613
FFFC2690 00060633
FFFC2694 00063D03
FFFC2698 00024637		sto		$t0,PIDMAP
FFFC269C 31060613
FFFC26A0 00060633
FFFC26A4 01A63023
FFFC26A8 00024637		stt		$x0,missed_ticks
FFFC26AC 32060613
FFFC26B0 00060633
FFFC26B4 00062023
FFFC26B8 FFF06D13		ldi		$t0,#-1
FFFC26BC 00024637		stt		$t0,TimeoutList
FFFC26C0 32860613
FFFC26C4 00060633
FFFC26C8 01A62023
FFFC26CC 00024637		stt		$t0,READYQ
FFFC26D0 30860613
FFFC26D4 00060633
FFFC26D8 01A62023
FFFC26DC 00024637		stt		$t0,READYQ+4
FFFC26E0 30C60613
FFFC26E4 00060633
FFFC26E8 01A62023
FFFC26EC 00025637		stw		$t0,hKeybdMbx
FFFC26F0 82260613
FFFC26F4 00060633
FFFC26F8 01A61023
FFFC26FC 10300073		pfi
FFFC2700 00025637		stb		$x0,SwitchIOFocus	
FFFC2704 82060613
FFFC2708 00060633
FFFC270C 00060023
FFFC2710 00025637		stt		$x0,IOFocusTbl
FFFC2714 81860613
FFFC2718 00060633
FFFC271C 00062023
FFFC2720 00025637		stt		$t0,IOFocusNdx
FFFC2724 81060613
FFFC2728 00060633
FFFC272C 01A62023
                        	
                        		; zero out device function table
FFFC2730 00022D37		ldi		$t0,#DVF_Base
FFFC2734 000D0D13
FFFC2738 40006D93		ldi		$t1,#32*32
                        	.0003:
FFFC273C 10300073		pfi
FFFC2740 000D3023		sto		$x0,[$t0]
FFFC2744 008D0D13		add		$t0,$t0,#8
FFFC2748 FFFD8D93		sub		$t1,$t1,#1
FFFC274C FFB048E3		bgt		$t1,$x0,.0003
                        	
                        		; Initialize mailboxes
FFFC2750 00020D37		ldi		$t0,#mbxs
FFFC2754 000D0D13
FFFC2758 08006D93		ldi		$t1,#4*32
                        	.0001:
FFFC275C 10300073		pfi
FFFC2760 000D3023		sto		$x0,[$t0]
FFFC2764 008D0D13		add		$t0,$t0,#8
FFFC2768 FFFD8D93		sub		$t1,$t1,#1
FFFC276C FFB048E3		bgt		$t1,$x0,.0001
                        	
                        		; Initialize free message list
FFFC2770 00010D37		ldi		$t0,#msgs
FFFC2774 000D0D13
FFFC2778 00024637		sto		$t0,FreeMsg
FFFC277C 35060613
FFFC2780 00060633
FFFC2784 01A63023
FFFC2788 00006D93		ldi		$t1,#0
FFFC278C 00001E37		ldi		$t2,#NR_MSG
FFFC2790 800E0E13
                        	.0002:
FFFC2794 10300073		pfi
FFFC2798 001D8D93		add		$t1,$t1,#1
FFFC279C 01BD3023		sto		$t1,MSG_LINK[$t0]
FFFC27A0 020D0D13		add		$t0,$t0,#32
FFFC27A4 FFFE0E13		sub		$t2,$t2,#1
FFFC27A8 FFC046E3		bgt		$t2,$x0,.0002
                        	
                        		; Initialize TCB's
FFFC27AC 03F06D13		ldi		$t0,#MAX_TID
FFFC27B0 00006D93		ldi		$t1,#TS_NONE
                        	.0004:
FFFC27B4 014D1E13		sll		$t2,$t0,#LOG_TCBSIZE
FFFC27B8 29BE0423		stb		$t1,TCBStatus[$t2]
FFFC27BC FFFD0D13		sub		$t0,$t0,#1
FFFC27C0 FE0D5AE3		bge		$t0,$x0,.0004
                        	
                        		; unlock the system semaphore	
                        		
FFFC27C4 FFF06813		ldi		v0,#-1
FFFC27C8 00024637		sw		v0,SysSema
FFFC27CC 34060613
FFFC27D0 00060633
FFFC27D4 01062023
                        	
FFFC27D8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	GetCurrentTid:
                        	;	csrrw	$v0,#$F10,$x0				; get current hart id
                        	;	and		$v0,$v0,#MAX_TID		; mask off extra bits
                        		
FFFC27DC 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC27E0 00008067	ret
                        	
                        	FMTK_GetCurrentTid:
FFFC27E4 3000E073		csrrs	$x0,#$300,#1				; enable ints
                        		
FFFC27E8 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC27EC 000868B3	mov		$v1,$v0
FFFC27F0 00006813		ldi		$v0,#E_Ok
FFFC27F4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = map id
                        	;------------------------------------------------------------------------------
                        	
                        	MapOSPages:
FFFC27F8 00306813		ldi			$v0,#OSPAGES	; number of pages pre-mapped
FFFC27FC 00006893		ldi			$v1,#0
FFFC2800 01091893		sll			$v1,$a0,#16		; put ASID in proper spot
                        	.nxt:
FFFC2804 10300073		pfi
FFFC2808 0318800D		mvmap		$x0,$v1,$v1
FFFC280C 03100D0D		mvmap		$t0,$x0,$v1
FFFC2810 00001637		and			$t1,$v1,#$FFF
FFFC2814 FFF60613
FFFC2818 01167DB3
FFFC281C 01BD1A63		bne			$t0,$t1,.failed
FFFC2820 00188893		add			$v1,$v1,#1
FFFC2824 FFF80813		sub			$v0,$v0,#1
FFFC2828 FD004EE3		bgt			$v0,$x0,.nxt
FFFC282C 00008067		ret
                        	.failed:
FFFC2830 00000063		bra			.failed
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready lists are searched in a circular
                        	; fashion beginning with the list identified indirectly by QNDX. There are
                        	; four ready lists to hold tasks of four different priorities. 
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		v0 = task id of task to run
                        	;------------------------------------------------------------------------------
                        	
                        	SelectTaskToRun:
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
                        	.searchQ:
FFFC2834 00024637		ldbu	$v1,QNDX						; get index into que check table
FFFC2838 30460613
FFFC283C 00060633
FFFC2840 00064883
FFFC2844 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC2848 01F8F893		and		$v1,$v1,#31
FFFC284C 00024637		stb		$v1,QNDX						; store back
FFFC2850 30460613
FFFC2854 00060633
FFFC2858 01160023
FFFC285C FFFC2637		ldbu	$v1,qToChk[$v1]			; assume this will be valid
FFFC2860 64E60613
FFFC2864 01160633
FFFC2868 00064883
FFFC286C 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC2870 10300073		pfi
FFFC2874 1C08880D		getrdy	$v0,$v1
;	ldw		$v0,READYQ[$v1]			; check queue to see if contains any
FFFC2878 02085263		bge		$v0,$x0,.dq					; yes, go dequeue
                        	.0001:
FFFC287C 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC2880 0038F893		and		$v1,$v1,#3					; 4 max
FFFC2884 FFFE0E13		sub		$t2,$t2,#1					;
FFFC2888 FFC044E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
FFFC288C 10100073		wfi
FFFC2890 FA0002E3		bra		.searchQ
                        		; just go back to what we were doing.
                        		
FFFC2894 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC2898 00008067	ret
                        	.dq:
                        	;	ldi		$t3,#MAX_TID				; ensure we have a valid tid
                        	;	bleu	$v0,$t3,.goodTid
                        		; If the tid isn't valid the readyq was screwed up
                        	;	ldi		$t3,#-1							; indicate queue empty
                        	;	stw		$t3,READYQ[$v1]
                        	;	bra		.0001								; and try next queue
                        	.goodTid:
FFFC289C 18181073		csrrw	$x0,#$181,$v0
                        		;sll		$t1,$v0,#LOG_TCBSZ
                        		;ldw		$t0,TCBNext[$t1]		; update head of ready queue
                        		;stw		$t0,READYQ[$v1]
FFFC28A0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SaveContext:
                        		
FFFC28A4 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC28A8 00A81213	sll		$s1,$v0,#LOG_TCBSZ
                        	SaveContext:
FFFC28AC 28A20D03		ldb		$t0,TCBContextSaved[$s1]
FFFC28B0 0A0D1C63		bnez	$t0,.xit
                        		; Save outgoing register set in TCB
FFFC28B4 79027073		csrrc	$x0,#CSR_REGSET,#4	; select previous (user) register set for Rs2
FFFC28B8 00123423		sto		$x1,8[$s1]
FFFC28BC 00223823		sto		$x2,16[$s1]
FFFC28C0 00323C23		sto		$x3,24[$s1]
FFFC28C4 02423023		sto		$x4,32[$s1]
FFFC28C8 02523423		sto		$x5,40[$s1]
FFFC28CC 02623823		sto		$x6,48[$s1]
FFFC28D0 02723C23		sto		$x7,56[$s1]
FFFC28D4 04823023		sto		$x8,64[$s1]
FFFC28D8 04923423		sto		$x9,72[$s1]
FFFC28DC 04A23823		sto		$x10,80[$s1]
FFFC28E0 04B23C23		sto		$x11,88[$s1]
FFFC28E4 06C23023		sto		$x12,96[$s1]
FFFC28E8 06D23423		sto		$x13,104[$s1]
FFFC28EC 06E23823		sto		$x14,112[$s1]
FFFC28F0 06F23C23		sto		$x15,120[$s1]
FFFC28F4 09023023		sto		$x16,128[$s1]
FFFC28F8 09123423		sto		$x17,136[$s1]
FFFC28FC 09223823		sto		$x18,144[$s1]
FFFC2900 09323C23		sto		$x19,152[$s1]
FFFC2904 0B423023		sto		$x20,160[$s1]
FFFC2908 0B523423		sto		$x21,168[$s1]
FFFC290C 0B623823		sto		$x22,176[$s1]
FFFC2910 0B723C23		sto		$x23,184[$s1]
FFFC2914 0D823023		sto		$x24,192[$s1]
FFFC2918 0D923423		sto		$x25,200[$s1]
FFFC291C 0DA23823		sto		$x26,208[$s1]
FFFC2920 0DB23C23		sto		$x27,216[$s1]
FFFC2924 0FC23023		sto		$x28,224[$s1]
FFFC2928 0FD23423		sto		$x29,232[$s1]
FFFC292C 0FE23823		sto		$x30,240[$s1]
FFFC2930 0FF23C23		sto		$x31,248[$s1]
FFFC2934 79026073		csrrs	$x0,#CSR_REGSET,#4				; select current register set for Rs2
FFFC2938 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC293C 28223023		sto		$x2,TCBepc[$s1]
                        		; Now save off segment registers
FFFC2940 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC2944 01B00D0D		mvseg	$t0,$x0,$t1
FFFC2948 003D9113		sll		$x2,$t1,#3
FFFC294C 00410133		add		$x2,$x2,$s1
FFFC2950 21A13023		sto		$t0,TCBsegs[$x2]
FFFC2954 001D8D93		add		$t1,$t1,#1
FFFC2958 00FDFD93		and		$t1,$t1,#15
FFFC295C FE0D94E3		bne		$t1,$x0,.svseg
FFFC2960 00106D13		ldi		$t0,#1
FFFC2964 29A20523		stb		$t0,TCBContextSaved[$s1]
                        	.xit:
FFFC2968 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	RestoreContext:
                        		; Switch memory maps
FFFC296C 00A2D813		srl		$v0,$s2,#10					; convert pointer to tid
FFFC2970 03F87813		and		$v0,$v0,#$3F				; mask to 64 task
FFFC2974 181818F3		csrrw	$v1,#$181,$v0				; set ASID
                        	
                        		; Restore segment register set
FFFC2978 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC297C 003D9113		sll		$x2,$t1,#3
FFFC2980 00510133		add		$x2,$x2,$s2
FFFC2984 20013D03		ldo		$t0,TCBsegs[$x2]
FFFC2988 01BD000D		mvseg	$x0,$t0,$t1
FFFC298C 001D8D93		add		$t1,$t1,#1
FFFC2990 00FDFD93		and		$t1,$t1,#15
FFFC2994 FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC2998 2802B103		ldo		$x2,TCBepc[$s2]			; restore epc
FFFC299C 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC29A0 7900F073		csrrc	$x0,#CSR_REGSET,#1				; select previous regset for Rd
FFFC29A4 0082B083		ldo		$x1,8[$s2]
FFFC29A8 0102B103		ldo		$x2,16[$s2]
FFFC29AC 0182B183		ldo		$x3,24[$s2]
FFFC29B0 0202B203		ldo		$x4,32[$s2]
FFFC29B4 0282B283		ldo		$x5,40[$s2]
FFFC29B8 0302B303		ldo		$x6,48[$s2]
FFFC29BC 0382B383		ldo		$x7,56[$s2]
FFFC29C0 0402B403		ldo		$x8,64[$s2]
FFFC29C4 0482B483		ldo		$x9,72[$s2]
FFFC29C8 0502B503		ldo		$x10,80[$s2]
FFFC29CC 0582B583		ldo		$x11,88[$s2]
FFFC29D0 0602B603		ldo		$x12,96[$s2]
FFFC29D4 0682B683		ldo		$x13,104[$s2]
FFFC29D8 0702B703		ldo		$x14,112[$s2]
FFFC29DC 0782B783		ldo		$x15,120[$s2]
FFFC29E0 0802B803		ldo		$x16,128[$s2]
FFFC29E4 0882B883		ldo		$x17,136[$s2]
FFFC29E8 0902B903		ldo		$x18,144[$s2]
FFFC29EC 0982B983		ldo		$x19,152[$s2]
FFFC29F0 0A02BA03		ldo		$x20,160[$s2]
FFFC29F4 0A82BA83		ldo		$x21,168[$s2]
FFFC29F8 0B02BB03		ldo		$x22,176[$s2]
FFFC29FC 0B82BB83		ldo		$x23,184[$s2]
FFFC2A00 0C02BC03		ldo		$x24,192[$s2]
FFFC2A04 0C82BC83		ldo		$x25,200[$s2]
FFFC2A08 0D02BD03		ldo		$x26,208[$s2]
FFFC2A0C 0D82BD83		ldo		$x27,216[$s2]
FFFC2A10 0E02BE03		ldo		$x28,224[$s2]
FFFC2A14 0E82BE83		ldo		$x29,232[$s2]
FFFC2A18 0F02BF03		ldo		$x30,240[$s2]
FFFC2A1C 0F82BF83		ldo		$x31,248[$s2]
FFFC2A20 7900E073		csrrs	$x0,#CSR_REGSET,#1				; select current regset for Rd
FFFC2A24 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	; This routine should be called with the system mutex already locked.
                        	; Called from Sleep() and SchedulerIRQ().
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB of outgoing context
                        	;		s2 = pointer to TCB of incoming context
                        	;------------------------------------------------------------------------------
                        	
                        	SwapContext:
FFFC2A28 06520663		beq		$s1,$s2,.noCtxSwitch@
FFFC2A2C 28A20883		ldb		$v1,TCBContextSaved[$s1]
FFFC2A30 10300073		pfi
FFFC2A34 02089863		bnez	$v1,.savedAlready
                        	
                        		; Save outgoing register set in TCB
FFFC2A38 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC2A3C 28223023		sto		$x2,TCBepc[$s1]
                        		; Now save off segment registers
FFFC2A40 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC2A44 10300073		pfi
FFFC2A48 01B00D0D		mvseg	$t0,$x0,$t1
FFFC2A4C 003D9113		sll		$x2,$t1,#3
FFFC2A50 00410133		add		$x2,$x2,$s1
FFFC2A54 21A13023		sto		$t0,TCBsegs[$x2]
FFFC2A58 001D8D93		add		$t1,$t1,#1
FFFC2A5C 00FDFD93		and		$t1,$t1,#15
FFFC2A60 FE0D92E3		bne		$t1,$x0,.svseg
                        	
                        	.savedAlready:
                        		; Restore segment register set
FFFC2A64 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC2A68 10300073		pfi
FFFC2A6C 003D9113		sll		$x2,$t1,#3
FFFC2A70 00510133		add		$x2,$x2,$s2
FFFC2A74 20013D03		ldo		$t0,TCBsegs[$x2]
FFFC2A78 01BD000D		mvseg	$x0,$t0,$t1
FFFC2A7C 001D8D93		add		$t1,$t1,#1
FFFC2A80 00FDFD93		and		$t1,$t1,#15
FFFC2A84 FE0D92E3		bne		$t1,$x0,.rsseg
                        	
FFFC2A88 2802B103		ldo		$x2,TCBepc[$s2]			; restore epc
FFFC2A8C 34111073		csrrw	$x0,#$341,$x2
FFFC2A90 28028523		stb		$x0,TCBContextSaved[$s2]
                        	.noCtxSwitch:
FFFC2A94 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system call dispatcher.
                        	;------------------------------------------------------------------------------
                        	
                        	OSCALL:
FFFC2A98 10300073		pfi													; check for interrupt
FFFC2A9C 79017073		csrrc	$x0,#CSR_REGSET,#$2		; select previous regs for Rs1		
FFFC2AA0 00096933		mov		$a0,$a0								; move previous to current
FFFC2AA4 0009E9B3		mov		$a1,$a1
FFFC2AA8 000A6A33		mov		$a2,$a2
FFFC2AAC 000AEAB3		mov		$a3,$a3
FFFC2AB0 000B6B33		mov		$a4,$a4
FFFC2AB4 000BEBB3		mov		$a5,$a5
FFFC2AB8 79016073		csrrs	$x0,#CSR_REGSET,#$2		; get back current registers for all
FFFC2ABC 40006D13		ldi		$t0,#1024
FFFC2AC0 0BA96063		bltu	$a0,$t0,.oscall
                        		
FFFC2AC4 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC2AC8 FF870713	sub		$sp,$sp,#8
FFFC2ACC 01073023		sto		$v0,[$sp]
FFFC2AD0 00A81213		sll		$s1,$v0,#LOG_TCBSZ
                        		; Lock BIOS mutex
FFFC2AD4 00181D13		sll		$t0,$v0,#1
FFFC2AD8 001D6D13		or		$t0,$t0,#1
                        	.lock:
FFFC2ADC 10300073		pfi
FFFC2AE0 FFDC0637		sto		$t0,BIOS_MUTEX
FFFC2AE4 F0860613
FFFC2AE8 00060633
FFFC2AEC 01A63023
FFFC2AF0 FFDC0637		ldo		$t2,BIOS_MUTEX
FFFC2AF4 F0860613
FFFC2AF8 00060633
FFFC2AFC 00063E03
FFFC2B00 FDCD1EE3		bne		$t0,$t2,.lock
                        	
FFFC2B04 01F97913		and		$a0,$a0,#31
FFFC2B08 00191913		sll		$a0,$a0,#1
FFFC2B0C FFFC1637		ldwu	$t0,BIOSCallTbl[$a0]
FFFC2B10 4B060613
FFFC2B14 01260633
FFFC2B18 00065D03
FFFC2B1C 080D0E63		beqz	$t0,.biosZero
FFFC2B20 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC2B24 00060613
FFFC2B28 01A66D33
FFFC2B2C 10300073		pfi
FFFC2B30 000D00E7		call	[$t0]									; call the BIOS Function
                        	.biosXit:
                        		; Unlock BIOS mutex
FFFC2B34 00073D03		ldo		$t0,[$sp]
FFFC2B38 001D1D13		sll		$t0,$t0,#1
FFFC2B3C FFDC0637		sto		$t0,BIOS_MUTEX
FFFC2B40 F0860613
FFFC2B44 00060633
FFFC2B48 01A63023
FFFC2B4C FFDC0637		sto		$t0,BIOS_MUTEX
FFFC2B50 F0860613
FFFC2B54 00060633
FFFC2B58 01A63023
FFFC2B5C 02000C63		bra		.xit
                        	.oscall:
FFFC2B60 10300073		pfi
FFFC2B64 01F97913		and		$a0,$a0,#31
FFFC2B68 04090463		beqz	$a0,.zero
FFFC2B6C 00191913		sll		$a0,$a0,#1
FFFC2B70 FFFC2637		lhu		$t0,OSCallTbl[$a0]
FFFC2B74 61860613
FFFC2B78 01260633
FFFC2B7C 00065D03
FFFC2B80 020D0863		beqz	$t0,.zero
FFFC2B84 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC2B88 00060613
FFFC2B8C 01A66D33
                        		; No interrupts after this point
FFFC2B90 000D00E7		call	[$t0]									; call the OS Function
                        	.xit:
FFFC2B94 00870713		add		$sp,$sp,#8
FFFC2B98 10300073		pfi
FFFC2B9C 7900F073		csrrc	$x0,#CSR_REGSET,#$1		; select previous regs for Rd
FFFC2BA0 00086833		mov		$v0,$v0
FFFC2BA4 0008E8B3		mov		$v1,$v1
FFFC2BA8 7900E073		csrrs	$x0,#CSR_REGSET,#$1		; select current regs for Rd
FFFC2BAC 10000073		eret
                        	.zero:
FFFC2BB0 01A06813		ldi		$v0,#E_BadCallno
FFFC2BB4 FE0000E3		bra		.xit
                        	.biosZero:
FFFC2BB8 01A06813		ldi		$v0,#E_BadCallno
FFFC2BBC F6000CE3		bra		.biosXit
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
                        	; Passing a time of zero or less causes the function to return right away.
                        	;
                        	; Parameters:
                        	;		a1 = length of time to sleep (must be >= 0)
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Sleep:
FFFC2BC0 0009D463		bge		$a1,$x0,.go
FFFC2BC4 00008067		ret
                        	.go:
FFFC2BC8 FF070713		sub		$sp,$sp,#16
FFFC2BCC 00173023		sto		$ra,[$sp]
                        		
FFFC2BD0 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC2BD4 01073423	sto		$v0,8[$sp]
FFFC2BD8 00A81213		sll		$s1,$v0,#LOG_TCBSZ
                        		; Lock system mutex
FFFC2BDC 00181D13		sll		$t0,$v0,#1
FFFC2BE0 001D6D13		or		$t0,$t0,#1
FFFC2BE4 FFDC0637		ldo		$t2,SYS_MUTEX
FFFC2BE8 F0060613
FFFC2BEC 00060633
FFFC2BF0 00063E03
FFFC2BF4 07CD0E63		beq		$t0,$t2,.alreadyLocked
                        	.lock:
FFFC2BF8 10300073		pfi
FFFC2BFC FFDC0637		sto		$t0,SYS_MUTEX
FFFC2C00 F0060613
FFFC2C04 00060633
FFFC2C08 01A63023
FFFC2C0C FFDC0637		ldo		$t2,SYS_MUTEX
FFFC2C10 F0060613
FFFC2C14 00060633
FFFC2C18 00063E03
FFFC2C1C FDCD1EE3		bne		$t0,$t2,.lock
                        	
FFFC2C20 10300073		pfi
                        		; First thing: set end time. We don't want to include time spent in the OS in
                        		; the time accounting, so we set the end time as soon as possible.
FFFC2C24 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2C28 2BC23C23		sto		$t2,TCBEndTime[$s1]
FFFC2C2C 00098A63		beqz	$a1,.0001
FFFC2C30 00086933		mov		$a0,$v0								; a0 = current tid
FFFC2C34 10300073		pfi
FFFC2C38 401000EF		call	RemoveFromReadyList
FFFC2C3C 429000EF		call	InsertIntoTimeoutList	; a1 = timeout
                        	.0001:
FFFC2C40 28824803		ldbu	$v0,TCBStatus[$s1]		; flag task as no longer running
FFFC2C44 F7F87813		and		$v0,$v0,#~TS_RUNNING
FFFC2C48 29020423		stb		$v0,TCBStatus[$s1]
                        	
                        		;	AccountTime
FFFC2C4C 10300073		pfi
FFFC2C50 2B823E03		ldo		$t2,TCBEndTime[$s1]		; get back end time
FFFC2C54 2B023E83		ldo		$t3,TCBStartTime[$s1]
FFFC2C58 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC2C5C 2C023F83		ldo		$t5,TCBElapsedTime[$s1]
FFFC2C60 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC2C64 2DF23023		sto		$t5,TCBElapsedTime[$s1]
                        		; Will switch to target memory map.
FFFC2C68 10300073		pfi
                        		; Go to the last half of scheduling which is identical code.
FFFC2C6C 10000463		bra		RunTask
                        	.alreadyLocked:
FFFC2C70 00073083		ldo		$ra,[$sp]
FFFC2C74 01070713		add		$sp,$sp,#16
FFFC2C78 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SchedulerIRQ:
FFFC2C7C FF070713		sub		$sp,$sp,#16
                        		
FFFC2C80 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC2C84 00173023	sto		$ra,[$sp]
FFFC2C88 01073423		sto		$v0,8[$sp]
FFFC2C8C 00A81213		sll		$s1,$v0,#LOG_TCBSZ		; compute pointer to TCB
                        		; Lock system mutex
FFFC2C90 00181D13		sll		$t0,$v0,#1
FFFC2C94 001D6D13		or		$t0,$t0,#1
FFFC2C98 FFDC0637		ldo		$v1,SYS_MUTEX					; first check already locked by this task?
FFFC2C9C F0060613
FFFC2CA0 00060633
FFFC2CA4 00063883
FFFC2CA8 1D1D0863		beq		$t0,$v1,noLock				; if already locked trying to enter again, so skip
FFFC2CAC FFDC0637		sto		$t0,SYS_MUTEX
FFFC2CB0 F0060613
FFFC2CB4 00060633
FFFC2CB8 01A63023
FFFC2CBC FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2CC0 F0060613
FFFC2CC4 00060633
FFFC2CC8 00063883
FFFC2CCC 1B1D1663		bne		$t0,$v1,noLock
                        	
FFFC2CD0 10300073		pfi
FFFC2CD4 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2CD8 2BC23C23		sto		$t2,TCBEndTime[$s1]
FFFC2CDC 1600000D		decto												; decrement timeouts (takes 64 clock cycles async)
FFFC2CE0 FF870713		sub		$sp,$sp,#8
FFFC2CE4 00173023		sto		$ra,[$sp]
                        	; Might need the following if the external timer isn't used.
                        	;	csrrw	$v0,#$701,$x0					; get the time
                        	;	add		$v0,$v0,#300000				; wait 300,000 cycles @40MHz (30ms)
                        	;	csrrw	$x0,#$321,$v0					; set next interrupt time
                        		;	AccountTime
FFFC2CE8 2B023E83		ldo		$t3,TCBStartTime[$s1]
FFFC2CEC 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC2CF0 2C023F83		ldo		$t5,TCBElapsedTime[$s1]
FFFC2CF4 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC2CF8 2DF23023		sto		$t5,TCBElapsedTime[$s1]
FFFC2CFC 10300073		pfi
FFFC2D00 28824F83		ldbu	$t5,TCBStatus[$s1]
FFFC2D04 020FEF93		or		$t5,$t5,#TS_PREEMPT
FFFC2D08 F7FFFF93		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC2D0C 29F20423		stb		$t5,TCBStatus[$s1]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
FFFC2D10 1400038D		getzl	$s4										; Get list of tasks whose timeout is zero
FFFC2D14 F1001973		csrrw	$a0,#$F10,$x0					; get hart id (we only care about tasks on this core)
FFFC2D18 02097913		and		$a0,$a0,#$20
FFFC2D1C 0123D3B3		srl		$s4,$s4,$a0						; shift by 0 or 32
FFFC2D20 FFF3F393		and		$s4,$s4,#$FFFFFFFF		; if shift of 0 selected, mask high order bits off
FFFC2D24 04038863		beqz	$s4,RunTask						; any tasks zeroed out?
FFFC2D28 F1001973		csrrw	$a0,#$F10,$x0					; get hart id (we only care about tasks on this core)
FFFC2D2C 02097913		and		$a0,$a0,#$20					; hartid starts at 0 or 32
                        	.0001:
FFFC2D30 10300073		pfi
FFFC2D34 00A91F13		sll		$t4,$a0,#LOG_TCBSZ		; convert tid to pointer
FFFC2D38 288F4E03		lbu		$t2,TCBStatus[$t4]
FFFC2D3C 010E7E13		and		$t2,$t2,#TS_TIMEOUT		; was the task actually timing out?
FFFC2D40 020E0263		beqz	$t2,.noTimeout
FFFC2D44 0013FE13		and		$t2,$s4,#1						; is zero bit set?
FFFC2D48 000E0E63		beqz	$t2,.notZero
FFFC2D4C 288F4E03		lbu		$t2,TCBStatus[$t4]		; clear timeout status
FFFC2D50 FE7E7E13		and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG)
	stb		$t2,TCBStatus[$t4]
FFFC2D54 29CF0423
FFFC2D58 10300073		pfi
FFFC2D5C 454000EF		call	MbxRemoveTask					; remove from mailbox (if queued there)
FFFC2D60 291000EF		call	InsertIntoReadyList		; add to ready list
                        	.notZero:
                        	.noTimeout:
FFFC2D64 10300073		pfi
FFFC2D68 00190913		add		$a0,$a0,#1						; next task
FFFC2D6C 0013D393		srl		$s4,$s4,#1						;
FFFC2D70 FC0390E3		bnez	$s4,.0001
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        		; The ready list was just updated, there could be new tasks
                        		; ready to run. Will switch to target memory map.
                        	RunTask:
FFFC2D74 AC1FF0EF		call	SelectTaskToRun
                        	
FFFC2D78 00A81293		sll		$s2,$v0,#LOG_TCBSZ	; s2 = pointer to incoming TCB
FFFC2D7C 2882C103		lbu		$x2,TCBStatus[$s2]	; x2 = incoming status
FFFC2D80 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; status = running
FFFC2D84 2C82B103		ldo		$x2,TCBException[$s2]	;
FFFC2D88 10300073		pfi
FFFC2D8C 02010263		beqz	$x2,.noException
FFFC2D90 0822B023		sto		$x2,128[$s2]					; t->regs[1] = t->exception
FFFC2D94 02D06113		ldi		$x2,#45
FFFC2D98 0822B423		sto		$x2,136[$s2]					; t->regs[2] = 45 (exception type)
FFFC2D9C 0602B103		ldo		$x2,96[$s2]						; x2 = reg12 (s10)
FFFC2DA0 2822B023		sto		$x2,TCBepc[$s2]				; set return address to catch handler
FFFC2DA4 0022B423		sto		$x2,8[$s2]						
FFFC2DA8 10300073	 	pfi
FFFC2DAC 2C02B423		sto		$x0,TCBException[$s2]	; t->exception = 0
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC2DB0 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC2DB4 06010663		beqz	$x2,.noMsg
FFFC2DB8 00010D37		ldi		$t0,#$10000						; mprv bit
FFFC2DBC 000D0D13
FFFC2DC0 0A02B903		ldo		$a0,160[$s2]					; user a2 (x20)
FFFC2DC4 10300073		pfi
FFFC2DC8 00090A63		beqz	$a0,.0002
FFFC2DCC 2982B103		ldo		$x2,TCBMsgD1[$s2]
FFFC2DD0 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2DD4 00293023		sto		$x2,[$a0]
FFFC2DD8 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0002:
FFFC2DDC 10300073		pfi
FFFC2DE0 0A82B903		ldo		$a0,168[$s2]
FFFC2DE4 00090A63		beqz	$a0,.0003
FFFC2DE8 2A02B103		ldo		$x2,TCBMsgD2[$s2]
FFFC2DEC 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2DF0 00293023		sto		$x2,[$a0]
FFFC2DF4 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0003:
FFFC2DF8 10300073		pfi
FFFC2DFC 0B02B903		ldo		$a0,176[$s2]
FFFC2E00 00090A63		beqz	$a0,.0004
FFFC2E04 2A82B103		ldo		$x2,TCBMsgD3[$s2]
FFFC2E08 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2E0C 00293023		sto		$x2,[$a0]
FFFC2E10 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0004:
FFFC2E14 10300073		pfi
FFFC2E18 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC2E1C 0822B023		sto		$x2,128[$s2]				; in v0
                        	
                        	.noMsg:
FFFC2E20 FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC2E24 29C28423		stb		$t2,TCBStatus[$s2]
                        	
FFFC2E28 10300073		pfi
FFFC2E2C BFDFF0EF		call	SwapContext
FFFC2E30 00073083		ldo		$ra,[$sp]
FFFC2E34 00870713		add		$sp,$sp,#8
FFFC2E38 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2E3C 2BC2B823		sto		$t2,TCBStartTime[$s2]
                        		; Unlock system mutex
FFFC2E40 10300073		pfi
FFFC2E44 00073083		ldo		$ra,[$sp]
FFFC2E48 00873E03		ldo		$t2,8[$sp]
FFFC2E4C 01070713		add		$sp,$sp,#16
FFFC2E50 001E1E13		sll		$t2,$t2,#1
FFFC2E54 FFDC0637		sto		$t2,SYS_MUTEX
FFFC2E58 F0060613
FFFC2E5C 00060633
FFFC2E60 01C63023
FFFC2E64 FFDC0637		sto		$t2,SYS_MUTEX
FFFC2E68 F0060613
FFFC2E6C 00060633
FFFC2E70 01C63023
FFFC2E74 00008067		ret
                        	noLock:
FFFC2E78 01070713		add		$sp,$sp,#16
FFFC2E7C 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2E80 2BC23823		sto		$t2,TCBStartTime[$s1]
FFFC2E84 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready list. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;		a1 = memory required
                        	;		a2 = start pc (usually $100)
                        	;		a3 = processor (0 or 1)
                        	;	Modifies:
                        	;		a0 = mid
                        	;	Returns:
                        	;		v0 = E_Ok if successful
                        	;		v1 = mid of started task if successful
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_StartTask:
FFFC2E88 FF070713		sub		$sp,$sp,#16
FFFC2E8C 00173023		sto		$ra,[$sp]
FFFC2E90 10300073		pfi
                        		
FFFC2E94 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC2E98 01073423	sto		$v0,8[$sp]			; save tid
                        		; Lock system mutex
FFFC2E9C 00181813		sll		$v0,$v0,#1
FFFC2EA0 00186813		or		$v0,$v0,#1
FFFC2EA4 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2EA8 F0060613
FFFC2EAC 00060633
FFFC2EB0 00063883
FFFC2EB4 19180663		beq		$v0,$v1,.alreadyLocked
                        	.lock:
FFFC2EB8 10300073		pfi
FFFC2EBC FFDC0637		sto		$v0,SYS_MUTEX
FFFC2EC0 F0060613
FFFC2EC4 00060633
FFFC2EC8 01063023
FFFC2ECC FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2ED0 F0060613
FFFC2ED4 00060633
FFFC2ED8 00063883
FFFC2EDC FD181EE3		bne		$v0,$v1,.lock
                        		;--------------------------
FFFC2EE0 1D9000EF		call	AllocTCB
FFFC2EE4 00004637		stb		$v1,$4321
FFFC2EE8 32160613
FFFC2EEC 00060633
FFFC2EF0 01160023
FFFC2EF4 10081C63		bnez	$v0,.err
FFFC2EF8 0008E933		mov		$a0,$v1
FFFC2EFC 10300073		pfi
FFFC2F00 8D1FE0EF		call	FreeAll
FFFC2F04 10300073		pfi
FFFC2F08 8F1FF0EF		call	MapOSPages			; Map OS pages into address space
FFFC2F0C 00A91213		sll		$s1,$a0,#LOG_TCBSZ	; compute TCB address
FFFC2F10 10300073		pfi
FFFC2F14 865FE0EF		call	AllocStack
FFFC2F18 A0010637		add		$t0,$v1,#$A000FFFC	; set stack pointer
FFFC2F1C FFC60613
FFFC2F20 01160D33
FFFC2F24 07A23823		sto		$t0,112[$s1]
FFFC2F28 29423023		sto		$a2,TCBepc[$s1]	; address task will begin at
FFFC2F2C 10300073		pfi
FFFC2F30 F40FE0EF		call	Alloc
FFFC2F34 00004637		stb		$v0,$4320
FFFC2F38 32060613
FFFC2F3C 00060633
FFFC2F40 01060023
                        	;	mov		$s3,$a0
                        	;	srl		$a0,$v1,#16
                        	;	pfi
                        	;	call	PutHexHalf
                        	;	mov		$a0,$s3
FFFC2F44 0C081463		bnez	$v0,.err
FFFC2F48 295205A3		stb		$a3,TCBAffinity[$s1]
FFFC2F4C 00106D13		ldi		$t0,#TS_READY
FFFC2F50 29A20423		stb		$t0,TCBStatus[$s1]
FFFC2F54 00206D13		ldi		$t0,#2					; normal execution priority
FFFC2F58 29A204A3		stb		$t0,TCBPriority[$s1]
                        		; leave segment base at $0, flat memory model
FFFC2F5C 10300073		pfi
FFFC2F60 00606D13		ldi		$t0,#6							; read,write
FFFC2F64 21A23023		sto		$t0,TCBsegs[$s1]			; segs 0 to 11
FFFC2F68 21A23423		sto		$t0,TCBsegs+8[$s1]
FFFC2F6C 21A23823		sto		$t0,TCBsegs+16[$s1]
FFFC2F70 21A23C23		sto		$t0,TCBsegs+24[$s1]
FFFC2F74 23A23023		sto		$t0,TCBsegs+32[$s1]
FFFC2F78 23A23423		sto		$t0,TCBsegs+40[$s1]
FFFC2F7C 10300073		pfi
FFFC2F80 23A23823		sto		$t0,TCBsegs+48[$s1]
FFFC2F84 23A23C23		sto		$t0,TCBsegs+56[$s1]
FFFC2F88 25A23023		sto		$t0,TCBsegs+64[$s1]
FFFC2F8C 25A23423		sto		$t0,TCBsegs+72[$s1]
FFFC2F90 25A23823		sto		$t0,TCBsegs+80[$s1]
FFFC2F94 25A23C23		sto		$t0,TCBsegs+88[$s1]
FFFC2F98 10300073		pfi
FFFC2F9C 00506D13		ldi		$t0,#5							; read,execute
FFFC2FA0 27A23023		sto		$t0,TCBsegs+96[$s1]	; segs 12 to 15
FFFC2FA4 27A23423		sto		$t0,TCBsegs+104[$s1]
FFFC2FA8 27A23823		sto		$t0,TCBsegs+112[$s1]
FFFC2FAC 27A23C23		sto		$t0,TCBsegs+120[$s1]
FFFC2FB0 00106993		ldi		$a1,#1
FFFC2FB4 10300073		pfi
FFFC2FB8 EB8FE0EF		call	Alloc
FFFC2FBC 33123823		sto		$v1,TCBVideoMem[$s1]
FFFC2FC0 FFD00D37		ldi		$t0,#$FFD00000
FFFC2FC4 000D0D13
FFFC2FC8 33A23C23		sto		$t0,TCBpVideo[$s1]
FFFC2FCC 10300073		pfi
                        		; No interruptions after this point
FFFC2FD0 021000EF		call	InsertIntoReadyList
FFFC2FD4 000968B3		mov		$v1,$a0
                        		; Unlock mutex
FFFC2FD8 00873D03		ldo		$t0,8[$sp]
FFFC2FDC 001D1D13		sll		$t0,$t0,#1
FFFC2FE0 FFDC0637		sto		$t0,SYS_MUTEX
FFFC2FE4 F0060613
FFFC2FE8 00060633
FFFC2FEC 01A63023
FFFC2FF0 FFDC0637		sto		$t0,SYS_MUTEX
FFFC2FF4 F0060613
FFFC2FF8 00060633
FFFC2FFC 01A63023
                        	;	call	DumpMemmap
                        	.xit:
FFFC3000 00073083		ldo		$ra,[$sp]
FFFC3004 01070713		add		$sp,$sp,#16
FFFC3008 00008067		ret
                        	.err:
                        		; Unlock mutex
FFFC300C 00873D03		ldo		$t0,8[$sp]
FFFC3010 001D1D13		sll		$t0,$t0,#1
FFFC3014 FFDC0637		sto		$t0,SYS_MUTEX
FFFC3018 F0060613
FFFC301C 00060633
FFFC3020 01A63023
FFFC3024 FFDC0637		sto		$t0,SYS_MUTEX
FFFC3028 F0060613
FFFC302C 00060633
FFFC3030 01A63023
                        	.err2:
FFFC3034 00000013		nop
FFFC3038 00000013		nop
FFFC303C FE000CE3		bra		.err2
                        	.alreadyLocked:
FFFC3040 00206813		ldi		$v0,#E_Busy
FFFC3044 00073083		ldo		$ra,[$sp]
FFFC3048 01070713		add		$sp,$sp,#16
FFFC304C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitTask:
FFFC3050 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC3054 FF870713		sub		$sp,$sp,#8
FFFC3058 00173023		sto		$ra,[$sp]
                        		
FFFC305C 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC3060 000869B3	mov		$a1,$v0
FFFC3064 10300073		pfi
FFFC3068 00000637		call	KillTask
FFFC306C 247600E7
                        	.xit:
FFFC3070 00073083		ldo		$ra,[$sp]
FFFC3074 00870713		add		$sp,$sp,#8
FFFC3078 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_KillTask:
FFFC307C 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC3080 FF870713		sub		$sp,$sp,#8
FFFC3084 00173023		sto		$ra,[$sp]
FFFC3088 0C098463		beqz	$a1,.immortal		; tid #0 is immortal (the system)
                        	
                        		; Lock system mutex
                        		
FFFC308C 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC3090 000864B3	mov		$s6,$v0
FFFC3094 00181813		sll		$v0,$v0,#1
FFFC3098 00186813		or		$v0,$v0,#1
FFFC309C FFDC0637		ldo		$v1,SYS_MUTEX
FFFC30A0 F0060613
FFFC30A4 00060633
FFFC30A8 00063883
FFFC30AC 99180F63		beq		$v0,$v1,KTAlreadyLocked
                        	.lock:
FFFC30B0 10300073		pfi
FFFC30B4 FFDC0637		sto		$v0,SYS_MUTEX
FFFC30B8 F0060613
FFFC30BC 00060633
FFFC30C0 01063023
FFFC30C4 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC30C8 F0060613
FFFC30CC 00060633
FFFC30D0 00063883
FFFC30D4 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC30D8 00206D13		ldi		$t0,#TS_DEAD				; flag task as dead (prevents it from being re-queued)
                        	;	and		$t1,$a1,#MAX_TID		; limit tid
FFFC30DC 00A99D93		sll		$t1,$a1,#LOG_TCBSZ	; convert to TCB address
FFFC30E0 29AD8423		stb		$t0,TCBStatus[$t1]
FFFC30E4 0009E933		mov		$a0,$a1								; a0 = pid
FFFC30E8 10300073		pfi
FFFC30EC 74C000EF		call	RemoveFromReadyList
FFFC30F0 EE0FE0EF		call	FreeAll							; free all the memory associated with the task
FFFC30F4 10300073		pfi
                        		; Now make process ID available for reuse
FFFC30F8 00024637		ldo		$t1,PIDMAP
FFFC30FC 31060613
FFFC3100 00060633
FFFC3104 00063D83
FFFC3108 00106D13		ldi		$t0,#1							; generate bit "off" mask
FFFC310C 013D1D33		sll		$t0,$t0,$a1
FFFC3110 FFFD4D13		xor		$t0,$t0,#-1					; complment for inverted mask
FFFC3114 01ADFDB3		and		$t1,$t1,$t0
FFFC3118 00024637		sto		$t1,PIDMAP
FFFC311C 31060613
FFFC3120 00060633
FFFC3124 01B63023
                        		; Unlock system mutex
FFFC3128 10300073		pfi
FFFC312C 00149D93		sll		$t1,$s6,#1
FFFC3130 FFDC0637		sto		$t1,SYS_MUTEX
FFFC3134 F0060613
FFFC3138 00060633
FFFC313C 01B63023
FFFC3140 FFDC0637		sto		$t1,SYS_MUTEX
FFFC3144 F0060613
FFFC3148 00060633
FFFC314C 01B63023
                        	.immortal:
FFFC3150 00006813		ldi		$v0,#E_Ok
FFFC3154 00073083		ldo		$ra,[$sp]
FFFC3158 00870713		add		$sp,$sp,#8
FFFC315C 00008067		ret
                        	KTlreadyLocked:
FFFC3160 00206813		ldi		$v0,#E_Busy
FFFC3164 00073083		ldo		$ra,[$sp]
FFFC3168 00870713		add		$sp,$sp,#8
FFFC316C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocVideoBuf:
                        		
FFFC3170 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC3174 00086933	mov		$a0,$v0
FFFC3178 00106993		ldi		$a1,#1			; request 1 byte to get 1 page (64kB)
FFFC317C 10300073		pfi
FFFC3180 CF0FE0EF		call	Alloc
FFFC3184 02081263		bnez	$v0,.err
FFFC3188 F1001273		csrrw	$s1,#$F10,$x0
FFFC318C 01220233		add		$s1,$s1,$a0
FFFC3190 00A21213		sll		$s1,$s1,#LOG_TCBSZ
FFFC3194 00000637		sto		$v1,TCBVidMem[$s1]
FFFC3198 24F60613
FFFC319C 00460633
FFFC31A0 01163023
FFFC31A4 33123C23		sto		$v1,TCBpVideo[$s1]
                        	.err:
FFFC31A8 10300073		pfi
FFFC31AC 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	MBX_WTIDS			equ		8		; tasks waiting at mailbox
                        	MBX_MQHEAD		equ		16		
                        	MBX_MQTAIL		equ		24
                        	MBX_SIZE			equ		32
                        	LOG_MBXSZ			equ		5
                        	
                        	MSG_LINK	equ		0
                        	MSG_D1		equ		8
                        	MSG_D2		equ		16
                        	MSG_D3		equ		24
                        	MSG_SIZE	equ		32
                        	LOG_MSGSZ	equ		5
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.r5a",48
                        		code
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove the task from the list of tasks waiting at the mailbox.
                        	; This routine is only called from a couple of places and it is convenient
                        	; not to stack the return address. So, it is implemented as a macro.
                        	;
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	MbxRemoveTask:
FFFC31B0 FE070713		sub		$sp,$sp,#32
FFFC31B4 00473023		sto		$s1,[$sp]
FFFC31B8 01A73423		sto		$t0,8[$sp]
FFFC31BC 01B73823		sto		$t1,16[$sp]
FFFC31C0 01C73C23		sto		$t2,24[$sp]
FFFC31C4 10300073		pfi
FFFC31C8 00A91213		sll		$s1,$a0,#LOG_TCBSZ		; tid to pointer
FFFC31CC 28C21D03		ldw		$t0,TCBWaitMbx[$s1]		; get mailbox handle
FFFC31D0 020D4863		blt		$t0,$x0,.xit					; handle good?
FFFC31D4 005D1D13		sll		$t0,$t0,#LOG_MBXSZ		; convert to pointer
FFFC31D8 00020637		add		$t0,$t0,#mbxs					; by adding base address
FFFC31DC 00060613
FFFC31E0 01A60D33
FFFC31E4 10300073		pfi
FFFC31E8 008D3D83		ldo		$t1,MBX_WTIDS[$t0]		; get waiting task list
FFFC31EC 00106E13		ldi		$t2,#1								; create a mask for given task id
FFFC31F0 012E1E33		sll		$t2,$t2,$a0
FFFC31F4 FFFE4E13		xor		$t2,$t2,#-1
FFFC31F8 01CDFDB3		and		$t1,$t1,$t2						; clear bit
FFFC31FC 01BD3423		sto		$t1,MBX_WTIDS[$t0]		; update waiting task list
                        	.xit:
FFFC3200 10300073		pfi
FFFC3204 00073203		ldo		$s1,[$sp]
FFFC3208 00873D03		ldo		$t0,8[$sp]
FFFC320C 01073D83		ldo		$t1,16[$sp]
FFFC3210 01873E03		ldo		$t2,24[$sp]
FFFC3214 02070713		add		$sp,$sp,#32
FFFC3218 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = task id of owner
                        	;		a2 = pointer where to store handle
                        	; Returns:
                        	;		v0 = E_Ok
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocMbx:
FFFC321C FF870713		sub		$sp,$sp,#8
FFFC3220 00173023		sto		$ra,[$sp]
FFFC3224 0A0A0863		beq		$a2,$x0,.badArg
FFFC3228 00020D37		ldi		$t0,#mbxs
FFFC322C 000D0D13
                        		; Lock system mutex
                        		
FFFC3230 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC3234 000864B3	mov		$s6,$v0
FFFC3238 00181813		sll		$v0,$v0,#1
FFFC323C 00186813		or		$v0,$v0,#1
FFFC3240 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC3244 F0060613
FFFC3248 00060633
FFFC324C 00063883
FFFC3250 0B180E63		beq		$v0,$v1,AlreadyLocked
                        	.lock:
FFFC3254 10300073		pfi
FFFC3258 FFDC0637		sto		$v0,SYS_MUTEX
FFFC325C F0060613
FFFC3260 00060633
FFFC3264 01063023
FFFC3268 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC326C F0060613
FFFC3270 00060633
FFFC3274 00063883
FFFC3278 FD181EE3		bne		$v0,$v1,.lock
                        	.nxt:
FFFC327C 10300073		pfi
FFFC3280 000D4D83		ldbu	$t1,MBX_OWNER[$t0]
FFFC3284 000D8E63		beq		$t1,$x0,.noOwner
FFFC3288 020D0D13		add		$t0,$t0,#MBX_SIZE
FFFC328C 00022637		slt		$t1,$t0,#mbxs_end
FFFC3290 00060613
FFFC3294 FE0D94E3		bne		$t1,$x0,.nxt
FFFC3298 04006813		ldi		$v0,#E_NoMoreMbx
FFFC329C 02000E63		bra		.xit
                        	.noOwner:
FFFC32A0 10300073		pfi
FFFC32A4 013D0023		stb		$a1,MBX_OWNER[$t0]
FFFC32A8 FFFE0637		sub		$t5,$t0,#mbxs				; convert pointer to handle
FFFC32AC 00060613
FFFC32B0 41A60FB3
FFFC32B4 005FDF93		srl		$t5,$t5,#LOG_MBXSZ
FFFC32B8 0009E933		mov		$a0,$a1
FFFC32BC 000A69B3		mov		$a1,$a2
FFFC32C0 10300073		pfi
FFFC32C4 D78FE0EF		call	VirtToPhys
FFFC32C8 01F83023		sto		$t5,[$v0]
FFFC32CC 00006813		ldi		$v0,#E_Ok
FFFC32D0 00000463		bra		.xit
                        	.badArg:
FFFC32D4 00106813		ldi		$v0,#E_Arg
                        	.xit:
FFFC32D8 10300073		pfi
                        		; Unlock system mutex
FFFC32DC 00149D13		sll		$t0,$s6,#1
FFFC32E0 FFDC0637		sto		$t0,SYS_MUTEX
FFFC32E4 F0060613
FFFC32E8 00060633
FFFC32EC 01A63023
FFFC32F0 FFDC0637		sto		$t0,SYS_MUTEX
FFFC32F4 F0060613
FFFC32F8 00060633
FFFC32FC 01A63023
FFFC3300 00073083		ldo		$ra,[$sp]
FFFC3304 00870713		add		$sp,$sp,#8
FFFC3308 00008067		ret
                        	AlreadyLocked:
FFFC330C 00206813		ldi		$v0,#E_Busy
FFFC3310 00073083		ldo		$ra,[$sp]
FFFC3314 00870713		add		$sp,$sp,#8
FFFC3318 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Free a mailbox
                        	;
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_FreeMbx:
FFFC331C FF870713		sub		$sp,$sp,#8
FFFC3320 00173023		sto		$ra,[$sp]
FFFC3324 1009A213		slt		$s1,$a1,#NR_MBX
FFFC3328 0C020063		beq		$s1,$x0,.badMbx
FFFC332C 00599213		sll		$s1,$a1,#LOG_MBXSZ		; convert handle to pointer
FFFC3330 00020637		add		$s1,$s1,#mbxs
FFFC3334 00060613
FFFC3338 00460233
FFFC333C 00006293		ldi		$s2,#0
FFFC3340 02006393		ldi		$s4,#NR_TCB						; possibly 64 tasks
                        		; Lock system mutex
                        		
FFFC3344 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC3348 00086533	mov		$s7,$v0
FFFC334C 00181813		sll		$v0,$v0,#1
FFFC3350 00186813		or		$v0,$v0,#1
FFFC3354 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC3358 F0060613
FFFC335C 00060633
FFFC3360 00063883
FFFC3364 FB1804E3		beq		$v0,$v1,AlreadyLocked
                        	.lock:
FFFC3368 10300073		pfi
FFFC336C FFDC0637		sto		$v0,SYS_MUTEX
FFFC3370 F0060613
FFFC3374 00060633
FFFC3378 01063023
FFFC337C FFDC0637		ldo		$v1,SYS_MUTEX
FFFC3380 F0060613
FFFC3384 00060633
FFFC3388 00063883
FFFC338C FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC3390 00823483		ldo		$s6,MBX_WTIDS[$s1]
                        	.0002:
FFFC3394 10300073		pfi
FFFC3398 0014F313		and		$s3,$s6,#1
FFFC339C 02030A63		beq		$s3,$x0,.0001
FFFC33A0 00A29413		sll		$s5,$s2,#LOG_TCBSZ		; tid to pointer
FFFC33A4 28844803		lbu		$v0,TCBStatus[$s5]
FFFC33A8 FF787813		and		$v0,$v0,#~TS_WAITMSG	; no longer waiting
FFFC33AC 29040423		stb		$v0,TCBStatus[$s5]
FFFC33B0 01087813		and		$v0,$v0,#TS_TIMEOUT
FFFC33B4 0002E933		mov		$a0,$s2
FFFC33B8 00080663		beqz	$v0,.0003
FFFC33BC 10300073		pfi
FFFC33C0 4C0000EF		call	RemoveFromTimeoutList
                        	.0003:
FFFC33C4 42C000EF		call	InsertIntoReadyList
FFFC33C8 00B06813		ldi		$v0,#E_NoMsg					; but no message
FFFC33CC 09043023		sto		$v0,128[$s5]					; v0 = E_NoMsg
                        	.0001:
FFFC33D0 10300073		pfi
FFFC33D4 0014D493		srl		$s6,$s6,#1
FFFC33D8 00128293		add		$s2,$s2,#1
FFFC33DC FA72ECE3		bltu	$s2,$s4,.0002
FFFC33E0 00006813		ldi		$v0,#E_Ok
FFFC33E4 00000463		bra		.xit
                        	.badMbx:
FFFC33E8 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
FFFC33EC 10300073		pfi
                        		; Unlock system mutex
FFFC33F0 00151D13		sll		$t0,$s7,#1
FFFC33F4 FFDC0637		sto		$t0,SYS_MUTEX
FFFC33F8 F0060613
FFFC33FC 00060633
FFFC3400 01A63023
FFFC3404 FFDC0637		sto		$t0,SYS_MUTEX
FFFC3408 F0060613
FFFC340C 00060633
FFFC3410 01A63023
FFFC3414 00073083		ldo		$ra,[$sp]
FFFC3418 00870713		add		$sp,$sp,#8
FFFC341C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		t0 = mailbox pointer
                        	;		t1 = message pointer
                        	;		s1 = task id of waiting task
                        	; Modifies:
                        	;		a0
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = message d1
                        	;		a3 = message d2
                        	;		a4 = message d3
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SendMsg:
FFFC3420 FF870713		sub		$sp,$sp,#8
FFFC3424 00173023		sto		$ra,[$sp]
FFFC3428 1009BD13		sltu	$t0,$a1,#NR_MBX
FFFC342C 140D0863		beq		$t0,$x0,.badMbx
FFFC3430 00599D13		sll		$t0,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC3434 00020637		add		$t0,$t0,#mbxs
FFFC3438 00060613
FFFC343C 01A60D33
                        		; Lock system mutex
                        		
FFFC3440 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC3444 000864B3	mov		$s6,$v0
FFFC3448 00181813		sll		$v0,$v0,#1
FFFC344C 00186813		or		$v0,$v0,#1
FFFC3450 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC3454 F0060613
FFFC3458 00060633
FFFC345C 00063883
FFFC3460 EB1806E3		beq		$v0,$v1,AlreadyLocked
                        	.lock:
FFFC3464 10300073		pfi
FFFC3468 FFDC0637		sto		$v0,SYS_MUTEX
FFFC346C F0060613
FFFC3470 00060633
FFFC3474 01063023
FFFC3478 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC347C F0060613
FFFC3480 00060633
FFFC3484 00063883
FFFC3488 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC348C 008D3F83		ldo		$t5,MBX_WTIDS[$t0]
FFFC3490 060F8C63		beq		$t5,$x0,.noWaiters	; no waiters = go queue message
FFFC3494 00006213		ldi		$s1,#0
                        	.0001:
FFFC3498 10300073		pfi
FFFC349C 001FF313		and		$s3,$t5,#1					; is tid waiting?
FFFC34A0 04030463		beq		$s3,$x0,.nxtTid
FFFC34A4 00A21313		sll		$s3,$s1,#LOG_TCBSZ	; convert tid to TCB pointer
FFFC34A8 29433C23		sto		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC34AC 2B533023		sto		$a3,TCBMsgD2[$s3]
FFFC34B0 2B633423		sto		$a4,TCBMsgD3[$s3]
FFFC34B4 10300073		pfi
FFFC34B8 28834E03		ldbu	$t2,TCBStatus[$s3]
FFFC34BC 004E6E13		or		$t2,$t2,#TS_MSGRDY
FFFC34C0 29C30423		stb		$t2,TCBStatus[$s3]
FFFC34C4 00026933		mov		$a0,$s1
FFFC34C8 FF070713		sub		$sp,$sp,#16
FFFC34CC 00173023		sto		$ra,[$sp]
FFFC34D0 01A73423		sto		$t0,8[$sp]						; push t0
FFFC34D4 10300073		pfi
FFFC34D8 318000EF		call	InsertIntoReadyList
FFFC34DC 00073083		ldo		$ra,[$sp]
FFFC34E0 00873D03		ldo		$t0,8[$sp]						; pop t0
FFFC34E4 01070713		add		$sp,$sp,#16
                        	.nxtTid:
FFFC34E8 10300073		pfi
FFFC34EC 001FDF93		srl		$t5,$t5,#1					; check next task
FFFC34F0 00120213		add		$s1,$s1,#1
FFFC34F4 03F27213		and		$s1,$s1,#63
FFFC34F8 FA0210E3		bne		$s1,$x0,.0001
FFFC34FC 000D3423		sto		$x0,MBX_WTIDS[$t0]	; clear waiters
FFFC3500 00006813		ldi		$v0,#E_Ok
FFFC3504 06000E63		bra		.xit
                        	.noWaiters:
FFFC3508 10300073		pfi
FFFC350C 00024637		ldo		$t1,FreeMsg
FFFC3510 35060613
FFFC3514 00060633
FFFC3518 00063D83
FFFC351C 040D8A63		beq		$t1,$x0,.noMsg			; message available?
FFFC3520 000DBE03		ldo		$t2,MSG_LINK[$t1]
FFFC3524 00024637		sto		$t2,FreeMsg
FFFC3528 35060613
FFFC352C 00060633
FFFC3530 01C63023
FFFC3534 014DB423		sto		$a2,MSG_D1[$t1]
FFFC3538 015DB823		sto		$a3,MSG_D2[$t1]
FFFC353C 016DBC23		sto		$a4,MSG_D3[$t1]
FFFC3540 10300073		pfi
FFFC3544 018D3E83		ldo		$t3,MBX_MQTAIL[$t0]
FFFC3548 000E8A63		beq		$t3,$x0,.mbxEmpty
FFFC354C 01BEB023		sto		$t1,MSG_LINK[$t3]
FFFC3550 01BD3C23		sto		$t1,MBX_MQTAIL[$t0]
FFFC3554 00006813		ldi		$v0,#E_Ok
FFFC3558 02000463		bra		.xit
                        	.mbxEmpty:
FFFC355C 10300073		pfi
FFFC3560 01BD3823		sto		$t1,MBX_MQHEAD[$t0]
FFFC3564 01BD3C23		sto		$t1,MBX_MQTAIL[$t0]
FFFC3568 00006813		ldi		$v0,#E_Ok
FFFC356C 00000A63		bra		.xit
                        	.noMsg:
FFFC3570 10300073		pfi
FFFC3574 00B06813		ldi		$v0,#E_NoMsg
FFFC3578 00000463		bra		.xit
                        	.badMbx:
FFFC357C 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
                        		; Unlock system mutex
FFFC3580 00149D13		sll		$t0,$s6,#1
FFFC3584 FFDC0637		sto		$t0,SYS_MUTEX
FFFC3588 F0060613
FFFC358C 00060633
FFFC3590 01A63023
FFFC3594 FFDC0637		sto		$t0,SYS_MUTEX
FFFC3598 F0060613
FFFC359C 00060633
FFFC35A0 01A63023
FFFC35A4 10300073		pfi
FFFC35A8 00073083		ldo		$ra,[$sp]
FFFC35AC 00870713		add		$sp,$sp,#8
FFFC35B0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC35B4 FF870713		sub		$sp,$sp,#8
FFFC35B8 00173023		sto		$ra,[$sp]
FFFC35BC 0209AD13		slt		$t0,$a1,#32
FFFC35C0 10300073		pfi
FFFC35C4 100D0063		beqz	$t0,.badMbx
                        		; Lock system mutex
                        		
FFFC35C8 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC35CC 000864B3	mov		$s6,$v0
FFFC35D0 00181813		sll		$v0,$v0,#1
FFFC35D4 00186813		or		$v0,$v0,#1
FFFC35D8 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC35DC F0060613
FFFC35E0 00060633
FFFC35E4 00063883
FFFC35E8 D31802E3		beq		$v0,$v1,AlreadyLocked
                        	.lock:
FFFC35EC 10300073		pfi
FFFC35F0 FFDC0637		sto		$v0,SYS_MUTEX
FFFC35F4 F0060613
FFFC35F8 00060633
FFFC35FC 01063023
FFFC3600 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC3604 F0060613
FFFC3608 00060633
FFFC360C 00063883
FFFC3610 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC3614 00599E13		sll		$t2,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC3618 00020637		add		$t2,$t2,#mbxs
FFFC361C 00060613
FFFC3620 01C60E33
FFFC3624 010E3D83		ldo		$t1,MBX_MQHEAD[$t2]
FFFC3628 080D8863		beq		$t1,$x0,.noMsg
FFFC362C 020B8863		beq		$a5,$x0,.nodq
FFFC3630 000DBE83		ldo		$t3,MSG_LINK[$t1]
FFFC3634 01DE3823		sto		$t3,MBX_MQHEAD[$t2]
FFFC3638 00024637		ldo		$t3,FreeMsg
FFFC363C 35060613
FFFC3640 00060633
FFFC3644 00063E83
FFFC3648 01DDB023		sto		$t3,MSG_LINK[$t1]
FFFC364C 00024637		sto		$t1,FreeMsg
FFFC3650 35060613
FFFC3654 00060633
FFFC3658 01B63023
                        	.nodq:
FFFC365C 10300073		pfi
FFFC3660 00010D37		ldi		$t0,#$10000
FFFC3664 000D0D13
FFFC3668 000A0A63		beqz	$a2,.nod1
FFFC366C 008DBE83		ldo		$t3,MSG_D1[$t1]
FFFC3670 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC3674 01DA3023		sto		$t3,[$a2]
FFFC3678 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod1:
FFFC367C 10300073		pfi
FFFC3680 000A8A63		beqz	$a3,.nod2
FFFC3684 010DBE83		ldo		$t3,MSG_D2[$t1]
FFFC3688 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC368C 01DAB023		sto		$t3,[$a3]
FFFC3690 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod2:
FFFC3694 10300073		pfi
FFFC3698 000B0A63		beqz	$a4,.nod3
FFFC369C 018DBE83		ldo		$t3,MSG_D3[$t1]
FFFC36A0 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC36A4 01DB3023		sto		$t3,[$a4]
FFFC36A8 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod3:
FFFC36AC 10300073		pfi
FFFC36B0 00006813		ldi		$v0,#E_Ok
FFFC36B4 00000A63		bra		.ret
                        	.noMsg:
FFFC36B8 10300073		pfi
FFFC36BC 00B06813		ldi		$v0,#E_NoMsg
FFFC36C0 00000463		bra		.ret
                        	.badMbx:
FFFC36C4 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
FFFC36C8 10300073		pfi
                        		; Unlock system mutex
FFFC36CC 00149D13		sll		$t0,$s6,#1
FFFC36D0 FFDC0637		sto		$t0,SYS_MUTEX
FFFC36D4 F0060613
FFFC36D8 00060633
FFFC36DC 01A63023
FFFC36E0 FFDC0637		sto		$t0,SYS_MUTEX
FFFC36E4 F0060613
FFFC36E8 00060633
FFFC36EC 01A63023
FFFC36F0 00073083		ldo		$ra,[$sp]
FFFC36F4 00870713		add		$sp,$sp,#8
FFFC36F8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_WaitMsg:
FFFC36FC FF870713		sub		$sp,$sp,#8
FFFC3700 00173023		sto		$ra,[$sp]
FFFC3704 000BE433		mov		$s5,$a5
FFFC3708 00106B93		ldi		$a5,#1
FFFC370C 10300073		pfi
FFFC3710 EA5FF0EF		call	FMTK_PeekMsg				; check for a message, return if available
FFFC3714 00B06D93		ldi		$t1,#E_NoMsg
FFFC3718 01B80463		beq		$v0,$t1,.qt					; no message? Then go queue task
FFFC371C 0C000263		bra		.xit
                        	.qt:
FFFC3720 10300073		pfi
                        		; Lock system mutex
                        		
FFFC3724 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC3728 000864B3	mov		$s6,$v0
FFFC372C 00181813		sll		$v0,$v0,#1
FFFC3730 00186813		or		$v0,$v0,#1
FFFC3734 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC3738 F0060613
FFFC373C 00060633
FFFC3740 00063883
FFFC3744 BD1804E3		beq		$v0,$v1,AlreadyLocked
                        	.lock:
FFFC3748 10300073		pfi
FFFC374C FFDC0637		sto		$v0,SYS_MUTEX
FFFC3750 F0060613
FFFC3754 00060633
FFFC3758 01063023
FFFC375C FFDC0637		ldo		$v1,SYS_MUTEX
FFFC3760 F0060613
FFFC3764 00060633
FFFC3768 00063883
FFFC376C FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC3770 00106E13		ldi		$t2,#1
FFFC3774 010E1E33		sll		$t2,$t2,$v0
FFFC3778 00599E93		sll		$t3,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC377C 00020637		add		$t3,$t3,#mbxs
FFFC3780 00060613
FFFC3784 01D60EB3
FFFC3788 10300073		pfi
FFFC378C 008EBF03		ldo		$t4,MBX_WTIDS[$t3]	; get waiting task list
FFFC3790 01CF6F33		or		$t4,$t4,$t2					; set bit for tid
FFFC3794 01EEB423		sto		$t4,MBX_WTIDS[$t3]	; save task list
FFFC3798 00A81F13		sll		$t4,$v0,#LOG_TCBSZ	; convert tid to TCB pointer
FFFC379C 288F4E83		ldbu	$t3,TCBStatus[$t4]
FFFC37A0 008EEE93		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC37A4 FFEEFE93		and		$t3,$t3,#~TS_READY	; not ready
FFFC37A8 10300073		pfi
FFFC37AC 29DF0423		stb		$t3,TCBStatus[$t4]
FFFC37B0 293F0623		stb		$a1,TCBWaitMbx[$t4]	; set mailbox task is waiting for
FFFC37B4 000BE9B3		mov		$a1,$a5
                        		; Unlock system mutex
FFFC37B8 00149D13		sll		$t0,$s6,#1
FFFC37BC FFDC0637		sto		$t0,SYS_MUTEX
FFFC37C0 F0060613
FFFC37C4 00060633
FFFC37C8 01A63023
FFFC37CC FFDC0637		sto		$t0,SYS_MUTEX
FFFC37D0 F0060613
FFFC37D4 00060633
FFFC37D8 01A63023
                        		; Continue by switching tasks
FFFC37DC BE4FF0EF		call		FMTK_Sleep
                        	.xit:
FFFC37E0 10300073		pfi
FFFC37E4 00073083		ldo		$ra,[$sp]
FFFC37E8 00870713		add		$sp,$sp,#8
FFFC37EC 00008067		ret
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/tcb.r5a",25
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready list. The list is a doubly linked circular list.
                        	;
                        	; Parameters:
                        	;		a0 = tid to insert
                        	; Modifies:
                        	;		v1,t0,t1,t2
                        	; Returns:
                        	;		v0 = 1 for success, 0 if failed
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoReadyList:
FFFC37F0 FF870713		sub		$sp,$sp,#8
FFFC37F4 00173023		sto		$ra,[$sp]
                        	;	mov		$v1,$a0
                        	;	ldi		$a0,#'i'
                        	;	call	Putch
                        	;	mov		$a0,$v1
                        	;	call	PutHexByte
FFFC37F8 03F06893		ldi		$v1,#MAX_TID				; check argument
FFFC37FC 0328E663		bgtu	$a0,$v1,.badTid
FFFC3800 00A91E93		sll		$t3,$a0,#LOG_TCBSZ	; tid to pointer
FFFC3804 288ECD03		ldbu	$t0,TCBStatus[$t3]	; set status to ready
FFFC3808 001D6D13		or		$t0,$t0,#TS_READY
FFFC380C 29AE8423		stb		$t0,TCBStatus[$t3]
FFFC3810 289E8D03		ldb		$t0,TCBPriority[$t3]
FFFC3814 19A9000D		insrdy	$a0,$t0
	ldo		$ra,[$sp]
FFFC3818 00073083
FFFC381C 00870713		add		$sp,$sp,#8
FFFC3820 00006813		ldi		$v0,#E_Ok
FFFC3824 00008067		ret
                        	.badTid:
FFFC3828 00073083		ldo		$ra,[$sp]
FFFC382C 00870713		add		$sp,$sp,#8
FFFC3830 00106813		ldi		$v0,#E_Arg
FFFC3834 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; The ready list is a doubly linked list to make it easier and faster to
                        	; remove items from the list. There's no need to search the list for the item
                        	; to remove.
                        	;
                        	; Parameters:
                        	;		a0 = tid to remove
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	; Returns:
                        	;		v0 = E_Ok for success
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromReadyList:
FFFC3838 03F06893		ldi		$v1,#MAX_TID					; check arg
FFFC383C 0128F863		bleu	$a0,$v1,.tidOk
FFFC3840 00106813		ldi		$v0,#E_Arg
FFFC3844 00000637		jmp		ERETx
FFFC3848 27E60067
                        	.tidOk:
FFFC384C 1A09000D		rmvrdy	$a0									; cheat and use hardware
FFFC3850 00A91F13		sll		$t4,$a0,#LOG_TCBSZ		; s1 = pointer to tcb
FFFC3854 288F0D03		ldb		$t0,TCBStatus[$t4]		; set status no longer ready or running
FFFC3858 F7ED7D13		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$t4]
FFFC385C 29AF0423
FFFC3860 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id to insert
                        	;		a1 = timeout value
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoTimeoutList:
FFFC3864 1139000D		setto	$a0,$a1
	sll		$t5,$a0,#LOG_TCBSZ		; tid to pointer
FFFC3868 00A91F93
FFFC386C 288FCE03		ldbu	$t2,TCBStatus[$t5]		; set status to timing out
FFFC3870 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC3874 29CF8423		stb		$t2,TCBStatus[$t5]
FFFC3878 00006813		ldi		$v0,#E_Ok
FFFC387C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove a task from the timeout list. The timeouts of following tasks are
                        	; adjusted. Called when a mailbox is freed and a task is waiting at the
                        	; mailbox. From within scheduling code mPopTimeoutList is used instead.
                        	;
                        	; Parameters:
                        	;		a0 = task id to remove
                        	; Modifies:
                        	;		t0,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromTimeoutList:
FFFC3880 00A91E93		sll		$t3,$a0,#LOG_TCBSZ		; tid to pointer
FFFC3884 288ECD03		ldbu	$t0,TCBStatus[$t3]		; check if waiting at a mailbox
FFFC3888 008D7D13		and		$t0,$t0,#TS_WAITMSG
FFFC388C 000D0C63		beqz	$t0,.noWait				
FFFC3890 FF870713		sub		$sp,$sp,#8
FFFC3894 00173023		sto		$ra,[$sp]
FFFC3898 919FF0EF		call	MbxRemoveTask					; remove task from mailbox
FFFC389C 00073083		ldo		$ra,[$sp]
FFFC38A0 00870713		add		$sp,$sp,#8
                        	.noWait:
FFFC38A4 FE7D7D13		and		$t0,$t0,#~(TS_TIMEOUT|TS_WAITMSG)
	stb		$t0,TCBStatus[$t3]
FFFC38A8 29AE8423
FFFC38AC 1009000D		setto	$a0,$x0
	ldi		$v0,#E_Ok
FFFC38B0 00006813
FFFC38B4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a3 = affinity
                        	; Returns:
                        	;		v1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	AllocTCB:
FFFC38B8 00006D93		ldi		$t1,#0
FFFC38BC 002A9E13		sll		$t2,$a3,#2				; t2 = index into pidmap
FFFC38C0 00024637		ldt		$v1,PIDMAP[$t2]
FFFC38C4 31060613
FFFC38C8 01C60633
FFFC38CC 00062883
                        	.0001:
FFFC38D0 0018FD13		and		$t0,$v1,#1
FFFC38D4 020D0463		beqz	$t0,.allocTid
FFFC38D8 0018D893		srl		$v1,$v1,#1
FFFC38DC 80000637		or		$v1,$v1,#$80000000
FFFC38E0 00060613
FFFC38E4 011668B3
FFFC38E8 001D8D93		add		$t1,$t1,#1
FFFC38EC 01FDFD93		and		$t1,$t1,#31
FFFC38F0 FE0D90E3		bnez	$t1,.0001
                        	; here no tcbs available
FFFC38F4 04506813		ldi		$v0,#E_NoMoreTCBs
FFFC38F8 00008067		ret
                        	.allocTid:
FFFC38FC 000DE833		mov		$v0,$t1
FFFC3900 0018E893		or		$v1,$v1,#1
FFFC3904 000D8A63		beqz	$t1,.0003
                        	.0002:
FFFC3908 00189893		sll		$v1,$v1,#1
FFFC390C 0018E893		or		$v1,$v1,#1
FFFC3910 FFFD8D93		sub		$t1,$t1,#1
FFFC3914 FE0D9AE3		bnez	$t1,.0002
                        	.0003:
FFFC3918 00024637		stt		$v1,PIDMAP[$t2]
FFFC391C 31060613
FFFC3920 01C60633
FFFC3924 01162023
FFFC3928 003E1E13		sll		$t2,$t2,#3					; t2 = hart id base
FFFC392C 01C808B3		add		$v1,$v0,$t2					; pids 0 to 63 (add in hart id base)
FFFC3930 00006813		ldi		$v0,#E_Ok
FFFC3934 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FreeTCB:
FFFC3938 00106D13		ldi		$t0,#1
FFFC393C 012D1D33		sll		$t0,$t0,$a0
FFFC3940 FFFD4D13		xor		$t0,$t0,#-1
FFFC3944 00024637		ldo		$t1,PIDMAP
FFFC3948 31060613
FFFC394C 00060633
FFFC3950 00063D83
FFFC3954 01ADFDB3		and		$t1,$t1,$t0
FFFC3958 FFFC2637		ldo		$t0,InitialPidmap
FFFC395C 67060613
FFFC3960 00060633
FFFC3964 00063D03
FFFC3968 01ADEDB3		or		$t1,$t1,$t0					; OS can't be freed
FFFC396C 00024637		sto		$t1,PIDMAP
FFFC3970 31060613
FFFC3974 00060633
FFFC3978 01B63023
FFFC397C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
                        	DumpReadyList:
FFFC3980 FC070713		sub		$sp,$sp,#64
FFFC3984 00173023		sto		$ra,[$sp]
FFFC3988 01273423		sto		$a0,8[$sp]
FFFC398C 01473823		sto		$a2,16[$sp]
FFFC3990 01573C23		sto		$a3,24[$sp]
FFFC3994 03B73023		sto		$t1,32[$sp]
FFFC3998 03C73423		sto		$t2,40[$sp]
FFFC399C 03D73823		sto		$t3,48[$sp]
FFFC39A0 02473C23		sto		$s1,56[$sp]
FFFC39A4 FFFC4937		ldi		$a0,#msgReadyList
FFFC39A8 AEC90913
FFFC39AC FA5FC0EF		call	PutString
FFFC39B0 00006D93		ldi		$t1,#0
FFFC39B4 3000F273		csrrc	$s1,#$300,#1
FFFC39B8 00006E13		ldi		$t2,#0
                        	.0002:
FFFC39BC AA8FE0EF		call	SerialPeekCharDirect
FFFC39C0 00384813		xor		$v0,$v0,#CTRLC
FFFC39C4 04080E63		beqz	$v0,.brk
FFFC39C8 00D06913		ldi		$a0,#CR
FFFC39CC 939FC0EF		call	Putch
FFFC39D0 F35FC0EF		call	PutHexNybble
FFFC39D4 03A06913		ldi		$a0,#':'
FFFC39D8 92DFC0EF		call	Putch
FFFC39DC 1E0E0E8D		qryrdy	$t3,$t2
	blt		$t3,$x0,.nxt
FFFC39E0 020ECA63
FFFC39E4 000E6933		mov		$a0,$t2
FFFC39E8 ED5FC0EF		call	PutHexHalf
FFFC39EC 02006913		ldi		$a0,#' '
FFFC39F0 915FC0EF		call	Putch
FFFC39F4 000EE933		mov		$a0,$t3
FFFC39F8 EE9FC0EF		call	PutHexByte
FFFC39FC 02006913		ldi		$a0,#' '
FFFC3A00 905FC0EF		call	Putch
FFFC3A04 008ED913		srl		$a0,$t3,#8
FFFC3A08 ED9FC0EF		call	PutHexByte
FFFC3A0C 00D06913		ldi		$a0,#CR
FFFC3A10 8F5FC0EF		call	Putch
                        	.nxt:
FFFC3A14 001E0E13		add		$t2,$t2,#1
FFFC3A18 03FE7E13		and		$t2,$t2,#$3F
FFFC3A1C FA0E10E3		bnez	$t2,.0002
                        	.brk:
FFFC3A20 30021073		csrrw	$x0,#$300,$s1
FFFC3A24 00073083		ldo		$ra,[$sp]
FFFC3A28 00873903		ldo		$a0,8[$sp]
FFFC3A2C 01073A03		ldo		$a2,16[$sp]
FFFC3A30 01873A83		ldo		$a3,24[$sp]
FFFC3A34 02073D83		ldo		$t1,32[$sp]
FFFC3A38 02873E03		ldo		$t2,40[$sp]
FFFC3A3C 03073E83		ldo		$t3,48[$sp]
FFFC3A40 03873203		ldo		$s1,56[$sp]
FFFC3A44 04070713		add		$sp,$sp,#64
FFFC3A48 00008067		ret
                        	
                        	DumpTimeoutList:
FFFC3A4C FE070713		sub		$sp,$sp,#32
FFFC3A50 00172023		stt		$ra,[$sp]
FFFC3A54 01272223		stt		$a0,4[$sp]
FFFC3A58 01472423		stt		$a2,8[$sp]
FFFC3A5C 01572623		stt		$a3,12[$sp]
FFFC3A60 01B72823		stt		$t1,16[$sp]
FFFC3A64 01C72A23		stt		$t2,20[$sp]
FFFC3A68 01D72C23		stt		$t3,24[$sp]
FFFC3A6C 00472E23		stt		$s1,28[$sp]
FFFC3A70 FFFC4937		ldi		$a0,#msgTimeoutList
FFFC3A74 B1890913
FFFC3A78 ED9FC0EF		call	PutString
FFFC3A7C 00006D93		ldi		$t1,#0
FFFC3A80 3000F273		csrrc	$s1,#$300,#1
FFFC3A84 00006A93		ldi		$a3,#0
                        	.0002:
FFFC3A88 9DCFE0EF		call	SerialPeekCharDirect
FFFC3A8C 00384813		xor		$v0,$v0,#CTRLC
FFFC3A90 02080863		beqz	$v0,.brk
FFFC3A94 00D06913		ldi		$a0,#CR
FFFC3A98 86DFC0EF		call	Putch
                        	;	ldw		$a2,TimeoutList
                        	;	bltz	$a2,.brk
                        	;	mov		$a3,$a2
                        	;.0001:
FFFC3A9C 000AE933		mov		$a0,$a3
FFFC3AA0 E1DFC0EF		call	PutHexHalf
FFFC3AA4 02D06913		ldi		$a0,#'-'
FFFC3AA8 85DFC0EF		call	Putch
FFFC3AAC 120D890D		getto	$a0,$t1
;	sll		$a3,$a3,#LOG_TCBSZ
                        	;	ldt		$a0,TCBTimeout[$a3]
FFFC3AB0 DE9FC0EF		call	PutHexWord
                        	;	ldi		$a0,#CR
                        	;	call	Putch
FFFC3AB4 001A8A93		add		$a3,$a3,#1
FFFC3AB8 00FAFA93		and		$a3,$a3,#15
FFFC3ABC FD5046E3		bgt		$a3,$x0,.0002
                        	;	ldw		$a3,TCBNext[$a3]
                        	;	bge		$a3,$x0,.0001
                        	.brk:
FFFC3AC0 30021073		csrrw	$x0,#$300,$s1
FFFC3AC4 00072083		ldt		$ra,[$sp]
FFFC3AC8 00472903		ldt		$a0,4[$sp]
FFFC3ACC 00872A03		ldt		$a2,8[$sp]
FFFC3AD0 00C72A83		ldt		$a3,12[$sp]
FFFC3AD4 01072D83		ldt		$t1,16[$sp]
FFFC3AD8 01472E03		ldt		$t2,20[$sp]
FFFC3ADC 01872E83		ldt		$t3,24[$sp]
FFFC3AE0 01C72203		ldt		$s1,28[$sp]
FFFC3AE4 02070713		add		$sp,$sp,#32
FFFC3AE8 00008067		ret
                        	
                        	msgReadyList:
FFFC3AEC 6165520D		db	CR,"Ready List",CR,LNFD
FFFC3AF0 4C207964
FFFC3AF4 0D747369
FFFC3AF8 6469540A
FFFC3AF9 20646954		db	"Tid  Prv  Nxt",CR,LNFD
FFFC3AFD 76725020
FFFC3B01 784E2020
FFFC3B05 2D0A0D74
FFFC3B08 2D2D2D2D		db	"-------------",CR,LNFD,0
FFFC3B0C 2D2D2D2D
FFFC3B10 2D2D2D2D
FFFC3B14 000A0D2D
                        	
                        	msgTimeoutList:
FFFC3B18 6D69540D		db	CR,"Timeout List",CR,LNFD
FFFC3B1C 74756F65
FFFC3B20 73694C20
FFFC3B24 200A0D74
FFFC3B27 64695420		db	" Tid - Timeout",CR,LNFD
FFFC3B2B 54202D20
FFFC3B2F 6F656D69
FFFC3B33 0A0D7475
FFFC3B37 2D2D2D2D		db	"--------------",CR,LNFD,0
FFFC3B3B 2D2D2D2D
FFFC3B3F 2D2D2D2D
FFFC3B43 0A0D2D2D
FFFC3B47 00E07300
                        	
                        		align 4                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;-----------------------------------------------------------------------------
                        	; IO Focus routines complicated by the fact that the base address of TCB
                        	; zero is zero (looks like a null pointer but isn't). So the value -1 is 
                        	; used to indicate no focus index.
                        	;-----------------------------------------------------------------------------
                        	
                        	.file "../fmtk/iofocus.r5a",31
                        		code
                        		align	4                        	
                        	
                        	;-----------------------------------------------------------------------------
                        	; Determine if the currently running task has the I/O focus.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		v0 = E_Ok
                        	;		v1 = 1 if task has IO focus, 0 otherwise
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_HasIOFocus:
                        		; Enable interrupts
FFFC3B48 3000E073		csrrs	$x0,#$300,#1				
FFFC3B4C 00025637		ldb		$v0,SwitchIOFocus
FFFC3B50 82060613
FFFC3B54 00060633
FFFC3B58 00060803
FFFC3B5C 00080C63		beqz	$v0,.noSwitch
FFFC3B60 00025637		stb		$x0,SwitchIOFocus
FFFC3B64 82060613
FFFC3B68 00060633
FFFC3B6C 00060023
FFFC3B70 034000EF		call	FMTK_SwitchIOFocus
                        	.noSwitch:
                        		
FFFC3B74 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC3B78 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC3B7C 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC3B80 2400088D		nxtiof	$v1
FFFC3B84 2600088D		prviof	$v1
FFFC3B88 3000E073		csrrs	$x0,#$300,#1				
                        	;	ldo		$v1,IOFocusNdx
FFFC3B8C 01180663		beq		$v0,$v1,.hasFocus
FFFC3B90 00006893		ldi		$v1,#0
FFFC3B94 00000463		bra		.xit
                        	.hasFocus:
FFFC3B98 00106893		ldi		$v1,#1
                        	.xit:
FFFC3B9C 00006813		ldi		$v0,#E_Ok
FFFC3BA0 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; First check if it's even possible to switch the focus to another
                        	; task. The I/O focus list could be empty or there may be only a
                        	; single task in the list. In either case it's not possible to
                        	; switch.
                        	;
                        	;	Parameters:
                        	;		none
                        	;	Modifies:
                        	;		a0,a1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_SwitchIOFocus:
FFFC3BA4 FF870713		sub		$sp,$sp,#8
FFFC3BA8 00173023		sto		$ra,[$sp]
FFFC3BAC 24000D0D		nxtiof	$t0
FFFC3BB0 26000D8D		prviof	$t1
FFFC3BB4 09BD0C63		beq		$t0,$t1,.sameFocus
FFFC3BB8 080D4A63		bltz	$t0,.noFocus
FFFC3BBC 24000D0D		nxtiof	$t0
                        	
                        	;	ldo		$t0,IOFocusNdx			; get focus pointer
                        	;	bltz	$t0,.noFocus				; is it -1?
                        	;	ldo		$t1,IOF_NEXT[$t0]
                        	;	beq		$t1,$t0,.sameFocus
                        	;	bltz	$t1,.noFocus
FFFC3BC0 3000E073		csrrs	$x0,#$300,#1				; enable interrupts
                        		; swap virtual text screens
FFFC3BC4 65806213		ldi		$s1,#56*29
FFFC3BC8 330D3E03		ldo		$t2,TCBVideoMem[$t0]
FFFC3BCC 020E0A63		beqz	$t2,.0002
FFFC3BD0 33CD3C23		sto		$t2,TCBpVideo[$t0]
FFFC3BD4 FFD00EB7		ldi		$t3,#$FFD00000
FFFC3BD8 000E8E93
FFFC3BDC 00AD5913		srl		$a0,$t0,#LOG_TCBSZ
FFFC3BE0 000E69B3		mov		$a1,$t2
FFFC3BE4 C59FD0EF		call	VirtToPhys
                        	.0001:
FFFC3BE8 000EBF03		ldo		$t4,[$t3]
FFFC3BEC 01E83023		sto		$t4,[$v0]
FFFC3BF0 008E8E93		add		$t3,$t3,#8
FFFC3BF4 00880813		add		$v0,$v0,#8
FFFC3BF8 FFF20213		sub		$s1,$s1,#1
FFFC3BFC FE4046E3		bgt		$s1,$x0,.0001
                        	.0002:
FFFC3C00 65806213		ldi		$s1,#56*29
FFFC3C04 330DBE03		ldo		$t2,TCBVideoMem[$t1]
FFFC3C08 020E0A63		beqz	$t2,.0004
FFFC3C0C FFD00EB7		ldi		$t3,#$FFD00000
FFFC3C10 000E8E93
FFFC3C14 33DDBC23		sto		$t3,TCBpVideo[$t1]
FFFC3C18 00ADD913		srl		$a0,$t1,#LOG_TCBSZ
FFFC3C1C 000E69B3		mov		$a1,$t2
FFFC3C20 C1DFD0EF		call	VirtToPhys
                        	.0003:
FFFC3C24 00083F03		ldo		$t4,[$v0]
FFFC3C28 01EEB023		sto		$t4,[$t3]
FFFC3C2C 008E8E93		add		$t3,$t3,#8
FFFC3C30 00880813		add		$v0,$v0,#8
FFFC3C34 FFF20213		sub		$s1,$s1,#1
FFFC3C38 FE4046E3		bgt		$s1,$x0,.0003
                        	.0004:
FFFC3C3C 00025637		sto		$t1,IOFocusNdx
FFFC3C40 81060613
FFFC3C44 00060633
FFFC3C48 01B63023
                        	.sameFocus:
                        	.noFocus:
FFFC3C4C 00006813		ldi		$v0,#E_Ok
FFFC3C50 00073083		ldo		$ra,[$sp]
FFFC3C54 00870713		add		$sp,$sp,#8
FFFC3C58 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; The I/O focus list is an array indicating which jobs are requesting the
                        	; I/O focus. The I/O focus is user controlled by pressing CNTRL-T on the
                        	; keyboard.
                        	;
                        	; Parameters:
                        	;		a1 = task id requesting focus for
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_RequestIOFocus:
FFFC3C5C 2009800D		insiof	$a1
FFFC3C60 00006813		ldi		$v0,#E_Ok
FFFC3C64 00008067		ret
                        	
FFFC3C68 00106D13		ldi		$t0,#1
FFFC3C6C 013D1D33		sll		$t0,$t0,$a1
FFFC3C70 00025637		ldo		$t1,IOFocusTbl			; Is the task already included in the IO focus?
FFFC3C74 81860613
FFFC3C78 00060633
FFFC3C7C 00063D83
FFFC3C80 01ADFE33		and		$t2,$t1,$t0					; test bit
FFFC3C84 060E1463		bnez	$t2,.ret						; If so, don't add again
FFFC3C88 01ADEDB3		or		$t1,$t1,$t0					; set bit indicator
FFFC3C8C 00025637		sto		$t1,IOFocusTbl
FFFC3C90 81860613
FFFC3C94 00060633
FFFC3C98 01B63023
                        		; Disable interrupts while manipulating IO focus list
FFFC3C9C 3000F073		csrrc	$x0,#$300,#1				
FFFC3CA0 00025637		ldo		$t0,IOFocusNdx			; get current index
FFFC3CA4 81060613
FFFC3CA8 00060633
FFFC3CAC 00063D03
FFFC3CB0 00A99D93		sll		$t1,$a1,#LOG_TCBSZ	; t1 = pointer to TCB
FFFC3CB4 020D5063		bge		$t0,$x0,.notEmpty		; is there one? (!= -1)
FFFC3CB8 00025637		sto		$t1,IOFocusNdx			; no current index, so set equal to requester
FFFC3CBC 81060613
FFFC3CC0 00060633
FFFC3CC4 01B63023
FFFC3CC8 2FBDB423		sto		$t1,IOF_NEXT[$t1]		; and loop back to self
FFFC3CCC 2FBDB823		sto		$t1,IOF_PREV[$t1]
FFFC3CD0 00000E63		bra		.ret
                        	.notEmpty:
FFFC3CD4 2F0D3E03		ldo		$t2,IOF_PREV[$t0]		; insert t1 into focus ring
FFFC3CD8 2FCDB823		sto		$t2,IOF_PREV[$t1]
FFFC3CDC 2FADB423		sto		$t0,IOF_NEXT[$t1]
FFFC3CE0 2F0D3E03		ldo		$t2,IOF_PREV[$t0]
FFFC3CE4 2FBE3423		sto		$t1,IOF_NEXT[$t2]
FFFC3CE8 2FBD3823		sto		$t1,IOF_PREV[$t0]
                        	.ret:
FFFC3CEC 00006813		ldi		$v0,#E_Ok
FFFC3CF0 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; ReleaseIOFocus called when the task no longer desires to be on the I/O
                        	; focus list.
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ReleaseIOFocus:
                        		
FFFC3CF4 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC3CF8 000869B3	mov		$a1,$v0
                        		; fall into ForceReleaseIOFocus
                        	
                        	;-----------------------------------------------------------------------------
                        	; Releasing the I/O focus causes the focus to switch if the running job
                        	; had the I/O focus.
                        	; ForceReleaseIOFocus forces the release of the IO focus for a job
                        	; different than the one currently running.
                        	; 
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		a1 = task id to release
                        	; Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ForceReleaseIOFocus:
FFFC3CFC FF870713		sub		$sp,$sp,#8
FFFC3D00 00173023		sto		$ra,[$sp]
FFFC3D04 2209880D		rmviof	$v0,$a1
	beqz	$v0,.noSwitch
FFFC3D08 00080463
FFFC3D0C E99FF0EF		call	FMTK_SwitchIOFocus
                        	.noSwitch:
FFFC3D10 00073083		ldo		$ra,[$sp]
FFFC3D14 00870713		add		$sp,$sp,#8
FFFC3D18 00006813		ldi		$v0,#E_Ok
FFFC3D1C 00008067		ret
                        	
FFFC3D20 3000E073		csrrs	$x0,#$300,#1				; enable interrupts
FFFC3D24 00106D13		ldi		$t0,#1
FFFC3D28 013D1D33		sll		$t0,$t0,$a1
FFFC3D2C 00025637		ldo		$t1,IOFocusTbl
FFFC3D30 81860613
FFFC3D34 00060633
FFFC3D38 00063D83
FFFC3D3C 01ADFE33		and		$t2,$t1,$t0				; test bit for task
FFFC3D40 080E0863		beq		$t2,$x0,.noFocus	; does it even have the focus?
FFFC3D44 FFFD4D13		xor		$t0,$t0,#-1				; get inverted mask
FFFC3D48 01ADFDB3		and		$t1,$t1,$t0				; clear bit for task
FFFC3D4C 00025637		sto		$t1,IOFocusTbl
FFFC3D50 81860613
FFFC3D54 00060633
FFFC3D58 01B63023
FFFC3D5C 00025637		ldo		$t1,IOFocusNdx		; check if the focus being released is the current
FFFC3D60 81060613
FFFC3D64 00060633
FFFC3D68 00063D83
FFFC3D6C 00A99D13		sll		$t0,$a1,#LOG_TCBSZ	; io focus. If so, switch focus
FFFC3D70 03BD1063		bne		$t0,$t1,.notSame
FFFC3D74 FF070713		sub		$sp,$sp,#16
FFFC3D78 01A73023		sto		$t0,[$sp]
FFFC3D7C 01B73423		sto		$t1,8[$sp]
FFFC3D80 E25FF0EF		call	FMTK_SwitchIOFocus
FFFC3D84 00073D03		ldo		$t0,[$sp]
FFFC3D88 00873D83		ldo		$t1,8[$sp]
FFFC3D8C 01070713		add		$sp,$sp,#16
                        	.notSame:
                        		; Disable interrupts while manipulating IO focus list
FFFC3D90 3000F073		csrrc	$x0,#$300,#1				
FFFC3D94 2E8D3E03		ldo		$t2,IOF_NEXT[$t0]
FFFC3D98 020E4C63		blt		$t2,$x0,.done
FFFC3D9C 01AE0A63		beq		$t2,$t0,.pjSame
FFFC3DA0 2F0D3D83		ldo		$t1,IOF_PREV[$t0]
FFFC3DA4 2FBE3823		sto		$t1,IOF_PREV[$t2]
FFFC3DA8 2FCDB423		sto		$t2,IOF_NEXT[$t1]
FFFC3DAC 00000C63		bra		.0001
                        	.pjSame:
FFFC3DB0 FFF06D93		ldi		$t1,#-1
FFFC3DB4 00025637		sto		$t1,IOFocusNdx
FFFC3DB8 81060613
FFFC3DBC 00060633
FFFC3DC0 01B63023
                        	.0001:
FFFC3DC4 FFF06D93		ldi		$t1,#-1
FFFC3DC8 2FBD3423		sto		$t1,IOF_NEXT[$t0]	
FFFC3DCC 2FBD3823		sto		$t1,IOF_PREV[$t0]	
                        	.done:
                        	.noFocus:
FFFC3DD0 00006813		ldi		$v0,#E_Ok
FFFC3DD4 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15   VIA							VIA1
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = function
                        	;		a3 = data
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_IO:
FFFC3DD8 02006813		ldi		$v0,#32
FFFC3DDC 0309FE63		bgeu	$a1,$v0,.badDev
FFFC3DE0 02006893		ldi		$v1,#32
FFFC3DE4 031A7663		bgeu	$a2,$v1,.badFunc
FFFC3DE8 00899813		sll		$v0,$a1,#8					; each device allowed 32 functions (*256)
FFFC3DEC 003A1893		sll		$v1,$a2,#3					; function number *8
FFFC3DF0 00022637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC3DF4 00060613
FFFC3DF8 01060833
FFFC3DFC 01186833		or		$v0,$v0,$v1
FFFC3E00 00083803		ldo		$v0,[$v0]
FFFC3E04 00080663		beq		$v0,$x0,.badFunc
FFFC3E08 000800E7		call	[$v0]
                        	.xit:
FFFC3E0C 00008067		ret
                        	.badFunc:
FFFC3E10 02206813		ldi		$v0,#E_BadDevOp
FFFC3E14 FE000CE3		bra		.xit
                        	.badDev:
FFFC3E18 02006813		ldi		$v0,#E_BadDevNum
FFFC3E1C FE0008E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = I/O channel
                        	;		a1 = points to function table
                        	;------------------------------------------------------------------------------
                        	
                        	CopyDevFuncTbl:
FFFC3E20 00891813		sll		$v0,$a0,#8					; each device allowed 32 functions (*256)
FFFC3E24 00022637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC3E28 00060613
FFFC3E2C 01060833
FFFC3E30 02006D13		ldi		$t0,#32							; 32 functions to copy
                        	.again:
FFFC3E34 0009BE03		ldo		$t2,[$a1]
FFFC3E38 01C83023		sto		$t2,[$v0]
FFFC3E3C 00898993		add		$a1,$a1,#8
FFFC3E40 00880813		add		$v0,$v0,#8
FFFC3E44 FFFD0D13		sub		$t0,$t0,#1
FFFC3E48 FFA046E3		bgt		$t0,$x0,.again
FFFC3E4C 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/scancodes.r5a",1
                        	.file "../fmtk/scancodes.r5a",1
                        		;--------------------------------------------------------------------------
                        		; PS2 scan codes to ascii conversion tables.
                        		;--------------------------------------------------------------------------
                        		;
                        		align	8                        	
                        	_unshiftedScanCodes:
FFFC3E50 A52EA92E		.byte	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
FFFC3E54 ACA2A1A3
FFFC3E58 A6A8AA2E		.byte	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
FFFC3E5C 2E6009A4
FFFC3E60 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
FFFC3E64 2E31712E
FFFC3E68 737A2E2E		.byte	$2e,$2e,$7a,$73,$61,$77,$32,$2e
FFFC3E6C 2E327761
FFFC3E70 6478632E		.byte	$2e,$63,$78,$64,$65,$34,$33,$2e
FFFC3E74 2E333465
FFFC3E78 6676202E		.byte	$2e,$20,$76,$66,$74,$72,$35,$2e
FFFC3E7C 2E357274
FFFC3E80 68626E2E		.byte	$2e,$6e,$62,$68,$67,$79,$36,$2e
FFFC3E84 2E367967
FFFC3E88 6A6D2E2E		.byte	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
FFFC3E8C 2E383775
FFFC3E90 696B2C2E		.byte	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
FFFC3E94 2E39306F
FFFC3E98 6C2F2E2E		.byte	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
FFFC3E9C 2E2D703B
FFFC3EA0 2E272E2E		.byte	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
FFFC3EA4 2E2E3D5B
FFFC3EA8 5D0D2EAD		.byte	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
FFFC3EAC 2E2E5C2E
FFFC3EB0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC3EB4 2E082E2E
FFFC3EB8 932E952E		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
FFFC3EBC 2E2E2E94
FFFC3EC0 2E927F98		.byte	$98,$7f,$92,$2e,$91,$90,$1b,$af
FFFC3EC4 AF1B9091
FFFC3EC8 2E972EAB		.byte	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
FFFC3ECC 2EAE962E
                        	
FFFC3ED0 A72E2E2E		.byte	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
FFFC3ED4 2E2E2E2E
FFFC3ED8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3EDC 2E2E2E2E
FFFC3EE0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3EE4 2E2E2E2E
FFFC3EE8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3EEC 2E2E2E2E
FFFC3EF0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3EF4 2E2E2E2E
FFFC3EF8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3EFC 2E2E2E2E
FFFC3F00 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3F04 2E2E2E2E
FFFC3F08 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3F0C 2E2E2E2E
FFFC3F10 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3F14 2E2E2E2E
FFFC3F18 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3F1C 2E2E2E2E
FFFC3F20 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3F24 2E2E2E2E
FFFC3F28 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3F2C 2E2E2E2E
FFFC3F30 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3F34 2E2E2E2E
FFFC3F38 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3F3C 2E2E2E2E
FFFC3F40 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3F44 2E2E2E2E
FFFC3F48 2EFA2E2E		.byte	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
FFFC3F4C 2E2E2E2E
                        	
                        	_shiftedScanCodes:
FFFC3F50 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3F54 2E2E2E2E
FFFC3F58 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
FFFC3F5C 2E7E092E
FFFC3F60 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
FFFC3F64 2E21512E
FFFC3F68 535A2E2E		.byte	$2e,$2e,$5a,$53,$41,$57,$40,$2e
FFFC3F6C 2E405741
FFFC3F70 4458432E		.byte	$2e,$43,$58,$44,$45,$24,$23,$2e
FFFC3F74 2E232445
FFFC3F78 4656202E		.byte	$2e,$20,$56,$46,$54,$52,$25,$2e
FFFC3F7C 2E255254
FFFC3F80 48424E2E		.byte	$2e,$4e,$42,$48,$47,$59,$5e,$2e
FFFC3F84 2E5E5947
FFFC3F88 4A4D2E2E		.byte	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
FFFC3F8C 2E2A2655
FFFC3F90 494B3C2E		.byte	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
FFFC3F94 2E28294F
FFFC3F98 4C3F3E2E		.byte	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
FFFC3F9C 2E5F503A
FFFC3FA0 2E222E2E		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
FFFC3FA4 2E2E2B7B
FFFC3FA8 7D0D2E2E		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
FFFC3FAC 2E2E7C2E
FFFC3FB0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC3FB4 2E082E2E
FFFC3FB8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3FBC 2E2E2E2E
FFFC3FC0 2E2E7F2E		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
FFFC3FC4 2E1B2E2E
FFFC3FC8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3FCC 2E2E2E2E
                        	
FFFC3FD0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3FD4 2E2E2E2E
FFFC3FD8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3FDC 2E2E2E2E
FFFC3FE0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3FE4 2E2E2E2E
FFFC3FE8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3FEC 2E2E2E2E
FFFC3FF0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3FF4 2E2E2E2E
FFFC3FF8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3FFC 2E2E2E2E
FFFC4000 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC4004 2E2E2E2E
FFFC4008 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC400C 2E2E2E2E
FFFC4010 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC4014 2E2E2E2E
FFFC4018 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC401C 2E2E2E2E
FFFC4020 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC4024 2E2E2E2E
FFFC4028 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC402C 2E2E2E2E
FFFC4030 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC4034 2E2E2E2E
FFFC4038 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC403C 2E2E2E2E
FFFC4040 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC4044 2E2E2E2E
FFFC4048 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC404C 2E2E2E2E
                        	
                        	; control
                        	_keybdControlCodes:
FFFC4050 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC4054 2E2E2E2E
FFFC4058 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
FFFC405C 2E7E092E
FFFC4060 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
FFFC4064 2E21112E
FFFC4068 131A2E2E		.byte	$2e,$2e,$1a,$13,$01,$17,$40,$2e
FFFC406C 2E401701
FFFC4070 0418032E		.byte	$2e,$03,$18,$04,$05,$24,$23,$2e
FFFC4074 2E232405
FFFC4078 0616202E		.byte	$2e,$20,$16,$06,$14,$12,$25,$2e
FFFC407C 2E251214
FFFC4080 08020E2E		.byte	$2e,$0e,$02,$08,$07,$19,$5e,$2e
FFFC4084 2E5E1907
FFFC4088 0A0D2E2E		.byte	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
FFFC408C 2E2A2615
FFFC4090 090B3C2E		.byte	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
FFFC4094 2E28290F
FFFC4098 0C3F3E2E		.byte	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
FFFC409C 2E5F103A
FFFC40A0 2E222E2E		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
FFFC40A4 2E2E2B7B
FFFC40A8 7D0D2E2E		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
FFFC40AC 2E2E7C2E
FFFC40B0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC40B4 2E082E2E
FFFC40B8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC40BC 2E2E2E2E
FFFC40C0 2E2E7F2E		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
FFFC40C4 2E1B2E2E
FFFC40C8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC40CC 2E2E2E2E
                        	
                        	_keybdExtendedCodes:
FFFC40D0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
FFFC40D4 2EA2A1A3
FFFC40D8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC40DC 2E2E2E2E
FFFC40E0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC40E4 2E2E2E2E
FFFC40E8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC40EC 2E2E2E2E
FFFC40F0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC40F4 2E2E2E2E
FFFC40F8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC40FC 2E2E2E2E
FFFC4100 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC4104 2E2E2E2E
FFFC4108 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC410C 2E2E2E2E
FFFC4110 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC4114 2E2E2E2E
FFFC4118 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC411C 2E2E2E2E
FFFC4120 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC4124 2E2E2E2E
FFFC4128 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC412C 2E2E2E2E
FFFC4130 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC4134 2E2E2E2E
FFFC4138 932E952E		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
FFFC413C 2E2E2E94
FFFC4140 2E929998		.byte	$98,$99,$92,$2e,$91,$90,$2e,$2e
FFFC4144 2E2E9091
FFFC4148 2E972E2E		.byte	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
FFFC414C 2E2E962E
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/keybd_driver_asm.r5a",1
                        	.file "../fmtk/keybd_driver_asm.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        		align	8                        	
                        	KeybdFuncTbl:
FFFC4150 00000000		dco		0							; no operation
FFFC4154 00000000
FFFC4158 00000000		dco		0							; setup
FFFC415C 00000000
FFFC4160 00000000		dco		0							; initialize
FFFC4164 00000000
FFFC4168 00000000		dco		0							; status
FFFC416C 00000000
FFFC4170 00000000		dco		0							; media check
FFFC4174 00000000
FFFC4178 00000000		dco		0							; build BPB
FFFC417C 00000000
FFFC4180 00000000		dco		0							; open
FFFC4184 00000000
FFFC4188 00000000		dco		0							; close
FFFC418C 00000000
FFFC4190 00000000		dco		0							; get char
FFFC4194 00000000
FFFC4198 00000000		dco		0							; Peek char
FFFC419C 00000000
FFFC41A0 FFFC455C		dco		_KeybdGetScancode		; get char direct
FFFC41A4 00000000
FFFC41A8 FFFC4548		dco		_KeybdPeekScancode	; Peek char direct
FFFC41AC 00000000
FFFC41B0 00000000		dco		0							; input status
FFFC41B4 00000000
FFFC41B8 00000000		dco		0							; Put char
FFFC41BC 00000000
FFFC41C0 FFFC44BC		dco		_KeybdSendByte	; reserved
FFFC41C4 00000000
FFFC41C8 00000000		dco		0							; set position
FFFC41CC 00000000
FFFC41D0 00000000		dco		0							; read block
FFFC41D4 00000000
FFFC41D8 00000000		dco		0							; write block
FFFC41DC 00000000
FFFC41E0 00000000		dco		0							; verify block
FFFC41E4 00000000
FFFC41E8 00000000		dco		0							; output status
FFFC41EC 00000000
FFFC41F0 00000000		dco		0							; flush input
FFFC41F4 00000000
FFFC41F8 00000000		dco		0							; flush output
FFFC41FC 00000000
FFFC4200 FFFC4580		dco		KeybdIRQ			; IRQ routine
FFFC4204 00000000
FFFC4208 00000000		dco		0							; Is removable
FFFC420C 00000000
FFFC4210 00000000		dco		0							; ioctrl read
FFFC4214 00000000
FFFC4218 00000000		dco		0							; ioctrl write
FFFC421C 00000000
FFFC4220 00000000		dco		0							; output until busy
FFFC4224 00000000
FFFC4228 00000000		dco		0							; 27
FFFC422C 00000000
FFFC4230 00000000		dco		0
FFFC4234 00000000
FFFC4238 00000000		dco		0
FFFC423C 00000000
FFFC4240 00000000		dco		0
FFFC4244 00000000
FFFC4248 00000000		dco		0							; 31
FFFC424C 00000000
                        	
                        	;===============================================================================
                        	; Keyboard routines
                        	;===============================================================================
                        	
                        	SC_C		equ		$21
                        	SC_Z		equ		$1A
                        	SC_TAB	equ		$0D
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Initialize the keyboard.
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        		align	4                        			; we don't know what was before
                        	_KeybdInit:
FFFC4250 FF070713		sub		$sp,$sp,#16
FFFC4254 00173023		sto		$ra,[$sp]
FFFC4258 10300073		pfi
FFFC425C 00106913		ldi		$a0,#1					; Keyboard device
FFFC4260 FFFC49B7		ldi		$a1,#KeybdFuncTbl
FFFC4264 15098993
FFFC4268 10300073		pfi
FFFC426C BB5FF0EF		call	CopyDevFuncTbl
FFFC4270 00006993		ldi		$a1,#0
FFFC4274 00025A37		ldi		$a2,#hKeybdMbx
FFFC4278 822A0A13
FFFC427C 10300073		pfi
FFFC4280 F9DFE0EF		call	FMTK_AllocMbx
FFFC4284 0E000C63		bra		.xit
FFFC4288 00506E93		ldi		$t3,#5
                        	.0002:
FFFC428C 00031937		ldi		$a0,#200000			; 10ms wait
FFFC4290 D4090913
FFFC4294 01D73423		sto		$t3,8[$sp]
FFFC4298 EF0FC0EF		call	_MicroDelay
FFFC429C FFF06913		ldi		$a0,#-1					; send reset code to keyboard
FFFC42A0 00000637		stb		$a0,KEYBD+1			; write $FF to status reg to clear TX state
FFFC42A4 2B060613
FFFC42A8 00060633
FFFC42AC 01260023
FFFC42B0 20C000EF		call	_KeybdSendByte	; now write to transmit register
FFFC42B4 21C000EF		call	_KeybdWaitTx		; wait until no longer busy
FFFC42B8 1A0000EF		call	_KeybdRecvByte	; look for an ACK ($FA)
FFFC42BC 0FA84E13		xor		$t2,$v0,#$FA
FFFC42C0 040E1863		bnez	$t2,.tryAgain
FFFC42C4 194000EF		call	_KeybdRecvByte	; look for BAT completion code ($AA)
FFFC42C8 0FC84E13		xor		$t2,$v0,#$FC		; reset error ?
FFFC42CC 040E0263		beqz	$t2,.tryAgain
FFFC42D0 0AA84813		xor		$v0,$v0,#$AA	; reset complete okay ?
FFFC42D4 02081E63		bnez	$v0,.tryAgain
                        	
                        		; After a reset, scan code set #2 should be active
                        	.config:
FFFC42D8 0F006913		ldi		$a0,#$F0			; send scan code select
FFFC42DC FFDC0637		stb		$a0,LEDS
FFFC42E0 60060613
FFFC42E4 00060633
FFFC42E8 01260023
FFFC42EC 1D0000EF		call	_KeybdSendByte
FFFC42F0 1E0000EF		call	_KeybdWaitTx
FFFC42F4 08087813		and		$v0,$v0,#$80
FFFC42F8 00081C63		bnez	$v0,.tryAgain
FFFC42FC 15C000EF		call	_KeybdRecvByte	; wait for response from keyboard
FFFC4300 08087893		and		$v1,$v0,#$80
FFFC4304 00089663		bnez	$v1,.tryAgain
FFFC4308 0FA84E13		xor		$t2,$v0,#$FA
FFFC430C 020E0463		beqz	$t2,.0004
                        	.tryAgain:
FFFC4310 00873E83		ldo		$t3,8[$sp]
FFFC4314 FFFE8E93	  sub   $t3,$t3,#1
FFFC4318 F60E9AE3		bnez	$t3,.0002
                        	.keybdErr:
FFFC431C 00000937		ldi		$a0,#msgBadKeybd
FFFC4320 2B690913
FFFC4324 FF870713		sub		$sp,$sp,#8
FFFC4328 01273023		sto		$a0,[$sp]
FFFC432C E24FC0EF		call	PutString		; _DBGDisplayAsciiStringCRLF
FFFC4330 02000863		bra		.ledxit
                        	.0004:
FFFC4334 00206913		ldi		$a0,#2			; select scan code set #2
FFFC4338 184000EF		call	_KeybdSendByte
FFFC433C 194000EF		call	_KeybdWaitTx
FFFC4340 08087813		and		$v0,$v0,#$80
FFFC4344 FC0816E3		bnez	$v0,.tryAgain
FFFC4348 110000EF		call	_KeybdRecvByte	; wait for response from keyboard
FFFC434C 08087893		and		$v1,$v0,#$80
FFFC4350 FC0890E3		bnez	$v1,.tryAgain
FFFC4354 0FA84E13		xor		$t2,$v0,#$FA
FFFC4358 FA0E1CE3		bnez	$t2,.tryAgain
FFFC435C 080000EF		call	_KeybdGetID
                        	.ledxit:
FFFC4360 00706913		ldi		$a0,#$07
FFFC4364 028000EF		call	_KeybdSetLED
FFFC4368 005B9937		ldi		$a0,#6000000	; 300 ms
FFFC436C D8090913
FFFC4370 E18FC0EF		call	_MicroDelay
FFFC4374 00006913		ldi		$a0,#$00
FFFC4378 014000EF		call	_KeybdSetLED
                        	.xit:
FFFC437C 10300073		pfi
FFFC4380 00073083		ldo		$ra,[$sp]
FFFC4384 01070713		add		$sp,$sp,#16
FFFC4388 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Set the LEDs on the keyboard.
                        	;
                        	; Parameters: $a0 LED status to set
                        	; Returns: none
                        	; Modifies: none
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdSetLED:
FFFC438C FF070713		sub		$sp,$sp,#16
FFFC4390 00173023		sto		$ra,[$sp]
FFFC4394 00096E33		mov		$t2,$a0
FFFC4398 0ED06913		ldi		$a0,#$ED
FFFC439C 01C73423		sto		$t2,8[$sp]
FFFC43A0 10300073		pfi
FFFC43A4 118000EF		call	_KeybdSendByte
FFFC43A8 128000EF		call	_KeybdWaitTx
FFFC43AC 0AC000EF		call	_KeybdRecvByte	; should be an ack
FFFC43B0 10300073		pfi
FFFC43B4 00873E03		ldo		$t2,8[$sp]
FFFC43B8 000E6933		mov		$a0,$t2
FFFC43BC 10300073		pfi
FFFC43C0 0FC000EF		call	_KeybdSendByte
FFFC43C4 10C000EF		call	_KeybdWaitTx
FFFC43C8 090000EF		call	_KeybdRecvByte	; should be an ack
FFFC43CC 10300073		pfi
FFFC43D0 00073083		ldo		$ra,[$sp]
FFFC43D4 01070713		add		$sp,$sp,#16
FFFC43D8 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get ID - get the keyboards identifier code.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = $AB83, $00 on fail
                        	; Modifies: r1, KeybdID updated
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdGetID:
FFFC43DC FF870713		sub		$sp,$sp,#8
FFFC43E0 00173023		sto		$ra,[$sp]
FFFC43E4 0F206913		ldi		$a0,#$F2
FFFC43E8 10300073		pfi
FFFC43EC 0D0000EF		call	_KeybdSendByte
FFFC43F0 0E0000EF		call	_KeybdWaitTx
FFFC43F4 064000EF		call	_KeybdRecvByte
FFFC43F8 10300073		pfi
FFFC43FC 08087893		and		$v1,$v0,#$80
FFFC4400 04089663		bnez	$v1,.notKbd
FFFC4404 0AB84E13		xor		$t2,$v0,#$AB
FFFC4408 040E1263		bnez	$t2,.notKbd
FFFC440C 10300073		pfi
FFFC4410 048000EF		call	_KeybdRecvByte
FFFC4414 08087893		and		$v1,$v0,#$80
FFFC4418 02089A63		bnez	$v1,.notKbd
FFFC441C 08384E13		xor		$t2,$v0,#$83
FFFC4420 020E1663		bnez	$t2,.notKbd
FFFC4424 0000B837		ldi		$v0,#$AB83
FFFC4428 B8380813
                        	.0001:
FFFC442C 10300073		pfi
FFFC4430 00000637		stt		$v0,_KeybdID
FFFC4434 2BC60613
FFFC4438 00060633
FFFC443C 01062023
FFFC4440 00073083		ldo		$ra,[$sp]
FFFC4444 00870713		add		$sp,$sp,#8
FFFC4448 00008067		ret
                        	.notKbd:
FFFC444C 10300073		pfi
FFFC4450 00006813		ldi		$v0,#$00
FFFC4454 FC000CE3		bra		.0001
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Recieve a byte from the keyboard, used after a command is sent to the
                        	; keyboard in order to wait for a response.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = recieved byte ($00 to $FF), -1 on timeout
                        	; Modifies: r1
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdRecvByte:
FFFC4458 FF070713		sub		$sp,$sp,#16
FFFC445C 00173023		sto		$ra,[$sp]
FFFC4460 06406E93		ldi		$t3,#100				; wait up to 1s
                        	.0003:
FFFC4464 10300073		pfi
FFFC4468 0CC000EF		call	_KeybdGetStatus	; wait for response from keyboard
FFFC446C 08087813		and		$v0,$v0,#$80		; is input buffer full ? yes, branch
FFFC4470 02081C63		bnez	$v0,.0004
FFFC4474 00031937		ldi		$a0,#200000
FFFC4478 D4090913
FFFC447C 01D73423		sto		$t3,8[$sp]
FFFC4480 10300073		pfi
FFFC4484 D04FC0EF		call	_MicroDelay
FFFC4488 00873E83		ldo		$t3,8[$sp]
FFFC448C FFFE8E93		sub   $t3,$t3,#1
FFFC4490 FC0E9AE3		bnez	$t3,.0003				; go back and try again
FFFC4494 10300073		pfi
FFFC4498 FFF06813		ldi		$v0,#-1				; return -1
FFFC449C 00073083		ldo		$ra,[$sp]
FFFC44A0 01070713		add		$sp,$sp,#16
FFFC44A4 00008067		ret
                        	.0004:
FFFC44A8 10300073		pfi
FFFC44AC 0B0000EF		call	_KeybdGetScancode
FFFC44B0 00073083		ldo		$ra,[$sp]
FFFC44B4 01070713		add		$sp,$sp,#16
FFFC44B8 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Send a byte to the keyboard.
                        	;
                        	; Parameters: $a0 byte to send
                        	; Returns: none
                        	; Modifies: none
                        	; Stack Space: 0 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdSendByte:
FFFC44BC 00000637		stb		$a0,KEYBD
FFFC44C0 2AF60613
FFFC44C4 00060633
FFFC44C8 01260023
FFFC44CC 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Wait until the keyboard transmit is complete
                        	;
                        	; Parameters: none
                        	; Returns: r1 = 0 if successful, r1 = -1 timeout
                        	; Modifies: v0,t3
                        	; Stack Space: 1 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdWaitTx:
FFFC44D0 FF070713		sub		$sp,$sp,#16
FFFC44D4 00173023		sto		$ra,[$sp]
FFFC44D8 06406E93		ldi		$t3,#100			; wait a max of 1s
                        	.0001:
FFFC44DC 10300073		pfi
FFFC44E0 054000EF		call	_KeybdGetStatus
FFFC44E4 04087813		and		$v0,$v0,#$40	; check for transmit complete bit; branch if bit set
FFFC44E8 02081C63		bnez	$v0,.0002
FFFC44EC 01D73423		sto		$t3,8[$sp]
FFFC44F0 00031937		ldi		$a0,#200000		; 10 ms @20MHz
FFFC44F4 D4090913
FFFC44F8 10300073		pfi
FFFC44FC C8CFC0EF		call	_MicroDelay		; delay a little bit
FFFC4500 00873E83		ldo		$t3,8[$sp]
FFFC4504 FFFE8E93		sub		$t3,$t3,#1
FFFC4508 FC0E9AE3		bnez	$t3,.0001
FFFC450C 10300073		pfi
FFFC4510 00073083		ldo		$ra,[$sp]			; timed out
FFFC4514 00870713		add		$sp,$sp,#8
FFFC4518 FFF06813		ldi		$v0,#-1
FFFC451C 00008067		ret		
                        	.0002:
FFFC4520 10300073		pfi
FFFC4524 00073083		ldo		$ra,[$sp]			; timed out
FFFC4528 01070713		add		$sp,$sp,#16
FFFC452C 00006813		ldi		$v0,#0
FFFC4530 00008067		ret		
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get the keyboard status
                        	;
                        	; Parameters: none
                        	; Returns: r1 = status
                        	; Modifies: r1
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdGetStatus:
FFFC4534 00000637		ldb		$v0,KEYBD+1
FFFC4538 2B060613
FFFC453C 00060633
FFFC4540 00060803
FFFC4544 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get the scancode from the keyboard port. Getting the scancode clears the
                        	; interrupt status.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = scancode
                        	; Modifies: r1
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdPeekScancode:
FFFC4548 00000637		ldbu		$v0,KEYBD			; get the scan code
FFFC454C 2AF60613
FFFC4550 00060633
FFFC4554 00064803
FFFC4558 00008067		ret
                        	
                        	_KeybdGetScancode:
FFFC455C 00000637		ldbu		$v0,KEYBD			; get the scan code
FFFC4560 2AF60613
FFFC4564 00060633
FFFC4568 00064803
FFFC456C 00000637		stb			$x0,KEYBD+1		; clear receive register
FFFC4570 2B060613
FFFC4574 00060633
FFFC4578 00060023
FFFC457C 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	KeybdIRQ:
FFFC4580 FB5FF0EF		call	_KeybdGetStatus
FFFC4584 0E085E63		bge		$v0,$x0,.notKbd
FFFC4588 FD5FF0EF		call	_KeybdGetScancode
FFFC458C 10300073		pfi
FFFC4590 00025637		ldo		$s1,IOFocusNdx
FFFC4594 81060613
FFFC4598 00060633
FFFC459C 00063203
FFFC45A0 0E020063		beqz	$s1,.notKbd
FFFC45A4 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC45A8 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC45AC 001D0D13		add		$t0,$t0,#1
FFFC45B0 01FD7D13		and		$t0,$t0,#31
FFFC45B4 01BD0863		beq		$t0,$t1,.noRoom
FFFC45B8 10300073		pfi
FFFC45BC 31A20023		stb		$t0,TCBKbdHead[$s1]
FFFC45C0 31020423		stb		$v0,TCBKbdBuf[$s1]
                        	.noRoom:
FFFC45C4 10300073		pfi
                        		; check trigger debugger
                        		; check CTRL-C
FFFC45C8 00000637		lbu		$t0,TCBKbdState2
FFFC45CC 2C460613
FFFC45D0 00060633
FFFC45D4 00064D03
FFFC45D8 004D7D93		and		$t1,$t0,#4
FFFC45DC 020D8E63		beqz	$t1,.notCtrl
FFFC45E0 02106D13		ldi		$t0,#SC_C
FFFC45E4 01A81863		bne		$v0,$t0,.notCtrlC
FFFC45E8 00306D13		ldi		$t0,#3
FFFC45EC 2DA23423		sto		$t0,TCBException[$s1]
FFFC45F0 02000463		bra		.0001
                        	.notCtrlC:
FFFC45F4 10300073		pfi
FFFC45F8 01A06D13		ldi		$t0,#SC_Z
FFFC45FC 01A81E63		bne		$v0,$t0,.notCtrlZ
FFFC4600 01A06D13		ldi		$t0,#26
                        		
FFFC4604 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC4608 00081813	sll		$v0,$v0,#32
FFFC460C 01A86833		or		$v0,$v0,$t0
FFFC4610 2D023423		sto		$v0,TCBException[$s1]
FFFC4614 00000263		bra		.0001
                        	.notCtrlZ:
                        	.0001:
                        	.notCtrl:
FFFC4618 10300073		pfi
FFFC461C 002D7D93		and		$t1,$t0,#2
FFFC4620 CA0D84E3		beqz	$t1,.notAlt
FFFC4624 00D06D13		ldi		$t0,#SC_TAB
FFFC4628 01A81A63		bne		$v0,$t0,.notAltTab
FFFC462C 00025637		stb		$t0,SwitchIOFocus
FFFC4630 82060613
FFFC4634 00060633
FFFC4638 01A60023
                        	.notAltTab:
FFFC463C 10300073		pfi
                        		; Send a message indicating a key is available
                        		; Keyboard mailbox setup yet?
FFFC4640 00025637		ldw		$a1,hKeybdMbx
FFFC4644 82260613
FFFC4648 00060633
FFFC464C 00061983
FFFC4650 0209C863		blt		$a1,$x0,.notKbd
                        		; If there's already a keyboard message, don't send another one.
FFFC4654 00599213		sll		$s1,$a1,#LOG_MBXSZ
FFFC4658 00020637		add		$s1,$s1,#mbxs
FFFC465C 00060613
FFFC4660 00460233
FFFC4664 01823D03		ldo		$t0,MBX_MQTAIL[$s1]
FFFC4668 000D1C63		bnez	$t0,.notKbd
FFFC466C 10300073		pfi
FFFC4670 FFF06A13		ldi		$a2,#-1
FFFC4674 FFF06A93		ldi		$a3,#-1
FFFC4678 FFF06B13		ldi		$a4,#-1
FFFC467C DA5FE0EF		call	FMTK_SendMsg
                        	.notKbd:
FFFC4680 10300073		pfi
FFFC4684 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC4688 10000073		eret
                        	
                        	; Return -1 if there is a scancode available in the buffer.
                        	
                        	_KeybdGetBufferStatus:
                        		
FFFC468C 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC4690 00A81213	sll		$s1,$v0,#LOG_TCBSZ
FFFC4694 10300073		pfi
FFFC4698 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC469C 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC46A0 01BD0663		beq		$t0,$t1,.empty
FFFC46A4 FFF06813		ldi		$v0,#-1
FFFC46A8 00008067		ret
                        	.empty:
FFFC46AC 10300073		pfi
FFFC46B0 00006813		ldi		$v0,#0
FFFC46B4 00008067		ret
                        	
                        	_KeybdGetBufferedScancode:	
                        		
FFFC46B8 18101873		csrrw	$v0,#$181,$x0
                        	;	csrrw	$v1,#$F10,$x0
                        	;	and		$v1,$v1,#$FFFFFF80
                        	;	and		$v0,$v0,#31
                        	;	or		$v0,$v0,$v1
FFFC46BC 00A81213	sll		$s1,$v0,#LOG_TCBSZ
FFFC46C0 00006813		ldi		$v0,#0									; $v0 = scancode
FFFC46C4 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC46C8 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC46CC 10300073		pfi
FFFC46D0 01BD0C63		beq		$t0,$t1,.empty					; return 0 if empty
FFFC46D4 004D8D33		add		$t0,$t1,$s1							; calc pointer to buffer entry
FFFC46D8 308D4803		ldbu	$v0,TCBKbdBuf[$t0]			; get buffer entry
FFFC46DC 001D8D93		add		$t1,$t1,#1							; increment tail pointer
FFFC46E0 01FDFD93		and		$t1,$t1,#31
FFFC46E4 31B200A3		stb		$t1,TCBKbdTail[$s1]			; store tail pointer
                        	.empty:
FFFC46E8 10300073		pfi
FFFC46EC 00008067		ret
                        	
                        	; Parameters:
                        	;		a0 = scancode
                        	
                        	_XlatScancode:
FFFC46F0 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/source/drivers/prng_driver_asm.r5a",1
                        	.file "../fmtk/source/drivers/prng_driver_asm.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2018-2020  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;
                        	;	prng_driver_asm.r5a
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	;
                        	;------------------------------------------------------------------------------
                        	
                        	PRNGL					equ		$FFDC0C00
                        	PRNG_VALUE		equ		$00
                        	PRNG_STREAM		equ		$08
                        	
                        	.file "../fmtk/source/drivers/prng_driver_asm.r5a",33
                        			code	18
                        	;------------------------------------------------------------------------------
                        	; Initialize PRNG
                        	;------------------------------------------------------------------------------
                        	_PRNGInit:
FFFC46F4 00025637			sto		$x0,_randStream
FFFC46F8 83060613
FFFC46FC 00060633
FFFC4700 00063023
FFFC4704 FFDC1D37			ldi		$t0,#PRNGL
FFFC4708 C00D0D13
FFFC470C 000D3423			sto		$x0,$08[$t0]			; select stream #0
FFFC4710 88889837			ldi		$v0,#$88888888
FFFC4714 88880813
FFFC4718 10300073			pfi
FFFC471C 010D3823			sto		$v0,$10[$t0]			; set initial m_z
FFFC4720 01234837			ldi		$v0,#$01234567
FFFC4724 56780813
FFFC4728 010D3C23			sto		$v0,$18[$t0]			; set initial m_w
FFFC472C 00008067			ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Seed random number generator.
                        	;
                        	; Parameters:
                        	;		$a0 - stream to seed
                        	;		$a1 - value to use as seed
                        	;		$a2 - value to use as seed
                        	; Modifies:
                        	;		$t0
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	_SeedRand:
FFFC4730 FFDC1D37			ldi		$t0,#PRNGL
FFFC4734 C00D0D13
FFFC4738 10300073			pfi
FFFC473C 012D3423			sto		$a0,$08[$t0]		; select stream #
FFFC4740 013D3823			sto		$a1,$10[$t0]		; set initial m_z
FFFC4744 014D3C23			sto		$a2,$18[$t0]		; set initial m_w
FFFC4748 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a random number, and generate the next number.
                        	;
                        	; Parameters:
                        	;		$a0 = random stream number.
                        	; Returns:
                        	;		$v0 = random 32 bit number.
                        	;------------------------------------------------------------------------------
                        	
                        	_PeekRand:
FFFC474C 10300073			pfi
FFFC4750 FFDC1637			sto		$a0,PRNGL+PRNG_STREAM	; set the stream
FFFC4754 C0860613
FFFC4758 00060633
FFFC475C 01263023
FFFC4760 FFDC1637			ldo		$v0,PRNGL+PRNG_VALUE		; get a number
FFFC4764 C0060613
FFFC4768 00060633
FFFC476C 00063803
FFFC4770 00008067			ret
                        	
                        	_GetRand:
FFFC4774 10300073			pfi
FFFC4778 FFDC1637			sto		$a0,PRNGL+PRNG_STREAM	; set the stream
FFFC477C C0860613
FFFC4780 00060633
FFFC4784 01263023
FFFC4788 FFDC1637			ldo		$v0,PRNGL+PRNG_VALUE		; get a number
FFFC478C C0060613
FFFC4790 00060633
FFFC4794 00063803
FFFC4798 FFDC1637			sto		$x0,PRNGL+PRNG_VALUE		; generate next number
FFFC479C C0060613
FFFC47A0 00060633
FFFC47A4 00063023
FFFC47A8 00008067			ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/source/kernel/DBGKeybd.s",1
                        	.file "../fmtk/source/kernel/DBGKeybd.s",1
                        	.file "../fmtk/source/kernel/DBGKeybd.s",94
                        		code
FFFC47AC 00000000		align	1
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC47B0 FE070713	public code _DBGCheckForKey:
	      	sub      	$sp,$sp,#32
FFFC47B4 00273023		      	sto      	$fp,[$sp]
FFFC47B8 00073423		      	sto      	$x0,8[$sp]
FFFC47BC 00173C23		      	sto      	$ra,24[$sp]
FFFC47C0 00076133		      	mov      	$fp,$sp
FFFC47C4 D71FF0EF		      	call     	_KeybdGetStatus
FFFC47C8 00086D33		      	mov      	$t0,$v0
FFFC47CC 000D6833		      	mov      	$v0,$t0
                        	DBGKeybd_5:
                        	DBGKeybd_8:
FFFC47D0 00016733		      	mov      	$sp,$fp
FFFC47D4 00073103		      	ldo      	$fp,[$sp]
FFFC47D8 01873083		      	ldo      	$ra,24[$sp]
FFFC47DC 02070713		      	add      	$sp,$sp,#32
FFFC47E0 00008067		      	ret      
                        	endpublic
                        	
                        	.file "../fmtk/source/kernel/DBGKeybd.s",119
                        		code
FFFC47E4 00000000		align	1
FFFC47E8 00000000
FFFC47EC 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC47F0 FE070713	public code _DBGGetKey:
	      	sub      	$sp,$sp,#32
FFFC47F4 00273023		      	sto      	$fp,[$sp]
FFFC47F8 00073423		      	sto      	$x0,8[$sp]
FFFC47FC 00173C23		      	sto      	$ra,24[$sp]
FFFC4800 00076133		      	mov      	$fp,$sp
FFFC4804 FC270713		      	sub      	$sp,$sp,#62
FFFC4808 00473023		      	sto      	$s1,0[$sp]
FFFC480C 00573423		      	sto      	$s2,8[$sp]
FFFC4810 00673823		      	sto      	$s3,16[$sp]
FFFC4814 00773C23		      	sto      	$s4,24[$sp]
FFFC4818 FEE13203		      	ldo      	$s1,-18[$fp]
FFFC481C FF710283		      	ldb      	$s2,-9[$fp]
FFFC4820 FF813303		      	ldo      	$s3,-8[$fp]
FFFC4824 0000A3B7		      	ldi      	$s4,#40000
FFFC4828 C4038393
                        	DBGKeybd_66:
                        	; 		for (count = 0; (KeybdGetStatus() & 0x40) != 0 && count < 40000; count++);
FFFC482C 00006233		      	mov      	$s1,$x0
FFFC4830 D05FF0EF		      	call     	_KeybdGetStatus
FFFC4834 00086DB3		      	mov      	$t1,$v0
FFFC4838 040DFD13		      	and      	$t0,$t1,#64
FFFC483C 020D0063		      	beq      	$t0,$x0,DBGKeybd_69
FFFC4840 00725E63		      	bge      	$s1,$s4,DBGKeybd_69
                        	DBGKeybd_68:
FFFC4844 00120213		      	add      	$s1,$s1,#1
FFFC4848 CEDFF0EF		      	call     	_KeybdGetStatus
FFFC484C 00086DB3		      	mov      	$t1,$v0
FFFC4850 040DFD13		      	and      	$t0,$t1,#64
FFFC4854 000D0463		      	beq      	$t0,$x0,DBGKeybd_71
FFFC4858 FE7246E3		      	blt      	$s1,$s4,DBGKeybd_68
                        	DBGKeybd_71:
                        	DBGKeybd_69:
                        	; 		while ((KeybdGetStatus() & 0x80) == 0) {
FFFC485C CD9FF0EF		      	call     	_KeybdGetStatus
FFFC4860 00086DB3		      	mov      	$t1,$v0
FFFC4864 080DFD13		      	and      	$t0,$t1,#128
FFFC4868 040D1063		      	bne      	$t0,$x0,DBGKeybd_73
                        	DBGKeybd_72:
                        	; 			if (!block)
FFFC486C 02091663		      	bne      	$a0,$x0,DBGKeybd_74
                        	; 				return (-1);
FFFC4870 FFF06813		      	ldi      	$v0,#-1
                        	DBGKeybd_62:
                        	DBGKeybd_65:
FFFC4874 00073203		      	ldo      	$s1,0[$sp]
FFFC4878 00873283		      	ldo      	$s2,8[$sp]
FFFC487C 01073303		      	ldo      	$s3,16[$sp]
FFFC4880 01873383		      	ldo      	$s4,24[$sp]
FFFC4884 00016733		      	mov      	$sp,$fp
FFFC4888 00073103		      	ldo      	$fp,[$sp]
FFFC488C 01873083		      	ldo      	$ra,24[$sp]
FFFC4890 02070713		      	add      	$sp,$sp,#32
FFFC4894 00008067		      	ret      
                        	DBGKeybd_74:
FFFC4898 C9DFF0EF		      	call     	_KeybdGetStatus
FFFC489C 00086DB3		      	mov      	$t1,$v0
FFFC48A0 080DFD13		      	and      	$t0,$t1,#128
FFFC48A4 FC0D04E3		      	beq      	$t0,$x0,DBGKeybd_72
                        	DBGKeybd_73:
                        	; 		sc = KeybdGetScancode() & 0xff;
FFFC48A8 CB5FF0EF		      	call     	_KeybdGetScancode
FFFC48AC 00086DB3		      	mov      	$t1,$v0
FFFC48B0 0FFDFD13		      	and      	$t0,$t1,#255
FFFC48B4 000D6333		      	mov      	$s3,$t0
                        	; 		for (count = 0; count < 20; count++)
FFFC48B8 00006233		      	mov      	$s1,$x0
FFFC48BC 01422D13		      	slt      	$t0,$s1,#20
FFFC48C0 000D0863		      	beqz     	$t0,DBGKeybd_77
                        	DBGKeybd_76:
                        	; 			;
FFFC48C4 00120213		      	add      	$s1,$s1,#1
FFFC48C8 01422D13		      	slt      	$t0,$s1,#20
FFFC48CC FE0D1CE3		      	bnez     	$t0,DBGKeybd_76
                        	DBGKeybd_77:
                        	; 	  case 0xF0:
FFFC48D0 0F034D13		      	xor      	$t0,$s3,#240
FFFC48D4 040D0063		      	beq      	$t0,$x0,DBGKeybd_90
                        	; 	  case 0xE0:
FFFC48D8 0E034D13		      	xor      	$t0,$s3,#224
FFFC48DC 040D0863		      	beq      	$t0,$x0,DBGKeybd_91
                        	; 	  case 0x14:
FFFC48E0 01434D13		      	xor      	$t0,$s3,#20
FFFC48E4 060D0863		      	beq      	$t0,$x0,DBGKeybd_92
                        	; 	  case 0x59:
FFFC48E8 05934D13		      	xor      	$t0,$s3,#89
FFFC48EC 0C0D0E63		      	beq      	$t0,$x0,DBGKeybd_93
                        	; 	  case 0x77:
FFFC48F0 07734D13		      	xor      	$t0,$s3,#119
FFFC48F4 140D0463		      	beq      	$t0,$x0,DBGKeybd_94
                        	; 	  case 0x58:
FFFC48F8 05834D13		      	xor      	$t0,$s3,#88
FFFC48FC 1A0D0063		      	beq      	$t0,$x0,DBGKeybd_95
                        	; 	  case 0x7E:
FFFC4900 07E34D13		      	xor      	$t0,$s3,#126
FFFC4904 1E0D0C63		      	beq      	$t0,$x0,DBGKeybd_96
                        	; 	  case 0x11:
FFFC4908 01134D13		      	xor      	$t0,$s3,#17
FFFC490C 240D0863		      	beq      	$t0,$x0,DBGKeybd_97
                        	; 	  default:
FFFC4910 2C000063		      	bra      	DBGKeybd_98
                        	DBGKeybd_90:
                        	;       KeyState1 = -1;
FFFC4914 FFF06D13		      	ldi      	$t0,#-1
FFFC4918 00025637		      	stb      	$t0,_KeyState1
FFFC491C 82460613
FFFC4920 00060633
FFFC4924 01A60023
                        	;       break;
FFFC4928 3C000663		      	bra      	DBGKeybd_79
                        	DBGKeybd_91:
                        	;       KeyState2 |= 0x80;
FFFC492C 00025637		      	ldb      	$t0,_KeyState2
FFFC4930 82560613
FFFC4934 00060633
FFFC4938 00060D03
FFFC493C 080D6D13		      	or       	$t0,$t0,#128
FFFC4940 00025637		      	stb      	$t0,_KeyState2
FFFC4944 82560613
FFFC4948 00060633
FFFC494C 01A60023
                        	;       break;
FFFC4950 3A000263		      	bra      	DBGKeybd_79
                        	DBGKeybd_92:
                        	;       if (KeyState1 >= 0)
FFFC4954 00025637		      	ldb      	$t0,_KeyState1
FFFC4958 82460613
FFFC495C 00060633
FFFC4960 00060D03
FFFC4964 020D4663		      	blt      	$t0,$x0,DBGKeybd_99
                        	;         KeyState2 |= 4;
FFFC4968 00025637		      	ldb      	$t0,_KeyState2
FFFC496C 82560613
FFFC4970 00060633
FFFC4974 00060D03
FFFC4978 004D6D13		      	or       	$t0,$t0,#4
FFFC497C 00025637		      	stb      	$t0,_KeyState2
FFFC4980 82560613
FFFC4984 00060633
FFFC4988 01A60023
FFFC498C 02000463		      	bra      	DBGKeybd_100
                        	DBGKeybd_99:
                        	;         KeyState2 &= ~4;
FFFC4990 00025637		      	ldb      	$t0,_KeyState2
FFFC4994 82560613
FFFC4998 00060633
FFFC499C 00060D03
FFFC49A0 FFBD7D13		      	and      	$t0,$t0,#-5
FFFC49A4 00025637		      	stb      	$t0,_KeyState2
FFFC49A8 82560613
FFFC49AC 00060633
FFFC49B0 01A60023
                        	DBGKeybd_100:
                        	;       KeyState1 = 0;
FFFC49B4 00025637		      	stb      	$x0,_KeyState1
FFFC49B8 82460613
FFFC49BC 00060633
FFFC49C0 00060023
                        	;       break;
FFFC49C4 32000863		      	bra      	DBGKeybd_79
                        	DBGKeybd_93:
                        	;       if (KeyState1 >= 0)
FFFC49C8 00025637		      	ldb      	$t0,_KeyState1
FFFC49CC 82460613
FFFC49D0 00060633
FFFC49D4 00060D03
FFFC49D8 020D4663		      	blt      	$t0,$x0,DBGKeybd_101
                        	;         KeyState2 |= 1;
FFFC49DC 00025637		      	ldb      	$t0,_KeyState2
FFFC49E0 82560613
FFFC49E4 00060633
FFFC49E8 00060D03
FFFC49EC 001D6D13		      	or       	$t0,$t0,#1
FFFC49F0 00025637		      	stb      	$t0,_KeyState2
FFFC49F4 82560613
FFFC49F8 00060633
FFFC49FC 01A60023
FFFC4A00 02000463		      	bra      	DBGKeybd_102
                        	DBGKeybd_101:
                        	;         KeyState2 &= ~1;
FFFC4A04 00025637		      	ldb      	$t0,_KeyState2
FFFC4A08 82560613
FFFC4A0C 00060633
FFFC4A10 00060D03
FFFC4A14 FFED7D13		      	and      	$t0,$t0,#-2
FFFC4A18 00025637		      	stb      	$t0,_KeyState2
FFFC4A1C 82560613
FFFC4A20 00060633
FFFC4A24 01A60023
                        	DBGKeybd_102:
                        	;       KeyState1 = 0;
FFFC4A28 00025637		      	stb      	$x0,_KeyState1
FFFC4A2C 82460613
FFFC4A30 00060633
FFFC4A34 00060023
                        	;       break;
FFFC4A38 2A000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_94:
                        	;       KeyState2 ^= 16;
FFFC4A3C 00025637		      	ldb      	$t0,_KeyState2
FFFC4A40 82560613
FFFC4A44 00060633
FFFC4A48 00060D03
FFFC4A4C 010D4D13		      	xor      	$t0,$t0,#16
FFFC4A50 00025637		      	stb      	$t0,_KeyState2
FFFC4A54 82560613
FFFC4A58 00060633
FFFC4A5C 01A60023
                        	;       KeyLED ^= 2;
FFFC4A60 00025637		      	ldb      	$t0,_KeyLED
FFFC4A64 82660613
FFFC4A68 00060633
FFFC4A6C 00060D03
FFFC4A70 002D4D13		      	xor      	$t0,$t0,#2
FFFC4A74 00025637		      	stb      	$t0,_KeyLED
FFFC4A78 82660613
FFFC4A7C 00060633
FFFC4A80 01A60023
                        	;       KeybdSetLED(KeyLED);
FFFC4A84 00025637		      	ldb      	$a0,_KeyLED
FFFC4A88 82660613
FFFC4A8C 00060633
FFFC4A90 00060903
FFFC4A94 8F9FF0EF		      	call     	_KeybdSetLED
                        	;       break;
FFFC4A98 24000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_95:
                        	;       KeyState2 ^= 32;
FFFC4A9C 00025637		      	ldb      	$t0,_KeyState2
FFFC4AA0 82560613
FFFC4AA4 00060633
FFFC4AA8 00060D03
FFFC4AAC 020D4D13		      	xor      	$t0,$t0,#32
FFFC4AB0 00025637		      	stb      	$t0,_KeyState2
FFFC4AB4 82560613
FFFC4AB8 00060633
FFFC4ABC 01A60023
                        	;       KeyLED ^= 4;
FFFC4AC0 00025637		      	ldb      	$t0,_KeyLED
FFFC4AC4 82660613
FFFC4AC8 00060633
FFFC4ACC 00060D03
FFFC4AD0 004D4D13		      	xor      	$t0,$t0,#4
FFFC4AD4 00025637		      	stb      	$t0,_KeyLED
FFFC4AD8 82660613
FFFC4ADC 00060633
FFFC4AE0 01A60023
                        	;       KeybdSetLED(KeyLED);
FFFC4AE4 00025637		      	ldb      	$a0,_KeyLED
FFFC4AE8 82660613
FFFC4AEC 00060633
FFFC4AF0 00060903
FFFC4AF4 899FF0EF		      	call     	_KeybdSetLED
                        	;       break;
FFFC4AF8 1E000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_96:
                        	;       KeyState2 ^= 64;
FFFC4AFC 00025637		      	ldb      	$t0,_KeyState2
FFFC4B00 82560613
FFFC4B04 00060633
FFFC4B08 00060D03
FFFC4B0C 040D4D13		      	xor      	$t0,$t0,#64
FFFC4B10 00025637		      	stb      	$t0,_KeyState2
FFFC4B14 82560613
FFFC4B18 00060633
FFFC4B1C 01A60023
                        	;       KeyLED ^= 1;
FFFC4B20 00025637		      	ldb      	$t0,_KeyLED
FFFC4B24 82660613
FFFC4B28 00060633
FFFC4B2C 00060D03
FFFC4B30 001D4D13		      	xor      	$t0,$t0,#1
FFFC4B34 00025637		      	stb      	$t0,_KeyLED
FFFC4B38 82660613
FFFC4B3C 00060633
FFFC4B40 01A60023
                        	;       KeybdSetLED(KeyLED);
FFFC4B44 00025637		      	ldb      	$a0,_KeyLED
FFFC4B48 82660613
FFFC4B4C 00060633
FFFC4B50 00060903
FFFC4B54 839FF0EF		      	call     	_KeybdSetLED
                        	;       break;
FFFC4B58 18000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_97:
                        	;       if (KeyState1 >= 0)
FFFC4B5C 00025637		      	ldb      	$t0,_KeyState1
FFFC4B60 82460613
FFFC4B64 00060633
FFFC4B68 00060D03
FFFC4B6C 020D4663		      	blt      	$t0,$x0,DBGKeybd_103
                        	;         KeyState2 |= 2;
FFFC4B70 00025637		      	ldb      	$t0,_KeyState2
FFFC4B74 82560613
FFFC4B78 00060633
FFFC4B7C 00060D03
FFFC4B80 002D6D13		      	or       	$t0,$t0,#2
FFFC4B84 00025637		      	stb      	$t0,_KeyState2
FFFC4B88 82560613
FFFC4B8C 00060633
FFFC4B90 01A60023
FFFC4B94 02000463		      	bra      	DBGKeybd_104
                        	DBGKeybd_103:
                        	;         KeyState2 &= ~2;
FFFC4B98 00025637		      	ldb      	$t0,_KeyState2
FFFC4B9C 82560613
FFFC4BA0 00060633
FFFC4BA4 00060D03
FFFC4BA8 FFDD7D13		      	and      	$t0,$t0,#-3
FFFC4BAC 00025637		      	stb      	$t0,_KeyState2
FFFC4BB0 82560613
FFFC4BB4 00060633
FFFC4BB8 01A60023
                        	DBGKeybd_104:
                        	;       KeyState1 = 0;
FFFC4BBC 00025637		      	stb      	$x0,_KeyState1
FFFC4BC0 82460613
FFFC4BC4 00060633
FFFC4BC8 00060023
                        	;       break;
FFFC4BCC 12000463		      	bra      	DBGKeybd_79
                        	DBGKeybd_98:
                        	; 				if (KeyState1) {
FFFC4BD0 00025637		      	ldb      	$t0,_KeyState1
FFFC4BD4 82460613
FFFC4BD8 00060633
FFFC4BDC 00060D03
FFFC4BE0 000D0C63		      	beq      	$t0,$x0,DBGKeybd_105
                        	; 					KeyState1 = 0;
FFFC4BE4 00025637		      	stb      	$x0,_KeyState1
FFFC4BE8 82460613
FFFC4BEC 00060633
FFFC4BF0 00060023
FFFC4BF4 10000063		      	bra      	DBGKeybd_106
                        	DBGKeybd_105:
                        	; 					if (((KeyState2 & 0x06)==0x06) && sc==0x71) {
FFFC4BF8 00025637		      	ldb      	$t1,_KeyState2
FFFC4BFC 82560613
FFFC4C00 00060633
FFFC4C04 00060D83
FFFC4C08 006DFD13		      	and      	$t0,$t1,#6
FFFC4C0C 006D4D93		      	xor      	$t1,$t0,#6
FFFC4C10 000D9C63		      	bnez     	$t1,DBGKeybd_107
FFFC4C14 07134D13		      	xor      	$t0,$s3,#113
FFFC4C18 000D1863		      	bnez     	$t0,DBGKeybd_107
                        	; 						__asm {
                        		      	;asm     	
FFFC4C1C 00000637				jmp		$FFFC0100
FFFC4C20 2F660067
                        	; 						}
FFFC4C24 0C000863		      	bra      	DBGKeybd_108
                        	DBGKeybd_107:
                        	; 					else if (KeyState2 & 0x80) { // Extended code ?
FFFC4C28 00025637		      	ldb      	$t1,_KeyState2
FFFC4C2C 82560613
FFFC4C30 00060633
FFFC4C34 00060D83
FFFC4C38 080DFD13		      	and      	$t0,$t1,#128
FFFC4C3C 040D0063		      	beq      	$t0,$x0,DBGKeybd_109
                        	; 						KeyState2 &= ~0x80;
FFFC4C40 00025637		      	ldb      	$t0,_KeyState2
FFFC4C44 82560613
FFFC4C48 00060633
FFFC4C4C 00060D03
FFFC4C50 F7FD7D13		      	and      	$t0,$t0,#-129
FFFC4C54 00025637		      	stb      	$t0,_KeyState2
FFFC4C58 82560613
FFFC4C5C 00060633
FFFC4C60 01A60023
                        	; 						ch = keybdExtendedCodes[sc];
FFFC4C64 FFFC4637		      	ldb      	$s2,_keybdExtendedCodes[$s3]
FFFC4C68 0D060613
FFFC4C6C 00660633
FFFC4C70 00060283
                        	; 						return (ch);
FFFC4C74 0002E833		      	mov      	$v0,$s2
FFFC4C78 BE000EE3		      	bra      	DBGKeybd_65
                        	DBGKeybd_109:
                        	; 					else if (KeyState2 & 0x04) { // control ?
FFFC4C7C 00025637		      	ldb      	$t1,_KeyState2
FFFC4C80 82560613
FFFC4C84 00060633
FFFC4C88 00060D83
FFFC4C8C 004DFD13		      	and      	$t0,$t1,#4
FFFC4C90 000D0E63		      	beq      	$t0,$x0,DBGKeybd_111
                        	; 						ch = keybdControlCodes[sc];
FFFC4C94 FFFC4637		      	ldb      	$s2,_keybdControlCodes[$s3]
FFFC4C98 05060613
FFFC4C9C 00660633
FFFC4CA0 00060283
                        	; 						return (ch);
FFFC4CA4 0002E833		      	mov      	$v0,$s2
FFFC4CA8 BC0006E3		      	bra      	DBGKeybd_65
                        	DBGKeybd_111:
                        	; 					else if (KeyState2 & 0x01) { // shifted ?
FFFC4CAC 00025637		      	ldb      	$t1,_KeyState2
FFFC4CB0 82560613
FFFC4CB4 00060633
FFFC4CB8 00060D83
FFFC4CBC 001DFD13		      	and      	$t0,$t1,#1
FFFC4CC0 000D0E63		      	beq      	$t0,$x0,DBGKeybd_113
                        	; 						ch = shiftedScanCodes[sc];
FFFC4CC4 FFFC4637		      	ldb      	$s2,_shiftedScanCodes[$s3]
FFFC4CC8 F5060613
FFFC4CCC 00660633
FFFC4CD0 00060283
                        	; 						return (ch);
FFFC4CD4 0002E833		      	mov      	$v0,$s2
FFFC4CD8 B8000EE3		      	bra      	DBGKeybd_65
                        	DBGKeybd_113:
                        	; 						ch = unshiftedScanCodes[sc];
FFFC4CDC FFFC4637		      	ldb      	$s2,_unshiftedScanCodes[$s3]
FFFC4CE0 E5060613
FFFC4CE4 00660633
FFFC4CE8 00060283
                        	; 						return (ch);
FFFC4CEC 0002E833		      	mov      	$v0,$s2
FFFC4CF0 B80002E3		      	bra      	DBGKeybd_65
                        	DBGKeybd_108:
                        	DBGKeybd_106:
                        	DBGKeybd_79:
FFFC4CF4 B2000CE3		      	bra      	DBGKeybd_66
                        	endpublic
                        	
                        	.file "../fmtk/source/kernel/DBGConsole.s",83
                        		code
FFFC4CF8 00000000		align	1
FFFC4CFC 00000000
                        	
                        	.file "../fmtk/source/kernel/DBGConsole.s",87
                        		code
                        		align	16                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC4D00 FE070713	public code _DBGClearScreen:
	      	sub      	$sp,$sp,#32
FFFC4D04 00273023		      	sto      	$fp,[$sp]
FFFC4D08 00073423		      	sto      	$x0,8[$sp]
FFFC4D0C 00173C23		      	sto      	$ra,24[$sp]
FFFC4D10 00076133		      	mov      	$fp,$sp
FFFC4D14 FD270713		      	sub      	$sp,$sp,#46
FFFC4D18 00473023		      	sto      	$s1,0[$sp]
FFFC4D1C 00573423		      	sto      	$s2,8[$sp]
FFFC4D20 10300073		      	pfi      
FFFC4D24 FEE13203		      	ldo      	$s1,-18[$fp]
FFFC4D28 FF813283		      	ldo      	$s2,-8[$fp]
                        	; 	__asm {
                        		      	;asm     	
                        				//		ldi	$v0,#$26
                        				//		stb	$v0,LEDS
                        	; 	p = (int *)0xFFFFFFFFFFD00000;
FFFC4D2C FFD002B7		      	ldi      	$s2,#-3145728
FFFC4D30 00028293
                        	; 	vc = ' ' | DBGAttr;
FFFC4D34 00003D83		      	ldo      	$t1,_DBGAttr
FFFC4D38 020DED13		      	or       	$t0,$t1,#32
FFFC4D3C 000D6233		      	mov      	$s1,$t0
                        	; 	memsetO(p, vc, 29*56); //2604);
FFFC4D40 10300073		      	pfi      
FFFC4D44 65806D13		      	ldi      	$t0,#1624
FFFC4D48 01A73C23		      	sto      	$t0,24[$sp]
FFFC4D4C 00473C23		      	sto      	$s1,24[$sp]
FFFC4D50 00573C23		      	sto      	$s2,24[$sp]
FFFC4D54 00000637		      	call     	_memsetO
FFFC4D58 000600E7
FFFC4D5C 01870713		      	add      	$sp,$sp,#24
                        	; 	__asm {
                        		      	;asm     	
                        				//		ldi	$v0,#$27
                        				//		stb	$v0,LEDS
                        	DBGConsole_9:
FFFC4D60 00073203		      	ldo      	$s1,0[$sp]
FFFC4D64 00873283		      	ldo      	$s2,8[$sp]
FFFC4D68 00016733		      	mov      	$sp,$fp
FFFC4D6C 00073103		      	ldo      	$fp,[$sp]
FFFC4D70 01873083		      	ldo      	$ra,24[$sp]
FFFC4D74 02070713		      	add      	$sp,$sp,#32
FFFC4D78 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC4D7C FE070713	public code _DBGUpdateCursorPos:
	      	sub      	$sp,$sp,#32
FFFC4D80 00273023		      	sto      	$fp,[$sp]
FFFC4D84 00073423		      	sto      	$x0,8[$sp]
FFFC4D88 00076133		      	mov      	$fp,$sp
FFFC4D8C FEE70713		      	sub      	$sp,$sp,#18
FFFC4D90 00473023		      	sto      	$s1,0[$sp]
FFFC4D94 10300073		      	pfi      
FFFC4D98 FF813203		      	ldo      	$s1,-8[$fp]
                        	; 	pos = DBGCursorRow * 56 + DBGCursorCol;
FFFC4D9C 00000E03		      	ldb      	$t2,_DBGCursorRow
FFFC4DA0 03806E93		      	ldi      	$t3,#56
FFFC4DA4 03DE0DB3		      	mul      	$t1,$t2,$t3
FFFC4DA8 00000E03		      	ldb      	$t2,_DBGCursorCol
FFFC4DAC 01CD8D33		      	add      	$t0,$t1,$t2
FFFC4DB0 000D6233		      	mov      	$s1,$t0
                        	;   DBGSetCursorPos(pos);
FFFC4DB4 10300073		      	pfi      
FFFC4DB8 00026933		      	mov      	$a0,$s1
FFFC4DBC 10300073		      	pfi      
FFFC4DC0 10300073		      	pfi      
                        		      	;        		__asm {
                        	; 	__asm {
                        		      	;asm     	
FFFC4DC4 FFD1E637				stt		$a0,$FFFFFFFFFFD1DF1C
FFFC4DC8 F1C60613
FFFC4DCC 00060633
FFFC4DD0 01262023
                        	DBGConsole_23:
FFFC4DD4 00073203		      	ldo      	$s1,0[$sp]
FFFC4DD8 00016733		      	mov      	$sp,$fp
FFFC4DDC 00073103		      	ldo      	$fp,[$sp]
FFFC4DE0 02070713		      	add      	$sp,$sp,#32
FFFC4DE4 00008067		      	ret      
                        	DBGConsole_20:
FFFC4DE8 793010F3		      	csrrw    	$ra,#1939,$x0
FFFC4DEC FE0004E3		      	bra      	DBGConsole_23
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC4DF0 FE070713	public code _DBGHomeCursor:
	      	sub      	$sp,$sp,#32
FFFC4DF4 00273023		      	sto      	$fp,[$sp]
FFFC4DF8 00073423		      	sto      	$x0,8[$sp]
FFFC4DFC 00173C23		      	sto      	$ra,24[$sp]
FFFC4E00 00076133		      	mov      	$fp,$sp
FFFC4E04 10300073		      	pfi      
                        	; 	DBGCursorCol = 0;
FFFC4E08 00000023		      	stb      	$x0,_DBGCursorCol
                        	; 	DBGCursorRow = 0;
FFFC4E0C 00000023		      	stb      	$x0,_DBGCursorRow
                        	; 	DBGUpdateCursorPos();
FFFC4E10 F6DFF0EF		      	call     	_DBGUpdateCursorPos
                        	DBGConsole_37:
FFFC4E14 00016733		      	mov      	$sp,$fp
FFFC4E18 00073103		      	ldo      	$fp,[$sp]
FFFC4E1C 01873083		      	ldo      	$ra,24[$sp]
FFFC4E20 02070713		      	add      	$sp,$sp,#32
FFFC4E24 00008067		      	ret      
                        	endpublic
                        	
                        	.file "../fmtk/source/kernel/DBGConsole.s",203
                        		code
FFFC4E28 00000000		align	1
FFFC4E2C 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC4E30 FE070713	public code _DBGBlankLine:
	      	sub      	$sp,$sp,#32
FFFC4E34 00273023		      	sto      	$fp,[$sp]
FFFC4E38 00073423		      	sto      	$x0,8[$sp]
FFFC4E3C 00173C23		      	sto      	$ra,24[$sp]
FFFC4E40 00076133		      	mov      	$fp,$sp
FFFC4E44 FC070713		      	sub      	$sp,$sp,#64
FFFC4E48 00473023		      	sto      	$s1,0[$sp]
FFFC4E4C 00573423		      	sto      	$s2,8[$sp]
FFFC4E50 10300073		      	pfi      
FFFC4E54 FF813203		      	ldo      	$s1,-8[$fp]
FFFC4E58 FDA13283		      	ldo      	$s2,-38[$fp]
                        	; 	p = (int *)0xFFFFFFFFFFD00000;
FFFC4E5C FFD00237		      	ldi      	$s1,#-3145728
FFFC4E60 00020213
                        	; 	p = p + row * 56;
FFFC4E64 02013E83		      	ldo      	$t3,32[$fp]
FFFC4E68 03806F13		      	ldi      	$t4,#56
FFFC4E6C 03EE8E33		      	mul      	$t2,$t3,$t4
FFFC4E70 003E1D93		      	sll      	$t1,$t2,#3
FFFC4E74 01B20D33		      	add      	$t0,$s1,$t1
FFFC4E78 000D6233		      	mov      	$s1,$t0
                        	; 	vc = DBGAttr | ' ';
FFFC4E7C 10300073		      	pfi      
FFFC4E80 00003D83		      	ldo      	$t1,_DBGAttr
FFFC4E84 020DED13		      	or       	$t0,$t1,#32
FFFC4E88 000D62B3		      	mov      	$s2,$t0
                        	; 	memsetW(p, vc, 56);
FFFC4E8C 03806D13		      	ldi      	$t0,#56
FFFC4E90 01A73C23		      	sto      	$t0,24[$sp]
FFFC4E94 00573C23		      	sto      	$s2,24[$sp]
FFFC4E98 00473C23		      	sto      	$s1,24[$sp]
FFFC4E9C 00000637		      	call     	_memsetW
FFFC4EA0 000600E7
FFFC4EA4 01870713		      	add      	$sp,$sp,#24
                        	DBGConsole_47:
FFFC4EA8 00073203		      	ldo      	$s1,0[$sp]
FFFC4EAC 00873283		      	ldo      	$s2,8[$sp]
FFFC4EB0 00016733		      	mov      	$sp,$fp
FFFC4EB4 00073103		      	ldo      	$fp,[$sp]
FFFC4EB8 01873083		      	ldo      	$ra,24[$sp]
FFFC4EBC 02870713		      	add      	$sp,$sp,#40
FFFC4EC0 00008067		      	ret      
                        	endpublic
                        	
                        	.file "../fmtk/source/kernel/DBGConsole.s",254
                        		code
FFFC4EC4 00000000		align	1
FFFC4EC8 00000000
FFFC4ECC 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC4ED0 FE070713	public code _DBGScrollUp:
	      	sub      	$sp,$sp,#32
FFFC4ED4 00273023		      	sto      	$fp,[$sp]
FFFC4ED8 00073423		      	sto      	$x0,8[$sp]
FFFC4EDC 00173C23		      	sto      	$ra,24[$sp]
FFFC4EE0 00076133		      	mov      	$fp,$sp
FFFC4EE4 FB870713		      	sub      	$sp,$sp,#72
FFFC4EE8 00473023		      	sto      	$s1,0[$sp]
FFFC4EEC 00573423		      	sto      	$s2,8[$sp]
FFFC4EF0 10300073		      	pfi      
FFFC4EF4 FE413203		      	ldo      	$s1,-28[$fp]
                        	; 	count = 29 * 56;
FFFC4EF8 65806293		      	ldi      	$s2,#1624
                        	; 	for (nn = 0; nn < count; nn++)
FFFC4EFC 00006233		      	mov      	$s1,$x0
FFFC4F00 04525063		      	bge      	$s1,$s2,DBGConsole_62
                        	DBGConsole_61:
                        	; 		scrn[nn] = scrn2[nn];
FFFC4F04 10300073		      	pfi      
FFFC4F08 00321D13		      	sll      	$t0,$s1,#3
FFFC4F0C FFD00637		      	add      	$t0,$t0,#-3145728
FFFC4F10 00060613
FFFC4F14 01A60D33
FFFC4F18 00321D93		      	sll      	$t1,$s1,#3
FFFC4F1C 10300073		      	pfi      
FFFC4F20 FFD00637		      	add      	$t1,$t1,#-3145280
FFFC4F24 1C060613
FFFC4F28 01B60DB3
FFFC4F2C 000DBE03		      	ldo      	$t2,[$t1]
FFFC4F30 01CD3023		      	sto      	$t2,[$t0]
FFFC4F34 10300073		      	pfi      
FFFC4F38 00120213		      	add      	$s1,$s1,#1
FFFC4F3C FC5244E3		      	blt      	$s1,$s2,DBGConsole_61
                        	DBGConsole_62:
                        	; 	DBGBlankLine(29-1);
FFFC4F40 01C06D13		      	ldi      	$t0,#28
FFFC4F44 01A73423		      	sto      	$t0,8[$sp]
FFFC4F48 EE9FF0EF		      	call     	_DBGBlankLine
                        	DBGConsole_60:
FFFC4F4C 00073203		      	ldo      	$s1,0[$sp]
FFFC4F50 00873283		      	ldo      	$s2,8[$sp]
FFFC4F54 00016733		      	mov      	$sp,$fp
FFFC4F58 00073103		      	ldo      	$fp,[$sp]
FFFC4F5C 01873083		      	ldo      	$ra,24[$sp]
FFFC4F60 02070713		      	add      	$sp,$sp,#32
FFFC4F64 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC4F68 FE070713	public code _DBGIncrementCursorRow:
	      	sub      	$sp,$sp,#32
FFFC4F6C 00273023		      	sto      	$fp,[$sp]
FFFC4F70 00073423		      	sto      	$x0,8[$sp]
FFFC4F74 00173C23		      	sto      	$ra,24[$sp]
FFFC4F78 00076133		      	mov      	$fp,$sp
FFFC4F7C 10300073		      	pfi      
                        	; 	if (DBGCursorRow < 29 - 1) {
FFFC4F80 00000D03		      	ldb      	$t0,_DBGCursorRow
FFFC4F84 01CD2D93		      	slt      	$t1,$t0,#28
FFFC4F88 020D8463		      	beqz     	$t1,DBGConsole_77
                        	; 		DBGCursorRow++;
FFFC4F8C 00000D03		      	ldb      	$t0,_DBGCursorRow
FFFC4F90 001D0D13		      	add      	$t0,$t0,#1
FFFC4F94 01A00023		      	stb      	$t0,_DBGCursorRow
                        	; 		DBGUpdateCursorPos();
FFFC4F98 DE5FF0EF		      	call     	_DBGUpdateCursorPos
                        	DBGConsole_76:
FFFC4F9C 00016733		      	mov      	$sp,$fp
FFFC4FA0 00073103		      	ldo      	$fp,[$sp]
FFFC4FA4 01873083		      	ldo      	$ra,24[$sp]
FFFC4FA8 02070713		      	add      	$sp,$sp,#32
FFFC4FAC 00008067		      	ret      
                        	DBGConsole_77:
                        	; 	DBGScrollUp();
FFFC4FB0 10300073		      	pfi      
FFFC4FB4 F1DFF0EF		      	call     	_DBGScrollUp
                        	; 	DBGCursorRow--;
FFFC4FB8 00000D03		      	ldb      	$t0,_DBGCursorRow
FFFC4FBC FFFD0D13		      	sub      	$t0,$t0,#1
FFFC4FC0 01A00023		      	stb      	$t0,_DBGCursorRow
FFFC4FC4 FC000CE3		      	bra      	DBGConsole_76
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC4FC8 FE070713	public code _DBGIncrementCursorPos:
	      	sub      	$sp,$sp,#32
FFFC4FCC 00273023		      	sto      	$fp,[$sp]
FFFC4FD0 00073423		      	sto      	$x0,8[$sp]
FFFC4FD4 00173C23		      	sto      	$ra,24[$sp]
FFFC4FD8 00076133		      	mov      	$fp,$sp
FFFC4FDC 10300073		      	pfi      
                        	; 	if (DBGCursorCol < 56) {
FFFC4FE0 00000D03		      	ldb      	$t0,_DBGCursorCol
FFFC4FE4 038D2D93		      	slt      	$t1,$t0,#56
FFFC4FE8 020D8463		      	beqz     	$t1,DBGConsole_93
                        	; 		DBGCursorCol++;
FFFC4FEC 00000D03		      	ldb      	$t0,_DBGCursorCol
FFFC4FF0 001D0D13		      	add      	$t0,$t0,#1
FFFC4FF4 01A00023		      	stb      	$t0,_DBGCursorCol
                        	; 		DBGUpdateCursorPos();
FFFC4FF8 D85FF0EF		      	call     	_DBGUpdateCursorPos
                        	DBGConsole_92:
FFFC4FFC 00016733		      	mov      	$sp,$fp
FFFC5000 00073103		      	ldo      	$fp,[$sp]
FFFC5004 01873083		      	ldo      	$ra,24[$sp]
FFFC5008 02070713		      	add      	$sp,$sp,#32
FFFC500C 00008067		      	ret      
                        	DBGConsole_93:
                        	; 	DBGCursorCol = 0;
FFFC5010 10300073		      	pfi      
FFFC5014 00000023		      	stb      	$x0,_DBGCursorCol
                        	; 	DBGIncrementCursorRow();
FFFC5018 F51FF0EF		      	call     	_DBGIncrementCursorRow
FFFC501C FE0000E3		      	bra      	DBGConsole_92
                        	endpublic
                        	
                        	.file "../fmtk/source/kernel/DBGConsole.s",377
                        		code
                        		align	16                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC5020 FE070713	public code _DBGDisplayChar:
	      	sub      	$sp,$sp,#32
FFFC5024 00273023		      	sto      	$fp,[$sp]
FFFC5028 00073423		      	sto      	$x0,8[$sp]
FFFC502C 00173C23		      	sto      	$ra,24[$sp]
FFFC5030 00076133		      	mov      	$fp,$sp
FFFC5034 FC270713		      	sub      	$sp,$sp,#62
FFFC5038 00473023		      	sto      	$s1,0[$sp]
FFFC503C 00573423		      	sto      	$s2,8[$sp]
FFFC5040 00673823		      	sto      	$s3,16[$sp]
FFFC5044 00773C23		      	sto      	$s4,24[$sp]
FFFC5048 10300073		      	pfi      
FFFC504C FEE13203		      	ldo      	$s1,-18[$fp]
FFFC5050 FF813283		      	ldo      	$s2,-8[$fp]
FFFC5054 02011303		      	ldw      	$s3,32[$fp]
FFFC5058 FFD003B7		      	ldi      	$s4,#-3145728
FFFC505C 00038393
                        	; 	case '\r':
FFFC5060 00D34D13		      	xor      	$t0,$s3,#13
FFFC5064 040D0C63		      	beq      	$t0,$x0,DBGConsole_169
                        	; 	case '\n':
FFFC5068 00A34D13		      	xor      	$t0,$s3,#10
FFFC506C 060D0063		      	beq      	$t0,$x0,DBGConsole_170
                        	; 	case 0x91:
FFFC5070 09134D13		      	xor      	$t0,$s3,#145
FFFC5074 060D0063		      	beq      	$t0,$x0,DBGConsole_171
                        	; 	case 0x90:
FFFC5078 09034D13		      	xor      	$t0,$s3,#144
FFFC507C 080D0063		      	beq      	$t0,$x0,DBGConsole_172
                        	; 	case 0x93:
FFFC5080 09334D13		      	xor      	$t0,$s3,#147
FFFC5084 080D0C63		      	beq      	$t0,$x0,DBGConsole_173
                        	; 	case 0x92:
FFFC5088 09234D13		      	xor      	$t0,$s3,#146
FFFC508C 0A0D0863		      	beq      	$t0,$x0,DBGConsole_174
                        	; 	case 0x94:
FFFC5090 09434D13		      	xor      	$t0,$s3,#148
FFFC5094 0C0D0663		      	beq      	$t0,$x0,DBGConsole_175
                        	; 	case 0x99:  // delete
FFFC5098 09934D13		      	xor      	$t0,$s3,#153
FFFC509C 0E0D0063		      	beq      	$t0,$x0,DBGConsole_176
                        	; 	case 0x08: // backspace
FFFC50A0 00834D13		      	xor      	$t0,$s3,#8
FFFC50A4 140D0263		      	beq      	$t0,$x0,DBGConsole_177
                        	; 	case 0x0C:   // CTRL-L
FFFC50A8 00C34D13		      	xor      	$t0,$s3,#12
FFFC50AC 1C0D0263		      	beq      	$t0,$x0,DBGConsole_178
                        	; 	case '\t':
FFFC50B0 00934D13		      	xor      	$t0,$s3,#9
FFFC50B4 1C0D0463		      	beq      	$t0,$x0,DBGConsole_179
                        	; 	default:
FFFC50B8 20000263		      	bra      	DBGConsole_180
                        	DBGConsole_169:
                        	; 		DBGCursorCol = 0;
FFFC50BC 10300073		      	pfi      
FFFC50C0 00000023		      	stb      	$x0,_DBGCursorCol
                        	; 		DBGUpdateCursorPos();
FFFC50C4 CB9FF0EF		      	call     	_DBGUpdateCursorPos
                        	; 		break;
FFFC50C8 22000A63		      	bra      	DBGConsole_155
                        	DBGConsole_170:
                        	; 		DBGIncrementCursorRow();
FFFC50CC E9DFF0EF		      	call     	_DBGIncrementCursorRow
                        	; 		break;
FFFC50D0 22000663		      	bra      	DBGConsole_155
                        	DBGConsole_171:
                        	;     if (DBGCursorCol < 56 - 1) {
FFFC50D4 10300073		      	pfi      
FFFC50D8 00000D03		      	ldb      	$t0,_DBGCursorCol
FFFC50DC 037D2D93		      	slt      	$t1,$t0,#55
FFFC50E0 000D8C63		      	beqz     	$t1,DBGConsole_181
                        	; 			DBGCursorCol++;
FFFC50E4 00000D03		      	ldb      	$t0,_DBGCursorCol
FFFC50E8 001D0D13		      	add      	$t0,$t0,#1
FFFC50EC 01A00023		      	stb      	$t0,_DBGCursorCol
                        	; 			DBGUpdateCursorPos();
FFFC50F0 10300073		      	pfi      
FFFC50F4 C89FF0EF		      	call     	_DBGUpdateCursorPos
                        	DBGConsole_181:
                        	;     break;
FFFC50F8 20000263		      	bra      	DBGConsole_155
                        	DBGConsole_172:
                        	;     if (DBGCursorRow > 0) {
FFFC50FC 00000D03		      	ldb      	$t0,_DBGCursorRow
FFFC5100 01A05C63		      	bge      	$x0,$t0,DBGConsole_183
                        	; 			DBGCursorRow--;
FFFC5104 00000D03		      	ldb      	$t0,_DBGCursorRow
FFFC5108 FFFD0D13		      	sub      	$t0,$t0,#1
FFFC510C 01A00023		      	stb      	$t0,_DBGCursorRow
                        	; 			DBGUpdateCursorPos();
FFFC5110 10300073		      	pfi      
FFFC5114 C69FF0EF		      	call     	_DBGUpdateCursorPos
                        	DBGConsole_183:
                        	;     break;
FFFC5118 1E000263		      	bra      	DBGConsole_155
                        	DBGConsole_173:
                        	;     if (DBGCursorCol > 0) {
FFFC511C 00000D03		      	ldb      	$t0,_DBGCursorCol
FFFC5120 01A05C63		      	bge      	$x0,$t0,DBGConsole_185
                        	; 			DBGCursorCol--;
FFFC5124 00000D03		      	ldb      	$t0,_DBGCursorCol
FFFC5128 FFFD0D13		      	sub      	$t0,$t0,#1
FFFC512C 01A00023		      	stb      	$t0,_DBGCursorCol
                        	; 			DBGUpdateCursorPos();
FFFC5130 10300073		      	pfi      
FFFC5134 C49FF0EF		      	call     	_DBGUpdateCursorPos
                        	DBGConsole_185:
                        	;     break;
FFFC5138 1C000263		      	bra      	DBGConsole_155
                        	DBGConsole_174:
                        	;     if (DBGCursorRow < 29-1) {
FFFC513C 00000D03		      	ldb      	$t0,_DBGCursorRow
FFFC5140 01CD2D93		      	slt      	$t1,$t0,#28
FFFC5144 000D8C63		      	beqz     	$t1,DBGConsole_187
                        	; 			DBGCursorRow++;
FFFC5148 00000D03		      	ldb      	$t0,_DBGCursorRow
FFFC514C 001D0D13		      	add      	$t0,$t0,#1
FFFC5150 01A00023		      	stb      	$t0,_DBGCursorRow
                        	; 			DBGUpdateCursorPos();
FFFC5154 10300073		      	pfi      
FFFC5158 C25FF0EF		      	call     	_DBGUpdateCursorPos
                        	DBGConsole_187:
                        	;     break;
FFFC515C 1A000063		      	bra      	DBGConsole_155
                        	DBGConsole_175:
                        	;     if (DBGCursorCol==0)
FFFC5160 00000D03		      	ldb      	$t0,_DBGCursorCol
FFFC5164 000D1463		      	bne      	$t0,$x0,DBGConsole_189
                        	; 			DBGCursorRow = 0;
FFFC5168 00000023		      	stb      	$x0,_DBGCursorRow
                        	DBGConsole_189:
                        	;     DBGCursorCol = 0;
FFFC516C 10300073		      	pfi      
FFFC5170 00000023		      	stb      	$x0,_DBGCursorCol
                        	;     DBGUpdateCursorPos();
FFFC5174 C09FF0EF		      	call     	_DBGUpdateCursorPos
                        	;     break;
FFFC5178 18000263		      	bra      	DBGConsole_155
                        	DBGConsole_176:
                        	;     p = (int *)0xFFFFFFFFFFD00000 + DBGCursorRow * 56;
FFFC517C 00000E83		      	ldb      	$t3,_DBGCursorRow
FFFC5180 03806F13		      	ldi      	$t4,#56
FFFC5184 03EE8E33		      	mul      	$t2,$t3,$t4
FFFC5188 003E1D93		      	sll      	$t1,$t2,#3
FFFC518C 007D8D33		      	add      	$t0,$t1,$s4
FFFC5190 000D62B3		      	mov      	$s2,$t0
                        	;     for (nn = DBGCursorCol; nn < 56-1; nn++) {
FFFC5194 10300073		      	pfi      
FFFC5198 00000203		      	ldb      	$s1,_DBGCursorCol
FFFC519C 03722D13		      	slt      	$t0,$s1,#55
FFFC51A0 020D0663		      	beqz     	$t0,DBGConsole_192
                        	DBGConsole_191:
                        	;       p[nn] = p[nn+1];
FFFC51A4 00321D13		      	sll      	$t0,$s1,#3
FFFC51A8 10300073		      	pfi      
FFFC51AC 01A28D33		      	add      	$t0,$s2,$t0
FFFC51B0 00321E13		      	sll      	$t2,$s1,#3
FFFC51B4 005E0DB3		      	add      	$t1,$t2,$s2
FFFC51B8 10300073		      	pfi      
FFFC51BC 008DBD03		      	ldo      	$t0,8[$t1]
FFFC51C0 00120213		      	add      	$s1,$s1,#1
FFFC51C4 03722D13		      	slt      	$t0,$s1,#55
FFFC51C8 FC0D1EE3		      	bnez     	$t0,DBGConsole_191
                        	DBGConsole_192:
                        	; 		p[nn] = DBGAttr | ' ';
FFFC51CC 10300073		      	pfi      
FFFC51D0 00321D13		      	sll      	$t0,$s1,#3
FFFC51D4 01A28D33		      	add      	$t0,$s2,$t0
FFFC51D8 00003E03		      	ldo      	$t2,_DBGAttr
FFFC51DC 020E6D93		      	or       	$t1,$t2,#32
FFFC51E0 01BD3023		      	sto      	$t1,[$t0]
                        	;     break;
FFFC51E4 10000C63		      	bra      	DBGConsole_155
                        	DBGConsole_177:
                        	;     if (DBGCursorCol > 0) {
FFFC51E8 10300073		      	pfi      
FFFC51EC 00000D03		      	ldb      	$t0,_DBGCursorCol
FFFC51F0 07A05E63		      	bge      	$x0,$t0,DBGConsole_194
                        	;       DBGCursorCol--;
FFFC51F4 00000D03		      	ldb      	$t0,_DBGCursorCol
FFFC51F8 FFFD0D13		      	sub      	$t0,$t0,#1
FFFC51FC 01A00023		      	stb      	$t0,_DBGCursorCol
                        	;   		p = (int *)0xFFFFFFFFFFD00000 + DBGCursorRow * 56;
FFFC5200 10300073		      	pfi      
FFFC5204 00000E83		      	ldb      	$t3,_DBGCursorRow
FFFC5208 03806F13		      	ldi      	$t4,#56
FFFC520C 03EE8E33		      	mul      	$t2,$t3,$t4
FFFC5210 003E1D93		      	sll      	$t1,$t2,#3
FFFC5214 007D8D33		      	add      	$t0,$t1,$s4
FFFC5218 000D62B3		      	mov      	$s2,$t0
                        	;       for (nn = DBGCursorCol; nn < 56-1; nn++) {
FFFC521C 10300073		      	pfi      
FFFC5220 00000203		      	ldb      	$s1,_DBGCursorCol
FFFC5224 03722D13		      	slt      	$t0,$s1,#55
FFFC5228 020D0663		      	beqz     	$t0,DBGConsole_197
                        	DBGConsole_196:
                        	;         p[nn] = p[nn+1];
FFFC522C 00321D13		      	sll      	$t0,$s1,#3
FFFC5230 01A28D33		      	add      	$t0,$s2,$t0
FFFC5234 10300073		      	pfi      
FFFC5238 00321E13		      	sll      	$t2,$s1,#3
FFFC523C 005E0DB3		      	add      	$t1,$t2,$s2
FFFC5240 008DBD03		      	ldo      	$t0,8[$t1]
FFFC5244 00120213		      	add      	$s1,$s1,#1
FFFC5248 10300073		      	pfi      
FFFC524C 03722D13		      	slt      	$t0,$s1,#55
FFFC5250 FC0D1EE3		      	bnez     	$t0,DBGConsole_196
                        	DBGConsole_197:
                        	;       p[nn] = DBGAttr | ' ';
FFFC5254 00321D13		      	sll      	$t0,$s1,#3
FFFC5258 01A28D33		      	add      	$t0,$s2,$t0
FFFC525C 00003E03		      	ldo      	$t2,_DBGAttr
FFFC5260 10300073		      	pfi      
FFFC5264 020E6D93		      	or       	$t1,$t2,#32
FFFC5268 01BD3023		      	sto      	$t1,[$t0]
                        	DBGConsole_194:
                        	;     break;
FFFC526C 08000863		      	bra      	DBGConsole_155
                        	DBGConsole_178:
                        	;     DBGClearScreen();
FFFC5270 10300073		      	pfi      
                        	;     DBGHomeCursor();
FFFC5274 B7DFF0EF		      	call     	_DBGHomeCursor
                        	;     break;
FFFC5278 08000263		      	bra      	DBGConsole_155
                        	DBGConsole_179:
                        	; 		for (nn = 0; nn < 32; nn++) {
FFFC527C 00006233		      	mov      	$s1,$x0
FFFC5280 02022D13		      	slt      	$t0,$s1,#32
FFFC5284 020D0A63		      	beqz     	$t0,DBGConsole_200
                        	DBGConsole_199:
                        	; 			if (DBGCursorCol < tabstops[nn]) {
FFFC5288 10300073		      	pfi      
FFFC528C 00000D03		      	ldb      	$t0,_DBGCursorCol
FFFC5290 00020D83		      	ldb      	$t1,_tabstops[$s1]
FFFC5294 01BD5A63		      	bge      	$t0,$t1,DBGConsole_202
                        	; 				DBGCursorCol = tabstops[nn];
FFFC5298 10300073		      	pfi      
FFFC529C 00020D03		      	ldb      	$t0,_tabstops[$s1]
FFFC52A0 01A00023		      	stb      	$t0,_DBGCursorCol
                        	; 				break;
FFFC52A4 00000A63		      	bra      	DBGConsole_200
                        	DBGConsole_202:
FFFC52A8 10300073		      	pfi      
FFFC52AC 00120213		      	add      	$s1,$s1,#1
FFFC52B0 02022D13		      	slt      	$t0,$s1,#32
FFFC52B4 FC0D1AE3		      	bnez     	$t0,DBGConsole_199
                        	DBGConsole_200:
                        	;     break;
FFFC52B8 04000263		      	bra      	DBGConsole_155
                        	DBGConsole_180:
                        	; 	  p = (int *)0xFFFFFFFFFFD00000;
FFFC52BC 10300073		      	pfi      
FFFC52C0 0003E2B3		      	mov      	$s2,$s4
                        	; 	  nn = DBGCursorRow * 56 + DBGCursorCol;
FFFC52C4 00000E03		      	ldb      	$t2,_DBGCursorRow
FFFC52C8 03806E93		      	ldi      	$t3,#56
FFFC52CC 03DE0DB3		      	mul      	$t1,$t2,$t3
FFFC52D0 10300073		      	pfi      
FFFC52D4 00000E03		      	ldb      	$t2,_DBGCursorCol
FFFC52D8 01CD8D33		      	add      	$t0,$t1,$t2
FFFC52DC 000D6233		      	mov      	$s1,$t0
                        	; 	  p[nn] = ch | DBGAttr;
FFFC52E0 00321D13		      	sll      	$t0,$s1,#3
FFFC52E4 01A28D33		      	add      	$t0,$s2,$t0
FFFC52E8 10300073		      	pfi      
FFFC52EC 00003E03		      	ldo      	$t2,_DBGAttr
FFFC52F0 01C36DB3		      	or       	$t1,$s3,$t2
FFFC52F4 01BD3023		      	sto      	$t1,[$t0]
                        	; 	  DBGIncrementCursorPos();
FFFC52F8 CD1FF0EF		      	call     	_DBGIncrementCursorPos
                        	DBGConsole_155:
                        	DBGConsole_154:
FFFC52FC 00073203		      	ldo      	$s1,0[$sp]
FFFC5300 00873283		      	ldo      	$s2,8[$sp]
FFFC5304 01073303		      	ldo      	$s3,16[$sp]
FFFC5308 01873383		      	ldo      	$s4,24[$sp]
FFFC530C 00016733		      	mov      	$sp,$fp
FFFC5310 00073103		      	ldo      	$fp,[$sp]
FFFC5314 01873083		      	ldo      	$ra,24[$sp]
FFFC5318 02070713		      	add      	$sp,$sp,#32
FFFC531C 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC5320 FE070713	public code _DBGCRLF:
	      	sub      	$sp,$sp,#32
FFFC5324 00273023		      	sto      	$fp,[$sp]
FFFC5328 00073423		      	sto      	$x0,8[$sp]
FFFC532C 00173C23		      	sto      	$ra,24[$sp]
FFFC5330 00076133		      	mov      	$fp,$sp
FFFC5334 10300073		      	pfi      
                        	; 	DBGDisplayChar('\r');
FFFC5338 00D06D13		      	ldi      	$t0,#13
FFFC533C 01A73423		      	sto      	$t0,8[$sp]
FFFC5340 CE1FF0EF		      	call     	_DBGDisplayChar
FFFC5344 00870713		      	add      	$sp,$sp,#8
                        	; 	DBGDisplayChar('\n');
FFFC5348 00A06D13		      	ldi      	$t0,#10
FFFC534C 01A73423		      	sto      	$t0,8[$sp]
FFFC5350 CD1FF0EF		      	call     	_DBGDisplayChar
FFFC5354 00870713		      	add      	$sp,$sp,#8
                        	; 	__asm {
                        		      	;asm     	
FFFC5358 03006813				ldi		$v0,#48
FFFC535C FFDC0637				stb		$v0,LEDS
FFFC5360 60060613
FFFC5364 00060633
FFFC5368 01060023
                        	DBGConsole_213:
FFFC536C 00016733		      	mov      	$sp,$fp
FFFC5370 00073103		      	ldo      	$fp,[$sp]
FFFC5374 01873083		      	ldo      	$ra,24[$sp]
FFFC5378 02070713		      	add      	$sp,$sp,#32
FFFC537C 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC5380 FE070713	public code _DBGDisplayString:
	      	sub      	$sp,$sp,#32
FFFC5384 00273023		      	sto      	$fp,[$sp]
FFFC5388 00073423		      	sto      	$x0,8[$sp]
FFFC538C 00173C23		      	sto      	$ra,24[$sp]
FFFC5390 00076133		      	mov      	$fp,$sp
FFFC5394 FE670713		      	sub      	$sp,$sp,#26
FFFC5398 00473023		      	sto      	$s1,0[$sp]
FFFC539C 00573423		      	sto      	$s2,8[$sp]
FFFC53A0 10300073		      	pfi      
FFFC53A4 02013203		      	ldo      	$s1,32[$fp]
                        	;   while (ch = *s) { DBGDisplayChar(ch); s++; }
FFFC53A8 00021283		      	ldw      	$s2,[$s1]
FFFC53AC 00028E63		      	beq      	$s2,$x0,DBGConsole_227
                        	DBGConsole_226:
FFFC53B0 00573423		      	sto      	$s2,8[$sp]
FFFC53B4 C6DFF0EF		      	call     	_DBGDisplayChar
FFFC53B8 00870713		      	add      	$sp,$sp,#8
FFFC53BC 00220213		      	add      	$s1,$s1,#2
FFFC53C0 00021283		      	ldw      	$s2,[$s1]
FFFC53C4 FE0296E3		      	bne      	$s2,$x0,DBGConsole_226
                        	DBGConsole_227:
                        	DBGConsole_225:
FFFC53C8 00073203		      	ldo      	$s1,0[$sp]
FFFC53CC 00873283		      	ldo      	$s2,8[$sp]
FFFC53D0 00016733		      	mov      	$sp,$fp
FFFC53D4 00073103		      	ldo      	$fp,[$sp]
FFFC53D8 01873083		      	ldo      	$ra,24[$sp]
FFFC53DC 02070713		      	add      	$sp,$sp,#32
FFFC53E0 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC53E4 FE070713	public code _DBGDisplayAsciiString:
	      	sub      	$sp,$sp,#32
FFFC53E8 00273023		      	sto      	$fp,[$sp]
FFFC53EC 00073423		      	sto      	$x0,8[$sp]
FFFC53F0 00173C23		      	sto      	$ra,24[$sp]
FFFC53F4 00076133		      	mov      	$fp,$sp
FFFC53F8 FE670713		      	sub      	$sp,$sp,#26
FFFC53FC 00473023		      	sto      	$s1,0[$sp]
FFFC5400 00573423		      	sto      	$s2,8[$sp]
FFFC5404 10300073		      	pfi      
FFFC5408 02013203		      	ldo      	$s1,32[$fp]
                        	;   while (ch = *s) { DBGDisplayChar(ch); s++; }
FFFC540C 00020283		      	ldb      	$s2,[$s1]
FFFC5410 00028E63		      	beq      	$s2,$x0,DBGConsole_241
                        	DBGConsole_240:
FFFC5414 00573423		      	sto      	$s2,8[$sp]
FFFC5418 C09FF0EF		      	call     	_DBGDisplayChar
FFFC541C 00870713		      	add      	$sp,$sp,#8
FFFC5420 00120213		      	add      	$s1,$s1,#1
FFFC5424 00020283		      	ldb      	$s2,[$s1]
FFFC5428 FE0296E3		      	bne      	$s2,$x0,DBGConsole_240
                        	DBGConsole_241:
                        	DBGConsole_239:
FFFC542C 00073203		      	ldo      	$s1,0[$sp]
FFFC5430 00873283		      	ldo      	$s2,8[$sp]
FFFC5434 00016733		      	mov      	$sp,$fp
FFFC5438 00073103		      	ldo      	$fp,[$sp]
FFFC543C 01873083		      	ldo      	$ra,24[$sp]
FFFC5440 02070713		      	add      	$sp,$sp,#32
FFFC5444 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC5448 FE070713	public code _DBGDisplayStringCRLF:
	      	sub      	$sp,$sp,#32
FFFC544C 00273023		      	sto      	$fp,[$sp]
FFFC5450 00073423		      	sto      	$x0,8[$sp]
FFFC5454 00173C23		      	sto      	$ra,24[$sp]
FFFC5458 00076133		      	mov      	$fp,$sp
FFFC545C 10300073		      	pfi      
                        	;    DBGDisplayString(s);
FFFC5460 02013D03		      	ldo      	$t0,32[$fp]
FFFC5464 01A73423		      	sto      	$t0,8[$sp]
FFFC5468 F19FF0EF		      	call     	_DBGDisplayString
FFFC546C 00870713		      	add      	$sp,$sp,#8
                        	;    DBGCRLF();
FFFC5470 EB1FF0EF		      	call     	_DBGCRLF
                        	DBGConsole_251:
FFFC5474 00016733		      	mov      	$sp,$fp
FFFC5478 00073103		      	ldo      	$fp,[$sp]
FFFC547C 01873083		      	ldo      	$ra,24[$sp]
FFFC5480 02070713		      	add      	$sp,$sp,#32
FFFC5484 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC5488 FE070713	public code _DBGDisplayAsciiStringCRLF:
	      	sub      	$sp,$sp,#32
FFFC548C 00273023		      	sto      	$fp,[$sp]
FFFC5490 00073423		      	sto      	$x0,8[$sp]
FFFC5494 00173C23		      	sto      	$ra,24[$sp]
FFFC5498 00076133		      	mov      	$fp,$sp
FFFC549C 10300073		      	pfi      
                        	;    DBGDisplayAsciiString(s);
FFFC54A0 02013D03		      	ldo      	$t0,32[$fp]
FFFC54A4 01A73423		      	sto      	$t0,8[$sp]
FFFC54A8 F3DFF0EF		      	call     	_DBGDisplayAsciiString
FFFC54AC 00870713		      	add      	$sp,$sp,#8
                        	;    DBGCRLF();
FFFC54B0 E71FF0EF		      	call     	_DBGCRLF
                        	DBGConsole_261:
FFFC54B4 00016733		      	mov      	$sp,$fp
FFFC54B8 00073103		      	ldo      	$fp,[$sp]
FFFC54BC 01873083		      	ldo      	$ra,24[$sp]
FFFC54C0 02070713		      	add      	$sp,$sp,#32
FFFC54C4 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC54C8 10300073	public code _DBGHideCursor:
	      	pfi      
                        	; 	if (hide) {
FFFC54CC 00073D03		      	ldo      	$t0,0[$sp]
FFFC54D0 020D0063		      	beq      	$t0,$x0,DBGConsole_274
                        	; 		__asm {
                        		      	;asm     	
FFFC54D4 00010837				ldi		$v0,#$FFFF
FFFC54D8 FFF80813
FFFC54DC FFD1E637				stw		$v0,$FFFFFFFFFFD1DF18
FFFC54E0 F1860613
FFFC54E4 00060633
FFFC54E8 01061023
                        	; 		}
FFFC54EC 00000C63		      	bra      	DBGConsole_275
                        	DBGConsole_274:
                        	; 		__asm {
                        		      	;asm     	
FFFC54F0 0E706813				ldi		$v0,#$00E7
FFFC54F4 FFD1E637				stw		$v0,$FFFFFFFFFFD1DF18
FFFC54F8 F1860613
FFFC54FC 00060633
FFFC5500 01061023
                        	DBGConsole_275:
                        	DBGConsole_273:
FFFC5504 02070713		      	add      	$sp,$sp,#32
FFFC5508 00008067		      	ret      
                        	endpublic
                        	
                        	.file "TinyBasic.r5a",84
                        			code
FFFC550C 00000000			align	25
FFFC5510 00000000
FFFC5514 00000000
FFFC5518 00000000
FFFC551C 00000000
FFFC5520 00000000
FFFC5524 00000000
FFFC5528 00000000
FFFC552C 00000000
FFFC5530 00000000
FFFC5534 00000000
FFFC5538 00000000
FFFC553C 00000000
FFFC5540 00000000
FFFC5544 00000000
FFFC5548 00000000
FFFC554C 00000000
FFFC5550 00000000
FFFC5554 00000000
FFFC5558 00000000
FFFC555C 00000000
FFFC5560 00000000
FFFC5564 00000000
FFFC5568 00000000
FFFC556C 00000000
FFFC5570 00000000
FFFC5574 00000000
FFFC5578 00000000
FFFC557C 00000000
FFFC5580 00000000
FFFC5584 00000000
FFFC5588 00000000
FFFC558C 00000000
FFFC5590 00000000
FFFC5594 00000000
FFFC5598 00000000
FFFC559C 00000000
FFFC55A0 00000000
FFFC55A4 00000000
FFFC55A8 00000000
FFFC55AC 00000000
FFFC55B0 00000000
FFFC55B4 00000000
FFFC55B8 00000000
FFFC55BC 00000000
FFFC55C0 00000000
FFFC55C4 00000000
FFFC55C8 00000000
FFFC55CC 00000000
FFFC55D0 00000000
FFFC55D4 00000000
FFFC55D8 00000000
FFFC55DC 00000000
FFFC55E0 00000000
FFFC55E4 00000000
FFFC55E8 00000000
FFFC55EC 00000000
FFFC55F0 00000000
FFFC55F4 00000000
FFFC55F8 00000000
FFFC55FC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC5600 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC5604 1200006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC5608 17C0206F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC560C 17C0206F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC5610 00000637			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC5614 34760067
                        	GOAUXI:	
FFFC5618 00000637			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC561C 34960067
                        	GOBYE:	
FFFC5620 1980206F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC5624 00000000		align	1
FFFC5628 00000000
FFFC562C 00000000
                        	
                        	//message "CSTART"
FFFC5630 B88FB0EF	public CSTART:
	call	DumpMemmap
                        		; First save off the link register and OS sp value
FFFC5634 00030637		sto		$sp,OSSP
FFFC5638 00060613
FFFC563C 00060633
FFFC5640 00E63023
FFFC5644 AFFFC737		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC5648 00070713
FFFC564C 00E06913		ldi		$a0,#14							; Get current tid
FFFC5650 00000073		ecall
FFFC5654 0008E9B3		mov		$a1,$v1
FFFC5658 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC565C 00000073		ecall
                        	;	call	_DBGHomeCursor[pc]
FFFC5660 00006933		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC5664 FFFC7937		ldi		a0,#msgInit	;	tell who we are
FFFC5668 7CC90913
FFFC566C 71D010EF		call	PRMESG
FFFC5670 00032937		ldi		a0,#TXTBGN	;	init. end-of-program pointer
FFFC5674 80090913
FFFC5678 00030637		sw		a0,TXTUNF
FFFC567C 00460613
FFFC5680 00060633
FFFC5684 01262023
FFFC5688 00040937		ldi		a0,#ENDMEM	;	get address of end of memory
FFFC568C FFC90913
FFFC5690 00080937		ldi		a0,#$7F800
FFFC5694 80090913
FFFC5698 00030637		sw		a0,STKBOT
FFFC569C 09C60613
FFFC56A0 00060633
FFFC56A4 01262023
FFFC56A8 00040937		ldi		a0,#ENDMEM
FFFC56AC FFC90913
FFFC56B0 00030637		sw		a0,VAREND
FFFC56B4 00C60613
FFFC56B8 00060633
FFFC56BC 01262023
FFFC56C0 CE090913		sub		a0,a0,#800 	;   100 vars
FFFC56C4 00030637		sw    a0,VARBGN
FFFC56C8 00860613
FFFC56CC 00060633
FFFC56D0 01262023
FFFC56D4 598000EF		call  clearVars   ; clear the variable area
FFFC56D8 00030637		sw		r0,IRQROUT
FFFC56DC 0A460613
FFFC56E0 00060633
FFFC56E4 00062023
FFFC56E8 00030637		lw    a0,VARBGN   ; calculate number of bytes free
FFFC56EC 00860613
FFFC56F0 00060633
FFFC56F4 00062903
FFFC56F8 00030637		lw		a1,TXTUNF
FFFC56FC 00460613
FFFC5700 00060633
FFFC5704 00062983
FFFC5708 41390933		sub   a0,a0,a1
FFFC570C 00606993		ldi		a1,#6		; max 6 digits
FFFC5710 00A06A13		ldi		a2,#10	; base 10
FFFC5714 399010EF		call  PRTNUM
FFFC5718 FFFC8937		ldi		a0,#msgBytesFree
FFFC571C 86D90913
FFFC5720 669010EF		call	PRMESG
                        	WSTART:
FFFC5724 00030637		sw		x0,LOPVAR   ; initialize internal variables
FFFC5728 01060613
FFFC572C 00060633
FFFC5730 00062023
FFFC5734 00030637		sw		x0,STKGOS
FFFC5738 01460613
FFFC573C 00060633
FFFC5740 00062023
FFFC5744 00030637		sw		x0,CURRNT	;	current line number pointer = 0
FFFC5748 01860613
FFFC574C 00060633
FFFC5750 00062023
FFFC5754 AFFFC737		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC5758 00070713
FFFC575C FFFC8937		ldi		a0,#msgReady	;	display "Ready"
FFFC5760 87A90913
FFFC5764 625010EF		call	PRMESG
                        	BASPRMPT:
FFFC5768 00E06913		ldi		a0,#14		; get current tid
FFFC576C 00000073		ecall
FFFC5770 0008E933		mov		a0,v1
FFFC5774 96CFB0EF		call	PutHexByte
FFFC5778 03E06913		ldi		a0,#'>'		; Prompt with a '>' and
FFFC577C 758010EF		call	GETLN		; read a line.
FFFC5780 555010EF		call	TOUPBUF 	; convert to upper case
FFFC5784 000E64B3		mov		$s6,$t2		; save pointer to end of line
FFFC5788 00030E37		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC578C 01CE0E13
FFFC5790 4A1010EF		call	TSTNUM		; is there a number there?
FFFC5794 511010EF		call	IGNBLK		; skip trailing blanks
FFFC5798 000E4483		lbu		$s6,[$t2]
FFFC579C 00D4C493		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC57A0 2C088063		beq		v1,x0,DIRECT		; if not, it's a direct statement
FFFC57A4 00100DB7		ldi		$t1,#$FFFFF
FFFC57A8 FFFD8D93
FFFC57AC 010DD863		ble		v0,$t1,ST2	; see if line no. is <= 16 bits
FFFC57B0 FFFC8937		ldi		a0,#msgLineRange	; if not, we've overflowed
FFFC57B4 89590913
FFFC57B8 6C00106F		jmp		ERROR
                        	ST2:
FFFC57BC 00086933	  mov		$a0,$v0		; a0 = line number
FFFC57C0 000E6433	  mov		$s5,$t2			; save line buffer pointer
FFFC57C4 FFCE0E13		sub		$t2,$t2,#4
FFFC57C8 012E2023	  sw		$a0,[$t2]		;	This will end up in buffer
FFFC57CC 015010EF		call	FNDLN		; find this line in save area
FFFC57D0 000EE533		mov		$s7,$t3		; save possible line pointer
FFFC57D4 00080663		beq		$v0,$x0,INSLINE	; if not found, insert
FFFC57D8 000EE933		mov		$a0,$t3
FFFC57DC 044000EF		call	DeleteLine
                        	INSLINE:
FFFC57E0 F80484E3		beq		$s6,$x0,BASPRMPT	; line was empty
FFFC57E4 00046933		mov		$a0,$s5			; a0 = buffer pointer	
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC57E8 0B8000EF		call	GetBuflen
FFFC57EC 00480393		add		$s4,$v0,#4
FFFC57F0 00056933		mov		$a0,$s7
FFFC57F4 0003E9B3		mov		$a1,$s4
FFFC57F8 0D4000EF		call	OpenSpace
FFFC57FC 00081863		bne		$v0,$x0,.0001	; space available?
FFFC5800 FFFC8937		ldi		a0,#msgTooBig	; no space available
FFFC5804 96790913
FFFC5808 6700106F		jmp		ERROR
                        	.0001:
FFFC580C 00056933		mov		$a0,$s7			; target
FFFC5810 FFC40993		sub		$a1,$s5,#4	; source (incl lineno)
FFFC5814 0003EA33		mov		$a2,$s4			; length
FFFC5818 068000EF		call	InsertLine
FFFC581C F40006E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
                        		; Find the end of the line to delete
FFFC5820 00490D13		add		$t0,$a0,#4		; t0 = pointer to line past line number
FFFC5824 00D06E13		ldi		$t2,#CR
FFFC5828 00030637		lw		$t3,TXTUNF		; last text address
FFFC582C 00460613
FFFC5830 00060633
FFFC5834 00062E83
                        	.0002:
FFFC5838 000D4D83		lbu		$t1,[$t0]
FFFC583C 000D8A63		beq		$t1,$x0,.0003	; might be null
FFFC5840 01CD8663		beq		$t1,$t2,.0001	; lines end with CR
FFFC5844 001D0D13		add		$t0,$t0,#1
FFFC5848 FFDD68E3		bltu	$t0,$t3,.0002	; end of program?
                        	.0001:
FFFC584C 001D0D13		add		$t0,$t0,#1
                        	.0003:
                        		; pull text after eol overtop
FFFC5850 000D4F03		lbu		$t4,[$t0]			; copy from next line
FFFC5854 01E90023		sb		$t4,[$a0]			; overtop deleted line
FFFC5858 001D0D13		add		$t0,$t0,#1		; increment pointers
FFFC585C 00190913		add		$a0,$a0,#1
FFFC5860 FFAEF8E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC5864 412D0933		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC5868 412E8EB3		sub		$t3,$t3,$a0		
FFFC586C 00030637		sw		$t3,TXTUNF
FFFC5870 00460613
FFFC5874 00060633
FFFC5878 01D62023
FFFC587C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC5880 000A0E63		beq		$a2,$x0,.done		; zero length? Probably a SW error
                        	.0001:
FFFC5884 0009CD83		lbu		$t1,[$a1]				; get from source text
FFFC5888 01B90023		sb		$t1,[$a0]				; store to insertion point
FFFC588C 00198993		add		$a1,$a1,#1			; increment pointers
FFFC5890 00190913		add		$a0,$a0,#1
FFFC5894 FFFA0A13		sub		$a2,$a2,#1			; decrement length
FFFC5898 FF4066E3		bgtu	$a2,$x0,.0001
                        	.done:
FFFC589C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		v0 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC58A0 00006813		ldi		$v0,#0
FFFC58A4 00D06E93		ldi		$t3,#CR
FFFC58A8 00096FB3		mov		$t5,$a0
                        	.0002:
FFFC58AC 000FCE03		lbu		$t2,[$t5]
FFFC58B0 001F8F93		add		$t5,$t5,#1
FFFC58B4 000E0A63		beq		$t2,$x0,.0001
FFFC58B8 01DE0663		beq		$t2,$t3,.0004
FFFC58BC 00180813		add		$v0,$v0,#1
FFFC58C0 FE0006E3		bra		.0002
                        	.0004:
FFFC58C4 00180813		add		$v0,$v0,#1
                        	.0001:
FFFC58C8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC58CC 00030637		lw		$t2,TXTUNF
FFFC58D0 00460613
FFFC58D4 00060633
FFFC58D8 00062E03
FFFC58DC 000E6EB3		mov		$t3,$t2				; t3 = old end of text
FFFC58E0 013E0E33		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC58E4 00030637		lw		$t1,VARBGN		; compare to start of variables
FFFC58E8 00860613
FFFC58EC 00060633
FFFC58F0 00062D83
FFFC58F4 03BE7863		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC58F8 00030637		sw		$t2,TXTUNF		; yes, set new end of text
FFFC58FC 00460613
FFFC5900 00060633
FFFC5904 01C62023
                        	.0003:
FFFC5908 000ECF83		lbu		$t5,[$t3]			; copy old text
FFFC590C 01FE0023		sb		$t5,[$t2]			; to new text loc
FFFC5910 FFFE8E93		sub		$t3,$t3,#1		; decrement pointers
FFFC5914 FFFE0E13		sub		$t2,$t2,#1
FFFC5918 FF2EF8E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC591C 00106813		ldi		$v0,#1				; return success
FFFC5920 00008067		ret
                        	.noSpace:
FFFC5924 00006813		ldi		$v0,#0
FFFC5928 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC592C D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC5930 C4414F4C		db	"LOA",'D'+0x80
FFFC5934 52D7454E		db	"NE",'W'+0x80
FFFC5937 53CE5552		db	"RU",'N'+0x80
FFFC593A C5564153		db	"SAV",'E'+0x80
                        	TAB2:
FFFC593E D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC5942 49D4454C		db	"LE",'T'+0x80
FFFC5945 4F47C649		db	"I",'F'+0x80
FFFC5947 CF544F47		db	"GOT",'O'+0x80
FFFC594B 55534F47		db	"GOSU",'B'+0x80
FFFC594F 544552C2
FFFC5950 55544552		db	"RETUR",'N'+0x80
FFFC5954 4552CE52
FFFC5956 46CD4552		db	"RE",'M'+0x80
FFFC5959 49D24F46		db	"FO",'R'+0x80
FFFC595C 55504E49		db	"INPU",'T'+0x80
FFFC5960 495250D4
FFFC5961 4E495250		db	"PRIN",'T'+0x80
FFFC5965 4B4F50D4
FFFC5966 C54B4F50		db	"POK",'E'+0x80
FFFC596A 454B4F50		db	"POKE",'W'+0x80
FFFC596E 4B4F50D7
FFFC596F 454B4F50		db	"POKE",'H'+0x80
FFFC5973 454959C8
FFFC5974 4C454959		db	"YIEL",'D'+0x80
FFFC5978 4F5453C4
FFFC5979 D04F5453		db	"STO",'P'+0x80
FFFC597D 53C55942		db	"BY",'E'+0x80
FFFC5980 43D35953		db	"SY",'S'+0x80
FFFC5983 43D34C43		db	"CL",'S'+0x80
FFFC5986 52D24C43	    db  "CL",'R'+0x80
FFFC5989 C6434452	    db	"RDC",'F'+0x80
FFFC598D 52494E4F	    db	"ONIR",'Q'+0x80
FFFC5991 494157D1
FFFC5992 D4494157	    db	"WAI",'T'+0x80
FFFC5996 45455000		db	0
                        	TAB4:
FFFC5997 CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC599B 4B454550		db	"PEEK",'W'+0x80
FFFC599F 454550D7
FFFC59A0 4B454550		db	"PEEK",'H'+0x80
FFFC59A4 C44E52C8
FFFC59A5 41C44E52		db	"RN",'D'+0x80
FFFC59A8 53D34241		db	"AB",'S'+0x80
FFFC59AB 54CE4753		db  "SG",'N'+0x80
FFFC59AE CB434954		db	"TIC",'K'+0x80
FFFC59B2 C55A4953		db	"SIZ",'E'+0x80
FFFC59B6 41D25355		db  "US",'R'+0x80
FFFC59B9 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC59BD D8424D43
FFFC59C1 444E4553	  db	"SENDMS",'G'+0x80
FFFC59C5 57C7534D
FFFC59C8 54494157	  db	"WAITMS",'G'+0x80
FFFC59CC 00C7534D
FFFC59CF 00CF5400		db	0
                        	TAB5:
FFFC59D0 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC59D2 45545300		db	0
                        	TAB6:
FFFC59D3 D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC59D7 3CBD3E00		db	0
                        	TAB8:
FFFC59D8 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC59DA BDBEBE3C		db	'<','>'+0x80
FFFC59DC BD3CBDBE		db	'>'+0x80
FFFC59DD BCBD3CBD		db	'='+0x80
FFFC59DE 00BCBD3C		db	'<','='+0x80
FFFC59E0 4E4100BC		db	'<'+0x80
FFFC59E1 C44E4100		db	0
                        	TAB9:
FFFC59E2 00C44E41	    db  "AN",'D'+0x80
FFFC59E5 00D24F00	    db  0
                        	TAB10:
FFFC59E6 0000D24F	    db  "O",'R'+0x80
FFFC59E8 5D0C0000	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
FFFC59E9 405D0C00		align	
                        	
                        	TAB1_1:
FFFC59EA 63405D0C		dh	LISTX			;Direct commands
FFFC59EC 5AE86340		dh	LOAD3
FFFC59EE 5B1C5AE8		dh	NEW
FFFC59F0 63A85B1C		dh	RUN
FFFC59F2 5FBC63A8		dh	SAVE3
                        	TAB2_1:
FFFC59F4 61D45FBC		dh	NEXT		;	Direct / statement
FFFC59F6 607C61D4		dh	LET
FFFC59F8 5C40607C		dh	IF0
FFFC59FA 5E005C40		dh	GOTO
FFFC59FC 5E745E00		dh	GOSUB
FFFC59FE 60885E74		dh	RETURN
FFFC5A00 5EDC6088		dh	IF2			; REM
FFFC5A02 60D45EDC		dh	FOR
FFFC5A04 5D6060D4		dh	INPUT
FFFC5A06 651C5D60		dh	PRINT
FFFC5A08 6548651C		dh	POKE
FFFC5A0A 65746548		dh	POKEW
FFFC5A0C 5B106574		dh	POKEH
FFFC5A0E 5B085B10		dh	YIELD0
FFFC5A10 56205B08		dh	STOP
FFFC5A12 65AC5620		dh	GOBYE
FFFC5A14 039965AC		dh	SYSX
FFFC5A16 5C640399		dh	_cls
FFFC5A18 039B5C64		dh  _clr
FFFC5A1A 5CB0039B		dh	_rdcf
FFFC5A1C 5CF05CB0		dh  ONIRQ
FFFC5A1E 61C85CF0		dh	WAITIRQ
FFFC5A20 6BEC61C8		dh	DEFLT
                        	TAB4_1:
FFFC5A22 6C046BEC		dh	PEEK			;Functions
FFFC5A24 6C1C6C04		dh	PEEKW
FFFC5A26 6C806C1C		dh	PEEKH
FFFC5A28 00006C80		dh	RND
FFFC5A2A 6D140000		dh	ABS
FFFC5A2C 6D006D14		dh  SGN
FFFC5A2E 6D506D00		dh	TICKX
FFFC5A30 6C346D50		dh	SIZEX
FFFC5A32 75A06C34		dh  USRX
FFFC5A34 761075A0		dh	ALLOCMBX
FFFC5A36 76AC7610		dh	SENDMSG
FFFC5A38 69A476AC		dh	WAITMSG
FFFC5A3A 5F0869A4		dh	XP40
                        	TAB5_1
FFFC5A3C 6E705F08		dh	FR1			;"TO" in "FOR"
FFFC5A3E 5F306E70		dh	QWHAT
                        	TAB6_1
FFFC5A40 5F385F30		dh	FR2			;"STEP" in "FOR"
FFFC5A42 675C5F38		dh	FR3
                        	TAB8_1
FFFC5A44 6774675C		dh	XP11	;>=		Relational operators
FFFC5A46 678C6774		dh	XP12	;<>
FFFC5A48 67BC678C		dh	XP13	;>
FFFC5A4A 67A467BC		dh	XP15	;=
FFFC5A4C 67D467A4		dh	XP14	;<=
FFFC5A4E 681467D4		dh	XP16	;<
FFFC5A50 666C6814		dh	XP17
                        	TAB9_1
FFFC5A52 6680666C	    dh  XP_AND
FFFC5A54 660C6680	    dh  XP_ANDX
                        	TAB10_1
FFFC5A56 6620660C	    dh  XP_OR
FFFC5A58 00006620	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC5A5A 00000000		align	1
FFFC5A5E 6EB70000
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC5A60 FFFC6EB7		ldi		$t3,#TAB1
FFFC5A64 92CE8E93
FFFC5A68 FFFC6F37		ldi		$t4,#TAB1_1
FFFC5A6C 9EAF0F13
                        	EXEC:
FFFC5A70 235010EF		call	IGNBLK		; ignore leading blanks
FFFC5A74 000E6FB3		mov		$t5,$t2		; save the pointer
FFFC5A78 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC5A7C 000E4903		lbu		a0,[$t2]		; get the program character
FFFC5A80 001E0E13		add		$t2,$t2,#1
FFFC5A84 000EC983		lbu		a1,[$t3]		; get the table character
FFFC5A88 00099663		bne		a1,x0,EXNGO		; If end of table,
FFFC5A8C 000FEE33		mov		$t2,$t5		;	restore the text pointer and...
FFFC5A90 04000263		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC5A94 04390063		beq		a0,r3,EXGO	; Else check for period... if so, execute
FFFC5A98 07F9F993		and		a1,a1,#0x7f	; ignore the table's high bit
FFFC5A9C 03298263		beq		a1,a0,EXMAT	;		is there a match?
FFFC5AA0 002F0F13		add		$t4,$t4,#2	;if not, try the next entry
FFFC5AA4 000FEE33		mov		$t2,$t5		; reset the program pointer
FFFC5AA8 000061B3		mov		r3,x0		; sorry, no match
                        	EX1:
FFFC5AAC 000EC903		lbu		a0,[$t3]		; get to the end of the entry
FFFC5AB0 001E8E93		add		$t3,$t3,#1
FFFC5AB4 08097D93		and		$t1,$a0,#$80
FFFC5AB8 FE0D8AE3		beq		$t1,$r0,EX1	; test for bit 7 set
FFFC5ABC FC0000E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC5AC0 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC5AC4 000EC903		lbu		a0,[$t3]		; end of table entry?
FFFC5AC8 001E8E93		add		$t3,$t3,#1
FFFC5ACC 08097D93		and		$t1,$a0,#$80
FFFC5AD0 FA0D86E3		beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC5AD4 000F5903		lhu		a0,[$t4]	; get the low mid order byte
FFFC5AD8 FFFC0637		or		a0,a0,#$FFFC0000	; add in ROM base
FFFC5ADC 00060613
FFFC5AE0 01266933
FFFC5AE4 00090067		jmp		[a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC5AE8 340010EF		call	ENDCHK
FFFC5AEC 00032837		ldi		v0,#TXTBGN
FFFC5AF0 80080813
FFFC5AF4 00030637		sw		v0,TXTUNF	;	set the end pointer
FFFC5AF8 00460613
FFFC5AFC 00060633
FFFC5B00 01062023
FFFC5B04 168000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC5B08 320010EF		call	ENDCHK
FFFC5B0C C19FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC5B10 00D06913		ldi		a0,#13
FFFC5B14 00000073		ecall
FFFC5B18 2E00006F		jmp		FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC5B1C 30C010EF		call	ENDCHK
FFFC5B20 00032E37		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC5B24 800E0E13
FFFC5B28 00030637		sw		$t2,CURRNT
FFFC5B2C 01860613
FFFC5B30 00060633
FFFC5B34 01C62023
FFFC5B38 134000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC5B3C 00030637		lw		$t2,CURRNT	; executing a program?
FFFC5B40 01860613
FFFC5B44 00060633
FFFC5B48 00062E03
FFFC5B4C 000E1463		bne		$t2,x0,RUN3	; if not, we've finished a direct stat.
                        	RUN2:
FFFC5B50 BD5FF06F		jmp		WSTART
                        	RUN3:
FFFC5B54 00030637		lw		a0,IRQROUT		; are we handling IRQ's ?
FFFC5B58 0A460613
FFFC5B5C 00060633
FFFC5B60 00062903
FFFC5B64 08090863		beq		a0,x0,RUN1
FFFC5B68 00030637		lw		$t1,IRQFlag		; was there an IRQ ?
FFFC5B6C 0B460613
FFFC5B70 00060633
FFFC5B74 00062D83
FFFC5B78 060D8E63		beq		$t1,x0,RUN1
FFFC5B7C 00030637		sw		x0,IRQFlag
FFFC5B80 0B460613
FFFC5B84 00060633
FFFC5B88 00062023
FFFC5B8C 598010EF		call	PUSHA_		; the same code as a GOSUB
FFFC5B90 FF470713		sub		$sp,$sp,#12
FFFC5B94 00030637		lw		a0,STKGOS
FFFC5B98 01460613
FFFC5B9C 00060633
FFFC5BA0 00062903
FFFC5BA4 01272023		sw		a0,[$sp]
FFFC5BA8 00030637		lw		a0,CURRNT
FFFC5BAC 01860613
FFFC5BB0 00060633
FFFC5BB4 00062903
FFFC5BB8 01272223		sw		a0,4[$sp]
FFFC5BBC 01C72423		sw		$t2,8[$sp]
FFFC5BC0 00030637		sw		x0,LOPVAR		; load new values
FFFC5BC4 01060613
FFFC5BC8 00060633
FFFC5BCC 00062023
FFFC5BD0 00030637		sw		$sp,STKGOS
FFFC5BD4 01460613
FFFC5BD8 00060633
FFFC5BDC 00E62023
FFFC5BE0 00030637		lw		$t3,IRQROUT
FFFC5BE4 0A460613
FFFC5BE8 00060633
FFFC5BEC 00062E83
FFFC5BF0 02000263		bra		RUNTSL
                        	RUN1:
FFFC5BF4 000E6EB3		mov		$t3,$t2
FFFC5BF8 00006933		mov		a0,x0
FFFC5BFC 404010EF		call	FNDLNP		; else find the next line number
FFFC5C00 00030637		lw		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC5C04 00460613
FFFC5C08 00060633
FFFC5C0C 00062D83
FFFC5C10 F5BEF0E3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC5C14 00030637		sw		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC5C18 01860613
FFFC5C1C 00060633
FFFC5C20 01D62023
FFFC5C24 004E8E13		add		$t2,$t3,#4	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC5C28 131010EF		call	CHKIO		; see if a control-C was pressed
FFFC5C2C FFFC6EB7		ldi		$t3,#TAB2		; find command in TAB2
FFFC5C30 93EE8E93
FFFC5C34 FFFC6F37		ldi		$t4,#TAB2_1
FFFC5C38 9F4F0F13
FFFC5C3C E35FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC5C40 199000EF		call	OREXPR		;evaluate the following expression
FFFC5C44 000862B3		mov   r5,v0
FFFC5C48 1E0010EF		call 	ENDCHK		;must find end of line
FFFC5C4C 0002E933		mov   a0,r5
FFFC5C50 390010EF		call 	FNDLN		; find the target line
FFFC5C54 FC0810E3		bne		v0,x0,RUNTSL; go do it
FFFC5C58 FFFC8937		ldi		a0,#msgBadGotoGosub
FFFC5C5C 93590913
FFFC5C60 2180106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC5C64 008000EF	    call    clearVars
FFFC5C68 1900006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC5C6C FF870713		sub		$sp,$sp,#8
FFFC5C70 00672023		sw		r6,[$sp]
FFFC5C74 00172223		sw		$ra,4[$sp]
FFFC5C78 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC5C7C 00030637	  lw    v0,VARBGN
FFFC5C80 00860613
FFFC5C84 00060633
FFFC5C88 00062803
                        	.cv1:
FFFC5C8C 00082023	  sw		x0,[$v0]		; variable name
FFFC5C90 00082223	  sw		x0,4[$v0]		; and value
FFFC5C94 00880813	  add		v0,v0,#8
FFFC5C98 FFF30313	  sub		r6,r6,#1
FFFC5C9C FE6048E3		bgt		r6,x0,.cv1
FFFC5CA0 00072303	  lw		r6,[$sp]
FFFC5CA4 00472083	  lw		$ra,4[$sp]
FFFC5CA8 00870713	  add		$sp,$sp,#8
FFFC5CAC 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC5CB0 129000EF		call	OREXPR		;evaluate the following expression
FFFC5CB4 000862B3		mov   r5,v0
FFFC5CB8 170010EF		call 	ENDCHK		;must find end of line
FFFC5CBC 0002E933		mov   a0,r5
FFFC5CC0 320010EF		call 	FNDLN		; find the target line
FFFC5CC4 00081C63		bne		v0,r0,ONIRQ1
FFFC5CC8 00030637		sw		x0,IRQROUT
FFFC5CCC 0A460613
FFFC5CD0 00060633
FFFC5CD4 00062023
FFFC5CD8 1200006F		jmp		FINISH
                        	ONIRQ1:
FFFC5CDC 00030637		sw		$t3,IRQROUT
FFFC5CE0 0A460613
FFFC5CE4 00060633
FFFC5CE8 01D62023
FFFC5CEC 10C0006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC5CF0 069010EF		call	CHKIO		; see if a control-C was pressed
FFFC5CF4 00030637		lw		$t1,IRQFlag
FFFC5CF8 0B460613
FFFC5CFC 00060633
FFFC5D00 00062D83
FFFC5D04 FE0D86E3		beq		$t1,x0,WAITIRQ
FFFC5D08 0F00006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC5D0C 724010EF		call		TSTNUM		; see if there's a line no.
FFFC5D10 000862B3		mov      r5,v0
FFFC5D14 114010EF		call		ENDCHK		; if not, we get a zero
FFFC5D18 0002E933		mov      a0,r5
FFFC5D1C 2C4010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC5D20 00081C63		bne		v0,r0,LS4
                        	LS5:
FFFC5D24 00030637		lw		$t1,TXTUNF
FFFC5D28 00460613
FFFC5D2C 00060633
FFFC5D30 00062D83
FFFC5D34 9FBEF8E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC5D38 000EE933		mov		a0,$t3
FFFC5D3C 64C010EF		call	PRTLN		; print the line
FFFC5D40 00086EB3		mov		$t3,$v0		; set pointer for next
FFFC5D44 015010EF		call	CHKIO		; check for listing halt request
FFFC5D48 00080A63		beq		v0,x0,LS3
FFFC5D4C 01306D93		ldi		$t1,#CTRLS
FFFC5D50 01B81663		bne		v0,$t1,LS3; pause the listing?
                        	LS2:
FFFC5D54 005010EF		call 	CHKIO		; if so, wait for another keypress
FFFC5D58 FE080EE3		beq		v0,r0,LS2
                        	LS3:
                        	;	mov		$v0,$x0
FFFC5D5C FC0004E3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC5D60 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC5D64 680010EF		call	TSTC		; if null list and ":"
FFFC5D68 0000003A		dw		':'
FFFC5D6C 00000663		bra		PR2
FFFC5D70 011010EF		call	CRLF		; give CR-LF and continue
FFFC5D74 EB5FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC5D78 66C010EF		call	TSTC		;if null list and <CR>
FFFC5D7C 0000000D		dw		CR
FFFC5D80 00000663		bra		PR0
FFFC5D84 7FC010EF		call	CRLF		;also give CR-LF and
FFFC5D88 DB5FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC5D8C 658010EF		call	TSTC		;else is it a format?
FFFC5D90 00000023		dw		'#'
FFFC5D94 00000863		bra		PR1
FFFC5D98 041000EF		call	OREXPR		; yes, evaluate expression
FFFC5D9C 000862B3		mov		r5,v0	; and save it as print width
FFFC5DA0 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC5DA4 640010EF		call	TSTC	;	is character expression? (MRL)
FFFC5DA8 00000024		dw		'$'
FFFC5DAC 00000863		bra		PR4
FFFC5DB0 029000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC5DB4 855FF0EF		call	GOOUT	;	print low byte (MRL)
FFFC5DB8 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC5DBC 45C010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC5DC0 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC5DC4 620010EF		call		TSTC	;	if ",", go find next
FFFC5DC8 0000002C		dw		','
FFFC5DCC 00000663		bra		PR6
FFFC5DD0 01C010EF		call		FIN		;in the list.
FFFC5DD4 FA000CE3		bra		PR0
                        	PR6:
FFFC5DD8 7A8010EF		call		CRLF		;list ends here
FFFC5DDC 01C0006F		jmp		FINISH
                        	PR8:
FFFC5DE0 7F8000EF		call	OREXPR		; evaluate the expression
FFFC5DE4 00086933		mov		a0,v0
FFFC5DE8 00506993		ldi		a1,#5		; set the width
FFFC5DEC 00A06A13		ldi		a2,#10
FFFC5DF0 4BC010EF		call	PRTNUM		; print its value
FFFC5DF4 FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC5DF8 7F5000EF		call	FIN		; Check end of command
FFFC5DFC 0740106F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC5E00 324010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC5E04 7D4000EF		call	OREXPR		; get line number
FFFC5E08 00086933		mov		$a0,$v0
FFFC5E0C 1D4010EF		call	FNDLN		; find the target line
FFFC5E10 00081863		bne		v0,r0,gosub1
FFFC5E14 FFFC8937		ldi		a0,#msgBadGotoGosub
FFFC5E18 93590913
FFFC5E1C 05C0106F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC5E20 FF470713		sub		$sp,$sp,#12
FFFC5E24 00030637		lw		a0,STKGOS	; 'STKGOS'
FFFC5E28 01460613
FFFC5E2C 00060633
FFFC5E30 00062903
FFFC5E34 01272023		sw		a0,[$sp]
FFFC5E38 00030637		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC5E3C 01860613
FFFC5E40 00060633
FFFC5E44 00062903
FFFC5E48 01272223		sw		a0,4[$sp]
FFFC5E4C 01C72423		sw		$t2,8[$sp]
FFFC5E50 00030637		sw		$x0,LOPVAR		; load new values
FFFC5E54 01060613
FFFC5E58 00060633
FFFC5E5C 00062023
FFFC5E60 00030637		sw		$sp,STKGOS
FFFC5E64 01460613
FFFC5E68 00060633
FFFC5E6C 00E62023
FFFC5E70 DA5FF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC5E74 7B5000EF		call	ENDCHK		; there should be just a <CR>
FFFC5E78 00030637		lw		a1,STKGOS		; get old stack pointer
FFFC5E7C 01460613
FFFC5E80 00060633
FFFC5E84 00062983
FFFC5E88 00099863		bne		a1,x0,return1
FFFC5E8C FFFC8937		ldi		a0,#msgRetWoGosub
FFFC5E90 95190913
FFFC5E94 7E50006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC5E98 0009E733		mov		$sp,a1		; else restore it
FFFC5E9C 00072903		lw		a0,[$sp]
FFFC5EA0 00470713		add		$sp,$sp,#4
FFFC5EA4 00030637		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC5EA8 01460613
FFFC5EAC 00060633
FFFC5EB0 01262023
FFFC5EB4 00072903		lw		a0,[$sp]
FFFC5EB8 00470713		add		$sp,$sp,#4
FFFC5EBC 00030637		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC5EC0 01860613
FFFC5EC4 00060633
FFFC5EC8 01262023
FFFC5ECC 00072E03		lw		$t2,[$sp]	; and the old text pointer
FFFC5ED0 00470713		add		$sp,$sp,#4
FFFC5ED4 1DC010EF		call	POPA_		;and the old 'FOR' parameters
FFFC5ED8 F21FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC5EDC 248010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC5EE0 6A5000EF		call	SETVAL		; set the control variable
FFFC5EE4 00030637		sw		v0,LOPVAR		; save its address
FFFC5EE8 01060613
FFFC5EEC 00060633
FFFC5EF0 01062023
FFFC5EF4 FFFC6EB7		ldi		$t3,#TAB5
FFFC5EF8 9D0E8E93
FFFC5EFC FFFC6F37		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC5F00 A3CF0F13
FFFC5F04 B6DFF06F		jmp		EXEC
                        	FR1:
FFFC5F08 6D0000EF		call	OREXPR		; evaluate the limit
FFFC5F0C 00030637		sw		v0,LOPLMT	; save that
FFFC5F10 07C60613
FFFC5F14 00060633
FFFC5F18 01062023
FFFC5F1C FFFC6EB7		ldi		$t3,#TAB6
FFFC5F20 9D3E8E93
FFFC5F24 FFFC6F37		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC5F28 A40F0F13
FFFC5F2C B45FF06F		jmp		EXEC
                        	FR2:
FFFC5F30 6A8000EF		call	OREXPR		; found it, get the step value
FFFC5F34 00000463		bra		FR4
                        	FR3:
FFFC5F38 00106813		ldi		v0,#1		; not found, step defaults to 1
                        	FR4:
FFFC5F3C 00030637		sw		v0,LOPINC	; save that too
FFFC5F40 07860613
FFFC5F44 00060633
FFFC5F48 01062023
                        	FR5:
FFFC5F4C 00030637		lw		a1,CURRNT
FFFC5F50 01860613
FFFC5F54 00060633
FFFC5F58 00062983
FFFC5F5C 00030637		sw		a1,LOPLN	; save address of current line number
FFFC5F60 07460613
FFFC5F64 00060633
FFFC5F68 01362023
FFFC5F6C 00030637		sw		$t2,LOPPT	; and text pointer
FFFC5F70 07060613
FFFC5F74 00060633
FFFC5F78 01C62023
FFFC5F7C 000761B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC5F80 00030637		lw		r6,LOPVAR
FFFC5F84 01060613
FFFC5F88 00060633
FFFC5F8C 00062303
FFFC5F90 00000463		bra		FR7
                        	FR6:
FFFC5F94 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC5F98 0001A983		lw		a1,[r3]		; is it zero?
FFFC5F9C 00098E63		beq		a1,x0,FR8	; if so, we're done
FFFC5FA0 FE699AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC5FA4 0001E933	  mov		a0,r3	   ; Else remove 5 words from...
FFFC5FA8 000769B3		mov		a1,$sp
FFFC5FAC 01418A13		add		a2,r3,#20  ; inside the stack.
FFFC5FB0 0F8010EF		call	MVDOWN
FFFC5FB4 01470713		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC5FB8 E41FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC5FBC 00006933		mov		a0,x0		; don't allocate it
FFFC5FC0 259000EF		call	TSTV		; get address of variable
FFFC5FC4 00081863		bne		v0,x0,NX4
FFFC5FC8 FFFC8937		ldi		a0,#msgNextVar
FFFC5FCC 91290913
FFFC5FD0 6A0004E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC5FD4 00086EB3		mov		$t3,v0	; save variable's address
                        	NX0:
FFFC5FD8 00030637		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC5FDC 01060613
FFFC5FE0 00060633
FFFC5FE4 00062903
FFFC5FE8 00091863		bne		a0,x0,NX5	; had a FOR loop
FFFC5FEC FFFC8937		ldi		a0,#msgNextFor
FFFC5FF0 90090913
FFFC5FF4 680002E3		bra		ERROR
                        	NX5:
FFFC5FF8 01D90663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC5FFC 0B4010EF		call	POPA_		; nope, let's see the next frame
FFFC6000 FC000CE3		bra		NX0
                        	NX2:
FFFC6004 000EA903		lw		a0,[$t3]		; get control variable's value
FFFC6008 00030637		lw		a1,LOPINC
FFFC600C 07860613
FFFC6010 00060633
FFFC6014 00062983
FFFC6018 01390933		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC601C 012EA023		sw		a0,[$t3]		; save control variable's new value
FFFC6020 00030637		lw		r3,LOPLMT	; get loop's limit value
FFFC6024 07C60613
FFFC6028 00060633
FFFC602C 00062183
FFFC6030 0009D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC6034 04394063		blt		a0,r3,NXPurge	; test against limit
FFFC6038 00000463		bra     NX3
                        	NX1:
FFFC603C 0321CC63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC6040 00030637		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC6044 07460613
FFFC6048 00060633
FFFC604C 00062E03
FFFC6050 00030637		sw		$t2,CURRNT
FFFC6054 01860613
FFFC6058 00060633
FFFC605C 01C62023
FFFC6060 00030637		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC6064 07060613
FFFC6068 00060633
FFFC606C 00062E03
FFFC6070 D89FF06F		jmp		FINISH
                        	NXPurge:
FFFC6074 03C010EF	  call    POPA_        ; purge this loop
FFFC6078 D81FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC607C 55C000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC6080 00080463	  beq	  v0,x0,IF2	; is it zero? if not, continue
FFFC6084 BA5FF06F	  jmp		RUNSML
                        	IF2:
FFFC6088 000E6EB3	  mov		$t3,$t2	; set lookup pointer
FFFC608C 00006933		mov		a0,x0		; find line #0 (impossible)
FFFC6090 7DD000EF		call	FNDSKP		; if so, skip the rest of the line
FFFC6094 00081463		bne		v0,x0,IF3; if no next line, do a warm start
FFFC6098 E8CFF06F		jmp		WSTART
                        	IF3:
FFFC609C B79FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC60A0 00030637		lw		$sp,STKINP		; restore the old stack pointer
FFFC60A4 09860613
FFFC60A8 00060633
FFFC60AC 00062703
FFFC60B0 00072903		lw		a0,[$sp]
FFFC60B4 00470713		add		$sp,$sp,#4
FFFC60B8 00030637		sw		a0,CURRNT		; and old 'CURRNT'
FFFC60BC 01860613
FFFC60C0 00060633
FFFC60C4 01262023
FFFC60C8 00072E03		lw		$t2,[$sp]		; and old text pointer
FFFC60CC 00470713		add		$sp,$sp,#4
FFFC60D0 01470713		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC60D4 FEC70713		sub		$sp,$sp,#20	; allocate five words on stack
FFFC60D8 00572823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC60DC 01C72023		sw		$t2,[$sp]	; save in case of error
FFFC60E0 138010EF		call	QTSTG		; is next item a string?
FFFC60E4 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC60E8 00106913		ldi		a0,#1		; allocate var
FFFC60EC 12D000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC60F0 0A090E63		beq    a0,r0,IP4   ; if not, brnch
FFFC60F4 00096F33		mov		$t4,a0		; put away the variable's address
FFFC60F8 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC60FC 01C72223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC6100 00106913		ldi		a0,#1
FFFC6104 115000EF		call	TSTV		; must be a variable now
FFFC6108 00091A63		bne		a0,r0,IP7
FFFC610C FFFC8937		ldi		a0,#msgInputVar
FFFC6110 8E490913
FFFC6114 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC6118 560000E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC611C 00096F33		mov		$t4,a0		; put away the variable's address
FFFC6120 000E4283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC6124 000E0023		sb		x0,[$t2]
FFFC6128 000069B3		mov		a1,x0
FFFC612C 00472903		lw		a0,4[$sp]	; get back text pointer
FFFC6130 080010EF		call	PRTSTG		; print string as prompt
FFFC6134 005E0023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC6138 01C72223		sw		$t2,4[$sp]	; save in case of error
FFFC613C 00030637		lw		a0,CURRNT
FFFC6140 01860613
FFFC6144 00060633
FFFC6148 00062903
FFFC614C 01272423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC6150 FFF06913		ldi		a0,#-1
FFFC6154 00030637		sw		a0,CURRNT	; flag that we are in INPUT
FFFC6158 01860613
FFFC615C 00060633
FFFC6160 01262023
FFFC6164 00030637		sw		$sp,STKINP	; save the stack pointer too
FFFC6168 09860613
FFFC616C 00060633
FFFC6170 00E62023
FFFC6174 01E72623		sw		$t4,12[$sp]	; save the variable address
FFFC6178 03A06913		ldi		a0,#':'		; print a colon first
FFFC617C 559000EF		call	GETLN		; then get an input line
FFFC6180 00030E37		ldi		$t2,#BUFFER	; point to the buffer
FFFC6184 01CE0E13
FFFC6188 450000EF		call	OREXPR		; evaluate the input
FFFC618C 00C72F03		lw		$t4,12[$sp]	; restore the variable address
FFFC6190 012F2023		sw		a0,[$t4]	; save value in variable
FFFC6194 00872903		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC6198 00030637		sw		a0,CURRNT
FFFC619C 01860613
FFFC61A0 00060633
FFFC61A4 01262023
FFFC61A8 00472E03		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC61AC 238010EF		call	TSTC
FFFC61B0 0000002C		dw		','
FFFC61B4 00000463		bra		IP5
FFFC61B8 F20002E3		bra		IP6			; yes, more items
                        	IP5:
FFFC61BC 01072283		lw		r5,16[$sp]
FFFC61C0 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC61C4 C35FF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC61C8 000E4903	  lbu    	a0,[$t2]
FFFC61CC 00D06D93	  ldi			$t1,#CR
FFFC61D0 C3B904E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC61D4 3B1000EF	  call	SETVAL		; do the assignment
FFFC61D8 20C010EF		call	TSTC		; check for more 'LET' items
FFFC61DC 0000002C		dw		','
FFFC61E0 C19FF06F		jmp		FINISH
FFFC61E4 FE0008E3		bra	    LET
                        	LT1:
FFFC61E8 C11FF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC61EC 00032E37		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC61F0 800E0E13
FFFC61F4 00D06913		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC61F8 C18FF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC61FC C1CFF0EF		call	GOAUXI		; look for start of line
FFFC6200 FF205EE3		ble		a0,r0,LOD1
FFFC6204 04006D93		ldi		$t1,#'@'
FFFC6208 03B90E63		beq		a0,$t1,LODEND	; end of program?
FFFC620C 01A06D93		ldi		$t1,#$1A
FFFC6210 03B90A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC6214 03A06D93		ldi		$t1,#':'
FFFC6218 FFB912E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC621C 03C000EF		call	GCHAR		; get line number
FFFC6220 012E2023		sw		a0,[$t2]		; store it
FFFC6224 004E0E13		add		$t2,$t2,#4
                        	LOD2:
FFFC6228 BF0FF0EF		call	GOAUXI		; get another text char.
FFFC622C FF205EE3		ble		a0,r0,LOD2
FFFC6230 012E0023		sb		a0,[$t2]		; store it
FFFC6234 001E0E13		add		$t2,$t2,#1
FFFC6238 00D06D93		ldi		$t1,#CR
FFFC623C FFB916E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC6240 FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC6244 00030637		sw		$t2,TXTUNF	; set end-of program pointer
FFFC6248 00460613
FFFC624C 00060633
FFFC6250 01C62023
FFFC6254 CD0FF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC6258 FF470713		sub		$sp,$sp,#12
FFFC625C 00572023		sw		r5,[$sp]
FFFC6260 00672223		sw		r6,4[$sp]
FFFC6264 00172423		sw		$ra,8[$sp]
FFFC6268 00806313		ldi		r6,#8       ; repeat ten times
FFFC626C 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC6270 BA8FF0EF		call	GOAUXI		; get a char
FFFC6274 FF205EE3		ble		a0,r0,GCHAR1
FFFC6278 02C000EF		call	asciiToHex
FFFC627C 00429293		sll		r5,r5,#4
FFFC6280 0122E2B3		or		r5,r5,a0
FFFC6284 FFF30313		sub		r6,r6,#1
FFFC6288 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC628C 0002E933		mov		a0,r5
FFFC6290 00072283		lw		r5,[$sp]
FFFC6294 00472303		lw		r6,4[$sp]
FFFC6298 00872083		lw		$ra,8[$sp]
FFFC629C 00C70713		add		$sp,$sp,#12
FFFC62A0 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC62A4 03906D93		ldi		$t1,#'9'
FFFC62A8 012DF463		bleu	a0,$t1,a2h1; less than '9'
FFFC62AC FF990913		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC62B0 FD090913		sub		a0,a0,#'0'
FFFC62B4 00F97913		and		a0,a0,#15	; make sure a nybble
FFFC62B8 00008067		ret
                        	
                        	GetFilename:
FFFC62BC FFC70713		sub		$sp,$sp,#4
FFFC62C0 00172023		sw		$ra,[$sp]
FFFC62C4 120010EF		call	TSTC
FFFC62C8 00000022		dw		'"'
FFFC62CC 06000863		bra		gfn1
FFFC62D0 000061B3		mov		r3,r0
                        	gfn2:
FFFC62D4 000E4903		lbu		a0,[$t2]		; get text character
FFFC62D8 001E0E13		add		$t2,$t2,#1
FFFC62DC 02206D93		ldi		$t1,#'"'
FFFC62E0 03B90863		beq		a0,$t1,gfn3
FFFC62E4 02090663		beq		a0,r0,gfn3
FFFC62E8 0003F637		sb		a0,FILENAME[r3]
FFFC62EC 6C060613
FFFC62F0 00360633
FFFC62F4 01260023
FFFC62F8 00118193		add		r3,r3,#1
FFFC62FC 04006D93		ldi		$t1,#64
FFFC6300 FDB1EAE3		bltu	r3,$t1,gfn2
FFFC6304 00072083		lw		$ra,[$sp]
FFFC6308 00470713		add		$sp,$sp,#4
FFFC630C 00008067		ret
                        	gfn3:
FFFC6310 02006913		ldi		a0,#' '
FFFC6314 0003F637		sb		a0,FILENAME[r3]
FFFC6318 6C060613
FFFC631C 00360633
FFFC6320 01260023
FFFC6324 00118193		add		r3,r3,#1
FFFC6328 04006D93		ldi		$t1,#64
FFFC632C FFB1E2E3		bltu	r3,$t1,gfn3
FFFC6330 00072083		lw		$ra,[$sp]
FFFC6334 00470713		add		$sp,$sp,#4
FFFC6338 00008067		ret
                        	gfn1:
FFFC633C BE8FF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC6340 F7DFF0EF		call	GetFilename
FFFC6344 00000637		call	AUXIN_INIT
FFFC6348 41C600E7
FFFC634C EA1FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC6350 000019B7		ldi		a1,#$E00
FFFC6354 E0098993
FFFC6358 00000637		call	SDReadSector
FFFC635C 41D600E7
FFFC6360 00190913		add		a0,a0,#1
FFFC6364 000329B7		ldi		a1,#TXTBGN
FFFC6368 80098993
                        	LOAD4:
FFFC636C FFC70713		sub		$sp,$sp,#4
FFFC6370 01272023		sw		a0,[$sp]
FFFC6374 00000637		call	SDReadSector
FFFC6378 41D600E7
FFFC637C 20098993		add		a1,a1,#512
FFFC6380 00072903		lw		a0,[$sp]
FFFC6384 00470713		add		$sp,$sp,#4
FFFC6388 00190913		add		a0,a0,#1
FFFC638C 00032237		ldi		r4,#TXTBGN
FFFC6390 80020213
FFFC6394 00010637		add		r4,r4,#65536
FFFC6398 00060613
FFFC639C 00460233
FFFC63A0 FC49C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC63A4 B8000063		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC63A8 F15FF0EF		call	GetFilename
FFFC63AC 00000637		call	AUXOUT_INIT
FFFC63B0 420600E7
FFFC63B4 0600006F		jmp		SAVE
                        	
FFFC63B8 220000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC63BC 000019B7		ldi		a1,#$E00	; starting address to write
FFFC63C0 E0098993
FFFC63C4 00000637		call	SDWriteSector
FFFC63C8 422600E7
FFFC63CC 00190913		add		a0,a0,#1
FFFC63D0 000329B7		ldi		a1,#TXTBGN
FFFC63D4 80098993
                        	SAVE4:
FFFC63D8 FFC70713		sub		$sp,$sp,#4
FFFC63DC 01272023		sw		a0,[$sp]
FFFC63E0 00000637		call	SDWriteSector
FFFC63E4 422600E7
FFFC63E8 20098993		add		a1,a1,#512
FFFC63EC 00072903		lw		a0,[$sp]
FFFC63F0 00470713		add		$sp,$sp,#4
FFFC63F4 00190913		add		a0,a0,#1
FFFC63F8 00032237		ldi		r4,#TXTBGN
FFFC63FC 80020213
FFFC6400 00010637		add		r4,r4,#65536
FFFC6404 00060613
FFFC6408 00460233
FFFC640C FC49C6E3		blt		a1,r4,SAVE4
FFFC6410 B0000A63		bra		WSTART
                        	
                        	SAVE:
FFFC6414 00032E37		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC6418 800E0E13
FFFC641C 00030637		lw		$t3,TXTUNF	;set pointer to end of prog. area
FFFC6420 00460613
FFFC6424 00060633
FFFC6428 00062E83
                        	SAVE1:
FFFC642C 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC6430 03CEC863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC6434 03A06913		ldi		a0,#':'		; if not, start a line
FFFC6438 9D8FF0EF		call	GOAUXO
FFFC643C 000E2903		lw		a0,[$t2]		; get line number
FFFC6440 004E0E13		add		$t2,$t2,#4
FFFC6444 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC6448 000E4903		lbu		a0,[$t2]		; get a text char.
FFFC644C 001E0E13		add		$t2,$t2,#1
FFFC6450 00D06D93		ldi		$t1,#CR
FFFC6454 FDB90CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC6458 9B8FF0EF		call	GOAUXO		; send it out
FFFC645C FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC6460 04006913		ldi		a0,#'@'		; send end-of-program indicator
FFFC6464 9ACFF0EF		call	GOAUXO
FFFC6468 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC646C 01A06913		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC6470 9A0FF0EF		call	GOAUXO
FFFC6474 00000637		call	AUXOUT_FLUSH
FFFC6478 429600E7
FFFC647C AA000463		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC6480 FFC70713		sub		$sp,$sp,#4
FFFC6484 00172023		sw		$ra,[$sp]
FFFC6488 00D06913	  ldi		a0,#CR
FFFC648C 984FF0EF	  call	GOAUXO
FFFC6490 00A06913	  ldi		a0,#LINEFD
FFFC6494 97CFF0EF	  call	GOAUXO
FFFC6498 00072083	  lw		$ra,[$sp]
FFFC649C 00470713	  add		$sp,$sp,#4
FFFC64A0 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC64A4 FF870713		sub		$sp,$sp,#8
FFFC64A8 00572023		sw		r5,[$sp]
FFFC64AC 00172223		sw		$ra,4[$sp]
FFFC64B0 000302B7		ldi		r5,#NUMWKA+14
FFFC64B4 0A228293
FFFC64B8 00096233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC64BC 00026933	  mov   a0,r4	    ; a0 = value
FFFC64C0 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC64C4 040000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC64C8 01228023	  sb    a0,[r5]		; save in work area
FFFC64CC FFF28293	  sub		r5,r5,#1
FFFC64D0 00030DB7	  ldi		$t1,#NUMWKA
FFFC64D4 094D8D93
FFFC64D8 FFB2D2E3		bge		r5,$t1,pword1
                        	pword2:
FFFC64DC 00128293	  add		r5,r5,#1
FFFC64E0 0002C903	  lbu   a0,[r5]     ; get char to output
FFFC64E4 92CFF0EF		call	GOAUXO		; send it
FFFC64E8 00030DB7		ldi		$t1,#NUMWKA+14
FFFC64EC 0A2D8D93
FFFC64F0 FFB2C6E3		blt		r5,$t1,pword2
FFFC64F4 00072283		lw		r5,[$sp]
FFFC64F8 00472083		lw		$ra,4[$sp]
FFFC64FC 00870713		add		$sp,$sp,#8
FFFC6500 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC6504 00F97913		and		a0,a0,#15	; make sure it's a nybble
FFFC6508 00A06D93		ldi		$t1,#10
FFFC650C 01B94463		blt		a0,$t1,tah1	; > 10 ?
FFFC6510 00790913		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC6514 03090913		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC6518 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC651C 0BC000EF		call	OREXPR		; get the memory address
FFFC6520 6C5000EF		call	TSTC		; it must be followed by a comma
FFFC6524 0000002C		dw		','
FFFC6528 06000C63		bra		PKER
FFFC652C FFC70713		sub		$sp,$sp,#4
FFFC6530 01272023		sw		a0,[$sp]	; save the address
FFFC6534 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC6538 00072983		lw		a1,[$sp]	; get the address back
FFFC653C 00470713		add		$sp,$sp,#4
FFFC6540 01298023		sb		a0,[a1]		; store the byte in memory
FFFC6544 8B5FF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC6548 090000EF		call	OREXPR		; get the memory address
FFFC654C 699000EF		call	TSTC		; it must be followed by a comma
FFFC6550 0000002C		dw		','
FFFC6554 04000663		bra		PKER
FFFC6558 FFC70713		sub		$sp,$sp,#4
FFFC655C 01272023		sw		a0,[$sp]	; save the address
FFFC6560 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC6564 00072983		lw		a1,[$sp]	; get the address back
FFFC6568 00470713		add		$sp,$sp,#4
FFFC656C 0129A023		sw		a0,[a1]		; store the byte in memory
FFFC6570 889FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC6574 064000EF		call	OREXPR		; get the memory address
FFFC6578 66D000EF		call	TSTC		; it must be followed by a comma
FFFC657C 0000002C		dw		','
FFFC6580 02000063		bra		PKER
FFFC6584 FFC70713		sub		$sp,$sp,#4
FFFC6588 01272023		sw		a0,[$sp]	; save the address
FFFC658C 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC6590 00072983		lw		a1,[$sp]	; get the address back
FFFC6594 00470713		add		$sp,$sp,#4
FFFC6598 01299023		sh		a0,[a1]		; store the byte in memory
FFFC659C 85DFF06F		jmp		FINISH
                        	
                        	PKER:
FFFC65A0 FFFC8937		ldi		a0,#msgComma
FFFC65A4 88290913
FFFC65A8 0D10006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC65AC 02C000EF		call	OREXPR		; get the subroutine's address
FFFC65B0 00081863		bne		v0,r0,sysx1; make sure we got a valid address
FFFC65B4 FFFC8937		ldi		a0,#msgSYSBad
FFFC65B8 8D390913
FFFC65BC 0BD0006F		jmp		ERROR
                        	sysx1:
FFFC65C0 FFC70713		sub		$sp,$sp,#4
FFFC65C4 01C72023		stt		$t2,[$sp]	; save the text pointer
FFFC65C8 000800E7		call	[v0]			; jump to the subroutine
FFFC65CC 00072E03		ldt		$t2,[$sp]	; restore the text pointer
FFFC65D0 00470713		add		$sp,$sp,#4
FFFC65D4 825FF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC65D8 FF470713		sub		$sp,$sp,#12
FFFC65DC 00172023		sw		$ra,[$sp]
FFFC65E0 00372223		sw		r3,4[$sp]
FFFC65E4 00472423		sw		r4,8[$sp]
FFFC65E8 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC65EC FF870713		sub		$sp,$sp,#8
FFFC65F0 01072023		sw		$v0,[$sp]		; save <ANDEXPR> value
FFFC65F4 01172223		sw		$v1,4[$sp]	; save type
FFFC65F8 FFFC6EB7		ldi		$t3,#TAB10	; look up a logical operator
FFFC65FC 9E6E8E93
FFFC6600 FFFC6F37		ldi		$t4,#TAB10_1
FFFC6604 A56F0F13
FFFC6608 C68FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC660C 034000EF	  call	ANDEXPR
FFFC6610 00072903	  lw		$a0,[$sp]
FFFC6614 00870713	  add		$sp,$sp,#8
FFFC6618 01286833	  or    v0,v0,a0
FFFC661C FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC6620 00072803	  lw		$v0,[$sp]
FFFC6624 00472883	  lw		$v1,4[$sp]
FFFC6628 00870713	  add		$sp,$sp,#8
FFFC662C 00072083		lw		$ra,[$sp]
FFFC6630 00472183		lw		r3,4[$sp]
FFFC6634 00872203		lw		r4,8[$sp]
FFFC6638 00C70713		add		$sp,$sp,#12
FFFC663C 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC6640 FFC70713		sub		$sp,$sp,#4
FFFC6644 00172023		sw		$ra,[$sp]
FFFC6648 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC664C FF870713		sub		$sp,$sp,#8
FFFC6650 01072023		sw		$v0,[$sp]		; save <EXPR> value
FFFC6654 01172223		sw		$v1,4[$sp]	; save type
FFFC6658 FFFC6EB7		ldi		$t3,#TAB9		; look up a logical operator
FFFC665C 9E2E8E93
FFFC6660 FFFC6F37		ldi		$t4,#TAB9_1
FFFC6664 A52F0F13
FFFC6668 C08FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC666C 0C4000EF	  call	EXPR
FFFC6670 00072903	  lw		$a0,[$sp]
FFFC6674 00870713	  add		$sp,$sp,#8
FFFC6678 01287833	  and   v0,v0,a0
FFFC667C FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC6680 00072803	  lw		$v0,[$sp]
FFFC6684 00472883	  lw		$v1,4[$sp]
FFFC6688 00870713	  add		$sp,$sp,#8
FFFC668C 00072083		lw		$ra,[$sp]
FFFC6690 00470713		add		$sp,$sp,#4
FFFC6694 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC6698 03006D93		ldi		$t1,#'0'
FFFC669C 01B94A63		blt		a0,$t1,isDigitFalse
FFFC66A0 03906D93		ldi		$t1,#'9'
FFFC66A4 012DC663		bgt		a0,$t1,isDigitFalse
FFFC66A8 00106813		ldi		v0,#1
FFFC66AC 00008067	  ret
                        	isDigitFalse:
FFFC66B0 00006833	  mov		v0,r0
FFFC66B4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC66B8 04106D93		ldi		$t1,#'A'
FFFC66BC 03B94263		blt		a0,$t1,isAlphaFalse
FFFC66C0 05A06D93		ldi		$t1,#'Z'
FFFC66C4 012DDA63		ble		a0,$t1,isAlphaTrue
FFFC66C8 06106D93		ldi		$t1,#'a'
FFFC66CC 01B94A63		blt		a0,$t1,isAlphaFalse
FFFC66D0 07A06D93		ldi		$t1,#'z'
FFFC66D4 012DC663		bgt		a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC66D8 00106813	  ldi		v0,#1
FFFC66DC 00008067	  ret
                        	isAlphaFalse:
FFFC66E0 00006833	  mov		v0,r0
FFFC66E4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC66E8 FFC70713		sub		$sp,$sp,#4
FFFC66EC 00172023		sw		$ra,[$sp]
FFFC66F0 FA9FF0EF	  call	isDigit
FFFC66F4 00081463		bne		v0,r0,isDigitx	; if it is a digit
FFFC66F8 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC66FC 00072083		lw		$ra,[$sp]
FFFC6700 00470713		add		$sp,$sp,#4
FFFC6704 00008067	  ret
                        	
                        	FORCEFIT:
FFFC6708 03198263		beq		a1,v1,.0001				; types match
FFFC670C 00006D13		ldi		$t0,#0
FFFC6710 01A98663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$v0
FFFC6714 00106913		ldi		a0,#1
FFFC6718 00008067		ret
                        	.intAnd:
FFFC671C 00106D13		ldi		$t0,#1
FFFC6720 01A89663		bne		$v1,$t0,.0001
                        	;	itof	$f2,$a1
FFFC6724 00106993		ldi		$a1,#1
FFFC6728 00008067		ret
                        	.0001:
FFFC672C 00008067		ret
                        	
                        	EXPR:
FFFC6730 FFC70713		sub		$sp,$sp,#4
FFFC6734 00172023		sw		$ra,[$sp]
FFFC6738 11C000EF		call	ADDEXPR
FFFC673C FF870713		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC6740 01072023		sw		v0,[$sp]
FFFC6744 01172223		sw		v1,4[$sp]					; save type
FFFC6748 FFFC6EB7		ldi		$t3,#TAB8		; look up a relational operator
FFFC674C 9D8E8E93
FFFC6750 FFFC6F37		ldi		$t4,#TAB8_1
FFFC6754 A44F0F13
FFFC6758 B18FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC675C 00072903		lw		a0,[$sp]
FFFC6760 00472983		lw		a1,4[$sp]
FFFC6764 00870713		add		$sp,$sp,#8
FFFC6768 0C4000EF		call	XP18	; is it ">="?
FFFC676C 09095A63		bge		a0,v0,XPRT1	; no, return v0=1
FFFC6770 06000E63		bra		XPRT0	; else return v0=0
                        	XP12:
FFFC6774 00072903		lw		a0,[$sp]
FFFC6778 00472983		lw		a1,4[$sp]
FFFC677C 00870713		add		$sp,$sp,#8
FFFC6780 0AC000EF		call	XP18	; is it "<>"?
FFFC6784 07091E63		bne		a0,v0,XPRT1	; no, return a1=1
FFFC6788 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC678C 00072903		lw		a0,[$sp]
FFFC6790 00472983		lw		a1,4[$sp]
FFFC6794 00870713		add		$sp,$sp,#8
FFFC6798 094000EF		call	XP18	; is it ">"?
FFFC679C 07284263		bgt		a0,v0,XPRT1	; no, return a1=1
FFFC67A0 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC67A4 00072903		lw		a0,[$sp]
FFFC67A8 00472983		lw		a1,4[$sp]
FFFC67AC 00870713		add		$sp,$sp,#8
FFFC67B0 07C000EF		call	XP18	; is it "<="?
FFFC67B4 05285663		ble		a0,v0,XPRT1	; no, return a1=1
FFFC67B8 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC67BC 00072903		lw		a0,[$sp]
FFFC67C0 00472983		lw		a1,4[$sp]
FFFC67C4 00870713		add		$sp,$sp,#8
FFFC67C8 064000EF		call	XP18	; is it "="?
FFFC67CC 03090A63		beq		a0,v0,XPRT1	; if not, return a1=1
FFFC67D0 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC67D4 00072903		lw		a0,[$sp]
FFFC67D8 00472983		lw		a1,4[$sp]
FFFC67DC 00870713		add		$sp,$sp,#8
FFFC67E0 04C000EF		call	XP18	; is it "<"?
FFFC67E4 01094E63		blt		a0,v0,XPRT1	; if not, return a1=1
FFFC67E8 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC67EC 00006833		mov		v0,x0   ; return a0=0 (false)
FFFC67F0 000068B3		mov		v1,x0		; type = int
FFFC67F4 00072083		lw		$ra,[$sp]
FFFC67F8 00470713		add		$sp,$sp,#4
FFFC67FC 00008067		ret
                        	XPRT1:
FFFC6800 00106813		ldi		v0,#1	; return a0=1 (true)
FFFC6804 00006893		ldi		v1,#0	; type = int
FFFC6808 00072083		lw		$ra,[$sp]
FFFC680C 00470713		add		$sp,$sp,#4
FFFC6810 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC6814 00072803		lw		v0,[$sp]; return a1=<ADDEXPR>
FFFC6818 00472883		lw		v1,4[$sp]
FFFC681C 00870713		add		$sp,$sp,#8
FFFC6820 00072083		lw		$ra,[$sp]
FFFC6824 00470713		add		$sp,$sp,#4
FFFC6828 00008067		ret
                        	
                        	XP18:
FFFC682C FF470713		sub		$sp,$sp,#12
FFFC6830 00172023		sw		$ra,[$sp]
FFFC6834 01072223		sw		v0,4[$sp]
FFFC6838 01172423		sw		v1,8[$sp]
FFFC683C 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC6840 00472903		lw		a0,4[$sp]
FFFC6844 00872983		lw		a1,8[$sp]
FFFC6848 00072083		lw		$ra,[$sp]
FFFC684C 00C70713		add		$sp,$sp,#12
FFFC6850 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC6854 FFC70713		sub		$sp,$sp,#4
FFFC6858 00172023		sw		$ra,[$sp]
FFFC685C 389000EF		call	TSTC		; negative sign?
FFFC6860 0000002D		dw		'-'
FFFC6864 00000C63		bra		XP21
FFFC6868 00006833		mov		v0,r0		; yes, fake '0-'
FFFC686C FF870713		sub		$sp,$sp,#8
FFFC6870 01072023		sw		v0,[$sp]
FFFC6874 01172223		sw		v1,4[$sp]
FFFC6878 04000863		bra		XP26
                        	XP21:
FFFC687C 369000EF		call	TSTC		; positive sign? ignore it
FFFC6880 0000002B		dw		'+'
FFFC6884 00000263		bra		XP22
                        	XP22:
FFFC6888 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC688C FF870713		sub		$sp,$sp,#8; yes, save the value
FFFC6890 01072023		sw		v0,[$sp]
FFFC6894 01172223		sw		v1,4[$sp]	; and type
FFFC6898 34D000EF		call	TSTC		; add?
FFFC689C 0000002B		dw		'+'
FFFC68A0 00000E63		bra		XP25
FFFC68A4 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC68A8 00072903		lw		a0,[$sp]
FFFC68AC 00472983		lw		a1,4[$sp]
FFFC68B0 00870713		add		$sp,$sp,#8
FFFC68B4 01280833		add		v0,v0,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC68B8 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC68BC 329000EF		call	TSTC		; subtract?
FFFC68C0 0000002D		dw		'-'
FFFC68C4 00000863		bra		XP45
                        	XP26:
FFFC68C8 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC68CC 41000833		sub		v0,r0,v0	; change its sign
FFFC68D0 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC68D4 00072803		lw		v0,[$sp]
FFFC68D8 00472883		lw		v1,4[$sp]
FFFC68DC 00870713		add		$sp,$sp,#8
FFFC68E0 00072083		lw		$ra,[$sp]
FFFC68E4 00470713		add		$sp,$sp,#4
FFFC68E8 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC68EC FFC70713		sub		$sp,$sp,#4
FFFC68F0 00172023		sw		$ra,[$sp]
FFFC68F4 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC68F8 FF870713		sub		$sp,$sp,#8
FFFC68FC 01072023		sw		v0,[$sp]; yes, save that first result
FFFC6900 01172223		sw		v1,4[$sp]
FFFC6904 2E1000EF		call	TSTC		; multiply?
FFFC6908 0000002A		dw		'*'
FFFC690C 00000E63		bra		XP34
FFFC6910 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC6914 00072903		lw		a0,[$sp]
FFFC6918 00472983		lw		a1,4[$sp]
FFFC691C 00870713		add		$sp,$sp,#8
FFFC6920 03280833		mul		v0,v0,a0	; multiply the two
FFFC6924 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC6928 2BD000EF		call	TSTC		; divide?
FFFC692C 0000002F		dw		'/'
FFFC6930 00000E63		bra		XP35
FFFC6934 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC6938 00072903		lw		a0,[$sp]
FFFC693C 00472983		lw		a1,4[$sp]
FFFC6940 00870713		add		$sp,$sp,#8
FFFC6944 03284833		div		v0,v0,a0	; do the division
FFFC6948 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC694C 299000EF		call	TSTC
FFFC6950 00000025		dw		'%'
FFFC6954 00000E63		bra		XP47
FFFC6958 030000EF		call	FUNCEXPR
FFFC695C 00072903		lw		a0,[$sp]
FFFC6960 00472983		lw		a1,4[$sp]
FFFC6964 00870713		add		$sp,$sp,#8
FFFC6968 03286833		rem		v0,v0,a0
FFFC696C F80006E3		bra		XP31
                        	XP47:
FFFC6970 00072803		lw		v0,[$sp]
FFFC6974 00472883		lw		v1,4[$sp]
FFFC6978 00870713		add		$sp,$sp,#8
FFFC697C 00072083		lw		$ra,[$sp]
FFFC6980 00470713		add		$sp,$sp,#4
FFFC6984 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC6988 FFC70713		sub		$sp,$sp,#4
FFFC698C 00172023		sw		$ra,[$sp]
FFFC6990 FFFC6EB7	  ldi		$t3,#TAB4		; find possible function
FFFC6994 997E8E93
FFFC6998 FFFC6F37	  ldi		$t4,#TAB4_1
FFFC699C A22F0F13
FFFC69A0 8D0FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC69A4 00006933		mov		a0,x0
FFFC69A8 070000EF		call	TSTV
FFFC69AC 00080A63		beq   v0,x0,XP41	; not a variable
FFFC69B0 00082803		lw		$v0,[$v0]		; if a variable, return its value in v0
FFFC69B4 00072083		lw		$ra,[$sp]
FFFC69B8 00470713		add		$sp,$sp,#4
FFFC69BC 00008067		ret
                        	XP41:
FFFC69C0 271000EF		call	TSTNUM		; or is it a number?
FFFC69C4 00089463		bne		v1,x0,XP46	; (if not, # of digits will be zero) if so, return it in v0
FFFC69C8 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC69CC 00072083		lw		$ra,[$sp]
FFFC69D0 00470713		add		$sp,$sp,#4
FFFC69D4 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC69D8 FFC70713		sub		$sp,$sp,#4
FFFC69DC 00172023		sw		$ra,[$sp]	
FFFC69E0 205000EF		call	TSTC		; else look for ( OREXPR )
FFFC69E4 00000028		dw		'('
FFFC69E8 02000063		bra		XP43
FFFC69EC BEDFF0EF		call	OREXPR
FFFC69F0 1F5000EF		call	TSTC
FFFC69F4 00000029		dw		')'
FFFC69F8 00000863		bra		XP43
                        	XP42:
FFFC69FC 00072083		lw		$ra,[$sp]
FFFC6A00 00470713		add		$sp,$sp,#4
FFFC6A04 00008067		ret
                        	XP43:
FFFC6A08 00470713		add		$sp,$sp,#4		; get rid of return address
FFFC6A0C FFFC8937		ldi		a0,#msgWhat
FFFC6A10 80890913
FFFC6A14 4640006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		v0 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC6A18 FF870713		sub		$sp,$sp,#8
FFFC6A1C 00572023		sw		r5,[$sp]
FFFC6A20 00172223		sw		$ra,4[$sp]
FFFC6A24 000962B3		mov		r5,a0		; r5=allocate flag
FFFC6A28 27D000EF		call	IGNBLK
FFFC6A2C 000E4903		lbu		a0,[$t2]		; look at the program text
FFFC6A30 04006D93		ldi		$t1,#'@'
FFFC6A34 07B94863		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC6A38 05B91463		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC6A3C 001E0E13		add		$t2,$t2,#1	; If it is, it should be
FFFC6A40 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC6A44 00000263		bra		TV3
                        	TV3:
FFFC6A48 FFC70713		sub		$sp,$sp,#4	; save the index
FFFC6A4C 01072023		sw		v0,[$sp]
FFFC6A50 300000EF		call	SIZEX		; get amount of free memory
FFFC6A54 00072983		lw		a1,[$sp]
FFFC6A58 00470713		add		$sp,$sp,#4	; get back the index
FFFC6A5C 0109C663		blt		a1,v0,TV2		; see if there's enough memory
FFFC6A60 00870713		add		$sp,$sp,#8
FFFC6A64 4000006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC6A68 00030637		lw		a0,VARBGN	; put address of array element...
FFFC6A6C 00860613
FFFC6A70 00060633
FFFC6A74 00062903
FFFC6A78 41390833		sub   v0,a0,a1    ; into a0 (neg. offset is used)
FFFC6A7C 00000C63		bra   TSTVRT
                        	TV1:	
FFFC6A80 038000EF	  call	getVarName      ; get variable name
FFFC6A84 00080863	  beq   v0,x0,TSTVRT    ; if not, return v0=0
FFFC6A88 00086933	  mov		a0,v0
FFFC6A8C 0002E9B3	  mov		a1,r5
FFFC6A90 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC6A94 00072283		lw		r5,[$sp]
FFFC6A98 00472083		lw		$ra,4[$sp]
FFFC6A9C 00870713		add		$sp,$sp,#8
FFFC6AA0 00008067		ret								; v0<>0 (if found)
                        	tstv_notfound:
FFFC6AA4 00072283		lw		r5,[$sp]
FFFC6AA8 00472083		lw		$ra,4[$sp]
FFFC6AAC 00870713		add		$sp,$sp,#8
FFFC6AB0 00006833		mov		v0,x0				; v0=0 if not found
FFFC6AB4 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   v0 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC6AB8 FF470713		sub		$sp,$sp,#12
FFFC6ABC 00572023		sw		r5,[$sp]
FFFC6AC0 00172223		sw		$ra,4[$sp]
FFFC6AC4 000E4903	  lbu   a0,[$t2]		; get first character
FFFC6AC8 01272423	  sw		a0,8[$sp]		; save off current name
FFFC6ACC BEDFF0EF	  call	isAlpha
FFFC6AD0 08080063	  beq   v0,r0,gvn1
FFFC6AD4 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC6AD8 001E0E13		add		$t2,$t2,#1
FFFC6ADC 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC6AE0 C09FF0EF		call	isAlnum
FFFC6AE4 02080863		beq   v0,x0,gvn2	; nope
FFFC6AE8 00872903		lw		a0,8[$sp]		; get varname
FFFC6AEC 00891913		sll		a0,a0,#8
FFFC6AF0 000E4983		lbu   a1,[$t2]
FFFC6AF4 01396933		or    a0,a0,a1   	; add in new char
FFFC6AF8 01272423	  sw		a0,8[$sp]		; save off current name again
FFFC6AFC FFF28293	  sub		r5,r5,#1
FFFC6B00 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC6B04 001E0E13		add		$t2,$t2,#1
FFFC6B08 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC6B0C BDDFF0EF	  call  isAlnum
FFFC6B10 FE081AE3	  bne   v0,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC6B14 000E4983		lbu   a1,[$t2]
FFFC6B18 02506D93		ldi		$t1,#'%'
FFFC6B1C 01B98A63		beq		a1,$t1,gvn3
FFFC6B20 02406D93		ldi		$t1,#'$'
FFFC6B24 01B98663		beq		a1,$t1,gvn3
FFFC6B28 FFFE0E13	  sub		$t2,$t2,#1
FFFC6B2C 02E06993	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC6B30 001E0E13		add		$t2,$t2,#1
FFFC6B34 00872903		lw		a0,8[$sp]		; get varname
FFFC6B38 00891913		sll		a0,a0,#8
FFFC6B3C 01396833	  or    v0,a0,a1    ; add in variable type
FFFC6B40 00072283	  lw		r5,[$sp]
FFFC6B44 00472083	  lw		$ra,4[$sp]
FFFC6B48 00C70713	  add		$sp,$sp,#12
FFFC6B4C 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC6B50 00072283		lw		r5,[$sp]
FFFC6B54 00472083	  lw		$ra,4[$sp]
FFFC6B58 00C70713		add		$sp,$sp,#12
FFFC6B5C 00006833	  mov		v0,x0       ; return v0 = 0 if not a varname
FFFC6B60 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   v0 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC6B64 FF870713		sub		$sp,$sp,#8
FFFC6B68 00772023		sw		x7,[$sp]
FFFC6B6C 00372223		sw		x3,4[$sp]
FFFC6B70 00030637	  lw    x3,VARBGN
FFFC6B74 00860613
FFFC6B78 00060633
FFFC6B7C 00062183
                        	fv4:
FFFC6B80 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC6B84 02038C63	  beq   x7,x0,fv3		; no more vars ?
FFFC6B88 02790E63	  beq   a0,x7,fv1		; match ?
FFFC6B8C 00818193		add		x3,x3,#8		; move to next var
FFFC6B90 00030637	  lw    x7,VAREND		; 
FFFC6B94 00C60613
FFFC6B98 00060633
FFFC6B9C 00062383
FFFC6BA0 FE71C0E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC6BA4 00072383	  lw		x7,[$sp]
FFFC6BA8 00472183	  lw		x3,4[$sp]
FFFC6BAC 00870713	  add		$sp,$sp,#8
FFFC6BB0 FFFC8937	  ldi		a0,#msgVarSpace
FFFC6BB4 85690913
FFFC6BB8 2C00006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC6BBC 00098E63		beq		a1,x0,fv2
FFFC6BC0 0121A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC6BC4 00418813	  add		v0,x3,#4
FFFC6BC8 00072383	  lw		x7,[$sp]
FFFC6BCC 00472183	  lw		x3,4[$sp]
FFFC6BD0 00870713	  add		$sp,$sp,#8
FFFC6BD4 00008067	  ret			    			; v0 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC6BD8 00072383	  lw		x7,[$sp]
FFFC6BDC 00472183	  lw		x3,4[$sp]
FFFC6BE0 00870713	  add		$sp,$sp,#8
FFFC6BE4 00006833		mov		v0,x0				; v0 = nullptr
FFFC6BE8 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC6BEC DEDFF0EF		call	PARN		; get the memory address
FFFC6BF0 00080803		lb		v0,[v0]		; get the addressed byte
FFFC6BF4 000068B3		mov		v1,x0			; type = int
FFFC6BF8 00072083		lw		$ra,[$sp]
FFFC6BFC 00470713		add		$sp,$sp,#4
FFFC6C00 00008067		ret
                        	PEEKW:
FFFC6C04 DD5FF0EF		call	PARN		; get the memory address
FFFC6C08 00082803		lw		v0,[v0]		; get the addressed word
FFFC6C0C 000068B3		mov		v1,x0			; type = int
FFFC6C10 00072083		lw		$ra,[$sp]
FFFC6C14 00470713		add		$sp,$sp,#4
FFFC6C18 00008067		ret
                        	PEEKH:
FFFC6C1C DBDFF0EF		call	PARN		; get the memory address
FFFC6C20 00081803		lh		v0,[v0]		; get the addressed byte
FFFC6C24 000068B3		mov		v1,x0			; type = int
FFFC6C28 00072083		lw		$ra,[$sp]
FFFC6C2C 00470713		add		$sp,$sp,#4
FFFC6C30 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC6C34 FFC70713		sub		$sp,$sp,#4
FFFC6C38 01A72023		sw		$t0,[$sp]
FFFC6C3C D9DFF0EF		call	PARN		; get expression value
FFFC6C40 00086933		mov		a0,v0
FFFC6C44 0008E9B3		mov		a1,v1
FFFC6C48 FFC70713		sub		$sp,$sp,#4	; save the text pointer
FFFC6C4C 01C72023		sw		$t2,[$sp]
FFFC6C50 00030637		lw		$t0,usrJmp
FFFC6C54 0A060613
FFFC6C58 00060633
FFFC6C5C 00062D03
FFFC6C60 000D00E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC6C64 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC6C68 00470713		add		$sp,$sp,#4
FFFC6C6C 00072D03		lw		$t0,[$sp]
FFFC6C70 00470713		add		$sp,$sp,#4
FFFC6C74 00072083		lw		$ra,[$sp]
FFFC6C78 00470713		add		$sp,$sp,#4
FFFC6C7C 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC6C80 D59FF0EF		call	PARN		; get the upper limit
FFFC6C84 04080063		beq		v0,r0,rnd2	; it must be positive and non-zero
FFFC6C88 02084663		blt		v0,r0,rnd1
FFFC6C8C 000869B3		mov		a1,v0
FFFC6C90 000868B3		mov		v1,v0
FFFC6C94 00000637		call	gen_rand	; generate a random number
FFFC6C98 46E600E7
FFFC6C9C 03186833		rem		v0,v0,v1
FFFC6CA0 00180813		add		v0,v0,#1
FFFC6CA4 000068B3		mov		v1,x0
FFFC6CA8 00072083		lw		$ra,[$sp]
FFFC6CAC 00470713		add		$sp,$sp,#4
FFFC6CB0 00008067		ret
                        	rnd1:
FFFC6CB4 FFFC8937		ldi		a0,#msgRNDBad
FFFC6CB8 8C090913
FFFC6CBC 00470713		add		$sp,$sp,#4
FFFC6CC0 1B80006F		jmp		ERROR
                        	rnd2:
FFFC6CC4 00000637		call	gen_rand	; generate a random number
FFFC6CC8 46E600E7
FFFC6CCC 000068B3		mov		v1,x0
FFFC6CD0 00072083		lw		$ra,[$sp]
FFFC6CD4 00470713		add		$sp,$sp,#4
FFFC6CD8 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC6CDC CFDFF0EF		call	PARN		; get the following expr.'s value
FFFC6CE0 00084863		blt		v0,r0,ABS1
FFFC6CE4 00072083		lw		$ra,[$sp]
FFFC6CE8 00470713		add		$sp,$sp,#4
FFFC6CEC 00008067		ret
                        	ABS1:
FFFC6CF0 41000833		sub		v0,x0,v0
FFFC6CF4 00072083		lw		$ra,[$sp]
FFFC6CF8 00470713		add		$sp,$sp,#4
FFFC6CFC 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC6D00 C0001873		csrrw	v0,#$C00,x0
FFFC6D04 000068B3		mov		v1,x0
FFFC6D08 00072083		lw		$ra,[$sp]
FFFC6D0C 00470713		add		$sp,$sp,#4
FFFC6D10 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC6D14 CC5FF0EF		call	PARN		; get the following expr.'s value
FFFC6D18 000068B3		mov		v1,x0
FFFC6D1C 02080463		beq		v0,r0,SGN1
FFFC6D20 00084A63		blt		v0,r0,SGN2
FFFC6D24 00106813		ldi		v0,#1
FFFC6D28 00072083		lw		$ra,[$sp]
FFFC6D2C 00470713		add		$sp,$sp,#4
FFFC6D30 00008067		ret
                        	SGN2:
FFFC6D34 FFF06813		ldi		v0,#-1
FFFC6D38 00072083		lw		$ra,[$sp]
FFFC6D3C 00470713		add		$sp,$sp,#4
FFFC6D40 00008067		ret
                        	SGN1:
FFFC6D44 00072083		lw		$ra,[$sp]
FFFC6D48 00470713		add		$sp,$sp,#4
FFFC6D4C 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in v0.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC6D50 00030637		lw		v0,VARBGN	; get the number of free bytes...
FFFC6D54 00860613
FFFC6D58 00060633
FFFC6D5C 00062803
FFFC6D60 00030637		lw		v1,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC6D64 00460613
FFFC6D68 00060633
FFFC6D6C 00062883
FFFC6D70 41180833		sub		v0,v0,v1
FFFC6D74 000068B3		mov		v1,x0			; type = int
FFFC6D78 00072083		lw		$ra,[$sp]
FFFC6D7C 00470713		add		$sp,$sp,#4
FFFC6D80 00008067		ret					; return the number in v0
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC6D84 FFC70713		sub		$sp,$sp,#4
FFFC6D88 00172023		sw		$ra,[$sp]
FFFC6D8C 00106913	  ldi		a0,#1		; allocate var
FFFC6D90 C89FF0EF	  call	TSTV		; variable name?
FFFC6D94 00081A63	  bne		v0,x0,.sv2
FFFC6D98 FFFC8937	 	ldi		a0,#msgVar
FFFC6D9C 8AA90913
FFFC6DA0 00470713		add		$sp,$sp,#4
FFFC6DA4 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC6DA8 FFC70713		sub		$sp,$sp,#4
FFFC6DAC 01072023		sw		v0,[$sp]	; save the variable's address
FFFC6DB0 634000EF		call	TSTC			; get past the "=" sign
FFFC6DB4 0000003D		dw		'='
FFFC6DB8 02000663		bra		SV1
FFFC6DBC 81DFF0EF		call	OREXPR		; evaluate the expression
FFFC6DC0 00072983		lw		a1,[$sp]	; get back the variable's address
FFFC6DC4 00470713		add		$sp,$sp,#4
FFFC6DC8 0109A023		sw    v0,[a1]   ; and save value in the variable
FFFC6DCC 0009E833		mov		v0,a1			; return v0 = variable address
FFFC6DD0 FFC9A883		lw		v1,-4[a1]
FFFC6DD4 0FF8F893		and		v1,v1,#$FF
FFFC6DD8 00072083		lw		$ra,[$sp]
FFFC6DDC 00470713		add		$sp,$sp,#4
FFFC6DE0 00008067		ret
                        	SV1:
FFFC6DE4 00470713		add		$sp,$sp,#4
FFFC6DE8 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC6DEC FFC70713		sub		$sp,$sp,#4
FFFC6DF0 00172023		sw		$ra,[$sp]
FFFC6DF4 5F0000EF		call	TSTC		; *** FIN ***
FFFC6DF8 0000003A		dw		':'
FFFC6DFC 00000663		bra		FI1
FFFC6E00 00470713		add		$sp,$sp,#4	; if ":", discard return address
FFFC6E04 E25FE06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC6E08 5DC000EF		call	TSTC		; not ":", is it a CR?
FFFC6E0C 0000000D		dw		CR
FFFC6E10 00000663		bra		FI2
                        							; else return to the caller
FFFC6E14 00470713		add		$sp,$sp,#4	; yes, purge return address
FFFC6E18 D25FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC6E1C 00072083		lw		$ra,[$sp]
FFFC6E20 00470713		add		$sp,$sp,#4
FFFC6E24 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC6E28 FFC70713		sub		$sp,$sp,#4
FFFC6E2C 00172023		sw		$ra,[$sp]
FFFC6E30 674000EF		call	IGNBLK
FFFC6E34 000E4903		lbu		a0,[$t2]
FFFC6E38 00D06D93		ldi		$t1,#CR
FFFC6E3C 01B90863		beq		a0,$t1,ec1	; does it end with a CR?
FFFC6E40 FFFC8937		ldi		a0,#msgExtraChars
FFFC6E44 97B90913
FFFC6E48 0300006F		jmp		ERROR
                        	ec1:
FFFC6E4C 00072083		lw		$ra,[$sp]
FFFC6E50 00470713		add		$sp,$sp,#4
FFFC6E54 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC6E58 FFFC8937		ldi		a0,#msgTooBig
FFFC6E5C 96790913
FFFC6E60 00000C63		bra		ERROR
                        	QSORRY:
FFFC6E64 FFFC8937	  ldi		a0,#SRYMSG
FFFC6E68 80F90913
FFFC6E6C 00000663		bra	    ERROR
                        	QWHAT:
FFFC6E70 FFFC8937		ldi		a0,#msgWhat
FFFC6E74 80890913
                        	ERROR:
FFFC6E78 710000EF		call	PRMESG		; display the error message
FFFC6E7C 00030637		lw		a0,CURRNT	; get the current line pointer
FFFC6E80 01860613
FFFC6E84 00060633
FFFC6E88 00062903
FFFC6E8C 04090263		beq		a0,r0,ERROR1	; if zero, do a warm start
FFFC6E90 FFF06D93		ldi		$t1,#-1
FFFC6E94 A1B90663		beq		a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC6E98 000E4283		lbu		r5,[$t2]		; save the char. pointed to
FFFC6E9C 000E0023		sb		x0,[$t2]		; put a zero where the error is
FFFC6EA0 00030637		lw		a0,CURRNT	; point to start of current line
FFFC6EA4 01860613
FFFC6EA8 00060633
FFFC6EAC 00062903
FFFC6EB0 4D8000EF		call	PRTLN		; display the line in error up to the 0
FFFC6EB4 00096333		mov     r6,a0	    ; save off end pointer
FFFC6EB8 005E0023		sb		r5,[$t2]		; restore the character
FFFC6EBC 03F06913		ldi		a0,#'?'		; display a "?"
FFFC6EC0 F48FE0EF		call	GOOUT
FFFC6EC4 000069B3		mov		a1,r0		; stop char = 0
FFFC6EC8 FFF30913		sub		a0,r6,#1	; point back to the error char.
FFFC6ECC 2E4000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC6ED0 855FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC6ED4 FF870713		sub		$sp,$sp,#8
FFFC6ED8 00572023		sw		r5,[$sp]
FFFC6EDC 00172223		sw		$ra,4[$sp]
FFFC6EE0 F28FE0EF		call	GOOUT		; display the prompt
FFFC6EE4 00106913		ldi		a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC6EE8 02006913		ldi		a0,#' '		; and a space
FFFC6EEC F1CFE0EF		call	GOOUT
FFFC6EF0 00030E37		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
FFFC6EF4 01CE0E13
                        	.GL1:
FFFC6EF8 660000EF		call	CHKIO		; check keyboard
FFFC6EFC FE080EE3		beq		v0,x0,.GL1	; wait for a char. to come in
FFFC6F00 00806D93		ldi		$t1,#CTRLH
FFFC6F04 05B80863		beq		v0,$t1,.GL3	; delete last character? if so
FFFC6F08 01806D93		ldi		$t1,#CTRLX
FFFC6F0C 07B80A63		beq		v0,$t1,.GL4	; delete the whole line?
FFFC6F10 00D06D93		ldi		$t1,#CR
FFFC6F14 01B80663		beq		v0,$t1,.GL2		; accept a CR
FFFC6F18 02006D93		ldi		$t1,#' '
FFFC6F1C FDB84EE3		blt		v0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC6F20 010E0023		sb		v0,[$t2]		; save the char.
FFFC6F24 001E0E13		add		$t2,$t2,#1
FFFC6F28 FFC70713		sub		$sp,$sp,#4
FFFC6F2C 01072023		sw		v0,[$sp]
FFFC6F30 00086933		mov		$a0,$v0
FFFC6F34 ED4FE0EF		call	GOOUT		; echo the char back out
FFFC6F38 00072803		lw		v0,[$sp]; get char back (GOOUT destroys a0)
FFFC6F3C 00470713		add		$sp,$sp,#4
FFFC6F40 00D06D93		ldi		$t1,#CR
FFFC6F44 09B80063		beq		v0,$t1,.GL7			; if it's a CR, end the line
FFFC6F48 00030DB7		ldi		$t1,#BUFFER+BUFLEN-1
FFFC6F4C 06FD8D93
FFFC6F50 FBBE44E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC6F54 00806913		ldi		a0,#CTRLH	; delete a char. if possible
FFFC6F58 EB0FE0EF		call	GOOUT
FFFC6F5C 02006913		ldi		a0,#' '
FFFC6F60 EA8FE0EF		call	GOOUT
FFFC6F64 00030DB7		ldi		$t1,#BUFFER
FFFC6F68 01CD8D93
FFFC6F6C F9CDD6E3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC6F70 00806913		ldi		a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC6F74 E94FE0EF		call	GOOUT
FFFC6F78 FFFE0E13		sub		$t2,$t2,#1	; decrement the text pointer
FFFC6F7C F6000EE3		bra		.GL1		; back for more
                        	.GL4:
FFFC6F80 000E6933		mov		a0,$t2		; delete the whole line
FFFC6F84 FFFD0637		sub		r5,a0,#BUFFER   ; figure out how many backspaces we need
FFFC6F88 FE460613
FFFC6F8C 412602B3
FFFC6F90 02028463		beq		r5,r0,.GL6		; if none needed, brnch
FFFC6F94 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC6F98 00806913		ldi		a0,#CTRLH		; and display BS-space-BS sequences
FFFC6F9C E6CFE0EF		call	GOOUT
FFFC6FA0 02006913		ldi		a0,#' '
FFFC6FA4 E64FE0EF		call	GOOUT
FFFC6FA8 00806913		ldi		a0,#CTRLH
FFFC6FAC E5CFE0EF		call	GOOUT
FFFC6FB0 FFF28293		sub		r5,r5,#1
FFFC6FB4 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC6FB8 00030E37		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC6FBC 01CE0E13
FFFC6FC0 F2000CE3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC6FC4 000E0023		sb		x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC6FC8 00A06913		ldi		a0,#LINEFD	; echo a LF for the CR
FFFC6FCC E3CFE0EF		call	GOOUT
FFFC6FD0 00072283		lw		r5,[$sp]
FFFC6FD4 00472083		lw		$ra,4[$sp]
FFFC6FD8 00870713		add		$sp,$sp,#8
FFFC6FDC 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $v0 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $v0 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $v0 = 0.
                        	; $v0=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; 'FNDSKP' uses $t3 to find a CR, and then starts the search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC6FE0 00100DB7		ldi		$t1,#$FFFFF
FFFC6FE4 FFFD8D93
FFFC6FE8 01B94863		blt		a0,$t1,fl1	; line no. must be < 65535
FFFC6FEC FFFC8937		ldi		a0,#msgLineRange
FFFC6FF0 89590913
FFFC6FF4 E85FF06F		jmp		ERROR
                        	fl1:
FFFC6FF8 00032EB7		ldi		$t3,#TXTBGN	; init. the text save pointer
FFFC6FFC 800E8E93
                        	
                        	FNDLNP:
FFFC7000 00030637		lw		$t4,TXTUNF	; check if we passed the end
FFFC7004 00460613
FFFC7008 00060633
FFFC700C 00062F03
FFFC7010 05EEF463		bgeu	$t3,$t4,FNDRET1; if so, return with r9=0,a0=0
FFFC7014 FF870713		sub		$sp,$sp,#8	; push a0
FFFC7018 01272023		sw		a0,[$sp]
FFFC701C 00172223		sw		ra,4[$sp]
FFFC7020 000EE933		mov		a0,t3
FFFC7024 338000EF		call	LoadWord		; get line number
FFFC7028 00072903		lw		a0,[$sp]		; pop a0
FFFC702C 00472083		lw		ra,4[$sp]
FFFC7030 00870713		add		$sp,$sp,#8
FFFC7034 03280663		beq		v0,a0,FNDRET2
FFFC7038 03286863		bltu	v0,a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET:
FFFC703C 004E8E93		add		$t3,$t3,#4	; find the next line, skip over line number
                        	.0001:
FFFC7040 000EC883		lbu		v1,[$t3]
FFFC7044 001E8E93		add		$t3,$t3,#1
FFFC7048 00D06D93		ldi		$t1,#CR
FFFC704C FFB89AE3		bne		v1,$t1,.0001	; try to find a CR, keep looking
FFFC7050 00006833		mov		v0,x0	; line not found, but $t3=next line pointer
FFFC7054 00008067		ret
                        	FNDRET1:
                        	;	eor		r9,r9,r9	; no higher line
FFFC7058 00006833		mov		v0,x0	; line not found
FFFC705C 00008067		ret
                        	FNDRET2:
FFFC7060 00106813		ldi		v0,#1	; line found
FFFC7064 00008067		ret
                        	
                        	FNDNXT:
FFFC7068 004E8E93		add		$t3,$t3,#4	; find the next line
                        	
                        	FNDSKP:
FFFC706C 000EC883		lbu		v1,[$t3]
FFFC7070 001E8E93		add		$t3,$t3,#1
FFFC7074 00D06D93		ldi		$t1,#CR
FFFC7078 FFB89AE3		bne		v1,$t1,FNDSKP	; try to find a CR, keep looking
FFFC707C F80002E3		bra		FNDLNP		; check if end of text
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC7080 00090203		lb		r4,[a0]
FFFC7084 00498023		sb		r4,[a1]
FFFC7088 00190913		add		a0,a0,#1
FFFC708C 00198993		add		a1,a1,#1
                        	MVUP:
FFFC7090 FF4918E3		bne		a0,a2,MVUP1
FFFC7094 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC7098 FFF90913		sub		a0,a0,#1
FFFC709C FFF98993		sub		a1,a1,#1
FFFC70A0 00090203		lb		r4,[a0]
FFFC70A4 00498023		sb		r4,[a1]
                        	MVDOWN:
FFFC70A8 FF4918E3		bne		a0,a2,MVDOWN1
FFFC70AC 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC70B0 00072903		lw		a0,[$sp]
FFFC70B4 00470713		add		$sp,$sp,#4
FFFC70B8 00030637		sw		a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC70BC 01060613
FFFC70C0 00060633
FFFC70C4 01262023
FFFC70C8 04090C63		beq		a0,x0,PP1
FFFC70CC 00072903		lw		a0,[$sp]
FFFC70D0 00030637		sw		a0,LOPPT
FFFC70D4 07060613
FFFC70D8 00060633
FFFC70DC 01262023
FFFC70E0 00472903		lw		a0,4[$sp]
FFFC70E4 00030637		sw		a0,LOPLN
FFFC70E8 07460613
FFFC70EC 00060633
FFFC70F0 01262023
FFFC70F4 00872903		lw		a0,8[$sp]
FFFC70F8 00030637		sw		a0,LOPLMT
FFFC70FC 07C60613
FFFC7100 00060633
FFFC7104 01262023
FFFC7108 00C72903		lw		a0,12[$sp]
FFFC710C 00030637		sw		a0,LOPINC
FFFC7110 07860613
FFFC7114 00060633
FFFC7118 01262023
FFFC711C 01070713		add		$sp,$sp,#16
                        	PP1:
FFFC7120 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC7124 00030637		lw		a0,STKBOT	; Are we running out of stack room?
FFFC7128 09C60613
FFFC712C 00060633
FFFC7130 00062903
FFFC7134 01490913		add		a0,a0,#20	; we might need this many bytes
FFFC7138 D32746E3		blt		$sp,a0,QSORRY	; out of stack space
FFFC713C 00030637		lw		a1,LOPVAR		; save loop variables
FFFC7140 01060613
FFFC7144 00060633
FFFC7148 00062983
FFFC714C 04098C63		beq		a1,x0,PU1		; if LOPVAR is zero, that's all
FFFC7150 FF070713		sub		$sp,$sp,#16
FFFC7154 00030637		lw		a0,LOPPT
FFFC7158 07060613
FFFC715C 00060633
FFFC7160 00062903
FFFC7164 01272023		sw		a0,[$sp]
FFFC7168 00030637		lw		a0,LOPLN
FFFC716C 07460613
FFFC7170 00060633
FFFC7174 00062903
FFFC7178 01272223		sw		a0,4[$sp]
FFFC717C 00030637		lw		a0,LOPLMT
FFFC7180 07C60613
FFFC7184 00060633
FFFC7188 00062903
FFFC718C 01272423		sw		a0,8[$sp]
FFFC7190 00030637		lw		a0,LOPINC
FFFC7194 07860613
FFFC7198 00060633
FFFC719C 00062903
FFFC71A0 01272623		sw		a0,12[$sp]
                        	PU1:
FFFC71A4 FFC70713		sub		$sp,$sp,#4
FFFC71A8 01372023		sw		a1,[$sp]
FFFC71AC 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return v0 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC71B0 FEC70713		sub		$sp,$sp,#20
FFFC71B4 00572023		sw		r5,[$sp]
FFFC71B8 00672223		sw		r6,4[$sp]
FFFC71BC 00772423		sw		r7,8[$sp]
FFFC71C0 00172623		sw		$ra,12[$sp]
FFFC71C4 01272823		sw		$a0,16[$sp]
FFFC71C8 000962B3		mov   r5,a0	    ; r5 = pointer
FFFC71CC 0009E333		mov   r6,a1	    ; r6 = stop char
                        	.PS1:
FFFC71D0 0002C383	  lbu   r7,[r5]     ; get a text character
FFFC71D4 00128293		add		r5,r5,#1
FFFC71D8 00638E63		beq	  r7,r6,.PRTRET	; same as stop character? if so, return
FFFC71DC 0003E933		mov   a0,r7
FFFC71E0 C28FE0EF		call	GOOUT		; display the char.
FFFC71E4 00D06D93		ldi		$t1,#CR
FFFC71E8 FFB394E3		bne   r7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC71EC 00A06913		ldi		a0,#LINEFD  ; yes, add a L.F.
FFFC71F0 C18FE0EF		call	GOOUT
                        	.PRTRET:
FFFC71F4 0003E8B3	  mov   v1,r7	    ; return a1 = stop char
FFFC71F8 0002E833		mov		v0,r5		; return a0 = line pointer
FFFC71FC 00072283		lw		$r5,[$sp]
FFFC7200 00472303		lw		$r6,4[$sp]
FFFC7204 00872383		lw		$r7,8[$sp]
FFFC7208 00C72083		lw		$ra,12[$sp]
FFFC720C 01072903		lw		$a0,16[$sp]
FFFC7210 01470713		add		$sp,$sp,#20
FFFC7214 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC7218 FFC70713		sub		$sp,$sp,#4
FFFC721C 00172023		sw		$ra,[$sp]
FFFC7220 1C4000EF		call	TSTC		; *** QTSTG ***
FFFC7224 00000022		dw		'"'
FFFC7228 02000063		bra		QT3
FFFC722C 02206993		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC7230 000E6933		mov		a0,$t2
FFFC7234 F7DFF0EF		call	PRTSTG		; print until another
FFFC7238 00086E33		mov		$t2,v0
FFFC723C 00D06D93		ldi		$t1,#CR
FFFC7240 03B89863		bne		v1,$t1,QT2	; was last one a CR?
FFFC7244 8F9FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC7248 19C000EF		call	TSTC		; is it a single quote?
FFFC724C 0000005C		dw		'\''
FFFC7250 00000663		bra		QT4
FFFC7254 02706993		ldi		a1,#'\''	; if so, do same as above
FFFC7258 FC000CE3		bra		QT1
                        	QT4:
FFFC725C 188000EF		call	TSTC		; is it an underline?
FFFC7260 0000005F		dw		'_'
FFFC7264 00000C63		bra		QT5
FFFC7268 00D06913		ldi		a0,#CR		; if so, output a CR without LF
FFFC726C B9CFE0EF		call	GOOUT
                        	QT2:
FFFC7270 00072083		lw		$ra,[$sp]		; get return address
FFFC7274 00470713		add		$sp,$sp,#4
FFFC7278 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC727C 00072083		lw		$ra,[$sp]		; get return address
FFFC7280 00470713		add		$sp,$sp,#4
FFFC7284 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC7288 FFC70713		sub		$sp,$sp,#4
FFFC728C 00172023		sw		$ra,[$sp]
FFFC7290 00D06913		ldi		a0,#CR
FFFC7294 B74FE0EF		call	GOOUT
FFFC7298 00A06913		ldi		a0,#LINEFD
FFFC729C B6CFE0EF		call	GOOUT
FFFC72A0 00072083		lw		$ra,[$sp]
FFFC72A4 00470713		add		$sp,$sp,#4
FFFC72A8 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
                        	
FFFC72AC FEC70713	public _prtnum:
public PRTNUM:
	sub		$sp,$sp,#20
FFFC72B0 00472023		sw		$s1,[$sp]
FFFC72B4 00572223		sw		$s2,4[$sp]
FFFC72B8 00672423		sw		$s3,8[$sp]
FFFC72BC 00772623		sw		$s4,12[$sp]
FFFC72C0 00172823		sw		$ra,16[$sp]
FFFC72C4 000303B7		ldi		s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC72C8 09438393
FFFC72CC 00096333		mov		s3,a0		; save number for later
FFFC72D0 0009E2B3		mov		s2,a1		; s2 = min number of chars
FFFC72D4 00095663		bge		a0,x0,.PN2	; is it negative? if not
FFFC72D8 41200933		sub		a0,x0,a0	; else make it positive
FFFC72DC FFF28293		sub		s2,s2,#1	; one less for width count
                        	.PN2:
FFFC72E0 00A06D93		ldi		$t1,#10
                        	.PN1:
FFFC72E4 034969B3		rem		a1,a0,a2	; a1 = a0 mod 10
FFFC72E8 03494933		div		a0,a0,a2	; a0 /= 10 divide by 10
FFFC72EC 013A7463		bleu	a1,a2,.PN7
FFFC72F0 00798993		add		a1,a1,#'A'-10-'0'
                        	.PN7:
FFFC72F4 03098993		add		a1,a1,#'0'	; convert remainder to ascii
FFFC72F8 01338023		sb		a1,[$s4]		; and store in buffer
FFFC72FC 00138393		add		s4,s4,#1
FFFC7300 FFF28293		sub		s2,s2,#1	; decrement width
FFFC7304 FE0910E3		bne		a0,x0,.PN1
FFFC7308 00505A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC730C 02006913		ldi		$a0,#' '		; display the required leading spaces
FFFC7310 AF8FE0EF		call	GOOUT
FFFC7314 FFF28293		sub		$s2,$s2,#1
FFFC7318 FE504AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC731C 00035663		bge		$s3,$x0,.PN5	; is number negative?
FFFC7320 02D06913		ldi		$a0,#'-'		; if so, display the sign
FFFC7324 AE4FE0EF		call	GOOUT
                        	.PN5:
FFFC7328 00030DB7		ldi		$t1,#NUMWKA
FFFC732C 094D8D93
                        	.PN6:
FFFC7330 FFF38393		sub		$s4,$s4,#1
FFFC7334 0003C903		lbu		$a0,[$s4]		; now unstack the digits and display
FFFC7338 AD0FE0EF		call	GOOUT
FFFC733C FE7DEAE3		bgtu	$s4,$t1,.PN6
                        	
FFFC7340 00072203		lw		$s1,[$sp]
FFFC7344 00472283		lw		$s2,4[$sp]
FFFC7348 00872303		lw		$s3,8[$sp]
FFFC734C 00C72383		lw		$s4,12[$sp]
FFFC7350 01072083		lw		$ra,16[$sp]
FFFC7354 01470713		add		$sp,$sp,#20
FFFC7358 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		v0 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC735C 00094803	  lbu		$v0,[$a0]	
FFFC7360 00194883	  lbu		$v1,1[$a0]
FFFC7364 00889893	  sll		$v1,$v1,#8
FFFC7368 01186833	  or		$v0,$v0,$v1
FFFC736C 00294883	  lbu		$v1,2[$a0]
FFFC7370 01089893	  sll		$v1,$v1,#16
FFFC7374 01186833	  or		$v0,$v0,$v1
FFFC7378 00394883	  lbu		$v1,3[$a0]
FFFC737C 01889893	  sll		$v1,$v1,#24
FFFC7380 01186833	  or		$v0,$v0,$v1
FFFC7384 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = pointer to line
                        	; Returns:
                        	;		v0 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC7388 FF070713		sub		$sp,$sp,#16
FFFC738C 00572023		sw		$r5,[$sp]
FFFC7390 00172223		sw		$ra,4[$sp]
FFFC7394 01272423		sw		$a0,8[$sp]
FFFC7398 01372623		sw		$a1,12[$sp]
FFFC739C 000962B3	  mov		$r5,$a0		; r5 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
FFFC73A0 FBDFF0EF	  call	LoadWord
FFFC73A4 00086933	  mov		a0,v0
                        	
FFFC73A8 00428293		add		r5,r5,#4
FFFC73AC 00506993	  ldi		a1,#5       ; display a 0 or more digit line no.
FFFC73B0 00A06A13	  ldi		a2,#10
FFFC73B4 EF9FF0EF		call	PRTNUM
FFFC73B8 02006913		ldi		a0,#' '     ; followed by a blank
FFFC73BC A4CFE0EF		call	GOOUT
FFFC73C0 000069B3		mov		a1,r0       ; stop char. is a zero
FFFC73C4 0002E933		mov		a0,r5
FFFC73C8 DE9FF0EF		call  PRTSTG		; display the rest of the line
FFFC73CC 00072283		lw		$r5,[$sp]
FFFC73D0 00472083		lw		$ra,4[$sp]
FFFC73D4 00872903		lw		$a0,8[$sp]
FFFC73D8 00C72983		lw		$a1,12[$sp]
FFFC73DC 01070713		add		$sp,$sp,#16
FFFC73E0 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC73E4 FF470713		sub		$sp,$sp,#12
FFFC73E8 01272023		sw		$a0,[$sp]
FFFC73EC 00172223		sw		$ra,4[$sp]
FFFC73F0 01372423		sw		$a1,8[$sp]
FFFC73F4 0B0000EF		call	IGNBLK		; ignore leading blanks
FFFC73F8 00472083		lw		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC73FC 000E4903		lbu		$a0,[$t2]
FFFC7400 0000C983		lbu		$a1,[$ra]
FFFC7404 01298A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC7408 00072903		lw		$a0,[$sp]		; restore a0
FFFC740C 00872983		lw		$a1,8[$sp]
FFFC7410 00C70713		add		$sp,$sp,#12	;
FFFC7414 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC7418 001E0E13		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC741C 00072903		lw		$a0,[$sp]
FFFC7420 00472083		lw		$ra,4[$sp]
FFFC7424 00872983		lw		$a1,8[$sp]
FFFC7428 00C70713		add		$sp,$sp,#12
FFFC742C 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $v0 and the number of digits in $v1,
                        	;	else return zero in $v0 and $v1.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	v0 = number
                        	;		v1 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC7430 FF870713		sub		$sp,$sp,#8
FFFC7434 00172223		sw		$ra,4[$sp]
FFFC7438 00372023		sw		r3,[$sp]
FFFC743C 068000EF		call	IGNBLK		; skip over blanks
FFFC7440 00006833		mov		$v0,$x0		; initialize return parameters
FFFC7444 000068B3		mov		$v1,$x0
                        	TN1:
FFFC7448 000E4183		lbu		r3,[$t2]
FFFC744C 03006D93		ldi		$t1,#'0'
FFFC7450 05B1C263		blt		r3,$t1,TSNMRET; is it less than zero?
FFFC7454 03906D93		ldi		$t1,#'9'
FFFC7458 023DCE63		bgt		r3,$t1,TSNMRET; is it greater than nine?
FFFC745C 00000DB7		ldi		$t1,#$7FFFFFFFFFFFFFF
FFFC7460 FFFD8D93
FFFC7464 010DF863		bleu	$v0,$t1,TN2; see if there's room for new digit
FFFC7468 FFFC8937		ldi		$a0,#msgNumTooBig
FFFC746C 83190913
FFFC7470 A09FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC7474 001E0E13		add		$t2,$t2,#1	; adjust text pointer
FFFC7478 00181E93		sll		$t3,$v0,#1	; quickly multiply result by 10
FFFC747C 00381813		sll		$v0,$v0,#3	; *8
FFFC7480 01D80833		add		$v0,$v0,$t3	; *8 + *2
FFFC7484 00F1F193		and		r3,r3,#$0F	; add in the new digit
FFFC7488 00380833		add		$v0,$v0,r3
FFFC748C 00188893		add		$v1,$v1,#1	; increment the no. of digits
FFFC7490 FA000CE3		bra		TN1
                        	TSNMRET:
FFFC7494 00072183		lw		r3,[$sp]
FFFC7498 00472083		lw		$ra,4[$sp]
FFFC749C 00870713		add		$sp,$sp,#8
FFFC74A0 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC74A4 FFC70713		sub		$sp,$sp,#4
FFFC74A8 01272023		sw		$a0,[$sp]
                        	IGB2:
FFFC74AC 000E4903		lbu		a0,[$t2]			; get char
FFFC74B0 02006D93		ldi		$t1,#' '
FFFC74B4 01B90663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC74B8 00906D93		ldi		$t1,#'\t'
FFFC74BC 01B91663		bne		a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC74C0 001E0E13		add		$t2,$t2,#1		; increment the text pointer
FFFC74C4 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC74C8 00072903		lw		$a0,[$sp]
FFFC74CC 00470713		add		$sp,$sp,#4
FFFC74D0 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC74D4 FFC70713		sub		$sp,$sp,#4
FFFC74D8 00172023		sw		$ra,[$sp]
FFFC74DC 00030E37		ldi		$t2,#BUFFER	; set up text pointer
FFFC74E0 01CE0E13
FFFC74E4 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC74E8 000E4903		lbu		a0,[$t2]		; get the next text char.
FFFC74EC 001E0E13		add		$t2,$t2,#1
FFFC74F0 00D06D93		ldi		$t1,#CR
FFFC74F4 03B90E63		beq		a0,$t1,TOUPBRT		; is it end of line?
FFFC74F8 02206D93		ldi		$t1,#'"'
FFFC74FC 01B90E63		beq		a0,$t1,DOQUO	; a double quote?
FFFC7500 02706D93		ldi		$t1,#'\''
FFFC7504 01B90A63		beq		a0,$t1,DOQUO	; or a single quote?
FFFC7508 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC750C 030000EF		call	toUpper 	; convert to upper case
FFFC7510 FF0E0FA3		sb		v0,-1[$t2]	; store it
FFFC7514 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC7518 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC751C 000961B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC7520 FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC7524 FD2192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC7528 000061B3		mov		r3,r0		; else clear quote flag
FFFC752C FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC7530 00072083		lw		$ra,[$sp]
FFFC7534 00470713		add		$sp,$sp,#4
FFFC7538 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	toUpper:
FFFC753C 00096833		mov		$v0,$a0
FFFC7540 06182D93		slt		$t1,$v0,#'a'
FFFC7544 000D9863		bne   $t1,$x0,TOUPRET	; is it < 'a'?
FFFC7548 07A06D93		ldi		$t1,#'z'
FFFC754C 010DC463		bgt		$v0,$t1,TOUPRET	; or > 'z'?
FFFC7550 FE080813		sub		$v0,$v0,#32	  ; if not, make it upper case
                        	TOUPRET:
FFFC7554 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC7558 FFC70713		sub		$sp,$sp,#4
FFFC755C 00172023		sw		$ra,[$sp]
FFFC7560 228000EF		call	INCH		; get input if possible
FFFC7564 00080863		beq		$v0,$x0,CHKRET	; if Zero, no input
FFFC7568 00384893		xor		$v1,$v0,#CTRLC
FFFC756C 00089463		bne		$v1,$x0,CHKRET; is it control-C?
FFFC7570 9B4FE06F		jmp		WSTART		; if so, do a warm start
                        	CHKRET:
FFFC7574 00072083		lw		$ra,[$sp]
FFFC7578 00470713		add		$sp,$sp,#4
FFFC757C 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC7580 FFFC8937		ldi		a0,#CLMSG
FFFC7584 81590913
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC7588 FFC70713		sub		$sp,$sp,#4
FFFC758C 00172023		sw		$ra,[$sp]
FFFC7590 BC0F90EF		call	PutString
FFFC7594 00072083		lw		$ra,[$sp]
FFFC7598 00470713		add		$sp,$sp,#4
FFFC759C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC75A0 E45FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC75A4 00000028		dw		'('
FFFC75A8 04000E63		bra		.paren
FFFC75AC 00106913		ldi		a0,#1
FFFC75B0 C68FF0EF		call	TSTV
FFFC75B4 00081863		bne		v0,x0,.0001
FFFC75B8 FFFC8937		ldi		a0,#msgVar
FFFC75BC 8AA90913
FFFC75C0 8B9FF06F		jmp		ERROR
                        	.0001:
FFFC75C4 E21FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC75C8 00000029		dw		')'
FFFC75CC 02000C63		bra		.paren
FFFC75D0 00086233		mov		s1,v0
FFFC75D4 00E06913		ldi		a0,#14			; get current tid
FFFC75D8 00000073		ecall
FFFC75DC 0008E9B3		mov		a1,v1
FFFC75E0 00026A33		mov		a2,s1
FFFC75E4 00606913		ldi		a0,#6
FFFC75E8 00000073		ecall
FFFC75EC 00081463		bne		v0,x0,.0002
FFFC75F0 01122023		sw		v1,[s1]				; save handle in variable
                        	.0002:
FFFC75F4 000068B3		mov		v1,x0
FFFC75F8 00072083		lw		$ra,[$sp]
FFFC75FC 00470713		add		$sp,$sp,#4
FFFC7600 00008067		ret
                        	.paren:
FFFC7604 FFFC8937		ldi		a0,#msgParen
FFFC7608 9B790913
FFFC760C 86DFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC7610 DD5FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC7614 00000028		dw		'('
FFFC7618 08000463		bra		.paren
FFFC761C FBDFE0EF		call	OREXPR	; get the mailbox handle
FFFC7620 00086233		mov		s1,v0
FFFC7624 DC1FF0EF		call	TSTC		; it must be followed by a comma
FFFC7628 0000002C		dw		','
FFFC762C 06000463		bra		.err
FFFC7630 FA9FE0EF		call	OREXPR	; get the memory address
FFFC7634 000862B3		mov		s2,v0
FFFC7638 DADFF0EF		call	TSTC		; it must be followed by a comma
FFFC763C 0000002C		dw		','
FFFC7640 04000A63		bra		.err
FFFC7644 F95FE0EF		call	OREXPR	; get the memory address
FFFC7648 00086333		mov		s3,v0
FFFC764C D99FF0EF		call	TSTC		; it must be followed by a comma
FFFC7650 0000002C		dw		','
FFFC7654 04000063		bra		.err
FFFC7658 F81FE0EF		call	OREXPR	; get the memory address
FFFC765C 000863B3		mov		s4,v0
FFFC7660 D85FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC7664 00000029		dw		')'
FFFC7668 02000C63		bra		.paren
FFFC766C 00906913		ldi		a0,#9		; SendMsg
FFFC7670 000269B3		mov		a1,s1
FFFC7674 0002EA33		mov		a2,s2
FFFC7678 00036AB3		mov		a3,s3
FFFC767C 0003EB33		mov		a4,s4
FFFC7680 00000073		ecall
FFFC7684 000068B3		mov		v1,x0
FFFC7688 00072083		lw		$ra,[$sp]
FFFC768C 00470713		add		$sp,$sp,#4
FFFC7690 00008067		ret
                        	.err:
FFFC7694 FFFC8937		ldi		a0,#msgComma
FFFC7698 88290913
FFFC769C FDCFF06F		jmp		ERROR
                        	.paren:
FFFC76A0 FFFC8937		ldi		a0,#msgParen
FFFC76A4 9B790913
FFFC76A8 FD0FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC76AC D39FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC76B0 00000028		dw		'('
FFFC76B4 0C000263		bra		.paren
FFFC76B8 F21FE0EF		call	OREXPR	; get the mailbox handle
FFFC76BC 00086233		mov		s1,v0
FFFC76C0 D25FF0EF		call	TSTC		; it must be followed by a comma
FFFC76C4 0000002C		dw		','
FFFC76C8 0A000263		bra		.err
FFFC76CC 00106913		ldi		a0,#1
FFFC76D0 B48FF0EF		call	TSTV
FFFC76D4 00081863		bne		v0,x0,.0001
                        	.0002:
FFFC76D8 FFFC8937		ldi		a0,#msgVar
FFFC76DC 8AA90913
FFFC76E0 F98FF06F		jmp		ERROR
                        	.0001:
FFFC76E4 D01FF0EF		call	TSTC		; it must be followed by a comma
FFFC76E8 0000002C		dw		','
FFFC76EC 08000063		bra		.err
FFFC76F0 000862B3		mov		s2,v0
FFFC76F4 00106913		ldi		a0,#1
FFFC76F8 B20FF0EF		call	TSTV
FFFC76FC FC080EE3		beq		v0,x0,.0002
FFFC7700 CE5FF0EF		call	TSTC		; it must be followed by a comma
FFFC7704 0000002C		dw		','
FFFC7708 06000263		bra		.err
FFFC770C 00086333		mov		s3,v0
FFFC7710 00106913		ldi		a0,#1
FFFC7714 B04FF0EF		call	TSTV
FFFC7718 FC0800E3		beq		v0,x0,.0002
FFFC771C 000863B3		mov		s4,v0
FFFC7720 CC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC7724 0000002C		dw		','
FFFC7728 04000263		bra		.err
FFFC772C EADFE0EF		call	OREXPR	; get queue remove flag
FFFC7730 00086BB3		mov		a5,v0
FFFC7734 000863B3		mov		s4,v0
FFFC7738 CADFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC773C 00000029		dw		')'
FFFC7740 02000C63		bra		.paren
FFFC7744 00A06913		ldi		a0,#10		; WaitMsg
FFFC7748 000269B3		mov		a1,s1
FFFC774C 0002EA33		mov		a2,s2
FFFC7750 00036AB3		mov		a3,s3
FFFC7754 0003EB33		mov		a4,s4
FFFC7758 00000073		ecall
FFFC775C 000068B3		mov		v1,x0
FFFC7760 00072083		lw		$ra,[$sp]
FFFC7764 00470713		add		$sp,$sp,#4
FFFC7768 00008067		ret
                        	.err:
FFFC776C FFFC8937		ldi		a0,#msgComma
FFFC7770 88290913
FFFC7774 F04FF06F		jmp		ERROR
                        	.paren:
FFFC7778 FFFC8937		ldi		a0,#msgParen
FFFC777C 9B790913
FFFC7780 EF8FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC7784 B81F806F		jmp		Putch
                        	
                        	; ===== Input a character from the console into register v0 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC7788 FFC70713		sub 	$sp,$sp,#4
FFFC778C 00172023		sw		$ra,[$sp]
FFFC7790 B45F80EF		call	Getch
FFFC7794 00180813		add		$v0,$v0,#1				; prepare test -1
FFFC7798 00080A63		beq		$v0,$x0,INCH1			; was = -1
FFFC779C FFF80813		sub		$v0,$v0,#1				; get char back
FFFC77A0 00072083		lw		$ra,[$sp]
FFFC77A4 00470713		add		$sp,$sp,#4
FFFC77A8 00008067		ret
                        	INCH1:
FFFC77AC 00072083		lw		$ra,[$sp]		; return a zero for no-char
FFFC77B0 00470713		add		$sp,$sp,#4
FFFC77B4 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	//message "BYEBYE"
                        	BYEBYE:
                        	//	call	ReleaseIOFocus
FFFC77B8 00030637		lw		$sp,OSSP
FFFC77BC 00060613
FFFC77C0 00060633
FFFC77C4 00062703
FFFC77C8 C05F806F		jmp		Monitor
                        	 
                        	
FFFC77CC 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.0",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,CR,0
FFFC77D0 54203130
FFFC77D4 20796E69
FFFC77D8 49534142
FFFC77DC 31762043
FFFC77E0 0A0D302E
FFFC77E4 20294328
FFFC77E8 37313032
FFFC77EC 3230322D
FFFC77F0 52202030
FFFC77F4 7265626F
FFFC77F8 69462074
FFFC77FC 0D68636E
FFFC7800 0A0D000D
FFFC7802 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC7806 6857000D
FFFC7808 74616857	msgWhat	db	"What?",CR,0
FFFC780C 53000D3F
FFFC780F 72726F53	SRYMSG	db	"Sorry."
FFFC7813 000D2E79
FFFC7815 6F43000D	CLMSG	db	CR,0
FFFC7817 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC781B 20746361
FFFC781F 53414C46
FFFC7823 65722048
FFFC7827 65206461
FFFC782B 726F7272
FFFC782F 754E000D
FFFC7831 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC7835 69207265
FFFC7839 6F742073
FFFC783D 6962206F
FFFC7841 44000D67
FFFC7844 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC7848 6E6F6973
FFFC784C 20796220
FFFC7850 6F72657A
FFFC7854 754F000D
FFFC7856 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC785A 7620666F
FFFC785E 61697261
FFFC7862 20656C62
FFFC7866 63617073
FFFC786A 20000D65
FFFC786D 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC7871 66207365
FFFC7875 0D656572
FFFC7879 65520D00
FFFC787A 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC787E 000D7964
FFFC7882 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC7886 6E697463
FFFC788A 20612067
FFFC788E 6D6D6F63
FFFC7892 4C000D61
FFFC7895 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC7899 6D756E20
FFFC789D 20726562
FFFC78A1 206F6F74
FFFC78A5 0D676962
FFFC78A9 70784500
FFFC78AA 65707845	msgVar			db "Expecting a variable",CR,0
FFFC78AE 6E697463
FFFC78B2 20612067
FFFC78B6 69726176
FFFC78BA 656C6261
FFFC78BE 4E52000D
FFFC78C0 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC78C4 20646162
FFFC78C8 61726170
FFFC78CC 6574656D
FFFC78D0 53000D72
FFFC78D3 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC78D7 20646162
FFFC78DB 72646461
FFFC78DF 0D737365
FFFC78E3 504E4900
FFFC78E4 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC78E8 78652054
FFFC78EC 74636570
FFFC78F0 20676E69
FFFC78F4 61762061
FFFC78F8 62616972
FFFC78FC 000D656C
FFFC7900 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC7904 74697720
FFFC7908 74756F68
FFFC790C 524F4620
FFFC7910 454E000D
FFFC7912 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC7916 70786520
FFFC791A 69746365
FFFC791E 6120676E
FFFC7922 66656420
FFFC7926 64656E69
FFFC792A 72617620
FFFC792E 6C626169
FFFC7932 47000D65
FFFC7935 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC7939 534F472F
FFFC793D 62204255
FFFC7941 6C206461
FFFC7945 20656E69
FFFC7949 626D756E
FFFC794D 000D7265
FFFC7951 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC7955 77204E52
FFFC7959 6F687469
FFFC795D 47207475
FFFC7961 4255534F
FFFC7965 7250000D
FFFC7967 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC796B 206D6172
FFFC796F 74207369
FFFC7973 62206F6F
FFFC7977 000D6769
FFFC797B 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC797F 68632061
FFFC7983 63617261
FFFC7987 73726574
FFFC798B 206E6F20
FFFC798F 656E696C
FFFC7993 6E676920
FFFC7997 6465726F
FFFC799B 4520000D
FFFC799D 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC79A1 6E6F7269
FFFC79A5 746E656D
FFFC79A9 6C616320
FFFC79AD 6166206C
FFFC79B1 64656C69
FFFC79B5 7845000D
FFFC79B7 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC79BB 6E697463
FFFC79BF 61702067
FFFC79C3 746E6572
FFFC79C7 69736568
FFFC79CB 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "SpriteDemo.s",1
                        	.file "SpriteDemo.s",1
                        	.file "SpriteDemo.s",2
                        		code
FFFC79CE 00730000		align	1
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
                        	public code _EnableSprite:
; 	pSPRCTRL[0x180] = pSPRCTRL[0x180] | (1 << spriteno);
FFFC79D0 10300073		      	pfi      
FFFC79D4 FFDAE637		      	ldo      	$t1,4292530176+3072
FFFC79D8 C0060613
FFFC79DC 00060633
FFFC79E0 00063D83
FFFC79E4 00106E93		      	ldi      	$t3,#1
FFFC79E8 00073F03		      	ldo      	$t4,0[$sp]
FFFC79EC 01EE9E33		      	sll      	$t2,$t3,$t4
FFFC79F0 01CDED33		      	or       	$t0,$t1,$t2
FFFC79F4 FFDAE637		      	sto      	$t0,4292530176+3072
FFFC79F8 C0060613
FFFC79FC 00060633
FFFC7A00 01A63023
                        	SpriteDemo_9:
FFFC7A04 02070713		      	add      	$sp,$sp,#32
FFFC7A08 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC7A0C FE070713	public code _EnableSprites:
	      	sub      	$sp,$sp,#32
FFFC7A10 00273023		      	sto      	$fp,[$sp]
FFFC7A14 00073423		      	sto      	$x0,8[$sp]
FFFC7A18 00076133		      	mov      	$fp,$sp
FFFC7A1C FEE70713		      	sub      	$sp,$sp,#18
FFFC7A20 00473023		      	sto      	$s1,0[$sp]
FFFC7A24 10300073		      	pfi      
                        	; 	unsigned int *pSPRCTRL = ((unsigned __int64 *)0xFFDAD000);
FFFC7A28 FFDAD237		      	ldi      	$s1,#4292530176
FFFC7A2C 00020213
                        	; 	pSPRCTRL[0x180] = pSPRCTRL[0x180] | sprites;
FFFC7A30 00001637		      	ldo      	$t1,3072[$s1]
FFFC7A34 C0060613
FFFC7A38 00460633
FFFC7A3C 00063D83
FFFC7A40 02013E03		      	ldo      	$t2,32[$fp]
FFFC7A44 01CDED33		      	or       	$t0,$t1,$t2
FFFC7A48 00001637		      	sto      	$t0,3072[$s1]
FFFC7A4C C0060613
FFFC7A50 00460633
FFFC7A54 01A63023
                        	SpriteDemo_17:
FFFC7A58 00073203		      	ldo      	$s1,0[$sp]
FFFC7A5C 00016733		      	mov      	$sp,$fp
FFFC7A60 00073103		      	ldo      	$fp,[$sp]
FFFC7A64 02070713		      	add      	$sp,$sp,#32
FFFC7A68 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC7A6C FE070713	public code _RandomizeSpriteColors:
	      	sub      	$sp,$sp,#32
FFFC7A70 00273023		      	sto      	$fp,[$sp]
FFFC7A74 00073423		      	sto      	$x0,8[$sp]
FFFC7A78 00173C23		      	sto      	$ra,24[$sp]
FFFC7A7C 00076133		      	mov      	$fp,$sp
FFFC7A80 FCC70713		      	sub      	$sp,$sp,#52
FFFC7A84 00473023		      	sto      	$s1,0[$sp]
FFFC7A88 10300073		      	pfi      
FFFC7A8C FF813203		      	ldo      	$s1,-8[$fp]
                        	; 	randStream = 0;
FFFC7A90 00025637		      	sto      	$x0,_randStream
FFFC7A94 83060613
FFFC7A98 00060633
FFFC7A9C 00063023
                        	; 	for (colorno = 2; colorno < 256; colorno++) {
FFFC7AA0 00206213		      	ldi      	$s1,#2
FFFC7AA4 10022D13		      	slt      	$t0,$s1,#256
FFFC7AA8 040D0463		      	beqz     	$t0,SpriteDemo_30
                        	SpriteDemo_29:
                        	; 		pSprite[colorno] = GetRand(randStream) & 0xffffffff;
FFFC7AAC 10300073		      	pfi      
FFFC7AB0 00321D13		      	sll      	$t0,$s1,#3
FFFC7AB4 FFDAD637		      	add      	$t0,$t0,#4292530176
FFFC7AB8 00060613
FFFC7ABC 01A60D33
FFFC7AC0 00025637		      	ldo      	$a0,_randStream
FFFC7AC4 83060613
FFFC7AC8 00060633
FFFC7ACC 00063903
FFFC7AD0 CA5FC0EF		      	call     	_GetRand
FFFC7AD4 00086E33		      	mov      	$t2,$v0
FFFC7AD8 10300073		      	pfi      
FFFC7ADC FFFE7D93		      	and      	$t1,$t2,#4294967295
FFFC7AE0 01BD3023		      	sto      	$t1,[$t0]
FFFC7AE4 00120213		      	add      	$s1,$s1,#1
FFFC7AE8 10022D13		      	slt      	$t0,$s1,#256
FFFC7AEC FC0D10E3		      	bnez     	$t0,SpriteDemo_29
                        	SpriteDemo_30:
                        	SpriteDemo_25:
                        	SpriteDemo_28:
FFFC7AF0 00073203		      	ldo      	$s1,0[$sp]
FFFC7AF4 00016733		      	mov      	$sp,$fp
FFFC7AF8 00073103		      	ldo      	$fp,[$sp]
FFFC7AFC 01873083		      	ldo      	$ra,24[$sp]
FFFC7B00 02070713		      	add      	$sp,$sp,#32
FFFC7B04 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC7B08 FE070713	public code _SetSpritePos:
	      	sub      	$sp,$sp,#32
FFFC7B0C 00273023		      	sto      	$fp,[$sp]
FFFC7B10 00073423		      	sto      	$x0,8[$sp]
FFFC7B14 00076133		      	mov      	$fp,$sp
FFFC7B18 FEE70713		      	sub      	$sp,$sp,#18
FFFC7B1C 00473023		      	sto      	$s1,0[$sp]
FFFC7B20 10300073		      	pfi      
                        	; 	__int32 *pSprite = &((unsigned __int64 *)0xFFDAD000)[0x100];
FFFC7B24 FFDAE237		      	ldi      	$s1,#4292532224
FFFC7B28 80020213
                        	; 	pSprite[spriteno*4 + 2] = (y << 16) | x;
FFFC7B2C 02013E83		      	ldo      	$t3,32[$fp]
FFFC7B30 002E9E13		      	sll      	$t2,$t3,#2
FFFC7B34 002E1D93		      	sll      	$t1,$t2,#2
FFFC7B38 004D8D33		      	add      	$t0,$t1,$s1
FFFC7B3C 10300073		      	pfi      
FFFC7B40 03413E83		      	ldo      	$t3,52[$fp]
FFFC7B44 010E9E13		      	sll      	$t2,$t3,#16
FFFC7B48 02A13E83		      	ldo      	$t3,42[$fp]
FFFC7B4C 01DE6DB3		      	or       	$t1,$t2,$t3
FFFC7B50 01BD2423		      	stt      	$t1,8[$t0]
                        	SpriteDemo_39:
FFFC7B54 00073203		      	ldo      	$s1,0[$sp]
FFFC7B58 00016733		      	mov      	$sp,$fp
FFFC7B5C 00073103		      	ldo      	$fp,[$sp]
FFFC7B60 02070713		      	add      	$sp,$sp,#32
FFFC7B64 00008067		      	ret      
                        	endpublic
                        	
                        	.file "SpriteDemo.s",127
                        		code
FFFC7B68 00000000		align	1
FFFC7B6C 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC7B70 FE070713	public code _RandomizeSpritePositions:
	      	sub      	$sp,$sp,#32
FFFC7B74 00273023		      	sto      	$fp,[$sp]
FFFC7B78 00073423		      	sto      	$x0,8[$sp]
FFFC7B7C 00173C23		      	sto      	$ra,24[$sp]
FFFC7B80 00076133		      	mov      	$fp,$sp
FFFC7B84 FA870713		      	sub      	$sp,$sp,#88
FFFC7B88 00473023		      	sto      	$s1,0[$sp]
FFFC7B8C 00573423		      	sto      	$s2,8[$sp]
FFFC7B90 00673823		      	sto      	$s3,16[$sp]
FFFC7B94 00773C23		      	sto      	$s4,24[$sp]
FFFC7B98 10300073		      	pfi      
FFFC7B9C FF813203		      	ldo      	$s1,-8[$fp]
FFFC7BA0 FD813283		      	ldo      	$s2,-40[$fp]
FFFC7BA4 FE413303		      	ldo      	$s3,-28[$fp]
FFFC7BA8 FEE13383		      	ldo      	$s4,-18[$fp]
                        	; 	int spriteno;
FFFC7BAC FFDAE2B7		      	ldi      	$s2,#4292532224
FFFC7BB0 80028293
                        	; 	randStream = 0;
FFFC7BB4 00025637		      	sto      	$x0,_randStream
FFFC7BB8 83060613
FFFC7BBC 00060633
FFFC7BC0 00063023
                        	; 	for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC7BC4 00006233		      	mov      	$s1,$x0
FFFC7BC8 10300073		      	pfi      
FFFC7BCC 04022D13		      	slt      	$t0,$s1,#64
FFFC7BD0 080D0463		      	beqz     	$t0,SpriteDemo_52
                        	SpriteDemo_51:
                        	; 		x = (GetRand(randStream) % 800) + 256;
FFFC7BD4 00025637		      	ldo      	$a0,_randStream
FFFC7BD8 83060613
FFFC7BDC 00060633
FFFC7BE0 00063903
FFFC7BE4 B91FC0EF		      	call     	_GetRand
FFFC7BE8 00086E33		      	mov      	$t2,$v0
FFFC7BEC 10300073		      	pfi      
FFFC7BF0 32006E93		      	ldi      	$t3,#800
FFFC7BF4 100D8D13		      	add      	$t0,$t1,#256
FFFC7BF8 000D63B3		      	mov      	$s4,$t0
                        	; 		y = (GetRand(randStream) % 600) + 28;
FFFC7BFC 00025637		      	ldo      	$a0,_randStream
FFFC7C00 83060613
FFFC7C04 00060633
FFFC7C08 00063903
FFFC7C0C B69FC0EF		      	call     	_GetRand
FFFC7C10 00086E33		      	mov      	$t2,$v0
FFFC7C14 10300073		      	pfi      
FFFC7C18 25806E93		      	ldi      	$t3,#600
FFFC7C1C 01CD8D13		      	add      	$t0,$t1,#28
FFFC7C20 000D6333		      	mov      	$s3,$t0
                        	; 		pSprite[1] = (2560 << 48) | (y << 16) | x;
FFFC7C24 01031E13		      	sll      	$t2,$s3,#16
FFFC7C28 FFFC9637		      	ldo      	$t3,SpriteDemo_longlit0
FFFC7C2C 02060613
FFFC7C30 00060633
FFFC7C34 00063E83
FFFC7C38 01DE6DB3		      	or       	$t1,$t2,$t3
FFFC7C3C 10300073		      	pfi      
FFFC7C40 007DED33		      	or       	$t0,$t1,$s4
FFFC7C44 01A2B423		      	sto      	$t0,8[$s2]
                        	; 		pSprite += 2;
FFFC7C48 01028293		      	add      	$s2,$s2,#16
FFFC7C4C 00120213		      	add      	$s1,$s1,#1
FFFC7C50 04022D13		      	slt      	$t0,$s1,#64
FFFC7C54 F80D10E3		      	bnez     	$t0,SpriteDemo_51
                        	SpriteDemo_52:
                        	SpriteDemo_47:
                        	SpriteDemo_50:
FFFC7C58 00073203		      	ldo      	$s1,0[$sp]
FFFC7C5C 00873283		      	ldo      	$s2,8[$sp]
FFFC7C60 01073303		      	ldo      	$s3,16[$sp]
FFFC7C64 01873383		      	ldo      	$s4,24[$sp]
FFFC7C68 00016733		      	mov      	$sp,$fp
FFFC7C6C 00073103		      	ldo      	$fp,[$sp]
FFFC7C70 01873083		      	ldo      	$ra,24[$sp]
FFFC7C74 02070713		      	add      	$sp,$sp,#32
FFFC7C78 00008067		      	ret      
                        	endpublic
                        	
                        	.file "SpriteDemo.s",211
                        		code
FFFC7C7C 00000000		align	1
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC7C80 FE070713	public code _SpriteDemo:
	      	sub      	$sp,$sp,#32
FFFC7C84 00273023		      	sto      	$fp,[$sp]
FFFC7C88 00073423		      	sto      	$x0,8[$sp]
FFFC7C8C 00173C23		      	sto      	$ra,24[$sp]
FFFC7C90 00076133		      	mov      	$fp,$sp
FFFC7C94 B2670713		      	sub      	$sp,$sp,#1242
FFFC7C98 00473023		      	sto      	$s1,0[$sp]
FFFC7C9C 00573423		      	sto      	$s2,8[$sp]
FFFC7CA0 00673823		      	sto      	$s3,16[$sp]
FFFC7CA4 00773C23		      	sto      	$s4,24[$sp]
FFFC7CA8 02873023		      	sto      	$s5,32[$sp]
FFFC7CAC 02973423		      	sto      	$s6,40[$sp]
FFFC7CB0 02A73823		      	sto      	$s7,48[$sp]
FFFC7CB4 02B73C23		      	sto      	$s8,56[$sp]
FFFC7CB8 04C73023		      	sto      	$s9,64[$sp]
FFFC7CBC 04D73423		      	sto      	$s10,72[$sp]
FFFC7CC0 10300073		      	pfi      
FFFC7CC4 FF813203		      	ldo      	$s1,-8[$fp]
FFFC7CC8 BDE13283		      	ldo      	$s2,-1058[$fp]
FFFC7CCC BD413303		      	ldo      	$s3,-1068[$fp]
FFFC7CD0 EF610393		      	lea      	$s4,-266[$fp]
FFFC7CD4 DF210413		      	lea      	$s5,-526[$fp]
FFFC7CD8 BEA10493		      	lea      	$s6,-1046[$fp]
FFFC7CDC BC013503		      	ldo      	$s7,-1088[$fp]
FFFC7CE0 10300073		      	pfi      
FFFC7CE4 CEE10593		      	lea      	$s8,-786[$fp]
FFFC7CE8 BB613603		      	ldo      	$s9,-1098[$fp]
FFFC7CEC BA013683		      	ldo      	$s10,-1120[$fp]
                        	; 	int spriteno;
FFFC7CF0 FFDAED37		      	ldi      	$t0,#4292532224
FFFC7CF4 800D0D13
FFFC7CF8 BBA13423		      	sto      	$t0,-1112[$fp]
FFFC7CFC 10300073		      	pfi      
FFFC7D00 000109B7		      	ldi      	$a1,#65536
FFFC7D04 00098993
FFFC7D08 00006933		      	mov      	$a0,$x0
FFFC7D0C A45F90EF		      	call     	_Alloc
FFFC7D10 00086D33		      	mov      	$t0,$v0
FFFC7D14 000D66B3		      	mov      	$s10,$t0
                        	; 	randStream = 0;
FFFC7D18 10300073		      	pfi      
FFFC7D1C 00025637		      	sto      	$x0,_randStream
FFFC7D20 83060613
FFFC7D24 00060633
FFFC7D28 00063023
                        	; 	RandomizeSpriteColors();
FFFC7D2C D41FF0EF		      	call     	_RandomizeSpriteColors
                        	; 	EnableSprites(-1);
FFFC7D30 FFF06D13		      	ldi      	$t0,#-1
FFFC7D34 01A73423		      	sto      	$t0,8[$sp]
FFFC7D38 CD5FF0EF		      	call     	_EnableSprites
FFFC7D3C 00870713		      	add      	$sp,$sp,#8
                        	; 	for (n = 0; n < 64 * 32 * 4; n = n + 1)
FFFC7D40 10300073		      	pfi      
FFFC7D44 000062B3		      	mov      	$s2,$x0
FFFC7D48 00002637		      	slt      	$t0,$s2,#8192
FFFC7D4C 00060613
FFFC7D50 060D0463		      	beqz     	$t0,SpriteDemo_96
                        	SpriteDemo_95:
                        	; 		pImages[n] = GetRand(randStream)|(GetRand(randStream)<<32);
FFFC7D54 10300073		      	pfi      
FFFC7D58 00329D13		      	sll      	$t0,$s2,#3
FFFC7D5C 01A68D33		      	add      	$t0,$s10,$t0
FFFC7D60 00025637		      	ldo      	$a0,_randStream
FFFC7D64 83060613
FFFC7D68 00060633
FFFC7D6C 00063903
FFFC7D70 A05FC0EF		      	call     	_GetRand
FFFC7D74 00086E33		      	mov      	$t2,$v0
FFFC7D78 10300073		      	pfi      
FFFC7D7C 00025637		      	ldo      	$a0,_randStream
FFFC7D80 83060613
FFFC7D84 00060633
FFFC7D88 00063903
FFFC7D8C 9E9FC0EF		      	call     	_GetRand
FFFC7D90 00086F33		      	mov      	$t4,$v0
FFFC7D94 000F1E93		      	sll      	$t3,$t4,#32
FFFC7D98 01DE6DB3		      	or       	$t1,$t2,$t3
FFFC7D9C 01BD3023		      	sto      	$t1,[$t0]
FFFC7DA0 00128D13		      	add      	$t0,$s2,#1
FFFC7DA4 000D62B3		      	mov      	$s2,$t0
FFFC7DA8 10300073		      	pfi      
FFFC7DAC 00002637		      	slt      	$t0,$s2,#8192
FFFC7DB0 00060613
FFFC7DB4 FA0D10E3		      	bnez     	$t0,SpriteDemo_95
                        	SpriteDemo_96:
                        	; 	x = 256; y = 64;
FFFC7DB8 10006513		      	ldi      	$s7,#256
FFFC7DBC 04006613		      	ldi      	$s9,#64
                        	; 	for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC7DC0 00006233		      	mov      	$s1,$x0
FFFC7DC4 04022D13		      	slt      	$t0,$s1,#64
FFFC7DC8 0A0D0063		      	beqz     	$t0,SpriteDemo_99
                        	SpriteDemo_98:
                        	; 		pSprite[spriteno*2] = VirtToPhys(0,&pImages[spriteno * 128]);
FFFC7DCC 10300073		      	pfi      
FFFC7DD0 00121D93		      	sll      	$t1,$s1,#1
FFFC7DD4 003D9D13		      	sll      	$t0,$t1,#3
FFFC7DD8 BA813E03		      	ldo      	$t2,-1112[$fp]
FFFC7DDC 01AE0D33		      	add      	$t0,$t2,$t0
FFFC7DE0 10300073		      	pfi      
FFFC7DE4 B7A13B23		      	sto      	$t0,-1162[$fp]
FFFC7DE8 00721E93		      	sll      	$t3,$s1,#7
FFFC7DEC 003E9E13		      	sll      	$t2,$t3,#3
FFFC7DF0 00DE09B3		      	add      	$a1,$t2,$s10
FFFC7DF4 00006933		      	mov      	$a0,$x0
FFFC7DF8 A45F90EF		      	call     	_VirtToPhys
FFFC7DFC B7613D03		      	ldo      	$t0,-1162[$fp]
FFFC7E00 00086DB3		      	mov      	$t1,$v0
FFFC7E04 01BD3023		      	sto      	$t1,[$t0]
                        	; 		xpos[spriteno] = x;
FFFC7E08 10300073		      	pfi      
FFFC7E0C 00221D13		      	sll      	$t0,$s1,#2
FFFC7E10 01A38D33		      	add      	$t0,$s4,$t0
FFFC7E14 00AD2023		      	stt      	$s7,[$t0]
                        	; 		ypos[spriteno] = y;
FFFC7E18 10300073		      	pfi      
FFFC7E1C 00221D13		      	sll      	$t0,$s1,#2
FFFC7E20 01A40D33		      	add      	$t0,$s5,$t0
FFFC7E24 00CD2023		      	stt      	$s9,[$t0]
                        	; 		SetSpritePos(spriteno, x, y);
FFFC7E28 10300073		      	pfi      
FFFC7E2C 00C73C23		      	sto      	$s9,24[$sp]
FFFC7E30 00A73C23		      	sto      	$s7,24[$sp]
FFFC7E34 00473C23		      	sto      	$s1,24[$sp]
FFFC7E38 CD1FF0EF		      	call     	_SetSpritePos
FFFC7E3C 01870713		      	add      	$sp,$sp,#24
                        	; 		x += 20;
FFFC7E40 10300073		      	pfi      
FFFC7E44 01450513		      	add      	$s7,$s7,#20
                        	; 		if (x >= 800) {
FFFC7E48 32052D13		      	slt      	$t0,$s7,#800
FFFC7E4C 000D1663		      	bnez     	$t0,SpriteDemo_101
                        	; 			x = 256;
FFFC7E50 10006513		      	ldi      	$s7,#256
                        	; 			y += 64;
FFFC7E54 04060613		      	add      	$s9,$s9,#64
                        	SpriteDemo_101:
FFFC7E58 00120213		      	add      	$s1,$s1,#1
FFFC7E5C 10300073		      	pfi      
FFFC7E60 04022D13		      	slt      	$t0,$s1,#64
FFFC7E64 F60D14E3		      	bnez     	$t0,SpriteDemo_98
                        	SpriteDemo_99:
                        	; 	for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC7E68 00006233		      	mov      	$s1,$x0
FFFC7E6C 10300073		      	pfi      
FFFC7E70 04022D13		      	slt      	$t0,$s1,#64
FFFC7E74 060D0C63		      	beqz     	$t0,SpriteDemo_104
                        	SpriteDemo_103:
                        	; 		dx[spriteno] = (GetRand(randStream) & 15) - 8;
FFFC7E78 00221D13		      	sll      	$t0,$s1,#2
FFFC7E7C 01A58D33		      	add      	$t0,$s8,$t0
FFFC7E80 00025637		      	ldo      	$a0,_randStream
FFFC7E84 83060613
FFFC7E88 00060633
FFFC7E8C 00063903
FFFC7E90 8E5FC0EF		      	call     	_GetRand
FFFC7E94 00086EB3		      	mov      	$t3,$v0
FFFC7E98 10300073		      	pfi      
FFFC7E9C 00FEFE13		      	and      	$t2,$t3,#15
FFFC7EA0 FF8E0D93		      	sub      	$t1,$t2,#8
FFFC7EA4 01BD2023		      	stt      	$t1,[$t0]
                        	; 		dy[spriteno] = (GetRand(randStream) & 15) - 8;
FFFC7EA8 00221D13		      	sll      	$t0,$s1,#2
FFFC7EAC 10300073		      	pfi      
FFFC7EB0 01A48D33		      	add      	$t0,$s6,$t0
FFFC7EB4 00025637		      	ldo      	$a0,_randStream
FFFC7EB8 83060613
FFFC7EBC 00060633
FFFC7EC0 00063903
FFFC7EC4 8B1FC0EF		      	call     	_GetRand
FFFC7EC8 00086EB3		      	mov      	$t3,$v0
FFFC7ECC 10300073		      	pfi      
FFFC7ED0 00FEFE13		      	and      	$t2,$t3,#15
FFFC7ED4 FF8E0D93		      	sub      	$t1,$t2,#8
FFFC7ED8 01BD2023		      	stt      	$t1,[$t0]
FFFC7EDC 00120213		      	add      	$s1,$s1,#1
FFFC7EE0 10300073		      	pfi      
FFFC7EE4 04022D13		      	slt      	$t0,$s1,#64
FFFC7EE8 F80D18E3		      	bnez     	$t0,SpriteDemo_103
                        	SpriteDemo_104:
                        	; 	for (n = 0; n < 64 * 32 * 2; n = n + 1)
FFFC7EEC 000062B3		      	mov      	$s2,$x0
FFFC7EF0 00001637		      	slt      	$t0,$s2,#4096
FFFC7EF4 00060613
FFFC7EF8 040D0263		      	beqz     	$t0,SpriteDemo_107
                        	SpriteDemo_106:
                        	; 		pImages[n] = GetRand(randStream);
FFFC7EFC 10300073		      	pfi      
FFFC7F00 00329D13		      	sll      	$t0,$s2,#3
FFFC7F04 01A68D33		      	add      	$t0,$s10,$t0
FFFC7F08 00025637		      	ldo      	$a0,_randStream
FFFC7F0C 83060613
FFFC7F10 00060633
FFFC7F14 00063903
FFFC7F18 85DFC0EF		      	call     	_GetRand
FFFC7F1C 00086DB3		      	mov      	$t1,$v0
FFFC7F20 01BD3023		      	sto      	$t1,[$t0]
FFFC7F24 10300073		      	pfi      
FFFC7F28 00128D13		      	add      	$t0,$s2,#1
FFFC7F2C 000D62B3		      	mov      	$s2,$t0
FFFC7F30 00001637		      	slt      	$t0,$s2,#4096
FFFC7F34 00060613
FFFC7F38 FC0D12E3		      	bnez     	$t0,SpriteDemo_106
                        	SpriteDemo_107:
                        	SpriteDemo_109:
                        	; 		btn = GetButton();
FFFC7F3C 10300073		      	pfi      
                        	; 	__asm {
                        		      	;asm     	
FFFC7F40 FFDC0637				ldt		$v0,BUTTONS
FFFC7F44 60060613
FFFC7F48 00060633
FFFC7F4C 00062803
FFFC7F50 01085813				srl		$v0,$v0,#16
FFFC7F54 01F87813				and		$v0,$v0,#$1F
                        	; 	}
FFFC7F58 00086D33		      	mov      	$t0,$v0
FFFC7F5C BDA13523		      	sto      	$t0,-1078[$fp]
                        	; 		for (m = 0; m < 50000; m++);	// Timing delay
FFFC7F60 00006333		      	mov      	$s3,$x0
FFFC7F64 0000C637		      	slt      	$t0,$s3,#50000
FFFC7F68 35060613
FFFC7F6C 000D0C63		      	beqz     	$t0,SpriteDemo_115
                        	SpriteDemo_114:
FFFC7F70 10300073		      	pfi      
FFFC7F74 00130313		      	add      	$s3,$s3,#1
FFFC7F78 0000C637		      	slt      	$t0,$s3,#50000
FFFC7F7C 35060613
FFFC7F80 FE0D18E3		      	bnez     	$t0,SpriteDemo_114
                        	SpriteDemo_115:
                        	; 		for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC7F84 00006233		      	mov      	$s1,$x0
FFFC7F88 04022D13		      	slt      	$t0,$s1,#64
FFFC7F8C 140D0863		      	beqz     	$t0,SpriteDemo_118
                        	SpriteDemo_117:
                        	; 			xpos[spriteno] = xpos[spriteno] + dx[spriteno];
FFFC7F90 10300073		      	pfi      
FFFC7F94 00221D13		      	sll      	$t0,$s1,#2
FFFC7F98 01A38D33		      	add      	$t0,$s4,$t0
FFFC7F9C 00221E13		      	sll      	$t2,$s1,#2
FFFC7FA0 01C38E33		      	add      	$t2,$s4,$t2
FFFC7FA4 10300073		      	pfi      
FFFC7FA8 00221E93		      	sll      	$t3,$s1,#2
FFFC7FAC 01D58EB3		      	add      	$t3,$s8,$t3
FFFC7FB0 01DE0DB3		      	add      	$t1,$t2,$t3
FFFC7FB4 01BD2023		      	stt      	$t1,[$t0]
                        	; 			ypos[spriteno] = ypos[spriteno] + dy[spriteno];
FFFC7FB8 10300073		      	pfi      
FFFC7FBC 00221D13		      	sll      	$t0,$s1,#2
FFFC7FC0 01A40D33		      	add      	$t0,$s5,$t0
FFFC7FC4 00221E13		      	sll      	$t2,$s1,#2
FFFC7FC8 01C40E33		      	add      	$t2,$s5,$t2
FFFC7FCC 10300073		      	pfi      
FFFC7FD0 00221E93		      	sll      	$t3,$s1,#2
FFFC7FD4 01D48EB3		      	add      	$t3,$s6,$t3
FFFC7FD8 01DE0DB3		      	add      	$t1,$t2,$t3
FFFC7FDC 01BD2023		      	stt      	$t1,[$t0]
                        	; 			if (xpos[spriteno] < 256) {
FFFC7FE0 10300073		      	pfi      
FFFC7FE4 00221D13		      	sll      	$t0,$s1,#2
FFFC7FE8 01A38D33		      	add      	$t0,$s4,$t0
FFFC7FEC 100D2D93		      	slt      	$t1,$t0,#256
FFFC7FF0 020D8663		      	beqz     	$t1,SpriteDemo_120
                        	; 				xpos[spriteno] = 256;
FFFC7FF4 10300073		      	pfi      
                        	; 				dx[spriteno] = -dx[spriteno];
FFFC7FF8 00221D13		      	sll      	$t0,$s1,#2
FFFC7FFC 01A58D33		      	add      	$t0,$s8,$t0
FFFC8000 10300073		      	pfi      
FFFC8004 00221E13		      	sll      	$t2,$s1,#2
FFFC8008 01C58E33		      	add      	$t2,$s8,$t2
FFFC800C 001B1C01		      	neg      	$t1,$t2
FFFC8010 1B010005
FFFC8011 1B1B0100		      	sxh      	$t1,$t1
FFFC8015 23000A00
FFFC8017 BD202300		      	stt      	$t1,[$t0]
FFFC801B 30007301
                        	SpriteDemo_120:
                        	; 			if (xpos[spriteno] >= 816) {
FFFC801C 10300073		      	pfi      
FFFC8020 00221D13		      	sll      	$t0,$s1,#2
FFFC8024 01A38D33		      	add      	$t0,$s4,$t0
FFFC8028 330D2D93		      	slt      	$t1,$t0,#816
FFFC802C 020D9463		      	bnez     	$t1,SpriteDemo_122
                        	; 				xpos[spriteno] = 816;
FFFC8030 10300073		      	pfi      
                        	; 				dx[spriteno] = -dx[spriteno];
FFFC8034 00221D13		      	sll      	$t0,$s1,#2
FFFC8038 01A58D33		      	add      	$t0,$s8,$t0
FFFC803C 00221E13		      	sll      	$t2,$s1,#2
FFFC8040 01C58E33		      	add      	$t2,$s8,$t2
FFFC8044 001B1C01		      	neg      	$t1,$t2
FFFC8048 1B010005
FFFC8049 1B1B0100		      	sxh      	$t1,$t1
FFFC804D 23000A00
FFFC804F BD202300		      	stt      	$t1,[$t0]
FFFC8053 30007301
                        	SpriteDemo_122:
                        	; 			if (ypos[spriteno] < 28) {
FFFC8054 10300073		      	pfi      
FFFC8058 00221D13		      	sll      	$t0,$s1,#2
FFFC805C 01A40D33		      	add      	$t0,$s5,$t0
FFFC8060 01CD2D93		      	slt      	$t1,$t0,#28
FFFC8064 020D8663		      	beqz     	$t1,SpriteDemo_124
                        	; 				ypos[spriteno] = 28;
FFFC8068 10300073		      	pfi      
                        	; 				dy[spriteno] = -dy[spriteno];
FFFC806C 00221D13		      	sll      	$t0,$s1,#2
FFFC8070 01A48D33		      	add      	$t0,$s6,$t0
FFFC8074 10300073		      	pfi      
FFFC8078 00221E13		      	sll      	$t2,$s1,#2
FFFC807C 01C48E33		      	add      	$t2,$s6,$t2
FFFC8080 001B1C01		      	neg      	$t1,$t2
FFFC8084 1B010005
FFFC8085 1B1B0100		      	sxh      	$t1,$t1
FFFC8089 23000A00
FFFC808B BD202300		      	stt      	$t1,[$t0]
FFFC808F 30007301
                        	SpriteDemo_124:
                        	; 			if (ypos[spriteno] >= 614)
FFFC8090 10300073		      	pfi      
FFFC8094 00221D13		      	sll      	$t0,$s1,#2
FFFC8098 01A40D33		      	add      	$t0,$s5,$t0
FFFC809C 266D2D93		      	slt      	$t1,$t0,#614
FFFC80A0 000D9663		      	bnez     	$t1,SpriteDemo_126
                        	; 				ypos[spriteno] = 614;
FFFC80A4 10300073		      	pfi      
FFFC80A8 26606D13		      	ldi      	$t0,#614
                        	SpriteDemo_126:
                        	; 				dy[spriteno] = -dy[spriteno];
FFFC80AC 00221D13		      	sll      	$t0,$s1,#2
FFFC80B0 01A48D33		      	add      	$t0,$s6,$t0
FFFC80B4 00221E13		      	sll      	$t2,$s1,#2
FFFC80B8 01C48E33		      	add      	$t2,$s6,$t2
FFFC80BC 001B1C01		      	neg      	$t1,$t2
FFFC80C0 1B010005
FFFC80C1 1B1B0100		      	sxh      	$t1,$t1
FFFC80C5 23000A00
FFFC80C7 BD202300		      	stt      	$t1,[$t0]
FFFC80CB 30007301
FFFC80CC 10300073		      	pfi      
FFFC80D0 00120213		      	add      	$s1,$s1,#1
FFFC80D4 04022D13		      	slt      	$t0,$s1,#64
FFFC80D8 EA0D1CE3		      	bnez     	$t0,SpriteDemo_117
                        	SpriteDemo_118:
                        	; 			SetSpritePos(spriteno, (int)xpos[spriteno], (int)ypos[spriteno]);
FFFC80DC 10300073		      	pfi      
FFFC80E0 00221D13		      	sll      	$t0,$s1,#2
FFFC80E4 01A40D33		      	add      	$t0,$s5,$t0
FFFC80E8 01A73C23		      	sto      	$t0,24[$sp]
FFFC80EC 10300073		      	pfi      
FFFC80F0 00221D13		      	sll      	$t0,$s1,#2
FFFC80F4 01A38D33		      	add      	$t0,$s4,$t0
FFFC80F8 01A73C23		      	sto      	$t0,24[$sp]
FFFC80FC 00473C23		      	sto      	$s1,24[$sp]
FFFC8100 A09FF0EF		      	call     	_SetSpritePos
FFFC8104 01870713		      	add      	$sp,$sp,#24
FFFC8108 E2000AE3		      	bra      	SpriteDemo_109
                        	SpriteDemo_91:
                        	SpriteDemo_94:
FFFC810C 00073203		      	ldo      	$s1,0[$sp]
FFFC8110 00873283		      	ldo      	$s2,8[$sp]
FFFC8114 01073303		      	ldo      	$s3,16[$sp]
FFFC8118 01873383		      	ldo      	$s4,24[$sp]
FFFC811C 02073403		      	ldo      	$s5,32[$sp]
FFFC8120 02873483		      	ldo      	$s6,40[$sp]
FFFC8124 03073503		      	ldo      	$s7,48[$sp]
FFFC8128 03873583		      	ldo      	$s8,56[$sp]
FFFC812C 04073603		      	ldo      	$s9,64[$sp]
FFFC8130 04873683		      	ldo      	$s10,72[$sp]
FFFC8134 00016733		      	mov      	$sp,$fp
FFFC8138 00073103		      	ldo      	$fp,[$sp]
FFFC813C 01873083		      	ldo      	$ra,24[$sp]
FFFC8140 02070713		      	add      	$sp,$sp,#32
FFFC8144 00008067		      	ret      
                        	endpublic
                        	
                        		rodata
                        		align	16                        	
                        		align	8                        	
                        	ramtest_105:	;   RAM Test
FFFC9000 0000000000000000		dcb	32,32,82,65,77,32,84,101,115,116,13,10
FFFC9008 0000000000000000
FFFC9010 0000000000000000
FFFC9018 0000000000000000
                        		dcb	0
                        		extern	_prtnum
	extern	_PutString
	extern	_DBGHideCursor
	extern	_puthexnum
	extern	_PutHexWord
;	global	_ramtest
                        		extern	_putch
;	global	_dumpaddr
                        	.file "boot.r5a",1
                        	.file "../bios/bios.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        		rodata
                        		align	16                        	
                        		extern	_tcbs
	extern	_nMsgBlk
	extern	_mmu_Free512kPage
	extern	_mmu_Alloc8kPage
	extern	_mmu_alloc
	extern	_IOFocusTbl
	extern	_outb
	extern	_outc
	extern	_mmu_MapCardMemory
	extern	_FMTK_StartApp
	extern	_outh
	extern	_irq_stack
	extern	_IOFocusNdx
	extern	_DumpTaskList
;	global	_GetImLevel
                        		extern	_outw
	extern	_fmtk_irq_stack
	extern	_mmu_SetOperateKey
	extern	_keybdControlCodes
	extern	_fmtk_sys_stack
	extern	_message
	extern	_mailbox
	extern	_FMTK_Inited
;	global	_UnlockIOFSemaphore
                        		extern	_KeybdSetLED
	extern	_mmu_AllocateMap
	extern	_FMTK_StartThread
;	global	_DBGCheckForKey
                        		extern	_GetRunningACBPtr
	extern	_KeyLED
	extern	_hFocusSwitchMbx
	extern	_KeybdClearRcv
	extern	_missed_ticks
;	global	_SetVBA
                        		extern	_mmu_SetMapEntry
	extern	_LockIOFSemaphore
	extern	_chkTCB
;	global	_UnlockSemaphore
                        	;	global	_DBGGetKey
                        		extern	_mmu_Alloc512kPage
	extern	_GetVecno
	extern	_GetACBPtr
;	global	_UnlockKbdSemaphore
                        		extern	_video_bufs
	extern	_getCPU
;	global	_LEDS
                        		extern	_hasUltraHighPriorityTasks
	extern	_LockSemaphore
	extern	_keybdExtendedCodes
	extern	_iof_switch
	extern	_KeybdGetScancode
	extern	_kbd_sema
	extern	_DeviceTable
	extern	_nMailbox
	extern	_unshiftedScanCodes
	extern	_set_vector
	extern	_LockKbdSemaphore
	extern	_FMTK_SendMsg
	extern	_iof_sema
	extern	_sys_stacks
	extern	_FocusSwitcher
	extern	_BIOS_RespMbx
	extern	_FMTK_WaitMsg
	extern	_mmu_FreeMap
	extern	_mmu_Free8kPage
	extern	_mmu_free
	extern	_mmu_SetAccessKey
	extern	_shiftedScanCodes
	extern	_KeyState1
	extern	_KeyState2
	extern	_BIOS1_sema
	extern	_sys_sema
	extern	_readyQ
	extern	_LockSysSemaphore
	extern	_ACBPtrs
	extern	_sysstack
	extern	_freeTCB
	extern	_RequestIOFocus
	extern	_TimeoutList
	extern	_RemoveFromTimeoutList
	extern	_stacks
	extern	_freeMSG
	extern	_freeMBX
	extern	_SetBound50
	extern	_SetBound51
	extern	_GetAppHandle
	extern	_SetBound48
	extern	_SetBound49
	extern	_InsertIntoTimeoutList
;	global	_RestoreImLevel
                        		extern	_RemoveFromReadyList
	extern	_KeybdGetStatus
	extern	_bios_stacks
	extern	_FMTK_Reschedule
	extern	_InsertIntoReadyList
.file "boot.r5a",1
                        	.file "../fmtk/source/kernel/DBGConsole.s",1
                        		rodata
                        		align	16                        	
                        	;	global	_DBGSetCursorPos
                        		extern	_mmu_Free512kPage
	extern	_in32u
	extern	_in16u
	extern	_mmu_Alloc8kPage
	extern	_mmu_alloc
	extern	_outb
	extern	_outc
	extern	_out32
	extern	_mmu_MapCardMemory
	extern	_out16
	extern	_FMTK_StartApp
	extern	_outh
	extern	_out64
	extern	_IOFocusNdx
	extern	_DumpTaskList
;	global	_DBGHideCursor
                        	;	global	_fast_out32
                        	;	global	_GetImLevel
                        		extern	_outw
;	global	_fast_out64
                        		extern	_mmu_SetOperateKey
;	global	_DBGHomeCursor
                        		extern	_memsetO
;	global	_DBGUpdateCursorPos
                        		extern	_memsetW
;	global	_UnlockIOFSemaphore
                        		extern	_puthexnum
	extern	_mmu_AllocateMap
;	global	_DBGCRLF
                        		extern	_FMTK_StartThread
	extern	_GetRunningACBPtr
;	global	_DBGScrollUp
                        	;	global	_DBGDisplayAsciiString
                        	;	global	_SetVBA
                        		extern	_mmu_SetMapEntry
	extern	_LockIOFSemaphore
;	global	_DBGSetVideoReg
                        		extern	_chkTCB
	extern	_in8
;	global	_UnlockSemaphore
                        	;	global	_DBGClearScreen
                        		extern	_mmu_Alloc512kPage
;	global	_DBGDisplayString
                        		extern	_GetVecno
	extern	_GetACBPtr
;	global	_UnlockKbdSemaphore
                        	;	global	_DBGDisplayChar
                        	;	global	_DBGIncrementCursorPos
                        		extern	_getCPU
;	global	_LEDS
                        	;	global	_DBGIncrementCursorRow
                        	;	global	_DBGDisplayAsciiStringCRLF
                        		extern	_LockSemaphore
	extern	_in32
;	global	_DBGBlankLine
                        		extern	_set_vector
	extern	_LockKbdSemaphore
	extern	_in16
	extern	_in64
;	global	_DBGDisplayStringCRLF
                        		extern	_FMTK_SendMsg
	extern	_FocusSwitcher
	extern	_FMTK_WaitMsg
	extern	_mmu_FreeMap
;	global	_fast_in64
                        		extern	_mmu_Free8kPage
	extern	_mmu_free
	extern	_rmemsetW
	extern	_mmu_SetAccessKey
	extern	_DBGAttr
	extern	_DBGCursorCol
	extern	_LockSysSemaphore
	extern	_tabstops
	extern	_RequestIOFocus
	extern	_DBGCursorRow
	extern	_in8u
	extern	_RemoveFromTimeoutList
	extern	_SetBound50
	extern	_SetBound51
	extern	_GetAppHandle
	extern	_SetBound48
	extern	_out8
	extern	_SetBound49
	extern	_InsertIntoTimeoutList
;	global	_RestoreImLevel
                        		extern	_RemoveFromReadyList
	extern	_FMTK_Reschedule
	extern	_InsertIntoReadyList
.file "boot.r5a",1
                        	.file "TinyBasic.r5a",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x3F6C0
                        	FILEBUF		EQU		0x03F600
                        	OSSP		EQU		0x30000
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	BUFFER		EQU		CURRNT+4
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	IRQFlag		EQU		CursorFlash+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x031800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x03FFFC	; end of available memory
                        	STACKOFFS	EQU		0xAFFFC000	; stack offset
                        	
                        	
                        		rodata
                        		align	16                        	
                        		align	8                        	
                        	SpriteDemo_longlit0:
FFFC9020 000004EF80000000		dco	A00000000000000
                        		extern	_GetRand
;	global	_EnableSprite
                        	;	global	_SetSpritePos
                        	;	global	_RandomizeSpritePositions
                        		extern	_Alloc
;	global	_SpriteDemo
                        		extern	_VirtToPhys
	extern	_randStream
;	global	_EnableSprites
                        	;	global	_RandomizeSpriteColors
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA000 00000000            		fill.b	4,0x00
FFFCA004 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
FFFCA008 00000000            		fill.b	4,0x00
FFFCA00C 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA010 0000000000000000		fill.b	40,0x00
FFFCA018 0000000000000000
FFFCA020 0000000000000000
FFFCA028 0000000000000000
FFFCA030 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA038 0000000000000000		fill.b	6,0x00
FFFCA03E 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA040 0000000000000000		fill.b	20,0x00
FFFCA048 0000000000000000
FFFCA050 00000000            
FFFCA054 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA058 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA060 0000000000000000		fill.b	944,0x00
FFFCA068 0000000000000000
FFFCA070 0000000000000000
FFFCA078 0000000000000000
FFFCA080 0000000000000000
FFFCA088 0000000000000000
FFFCA090 0000000000000000
FFFCA098 0000000000000000
FFFCA0A0 0000000000000000
FFFCA0A8 0000000000000000
FFFCA0B0 0000000000000000
FFFCA0B8 0000000000000000
FFFCA0C0 0000000000000000
FFFCA0C8 0000000000000000
FFFCA0D0 0000000000000000
FFFCA0D8 0000000000000000
FFFCA0E0 0000000000000000
FFFCA0E8 0000000000000000
FFFCA0F0 0000000000000000
FFFCA0F8 0000000000000000
FFFCA100 0000000000000000
FFFCA108 0000000000000000
FFFCA110 0000000000000000
FFFCA118 0000000000000000
FFFCA120 0000000000000000
FFFCA128 0000000000000000
FFFCA130 0000000000000000
FFFCA138 0000000000000000
FFFCA140 0000000000000000
FFFCA148 0000000000000000
FFFCA150 0000000000000000
FFFCA158 0000000000000000
FFFCA160 0000000000000000
FFFCA168 0000000000000000
FFFCA170 0000000000000000
FFFCA178 0000000000000000
FFFCA180 0000000000000000
FFFCA188 0000000000000000
FFFCA190 0000000000000000
FFFCA198 0000000000000000
FFFCA1A0 0000000000000000
FFFCA1A8 0000000000000000
FFFCA1B0 0000000000000000
FFFCA1B8 0000000000000000
FFFCA1C0 0000000000000000
FFFCA1C8 0000000000000000
FFFCA1D0 0000000000000000
FFFCA1D8 0000000000000000
FFFCA1E0 0000000000000000
FFFCA1E8 0000000000000000
FFFCA1F0 0000000000000000
FFFCA1F8 0000000000000000
FFFCA200 0000000000000000
FFFCA208 0000000000000000
FFFCA210 0000000000000000
FFFCA218 0000000000000000
FFFCA220 0000000000000000
FFFCA228 0000000000000000
FFFCA230 0000000000000000
FFFCA238 0000000000000000
FFFCA240 0000000000000000
FFFCA248 0000000000000000
FFFCA250 0000000000000000
FFFCA258 0000000000000000
FFFCA260 0000000000000000
FFFCA268 0000000000000000
FFFCA270 0000000000000000
FFFCA278 0000000000000000
FFFCA280 0000000000000000
FFFCA288 0000000000000000
FFFCA290 0000000000000000
FFFCA298 0000000000000000
FFFCA2A0 0000000000000000
FFFCA2A8 0000000000000000
FFFCA2B0 0000000000000000
FFFCA2B8 0000000000000000
FFFCA2C0 0000000000000000
FFFCA2C8 0000000000000000
FFFCA2D0 0000000000000000
FFFCA2D8 0000000000000000
FFFCA2E0 0000000000000000
FFFCA2E8 0000000000000000
FFFCA2F0 0000000000000000
FFFCA2F8 0000000000000000
FFFCA300 0000000000000000
FFFCA308 0000000000000000
FFFCA310 0000000000000000
FFFCA318 0000000000000000
FFFCA320 0000000000000000
FFFCA328 0000000000000000
FFFCA330 0000000000000000
FFFCA338 0000000000000000
FFFCA340 0000000000000000
FFFCA348 0000000000000000
FFFCA350 0000000000000000
FFFCA358 0000000000000000
FFFCA360 0000000000000000
FFFCA368 0000000000000000
FFFCA370 0000000000000000
FFFCA378 0000000000000000
FFFCA380 0000000000000000
FFFCA388 0000000000000000
FFFCA390 0000000000000000
FFFCA398 0000000000000000
FFFCA3A0 0000000000000000
FFFCA3A8 0000000000000000
FFFCA3B0 0000000000000000
FFFCA3B8 0000000000000000
FFFCA3C0 0000000000000000
FFFCA3C8 0000000000000000
FFFCA3D0 0000000000000000
FFFCA3D8 0000000000000000
FFFCA3E0 0000000000000000
FFFCA3E8 0000000000000000
FFFCA3F0 0000000000000000
FFFCA3F8 0000000000000000
FFFCA400 0000000000000000
FFFCA408 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA410 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA418 00000000            		fill.b	4,0x00
FFFCA41C 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA420 0000000000000000		fill.b	56,0x00
FFFCA428 0000000000000000
FFFCA430 0000000000000000
FFFCA438 0000000000000000
FFFCA440 0000000000000000
FFFCA448 0000000000000000
FFFCA450 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA458 00000000            		fill.b	4,0x00
FFFCA45C 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA460 0000000000000000		fill.b	22,0x00
FFFCA468 0000000000000000
FFFCA470 0000000000000000
FFFCA476 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA478 0000000000000000		fill.b	6,0x00
FFFCA47E 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA480 0000000000000000		fill.b	50,0x00
FFFCA488 0000000000000000
FFFCA490 0000000000000000
FFFCA498 0000000000000000
FFFCA4A0 0000000000000000
FFFCA4A8 0000000000000000
FFFCA4B0 00000000            
FFFCA4B2 0000000000000000		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA4B8 00000000            		fill.b	2,0x00
FFFCA4BA 0000000000000000		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        	
FFFCA4C0 0000000000000000		rodata
FFFCA4C8 0000000000000000
FFFCA4D0 0000000000000000
FFFCA4D8 0000000000000000
FFFCA4E0 0000000000000000
FFFCA4E8 0000000000000000
FFFCA4F0 0000000000000000
FFFCA4F8 0000000000000000
FFFCA500 0000000000000000
FFFCA508 0000000000000000
FFFCA510 0000000000000000
FFFCA518 0000000000000000
FFFCA520 0000000000000000
FFFCA528 0000000000000000
FFFCA530 0000000000000000
FFFCA538 0000000000000000
FFFCA540 0000000000000000
FFFCA548 0000000000000000
FFFCA550 0000000000000000
FFFCA558 0000000000000000
FFFCA560 0000000000000000
FFFCA568 0000000000000000
FFFCA570 0000000000000000
FFFCA578 0000000000000000
FFFCA580 0000000000000000
FFFCA588 0000000000000000
FFFCA590 0000000000000000
FFFCA598 0000000000000000
FFFCA5A0 0000000000000000
FFFCA5A8 0000000000000000
FFFCA5B0 0000000000000000
FFFCA5B8 0000000000000000
FFFCA5C0 0000000000000000
FFFCA5C8 0000000000000000
FFFCA5D0 0000000000000000
FFFCA5D8 0000000000000000
FFFCA5E0 0000000000000000
FFFCA5E8 0000000000000000
FFFCA5F0 0000000000000000
FFFCA5F8 0000000000000000
FFFCA600 0000000000000000
FFFCA608 0000000000000000
FFFCA610 0000000000000000
FFFCA618 0000000000000000
FFFCA620 0000000000000000
FFFCA628 0000000000000000
FFFCA630 0000000000000000
FFFCA638 0000000000000000
FFFCA640 0000000000000000
FFFCA648 0000000000000000
FFFCA650 0000000000000000
FFFCA658 0000000000000000
FFFCA660 0000000000000000
FFFCA668 0000000000000000
FFFCA670 0000000000000000
FFFCA678 0000000000000000
FFFCA680 0000000000000000
FFFCA688 0000000000000000
FFFCA690 0000000000000000
FFFCA698 0000000000000000
FFFCA6A0 0000000000000000
FFFCA6A8 0000000000000000
FFFCA6B0 0000000000000000
FFFCA6B8 0000000000000000
FFFCA6C0 0000000000000000
FFFCA6C8 0000000000000000
FFFCA6D0 0000000000000000
FFFCA6D8 0000000000000000
FFFCA6E0 0000000000000000
FFFCA6E8 0000000000000000
FFFCA6F0 0000000000000000
FFFCA6F8 0000000000000000
FFFCA700 0000000000000000
FFFCA708 0000000000000000
FFFCA710 0000000000000000
FFFCA718 0000000000000000
FFFCA720 0000000000000000
FFFCA728 0000000000000000
FFFCA730 0000000000000000
FFFCA738 0000000000000000
FFFCA740 0000000000000000
FFFCA748 0000000000000000
FFFCA750 0000000000000000
FFFCA758 0000000000000000
FFFCA760 0000000000000000
FFFCA768 0000000000000000
FFFCA770 0000000000000000
FFFCA778 0000000000000000
FFFCA780 0000000000000000
FFFCA788 0000000000000000
FFFCA790 0000000000000000
FFFCA798 0000000000000000
FFFCA7A0 0000000000000000
FFFCA7A8 0000000000000000
FFFCA7B0 0000000000000000
FFFCA7B8 0000000000000000
FFFCA7C0 0000000000000000
FFFCA7C8 0000000000000000
FFFCA7D0 0000000000000000
FFFCA7D8 0000000000000000
FFFCA7E0 0000000000000000
FFFCA7E8 0000000000000000
FFFCA7F0 0000000000000000
FFFCA7F8 0000000000000000
FFFCA800 0000000000000000
FFFCA808 0000000000000000
FFFCA810 0000000000000000
FFFCA818 0000000000000000
FFFCA820 0000000000000000
FFFCA828 0000000000000000
FFFCA830 0000000000000000
FFFCA838 0000000000000000
FFFCA840 0000000000000000
FFFCA848 0000000000000000
FFFCA850 0000000000000000
FFFCA858 0000000000000000
FFFCA860 0000000000000000
FFFCA868 0000000000000000
FFFCA870 0000000000000000
FFFCA878 0000000000000000
FFFCA880 0000000000000000
FFFCA888 0000000000000000
FFFCA890 0000000000000000
FFFCA898 0000000000000000
FFFCA8A0 0000000000000000
FFFCA8A8 0000000000000000
FFFCA8B0 0000000000000000
FFFCA8B8 0000000000000000
FFFCA8C0 0000000000000000
FFFCA8C8 0000000000000000
FFFCA8D0 0000000000000000
FFFCA8D8 0000000000000000
FFFCA8E0 0000000000000000
FFFCA8E8 0000000000000000
FFFCA8F0 0000000000000000
FFFCA8F8 0000000000000000
FFFCA900 0000000000000000
FFFCA908 0000000000000000
FFFCA910 0000000000000000
FFFCA918 0000000000000000
FFFCA920 0000000000000000
FFFCA928 0000000000000000
FFFCA930 0000000000000000
FFFCA938 0000000000000000
FFFCA940 0000000000000000
FFFCA948 0000000000000000
FFFCA950 0000000000000000
FFFCA958 0000000000000000
FFFCA960 0000000000000000
FFFCA968 0000000000000000
FFFCA970 0000000000000000
FFFCA978 0000000000000000
FFFCA980 0000000000000000
FFFCA988 0000000000000000
FFFCA990 0000000000000000
FFFCA998 0000000000000000
FFFCA9A0 0000000000000000
FFFCA9A8 0000000000000000
FFFCA9B0 0000000000000000
FFFCA9B8 0000000000000000
FFFCA9C0 0000000000000000
FFFCA9C8 0000000000000000
FFFCA9D0 0000000000000000
FFFCA9D8 0000000000000000
FFFCA9E0 0000000000000000
FFFCA9E8 0000000000000000
FFFCA9F0 0000000000000000
FFFCA9F8 0000000000000000
FFFCAA00 0000000000000000
FFFCAA08 0000000000000000
FFFCAA10 0000000000000000
FFFCAA18 0000000000000000
FFFCAA20 0000000000000000
FFFCAA28 0000000000000000
FFFCAA30 0000000000000000
FFFCAA38 0000000000000000
FFFCAA40 0000000000000000
FFFCAA48 0000000000000000
FFFCAA50 0000000000000000
FFFCAA58 0000000000000000
FFFCAA60 0000000000000000
FFFCAA68 0000000000000000
FFFCAA70 0000000000000000
FFFCAA78 0000000000000000
FFFCAA80 0000000000000000
FFFCAA88 0000000000000000
FFFCAA90 0000000000000000
FFFCAA98 0000000000000000
FFFCAAA0 0000000000000000
FFFCAAA8 0000000000000000
FFFCAAB0 0000000000000000
FFFCAAB8 0000000000000000
FFFCAAC0 0000000000000000
FFFCAAC8 0000000000000000
FFFCAAD0 0000000000000000
FFFCAAD8 0000000000000000
FFFCAAE0 0000000000000000
FFFCAAE8 0000000000000000
FFFCAAF0 0000000000000000
FFFCAAF8 0000000000000000
FFFCAB00 0000000000000000
FFFCAB08 0000000000000000
FFFCAB10 0000000000000000
FFFCAB18 0000000000000000
FFFCAB20 0000000000000000
FFFCAB28 0000000000000000
FFFCAB30 0000000000000000
FFFCAB38 0000000000000000
FFFCAB40 0000000000000000
FFFCAB48 0000000000000000
FFFCAB50 0000000000000000
FFFCAB58 0000000000000000
FFFCAB60 0000000000000000
FFFCAB68 0000000000000000
FFFCAB70 0000000000000000
FFFCAB78 0000000000000000
FFFCAB80 0000000000000000
FFFCAB88 0000000000000000
FFFCAB90 0000000000000000
FFFCAB98 0000000000000000
FFFCABA0 0000000000000000
FFFCABA8 0000000000000000
FFFCABB0 0000000000000000
FFFCABB8 0000000000000000
FFFCABC0 0000000000000000
FFFCABC8 0000000000000000
FFFCABD0 0000000000000000
FFFCABD8 0000000000000000
FFFCABE0 0000000000000000
FFFCABE8 0000000000000000
FFFCABF0 0000000000000000
FFFCABF8 0000000000000000
FFFCAC00 0000000000000000
FFFCAC08 0000000000000000
FFFCAC10 0000000000000000
FFFCAC18 0000000000000000
FFFCAC20 0000000000000000
FFFCAC28 0000000000000000
FFFCAC30 0000000000000000
FFFCAC38 0000000000000000
FFFCAC40 0000000000000000
FFFCAC48 0000000000000000
FFFCAC50 0000000000000000
FFFCAC58 0000000000000000
FFFCAC60 0000000000000000
FFFCAC68 0000000000000000
FFFCAC70 0000000000000000
FFFCAC78 0000000000000000
FFFCAC80 0000000000000000
FFFCAC88 0000000000000000
FFFCAC90 0000000000000000
FFFCAC98 0000000000000000
FFFCACA0 0000000000000000
FFFCACA8 0000000000000000
FFFCACB0 0000000000000000
FFFCACB8 0000000000000000
FFFCACC0 0000000000000000
FFFCACC8 0000000000000000
FFFCACD0 0000000000000000
FFFCACD8 0000000000000000
FFFCACE0 0000000000000000
FFFCACE8 0000000000000000
FFFCACF0 0000000000000000
FFFCACF8 0000000000000000
FFFCAD00 0000000000000000
FFFCAD08 0000000000000000
FFFCAD10 0000000000000000
FFFCAD18 0000000000000000
FFFCAD20 0000000000000000
FFFCAD28 0000000000000000
FFFCAD30 0000000000000000
FFFCAD38 0000000000000000
FFFCAD40 0000000000000000
FFFCAD48 0000000000000000
FFFCAD50 0000000000000000
FFFCAD58 0000000000000000
FFFCAD60 0000000000000000
FFFCAD68 0000000000000000
FFFCAD70 0000000000000000
FFFCAD78 0000000000000000
FFFCAD80 0000000000000000
FFFCAD88 0000000000000000
FFFCAD90 0000000000000000
FFFCAD98 0000000000000000
FFFCADA0 0000000000000000
FFFCADA8 0000000000000000
FFFCADB0 0000000000000000
FFFCADB8 0000000000000000
FFFCADC0 0000000000000000
FFFCADC8 0000000000000000
FFFCADD0 0000000000000000
FFFCADD8 0000000000000000
FFFCADE0 0000000000000000
FFFCADE8 0000000000000000
FFFCADF0 0000000000000000
FFFCADF8 0000000000000000
FFFCAE00 0000000000000000
FFFCAE08 0000000000000000
FFFCAE10 0000000000000000
FFFCAE18 0000000000000000
FFFCAE20 0000000000000000
FFFCAE28 0000000000000000
FFFCAE30 0000000000000000
FFFCAE38 0000000000000000
FFFCAE40 0000000000000000
FFFCAE48 0000000000000000
FFFCAE50 0000000000000000
FFFCAE58 0000000000000000
FFFCAE60 0000000000000000
FFFCAE68 0000000000000000
FFFCAE70 0000000000000000
FFFCAE78 0000000000000000
FFFCAE80 0000000000000000
FFFCAE88 0000000000000000
FFFCAE90 0000000000000000
FFFCAE98 0000000000000000
FFFCAEA0 0000000000000000
FFFCAEA8 0000000000000000
FFFCAEB0 0000000000000000
FFFCAEB8 0000000000000000
FFFCAEC0 0000000000000000
FFFCAEC8 0000000000000000
FFFCAED0 0000000000000000
FFFCAED8 0000000000000000
FFFCAEE0 0000000000000000
FFFCAEE8 0000000000000000
FFFCAEF0 0000000000000000
FFFCAEF8 0000000000000000
FFFCAF00 0000000000000000
FFFCAF08 0000000000000000
FFFCAF10 0000000000000000
FFFCAF18 0000000000000000
FFFCAF20 0000000000000000
FFFCAF28 0000000000000000
FFFCAF30 0000000000000000
FFFCAF38 0000000000000000
FFFCAF40 0000000000000000
FFFCAF48 0000000000000000
FFFCAF50 0000000000000000
FFFCAF58 0000000000000000
FFFCAF60 0000000000000000
FFFCAF68 0000000000000000
FFFCAF70 0000000000000000
FFFCAF78 0000000000000000
FFFCAF80 0000000000000000
FFFCAF88 0000000000000000
FFFCAF90 0000000000000000
FFFCAF98 0000000000000000
FFFCAFA0 0000000000000000
FFFCAFA8 0000000000000000
FFFCAFB0 0000000000000000
FFFCAFB8 0000000000000000
FFFCAFC0 0000000000000000
FFFCAFC8 0000000000000000
FFFCAFD0 0000000000000000
FFFCAFD8 0000000000000000
FFFCAFE0 0000000000000000
FFFCAFE8 0000000000000000
FFFCAFF0 0000000000000000
FFFCAFF8 0000000000000000
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA4C0 00000000            		fill.b	4,0x00
FFFCA4C4 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
FFFCA4C8 00000000            		fill.b	4,0x00
FFFCA4CC 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA4D0 0000000000000000		fill.b	40,0x00
FFFCA4D8 0000000000000000
FFFCA4E0 0000000000000000
FFFCA4E8 0000000000000000
FFFCA4F0 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA4F8 0000000000000000		fill.b	6,0x00
FFFCA4FE 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA500 0000000000000000		fill.b	20,0x00
FFFCA508 0000000000000000
FFFCA510 00000000            
FFFCA514 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA518 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA520 0000000000000000		fill.b	944,0x00
FFFCA528 0000000000000000
FFFCA530 0000000000000000
FFFCA538 0000000000000000
FFFCA540 0000000000000000
FFFCA548 0000000000000000
FFFCA550 0000000000000000
FFFCA558 0000000000000000
FFFCA560 0000000000000000
FFFCA568 0000000000000000
FFFCA570 0000000000000000
FFFCA578 0000000000000000
FFFCA580 0000000000000000
FFFCA588 0000000000000000
FFFCA590 0000000000000000
FFFCA598 0000000000000000
FFFCA5A0 0000000000000000
FFFCA5A8 0000000000000000
FFFCA5B0 0000000000000000
FFFCA5B8 0000000000000000
FFFCA5C0 0000000000000000
FFFCA5C8 0000000000000000
FFFCA5D0 0000000000000000
FFFCA5D8 0000000000000000
FFFCA5E0 0000000000000000
FFFCA5E8 0000000000000000
FFFCA5F0 0000000000000000
FFFCA5F8 0000000000000000
FFFCA600 0000000000000000
FFFCA608 0000000000000000
FFFCA610 0000000000000000
FFFCA618 0000000000000000
FFFCA620 0000000000000000
FFFCA628 0000000000000000
FFFCA630 0000000000000000
FFFCA638 0000000000000000
FFFCA640 0000000000000000
FFFCA648 0000000000000000
FFFCA650 0000000000000000
FFFCA658 0000000000000000
FFFCA660 0000000000000000
FFFCA668 0000000000000000
FFFCA670 0000000000000000
FFFCA678 0000000000000000
FFFCA680 0000000000000000
FFFCA688 0000000000000000
FFFCA690 0000000000000000
FFFCA698 0000000000000000
FFFCA6A0 0000000000000000
FFFCA6A8 0000000000000000
FFFCA6B0 0000000000000000
FFFCA6B8 0000000000000000
FFFCA6C0 0000000000000000
FFFCA6C8 0000000000000000
FFFCA6D0 0000000000000000
FFFCA6D8 0000000000000000
FFFCA6E0 0000000000000000
FFFCA6E8 0000000000000000
FFFCA6F0 0000000000000000
FFFCA6F8 0000000000000000
FFFCA700 0000000000000000
FFFCA708 0000000000000000
FFFCA710 0000000000000000
FFFCA718 0000000000000000
FFFCA720 0000000000000000
FFFCA728 0000000000000000
FFFCA730 0000000000000000
FFFCA738 0000000000000000
FFFCA740 0000000000000000
FFFCA748 0000000000000000
FFFCA750 0000000000000000
FFFCA758 0000000000000000
FFFCA760 0000000000000000
FFFCA768 0000000000000000
FFFCA770 0000000000000000
FFFCA778 0000000000000000
FFFCA780 0000000000000000
FFFCA788 0000000000000000
FFFCA790 0000000000000000
FFFCA798 0000000000000000
FFFCA7A0 0000000000000000
FFFCA7A8 0000000000000000
FFFCA7B0 0000000000000000
FFFCA7B8 0000000000000000
FFFCA7C0 0000000000000000
FFFCA7C8 0000000000000000
FFFCA7D0 0000000000000000
FFFCA7D8 0000000000000000
FFFCA7E0 0000000000000000
FFFCA7E8 0000000000000000
FFFCA7F0 0000000000000000
FFFCA7F8 0000000000000000
FFFCA800 0000000000000000
FFFCA808 0000000000000000
FFFCA810 0000000000000000
FFFCA818 0000000000000000
FFFCA820 0000000000000000
FFFCA828 0000000000000000
FFFCA830 0000000000000000
FFFCA838 0000000000000000
FFFCA840 0000000000000000
FFFCA848 0000000000000000
FFFCA850 0000000000000000
FFFCA858 0000000000000000
FFFCA860 0000000000000000
FFFCA868 0000000000000000
FFFCA870 0000000000000000
FFFCA878 0000000000000000
FFFCA880 0000000000000000
FFFCA888 0000000000000000
FFFCA890 0000000000000000
FFFCA898 0000000000000000
FFFCA8A0 0000000000000000
FFFCA8A8 0000000000000000
FFFCA8B0 0000000000000000
FFFCA8B8 0000000000000000
FFFCA8C0 0000000000000000
FFFCA8C8 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA8D0 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA8D8 00000000            		fill.b	4,0x00
FFFCA8DC 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA8E0 0000000000000000		fill.b	56,0x00
FFFCA8E8 0000000000000000
FFFCA8F0 0000000000000000
FFFCA8F8 0000000000000000
FFFCA900 0000000000000000
FFFCA908 0000000000000000
FFFCA910 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA918 00000000            		fill.b	4,0x00
FFFCA91C 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA920 0000000000000000		fill.b	22,0x00
FFFCA928 0000000000000000
FFFCA930 0000000000000000
FFFCA936 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA938 0000000000000000		fill.b	6,0x00
FFFCA93E 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA940 0000000000000000		fill.b	50,0x00
FFFCA948 0000000000000000
FFFCA950 0000000000000000
FFFCA958 0000000000000000
FFFCA960 0000000000000000
FFFCA968 0000000000000000
FFFCA970 00000000            
FFFCA972 0000000000000000		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFCA978 00000000            		fill.b	2,0x00
FFFCA97A 0000000000000000		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
1364 symbols
  Symbol Name                              seg     address bits
  A00000000000000                          rodata  80000000000004ef 32
  ABS                                        code  fffc6cdc 18
  ABS1                                       code  fffc6cf0 18
  ADDEXPR                                    code  fffc6854 18
  ALLOCMBX                                   code  fffc75a0 18
  ALLOCMBX.0001                              code  fffc75c4 18
  ALLOCMBX.0002                              code  fffc75f4 18
  ALLOCMBX.paren                             code  fffc7604 18
  ANDEXPR                                    code  fffc6640 18
  AUXIN                                      code  8000000000000349 32
  AUXIN_INIT                                 code  800000000000041c 32
  AUXOCRLF                                   code  fffc6480 18
  AUXOUT                                     code  8000000000000347 32
  AUXOUT_FLUSH                               code  8000000000000429 32
  AUXOUT_INIT                                code  8000000000000420 32
  Alloc                                      code  fffc1670 18
  Alloc.0001                                 code  fffc16f4 18
  Alloc.enough                               code  fffc16b4 18
  Alloc.noRun                                code  fffc172c 18
  Alloc.noRun2                               code  fffc16ac 18
  Alloc.xit                                  code  fffc1734 18
  AllocInCurrentAS                           code  fffc1668 18
  AllocStack                                 code  fffc1778 18
  AllocStack.0001                            code  fffc17a8 18
  AllocStack.xit                             code  fffc17c0 18
  AllocTCB                                   code  fffc38b8 18
  AllocTCB.0001                              code  fffc38d0 18
  AllocTCB.0002                              code  fffc3908 18
  AllocTCB.0003                              code  fffc3918 18
  AllocTCB.allocTid                          code  fffc38fc 18
  AlreadyLocked                              code  fffc330c 18
  BASPRMPT                                   code  fffc5768 18
  BIOSCallTbl                                code  fffc14b0 18
  BIOS_ClearScreen                           code  fffc14b8 18
  BIOS_HomeCursor                            code  fffc14bc 18
  BIOS_MUTEX                                const  ffdbff08 33
  BIOS_VideoPutChar                          code  fffc14c0 18
  BIOS_VideoPutString                        code  fffc14c4 18
  BS                                        const  000008 5
  BUFFER                                    const  03001c 19
  BUFLEN                                    const  000054 8
  BUTTONS                                   const  ffdc0600 33
  BYEBYE                                     code  fffc77b8 18
  CHKIO                                      code  fffc7558 18
  CHKRET                                     code  fffc7574 18
  CLMSG                                      code  fffc7815 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc7580 18
  CSR_REGSET                                const  000790 12
  CSTART                                     code  fffc5630 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLX                                     const  000018 6
  CURRNT                                    const  030018 19
  CopyDevFuncTbl                             code  fffc3e20 18
  CopyDevFuncTbl.again                       code  fffc3e34 18
  CursorFlash                               const  0300b0 19
  CursorX                                   const  024800 19
  CursorY                                   const  024801 19
  DBGConsole_154                             code  fffc52fc 18
  DBGConsole_155                             code  fffc52fc 18
  DBGConsole_169                             code  fffc50bc 18
  DBGConsole_170                             code  fffc50cc 18
  DBGConsole_171                             code  fffc50d4 18
  DBGConsole_172                             code  fffc50fc 18
  DBGConsole_173                             code  fffc511c 18
  DBGConsole_174                             code  fffc513c 18
  DBGConsole_175                             code  fffc5160 18
  DBGConsole_176                             code  fffc517c 18
  DBGConsole_177                             code  fffc51e8 18
  DBGConsole_178                             code  fffc5270 18
  DBGConsole_179                             code  fffc527c 18
  DBGConsole_180                             code  fffc52bc 18
  DBGConsole_181                             code  fffc50f8 18
  DBGConsole_183                             code  fffc5118 18
  DBGConsole_185                             code  fffc5138 18
  DBGConsole_187                             code  fffc515c 18
  DBGConsole_189                             code  fffc516c 18
  DBGConsole_191                             code  fffc51a4 18
  DBGConsole_192                             code  fffc51cc 18
  DBGConsole_194                             code  fffc526c 18
  DBGConsole_196                             code  fffc522c 18
  DBGConsole_197                             code  fffc5254 18
  DBGConsole_199                             code  fffc5288 18
  DBGConsole_20                              code  fffc4de8 18
  DBGConsole_200                             code  fffc52b8 18
  DBGConsole_202                             code  fffc52a8 18
  DBGConsole_213                             code  fffc536c 18
  DBGConsole_225                             code  fffc53c8 18
  DBGConsole_226                             code  fffc53b0 18
  DBGConsole_227                             code  fffc53c8 18
  DBGConsole_23                              code  fffc4dd4 18
  DBGConsole_239                             code  fffc542c 18
  DBGConsole_240                             code  fffc5414 18
  DBGConsole_241                             code  fffc542c 18
  DBGConsole_251                             code  fffc5474 18
  DBGConsole_261                             code  fffc54b4 18
  DBGConsole_273                             code  fffc5504 18
  DBGConsole_274                             code  fffc54f0 18
  DBGConsole_275                             code  fffc5504 18
  DBGConsole_37                              code  fffc4e14 18
  DBGConsole_47                              code  fffc4ea8 18
  DBGConsole_60                              code  fffc4f4c 18
  DBGConsole_61                              code  fffc4f04 18
  DBGConsole_62                              code  fffc4f40 18
  DBGConsole_76                              code  fffc4f9c 18
  DBGConsole_77                              code  fffc4fb0 18
  DBGConsole_9                               code  fffc4d60 18
  DBGConsole_92                              code  fffc4ffc 18
  DBGConsole_93                              code  fffc5010 18
  DBGKeybd_100                               code  fffc49b4 18
  DBGKeybd_101                               code  fffc4a04 18
  DBGKeybd_102                               code  fffc4a28 18
  DBGKeybd_103                               code  fffc4b98 18
  DBGKeybd_104                               code  fffc4bbc 18
  DBGKeybd_105                               code  fffc4bf8 18
  DBGKeybd_106                               code  fffc4cf4 18
  DBGKeybd_107                               code  fffc4c28 18
  DBGKeybd_108                               code  fffc4cf4 18
  DBGKeybd_109                               code  fffc4c7c 18
  DBGKeybd_111                               code  fffc4cac 18
  DBGKeybd_113                               code  fffc4cdc 18
  DBGKeybd_5                                 code  fffc47d0 18
  DBGKeybd_62                                code  fffc4874 18
  DBGKeybd_65                                code  fffc4874 18
  DBGKeybd_66                                code  fffc482c 18
  DBGKeybd_68                                code  fffc4844 18
  DBGKeybd_69                                code  fffc485c 18
  DBGKeybd_71                                code  fffc485c 18
  DBGKeybd_72                                code  fffc486c 18
  DBGKeybd_73                                code  fffc48a8 18
  DBGKeybd_74                                code  fffc4898 18
  DBGKeybd_76                                code  fffc48c4 18
  DBGKeybd_77                                code  fffc48d0 18
  DBGKeybd_79                                code  fffc4cf4 18
  DBGKeybd_8                                 code  fffc47d0 18
  DBGKeybd_90                                code  fffc4914 18
  DBGKeybd_91                                code  fffc492c 18
  DBGKeybd_92                                code  fffc4954 18
  DBGKeybd_93                                code  fffc49c8 18
  DBGKeybd_94                                code  fffc4a3c 18
  DBGKeybd_95                                code  fffc4a9c 18
  DBGKeybd_96                                code  fffc4afc 18
  DBGKeybd_97                                code  fffc4b5c 18
  DBGKeybd_98                                code  fffc4bd0 18
  DBGKeybd_99                                code  fffc4990 18
  DCB_LastErc                               const  000018 6
  DCB_Mbx                                   const  000048 8
  DCB_Name                                  const  000000 1
  DCB_ReentCount                            const  000038 7
  DCB_Resv1                                 const  000058 8
  DCB_Resv2                                 const  000060 8
  DCB_Size                                  const  000068 8
  DCB_StartBlock                            const  000020 7
  DCB_Type                                  const  00000c 5
  DCB_fSingleUser                           const  000039 7
  DCB_hJob                                  const  000040 8
  DCB_nBPB                                  const  000010 6
  DCB_nBlocks                               const  000028 7
  DCB_pCmdProc                              const  000030 7
  DCB_pSema                                 const  000050 8
  DEFLT                                      code  fffc61c8 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc5a60 18
  DOQUO                                      code  fffc7518 18
  DOQUO1                                     code  fffc7524 18
  DRSP_DONE                                 const  000001 2
  DVC_BuildBPB                              const  000005 4
  DVC_Close                                 const  000007 4
  DVC_FlushInput                            const  000014 6
  DVC_FlushOutput                           const  000015 6
  DVC_GetChar                               const  000008 5
  DVC_GetCharDirect                         const  00000a 5
  DVC_IOCTRL_READ                           const  000018 6
  DVC_IOCTRL_WRITE                          const  000019 6
  DVC_IRQ                                   const  000016 6
  DVC_Initialize                            const  000002 3
  DVC_InputStatus                           const  00000c 5
  DVC_IsRemoveable                          const  000017 6
  DVC_MediaCheck                            const  000004 4
  DVC_Nop                                   const  000000 1
  DVC_Open                                  const  000006 4
  DVC_OutputStatus                          const  000013 6
  DVC_OutputUntilBusy                       const  00001a 6
  DVC_PeekChar                              const  000009 5
  DVC_PeekCharDirect                        const  00000b 5
  DVC_PutChar                               const  00000d 5
  DVC_ReadBlock                             const  000010 6
  DVC_SetPosition                           const  00000f 5
  DVC_Setup                                 const  000001 2
  DVC_Status                                const  000003 3
  DVC_VerifyBlock                           const  000012 6
  DVC_WriteBlock                            const  000011 6
  DVF_Base                                  const  022000 19
  DVF_Limit                                 const  024000 19
  DeleteLine                                 code  fffc5820 18
  DeleteLine.0001                            code  fffc584c 18
  DeleteLine.0002                            code  fffc5838 18
  DeleteLine.0003                            code  fffc5850 18
  DispAttr                                  const  024808 19
  DumpMemmap                                 code  fffc09b8 18
  DumpMemmap.again                           code  fffc09d0 18
  DumpReadyList                              code  fffc3980 18
  DumpReadyList.0002                         code  fffc39bc 18
  DumpReadyList.brk                          code  fffc3a20 18
  DumpReadyList.nxt                          code  fffc3a14 18
  DumpTimeoutList                            code  fffc3a4c 18
  DumpTimeoutList.0002                       code  fffc3a88 18
  DumpTimeoutList.brk                        code  fffc3ac0 18
  ENDCHK                                     code  fffc6e28 18
  ENDMEM                                    const  03fffc 19
  ERETx                                      code  800000000000027e 32
  ERROR                                      code  fffc6e78 18
  ERROR1                                     code  fffc6ed0 18
  EX1                                        code  fffc5aac 18
  EXEC                                       code  fffc5a70 18
  EXGO                                       code  fffc5ad4 18
  EXLP                                       code  fffc5a7c 18
  EXMAT                                      code  fffc5ac0 18
  EXNGO                                      code  fffc5a94 18
  EXPR                                       code  fffc6730 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadBlockNum                             const  000025 7
  E_BadCallno                               const  00001a 6
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_Busy                                    const  000002 3
  E_DCBInUse                                const  000019 6
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  00000c 5
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc072c 18
  FFFC0100                                   code  80000000000002f6 32
  FI1                                        code  fffc6e08 18
  FI2                                        code  fffc6e1c 18
  FILEBUF                                   const  03f600 19
  FILENAME                                  const  03f6c0 19
  FIN                                        code  fffc6dec 18
  FINISH                                     code  fffc5df8 18
  FMTKInit                                   code  fffc2678 18
  FMTKInit.0001                              code  fffc275c 18
  FMTKInit.0002                              code  fffc2794 18
  FMTKInit.0003                              code  fffc273c 18
  FMTKInit.0004                              code  fffc27b4 18
  FMTK_AllocMbx                              code  fffc321c 18
  FMTK_AllocMbx.badArg                       code  fffc32d4 18
  FMTK_AllocMbx.lock                         code  fffc3254 18
  FMTK_AllocMbx.noOwner                      code  fffc32a0 18
  FMTK_AllocMbx.nxt                          code  fffc327c 18
  FMTK_AllocMbx.xit                          code  fffc32d8 18
  FMTK_AllocVideoBuf                         code  fffc3170 18
  FMTK_AllocVideoBuf.err                     code  fffc31a8 18
  FMTK_ExitTask                              code  fffc3050 18
  FMTK_ExitTask.xit                          code  fffc3070 18
  FMTK_ForceReleaseIOFocus                   code  fffc3cfc 18
  FMTK_ForceReleaseIOFocus.0001              code  fffc3dc4 18
  FMTK_ForceReleaseIOFocus.done              code  fffc3dd0 18
  FMTK_ForceReleaseIOFocus.noFocus           code  fffc3dd0 18
  FMTK_ForceReleaseIOFocus.noSwitch          code  fffc3d10 18
  FMTK_ForceReleaseIOFocus.notSame           code  fffc3d90 18
  FMTK_ForceReleaseIOFocus.pjSame            code  fffc3db0 18
  FMTK_FreeMbx                               code  fffc331c 18
  FMTK_FreeMbx.0001                          code  fffc33d0 18
  FMTK_FreeMbx.0002                          code  fffc3394 18
  FMTK_FreeMbx.0003                          code  fffc33c4 18
  FMTK_FreeMbx.badMbx                        code  fffc33e8 18
  FMTK_FreeMbx.lock                          code  fffc3368 18
  FMTK_FreeMbx.xit                           code  fffc33ec 18
  FMTK_GetCurrentTid                         code  fffc27e4 18
  FMTK_HasIOFocus                            code  fffc3b48 18
  FMTK_HasIOFocus.hasFocus                   code  fffc3b98 18
  FMTK_HasIOFocus.noSwitch                   code  fffc3b74 18
  FMTK_HasIOFocus.xit                        code  fffc3b9c 18
  FMTK_IO                                    code  fffc3dd8 18
  FMTK_IO.badDev                             code  fffc3e18 18
  FMTK_IO.badFunc                            code  fffc3e10 18
  FMTK_IO.xit                                code  fffc3e0c 18
  FMTK_Initialize                            code  80000000000001f8 32
  FMTK_KillTask                              code  fffc307c 18
  FMTK_KillTask.immortal                     code  fffc3150 18
  FMTK_KillTask.lock                         code  fffc30b0 18
  FMTK_PeekMsg                               code  fffc35b4 18
  FMTK_PeekMsg.badMbx                        code  fffc36c4 18
  FMTK_PeekMsg.lock                          code  fffc35ec 18
  FMTK_PeekMsg.noMsg                         code  fffc36b8 18
  FMTK_PeekMsg.nod1                          code  fffc367c 18
  FMTK_PeekMsg.nod2                          code  fffc3694 18
  FMTK_PeekMsg.nod3                          code  fffc36ac 18
  FMTK_PeekMsg.nodq                          code  fffc365c 18
  FMTK_PeekMsg.ret                           code  fffc36c8 18
  FMTK_PostMsg                               code  8000000000000200 32
  FMTK_ReleaseIOFocus                        code  fffc3cf4 18
  FMTK_RequestIOFocus                        code  fffc3c5c 18
  FMTK_RequestIOFocus.notEmpty               code  fffc3cd4 18
  FMTK_RequestIOFocus.ret                    code  fffc3cec 18
  FMTK_SaveContext                           code  fffc28a4 18
  FMTK_SchedulerIRQ                          code  fffc2c7c 18
  FMTK_SchedulerIRQ.0001                     code  fffc2d30 18
  FMTK_SchedulerIRQ.noTimeout                code  fffc2d64 18
  FMTK_SchedulerIRQ.notZero                  code  fffc2d64 18
  FMTK_SendMsg                               code  fffc3420 18
  FMTK_SendMsg.0001                          code  fffc3498 18
  FMTK_SendMsg.badMbx                        code  fffc357c 18
  FMTK_SendMsg.lock                          code  fffc3464 18
  FMTK_SendMsg.mbxEmpty                      code  fffc355c 18
  FMTK_SendMsg.noMsg                         code  fffc3570 18
  FMTK_SendMsg.noWaiters                     code  fffc3508 18
  FMTK_SendMsg.nxtTid                        code  fffc34e8 18
  FMTK_SendMsg.xit                           code  fffc3580 18
  FMTK_SetTaskPriority                       code  80000000000001fc 32
  FMTK_Sleep                                 code  fffc2bc0 18
  FMTK_Sleep.0001                            code  fffc2c40 18
  FMTK_Sleep.alreadyLocked                   code  fffc2c70 18
  FMTK_Sleep.go                              code  fffc2bc8 18
  FMTK_Sleep.lock                            code  fffc2bf8 18
  FMTK_StartApp                              code  8000000000000204 32
  FMTK_StartTask                             code  fffc2e88 18
  FMTK_StartTask.alreadyLocked               code  fffc3040 18
  FMTK_StartTask.err                         code  fffc300c 18
  FMTK_StartTask.err2                        code  fffc3034 18
  FMTK_StartTask.lock                        code  fffc2eb8 18
  FMTK_StartTask.xit                         code  fffc3000 18
  FMTK_SwitchIOFocus                         code  fffc3ba4 18
  FMTK_SwitchIOFocus.0001                    code  fffc3be8 18
  FMTK_SwitchIOFocus.0002                    code  fffc3c00 18
  FMTK_SwitchIOFocus.0003                    code  fffc3c24 18
  FMTK_SwitchIOFocus.0004                    code  fffc3c3c 18
  FMTK_SwitchIOFocus.noFocus                 code  fffc3c4c 18
  FMTK_SwitchIOFocus.sameFocus               code  fffc3c4c 18
  FMTK_WaitMsg                               code  fffc36fc 18
  FMTK_WaitMsg.lock                          code  fffc3748 18
  FMTK_WaitMsg.qt                            code  fffc3720 18
  FMTK_WaitMsg.xit                           code  fffc37e0 18
  FNDLN                                      code  fffc6fe0 18
  FNDLNP                                     code  fffc7000 18
  FNDNXT                                     code  fffc7068 18
  FNDRET                                     code  fffc703c 18
  FNDRET.0001                                code  fffc7040 18
  FNDRET1                                    code  fffc7058 18
  FNDRET2                                    code  fffc7060 18
  FNDSKP                                     code  fffc706c 18
  FOR                                        code  fffc5edc 18
  FORCEFIT                                   code  fffc6708 18
  FORCEFIT.0001                              code  fffc672c 18
  FORCEFIT.intAnd                            code  fffc671c 18
  FR1                                        code  fffc5f08 18
  FR2                                        code  fffc5f30 18
  FR3                                        code  fffc5f38 18
  FR4                                        code  fffc5f3c 18
  FR5                                        code  fffc5f4c 18
  FR6                                        code  fffc5f94 18
  FR7                                        code  fffc5f98 18
  FR8                                        code  fffc5fb8 18
  FUNCEXPR                                   code  fffc6988 18
  FillMem                                    code  fffc074c 18
  FillMem.0001                               code  fffc0774 18
  FindRun                                    code  fffc158c 18
  FindRun.0001                               code  fffc15b0 18
  FindRun.0002                               code  fffc15c4 18
  FindRun.0003                               code  fffc15a8 18
  FindRun.empty0                             code  fffc15cc 18
  FindRun.empty1                             code  fffc15d0 18
  FindRun.foundEnough                        code  fffc15f0 18
  FindStackRun                               code  fffc15fc 18
  FindStackRun.0001                          code  fffc1620 18
  FindStackRun.0002                          code  fffc1634 18
  FindStackRun.0003                          code  fffc161c 18
  FindStackRun.empty0                        code  fffc163c 18
  FindStackRun.empty1                        code  fffc163c 18
  FindStackRun.foundEnough                   code  fffc165c 18
  FreeAll                                    code  fffc17d0 18
  FreeAll.0001                               code  fffc1838 18
  FreeAll.nxt                                code  fffc17d8 18
  FreeMsg                                   const  024350 19
  FreeTCB                                    code  fffc3938 18
  GCHAR                                      code  fffc6258 18
  GCHAR1                                     code  fffc6270 18
  GETLN                                      code  fffc6ed4 18
  GETLN.GL1                                  code  fffc6ef8 18
  GETLN.GL2                                  code  fffc6f20 18
  GETLN.GL3                                  code  fffc6f54 18
  GETLN.GL4                                  code  fffc6f80 18
  GETLN.GL5                                  code  fffc6f98 18
  GETLN.GL6                                  code  fffc6fb8 18
  GETLN.GL7                                  code  fffc6fc4 18
  GOAUXI                                     code  fffc5618 18
  GOAUXO                                     code  fffc5610 18
  GOBYE                                      code  fffc5620 18
  GOIN                                       code  fffc560c 18
  GOOUT                                      code  fffc5608 18
  GOSTART                                    code  fffc5600 18
  GOSUB                                      code  fffc5e00 18
  GOTO                                       code  fffc5c40 18
  GOWARM                                     code  fffc5604 18
  GetBuflen                                  code  fffc58a0 18
  GetBuflen.0001                             code  fffc58c8 18
  GetBuflen.0002                             code  fffc58ac 18
  GetBuflen.0004                             code  fffc58c4 18
  GetCurrentTid                              code  fffc27dc 18
  GetFilename                                code  fffc62bc 18
  GetHexNum                                  code  fffc07bc 18
  GetHexNum.0001                             code  fffc0814 18
  GetHexNum.isDigit                          code  fffc085c 18
  GetHexNum.isHexLower                       code  fffc0840 18
  GetHexNum.isHexUpper                       code  fffc0824 18
  GetHexNum.next                             code  fffc07d0 18
  Getch                                      code  fffc02d4 18
  IF0                                        code  fffc607c 18
  IF1                                        code  fffc6080 18
  IF2                                        code  fffc6088 18
  IF3                                        code  fffc609c 18
  IGB1                                       code  fffc74c0 18
  IGB2                                       code  fffc74ac 18
  IGBRET                                     code  fffc74c8 18
  IGNBLK                                     code  fffc74a4 18
  INBUF                                     const  014100 18
  INCH                                       code  fffc7788 18
  INCH1                                      code  fffc77ac 18
  INPERR                                     code  fffc60a0 18
  INPPTR                                    const  0300ac 19
  INPUT                                      code  fffc60d4 18
  INSLINE                                    code  fffc57e0 18
  INSLINE.0001                               code  fffc580c 18
  IOF_NEXT                                  const  0002e8 11
  IOF_PREV                                  const  0002f0 11
  IOFocusNdx                                const  024810 19
  IOFocusTbl                                const  024818 19
  IP2                                        code  fffc60fc 18
  IP3                                        code  fffc6138 18
  IP4                                        code  fffc61ac 18
  IP5                                        code  fffc61bc 18
  IP6                                        code  fffc60dc 18
  IP7                                        code  fffc611c 18
  IRQFlag                                   const  0300b4 19
  IRQROUT                                   const  0300a4 19
  IRQRout                                    code  fffc0a54 18
  IRQRout.cause0to7                          code  fffc0b40 18
  IRQRout.cause12plus                        code  fffc0b78 18
  IRQRout.doIRQ                              code  fffc0ac8 18
  IRQRout.doMsgReserved                      code  fffc0b68 18
  IRQRout.isIRQ                              code  fffc0a8c 18
  IRQRout.noIRQ                              code  fffc0b08 18
  IRQRout.notPfi                             code  fffc0ae8 18
  IdleTask                                   code  fffc02d0 18
  InitialPidmap                              code  fffc2670 18
  InsertIntoReadyList                        code  fffc37f0 18
  InsertIntoReadyList.badTid                 code  fffc3828 18
  InsertIntoTimeoutList                      code  fffc3864 18
  InsertLine                                 code  fffc5880 18
  InsertLine.0001                            code  fffc5884 18
  InsertLine.done                            code  fffc589c 18
  KEYBD                                      code  80000000000002af 32
  KTAlreadyLocked                            code  800000000000024a 32
  KTlreadyLocked                             code  fffc3160 18
  KeybdFuncTbl                               code  fffc4150 18
  KeybdIRQ                                   code  fffc4580 18
  KeybdIRQ.0001                              code  fffc4618 18
  KeybdIRQ.noRoom                            code  fffc45c4 18
  KeybdIRQ.notAlt                            code  80000000000002c9 32
  KeybdIRQ.notAltTab                         code  fffc463c 18
  KeybdIRQ.notCtrl                           code  fffc4618 18
  KeybdIRQ.notCtrlC                          code  fffc45f4 18
  KeybdIRQ.notCtrlZ                          code  fffc4618 18
  KeybdIRQ.notKbd                            code  fffc4680 18
  KillTask                                   code  8000000000000247 32
  LEDS                                      const  ffdc0600 33
  LET                                        code  fffc61d4 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc5d0c 18
  LNFD                                      const  00000a 5
  LOAD                                       code  fffc61ec 18
  LOAD3                                      code  fffc6340 18
  LOAD4                                      code  fffc636c 18
  LOAD5                                      code  fffc63a4 18
  LOD1                                       code  fffc61fc 18
  LOD2                                       code  fffc6228 18
  LODEND                                     code  fffc6244 18
  LOG_MBXSZ                                 const  000005 4
  LOG_MSGSZ                                 const  000005 4
  LOG_PGSZ                                  const  000010 6
  LOG_TCBSIZE                                code  8000000000000214 32
  LOG_TCBSZ                                 const  00000a 5
  LOPINC                                    const  030078 19
  LOPLMT                                    const  03007c 19
  LOPLN                                     const  030074 19
  LOPPT                                     const  030070 19
  LOPVAR                                    const  030010 19
  LS1                                        code  fffc5d20 18
  LS2                                        code  fffc5d54 18
  LS3                                        code  fffc5d5c 18
  LS4                                        code  fffc5d38 18
  LS5                                        code  fffc5d24 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc61e8 18
  LoadWord                                   code  fffc735c 18
  MAX_ASID                                  const  00001f 6
  MAX_DEV_OP                                const  00001f 6
  MAX_MID                                   const  00001f 6
  MAX_TID                                   const  00003f 7
  MBX_MQHEAD                                const  000010 6
  MBX_MQTAIL                                const  000018 6
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000020 7
  MBX_WTIDS                                 const  000008 5
  MMUInit                                    code  fffc14c8 18
  MMUInit.0001                               code  fffc1500 18
  MMUInit.0002                               code  fffc156c 18
  MMUInit.0004                               code  fffc14f0 18
  MMUInit.0006                               code  fffc152c 18
  MSG_D1                                    const  000008 5
  MSG_D2                                    const  000010 6
  MSG_D3                                    const  000018 6
  MSG_LINK                                  const  000000 1
  MSG_SIZE                                  const  000020 7
  MULEXPR                                    code  fffc68ec 18
  MVDOWN                                     code  fffc70a8 18
  MVDOWN1                                    code  fffc7098 18
  MVUP                                       code  fffc7090 18
  MVUP1                                      code  fffc7080 18
  MachineStart                               code  fffc0100 18
  MachineStart.0001                          code  fffc01b4 18
  MachineStart.hart00                        code  fffc0120 18
  MachineStart.hart20                        code  fffc0118 18
  MachineStart.skip1                         code  fffc01ec 18
  MachineStart.skip2                         code  fffc021c 18
  MachineStart.skipInit                      code  fffc01b4 18
  MapOSPages                                 code  fffc27f8 18
  MapOSPages.failed                          code  fffc2830 18
  MapOSPages.nxt                             code  fffc2804 18
  MbxRemoveTask                              code  fffc31b0 18
  MbxRemoveTask.xit                          code  fffc3200 18
  MonEntry                                   code  fffc03c4 18
  Monitor                                    code  fffc03cc 18
  Monitor.0001                               code  fffc03f8 18
  Monitor.0002                               code  fffc0454 18
  Monitor.0003                               code  fffc04c0 18
  Monitor.0004                               code  fffc0558 18
  Monitor.0005                               code  fffc0684 18
  Monitor.0006                               code  fffc05d4 18
  Monitor.0007                               code  fffc060c 18
  Monitor.0008                               code  fffc061c 18
  Monitor.0009                               code  fffc062c 18
  Monitor.0010                               code  fffc0648 18
  Monitor.0011                               code  fffc0668 18
  Monitor.0012                               code  fffc0684 18
  Monitor.doBackspace                        code  fffc04a8 18
  Monitor.doDelete                           code  fffc0448 18
  Monitor.noT                                code  fffc0600 18
  Monitor.procLine                           code  fffc0514 18
  Monitor.skip                               code  fffc052c 18
  Monitor.skip2                              code  fffc054c 18
  NEW                                        code  fffc5ae8 18
  NEXT                                       code  fffc5fbc 18
  NPAGES                                    const  024828 19
  NR_DCB                                    const  000020 7
  NR_MBX                                    const  000100 10
  NR_MSG                                    const  000800 13
  NR_TCB                                    const  000020 7
  NUMWKA                                    const  030094 19
  NX0                                        code  fffc5fd8 18
  NX1                                        code  fffc603c 18
  NX2                                        code  fffc6004 18
  NX3                                        code  fffc6040 18
  NX4                                        code  fffc5fd4 18
  NX5                                        code  fffc5ff8 18
  NXPurge                                    code  fffc6074 18
  OKMSG                                      code  fffc7802 18
  ONIRQ                                      code  fffc5cb0 18
  ONIRQ1                                     code  fffc5cdc 18
  OREXPR                                     code  fffc65d8 18
  OSCALL                                     code  fffc2a98 18
  OSCALL.biosXit                             code  fffc2b34 18
  OSCALL.biosZero                            code  fffc2bb8 18
  OSCALL.lock                                code  fffc2adc 18
  OSCALL.oscall                              code  fffc2b60 18
  OSCALL.xit                                 code  fffc2b94 18
  OSCALL.zero                                code  fffc2bb0 18
  OSCallTbl                                  code  fffc2618 18
  OSPAGES                                   const  000003 3
  OSSP                                      const  030000 19
  OUTC                                       code  fffc7784 18
  OUTPTR                                    const  0300a8 19
  OpenSpace                                  code  fffc58cc 18
  OpenSpace.0003                             code  fffc5908 18
  OpenSpace.noSpace                          code  fffc5924 18
  PAGESZ                                    const  010000 18
  PAGES_PER_MAP                             const  001000 14
  PAGES_PER_TASK                            const  001000 14
  PARN                                       code  fffc69d8 18
  PEEK                                       code  fffc6bec 18
  PEEKH                                      code  fffc6c1c 18
  PEEKW                                      code  fffc6c04 18
  PIC                                       const  ffdc0f00 33
  PIC_CH16                                  const  0000c0 9
  PIC_CH28                                  const  0000f0 9
  PIC_CH31                                  const  0000fc 9
  PIDMAP                                    const  024310 19
  PKER                                       code  fffc65a0 18
  POKE                                       code  fffc651c 18
  POKEH                                      code  fffc6574 18
  POKEW                                      code  fffc6548 18
  POPA_                                      code  fffc70b0 18
  PP1                                        code  fffc7120 18
  PR0                                        code  fffc5d8c 18
  PR1                                        code  fffc5da4 18
  PR2                                        code  fffc5d78 18
  PR3                                        code  fffc5dc4 18
  PR4                                        code  fffc5dbc 18
  PR6                                        code  fffc5dd8 18
  PR8                                        code  fffc5de0 18
  PRINT                                      code  fffc5d60 18
  PRMESG                                     code  fffc7588 18
  PRNGL                                     const  ffdc0c00 33
  PRNG_STREAM                               const  000008 5
  PRNG_VALUE                                const  000000 1
  PRTLN                                      code  fffc7388 18
  PRTNUM                                     code  fffc72ac 32
  PRTNUM.PN1                                 code  fffc72e4 18
  PRTNUM.PN2                                 code  fffc72e0 18
  PRTNUM.PN3                                 code  fffc730c 18
  PRTNUM.PN4                                 code  fffc731c 18
  PRTNUM.PN5                                 code  fffc7328 18
  PRTNUM.PN6                                 code  fffc7330 18
  PRTNUM.PN7                                 code  fffc72f4 18
  PRTSTG                                     code  fffc71b0 18
  PRTSTG.PRTRET                              code  fffc71f4 18
  PRTSTG.PS1                                 code  fffc71d0 18
  PU1                                        code  fffc71a4 18
  PUSHA_                                     code  fffc7124 18
  PWORD                                      code  fffc64a4 18
  PicInit                                    code  fffc187c 18
  PutHexByte                                 code  fffc08e0 18
  PutHexDword                                code  fffc0874 18
  PutHexHalf                                 code  fffc08bc 18
  PutHexNybble                               code  fffc0904 18
  PutHexNybble.0001                          code  fffc0940 18
  PutHexNybble.lt10                          code  fffc0934 18
  PutHexWord                                 code  fffc0898 18
  PutString                                  code  fffc0950 18
  PutString.0001                             code  fffc0960 18
  PutString.done                             code  fffc0978 18
  Putch                                      code  fffc0304 18
  QNDX                                      const  024304 19
  QSORRY                                     code  fffc6e64 18
  QT1                                        code  fffc7230 18
  QT2                                        code  fffc7270 18
  QT3                                        code  fffc7248 18
  QT4                                        code  fffc725c 18
  QT5                                        code  fffc727c 18
  QTSTG                                      code  fffc7218 18
  QWHAT                                      code  fffc6e70 18
  RDYQ0                                     const  024400 19
  RDYQ1                                     const  024500 19
  RDYQ2                                     const  024600 19
  RDYQ3                                     const  024700 19
  READYQ                                    const  024308 19
  RETURN                                     code  fffc5e74 18
  RND                                        code  fffc6c80 18
  RUN                                        code  fffc5b1c 18
  RUN1                                       code  fffc5bf4 18
  RUN2                                       code  fffc5b50 18
  RUN3                                       code  fffc5b54 18
  RUNNXL                                     code  fffc5b3c 18
  RUNSML                                     code  fffc5c28 18
  RUNTSL                                     code  fffc5c14 18
  RemoveFromReadyList                        code  fffc3838 18
  RemoveFromReadyList.tidOk                  code  fffc384c 18
  RemoveFromTimeoutList                      code  fffc3880 18
  RemoveFromTimeoutList.noWait               code  fffc38a4 18
  RestoreContext                             code  fffc296c 18
  RestoreContext.rsseg                       code  fffc297c 18
  RunTask                                    code  fffc2d74 18
  RunTask.0002                               code  fffc2ddc 18
  RunTask.0003                               code  fffc2df8 18
  RunTask.0004                               code  fffc2e14 18
  RunTask.noException                        code  fffc2db0 18
  RunTask.noMsg                              code  fffc2e20 18
  SAVE                                       code  fffc6414 18
  SAVE1                                      code  fffc642c 18
  SAVE2                                      code  fffc6448 18
  SAVE3                                      code  fffc63a8 18
  SAVE4                                      code  fffc63d8 18
  SAVEND                                     code  fffc6460 18
  SC_C                                      const  000021 7
  SC_TAB                                    const  00000d 5
  SC_Z                                      const  00001a 6
  SDReadSector                               code  800000000000041d 32
  SDWriteSector                              code  8000000000000422 32
  SENDMSG                                    code  fffc7610 18
  SENDMSG.err                                code  fffc7694 18
  SENDMSG.paren                              code  fffc76a0 18
  SETVAL                                     code  fffc6d84 18
  SETVAL.sv2                                 code  fffc6da8 18
  SGN                                        code  fffc6d14 18
  SGN1                                       code  fffc6d44 18
  SGN2                                       code  fffc6d34 18
  SIZEX                                      code  fffc6d50 18
  SRYMSG                                     code  fffc780f 18
  ST2                                        code  fffc57bc 18
  STACKOFFS                                 const  afffc000 33
  STKBOT                                    const  03009c 19
  STKGOS                                    const  030014 19
  STKINP                                    const  030098 19
  STOP                                       code  fffc5b08 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc6de4 18
  SYSX                                       code  fffc65ac 18
  SYS_MUTEX                                 const  ffdbff00 33
  SaveContext                                code  fffc28ac 18
  SaveContext.svseg                          code  fffc2944 18
  SaveContext.xit                            code  fffc2968 18
  SelectTaskToRun                            code  fffc2834 18
  SelectTaskToRun.0001                       code  fffc287c 18
  SelectTaskToRun.dq                         code  fffc289c 18
  SelectTaskToRun.goodTid                    code  fffc289c 18
  SelectTaskToRun.nxtQ                       code  fffc2870 18
  SelectTaskToRun.searchQ                    code  fffc2834 18
  SerHeadRcv                                const  025800 19
  SerHeadXmit                               const  025808 19
  SerRcvBuf                                 const  025000 19
  SerRcvXoff                                const  025811 19
  SerRcvXon                                 const  025810 19
  SerTailRcv                                const  025804 19
  SerTailXmit                               const  02580c 19
  SerXmitBuf                                const  025400 19
  SerialFinishCmd                            code  fffc1af4 18
  SerialFinishCmd.0001                       code  fffc1b18 18
  SerialFuncTbl                              code  fffc18b0 18
  SerialGetChar                              code  fffc1b1c 18
  SerialGetChar.0001                         code  fffc1bdc 18
  SerialGetChar.0002                         code  fffc1b88 18
  SerialGetChar.noChars                      code  fffc1bdc 18
  SerialGetChar.xit                          code  fffc1be4 18
  SerialIRQ                                  code  fffc1d88 18
  SerialIRQ.0001                             code  fffc1e38 18
  SerialIRQ.notRxInt                         code  fffc1e4c 18
  SerialIRQ.nxtByte                          code  fffc1d88 18
  SerialIRQ.rxFull                           code  fffc1e4c 18
  SerialInit                                 code  fffc19b0 18
  SerialPeekChar                             code  fffc1bfc 18
  SerialPeekChar.0001                        code  fffc1c48 18
  SerialPeekChar.noChars                     code  fffc1c48 18
  SerialPeekChar.xit                         code  fffc1c4c 18
  SerialPeekCharDirect                       code  fffc1c64 18
  SerialPeekCharDirect.0001                  code  fffc1ca4 18
  SerialPeekCharDirect.xit                   code  fffc1ca8 18
  SerialPutChar                              code  fffc1cc0 18
  SerialPutChar.0001                         code  fffc1cd8 18
  SerialPutChar.0002                         code  fffc1cd4 18
  SerialPutChar.goSleep                      code  fffc1d1c 18
  SerialRcvCount                             code  fffc1d4c 18
  SerialRcvCount.xit                         code  fffc1d80 18
  SerialService                              code  fffc1a9c 18
  SerialServiceInit                          code  fffc1a84 18
  SerialServiceLoop                          code  fffc1ab8 18
  SkipSpaces                                 code  fffc0788 18
  SkipSpaces.skip1                           code  fffc07b0 18
  SkipSpaces.skip2                           code  fffc0788 18
  SpriteDemo_101                             code  fffc7e58 18
  SpriteDemo_103                             code  fffc7e78 18
  SpriteDemo_104                             code  fffc7eec 18
  SpriteDemo_106                             code  fffc7efc 18
  SpriteDemo_107                             code  fffc7f3c 18
  SpriteDemo_109                             code  fffc7f3c 18
  SpriteDemo_114                             code  fffc7f70 18
  SpriteDemo_115                             code  fffc7f84 18
  SpriteDemo_117                             code  fffc7f90 18
  SpriteDemo_118                             code  fffc80dc 18
  SpriteDemo_120                             code  fffc801c 18
  SpriteDemo_122                             code  fffc8054 18
  SpriteDemo_124                             code  fffc8090 18
  SpriteDemo_126                             code  fffc80ac 18
  SpriteDemo_17                              code  fffc7a58 18
  SpriteDemo_25                              code  fffc7af0 18
  SpriteDemo_28                              code  fffc7af0 18
  SpriteDemo_29                              code  fffc7aac 18
  SpriteDemo_30                              code  fffc7af0 18
  SpriteDemo_39                              code  fffc7b54 18
  SpriteDemo_47                              code  fffc7c58 18
  SpriteDemo_50                              code  fffc7c58 18
  SpriteDemo_51                              code  fffc7bd4 18
  SpriteDemo_52                              code  fffc7c58 18
  SpriteDemo_9                               code  fffc7a04 18
  SpriteDemo_91                              code  fffc810c 18
  SpriteDemo_94                              code  fffc810c 18
  SpriteDemo_95                              code  fffc7d54 18
  SpriteDemo_96                              code  fffc7db8 18
  SpriteDemo_98                              code  fffc7dcc 18
  SpriteDemo_99                              code  fffc7e68 18
  SpriteDemo_longlit0                      rodata  fffc9020 32
  SwapContext                                code  fffc2a28 18
  SwapContext.noCtxSwitch                    code  fffc2a94 18
  SwapContext.rsseg                          code  fffc2a68 18
  SwapContext.savedAlready                   code  fffc2a64 18
  SwapContext.svseg                          code  fffc2a44 18
  SwitchIOFocus                             const  024820 19
  SysSema                                   const  024340 19
  TAB                                       const  000009 5
  TAB1                                       code  fffc592c 18
  TAB10                                      code  fffc59e6 18
  TAB10_1                                    code  fffc5a56 18
  TAB1_1                                     code  fffc59ea 18
  TAB2                                       code  fffc593e 18
  TAB2_1                                     code  fffc59f4 18
  TAB4                                       code  fffc5997 18
  TAB4_1                                     code  fffc5a22 18
  TAB5                                       code  fffc59d0 18
  TAB5_1                                     code  fffc5a3c 18
  TAB6                                       code  fffc59d3 18
  TAB6_1                                     code  fffc5a40 18
  TAB8                                       code  fffc59d8 18
  TAB8_1                                     code  fffc5a44 18
  TAB9                                       code  fffc59e2 18
  TAB9_1                                     code  fffc5a52 18
  TC1                                        code  fffc7418 18
  TC64CursorAddr                            const  ffd1df1c 33
  TCBAffinity                               const  00028b 11
  TCBContextSaved                           const  00028a 11
  TCBElapsedTime                            const  0002c0 11
  TCBEndTime                                const  0002b8 11
  TCBException                              const  0002c8 11
  TCBKbdBuf                                 const  000308 11
  TCBKbdHead                                const  000300 11
  TCBKbdState2                               code  80000000000002c4 32
  TCBKbdTail                                const  000301 11
  TCBMsgD1                                  const  000298 11
  TCBMsgD2                                  const  0002a0 11
  TCBMsgD3                                  const  0002a8 11
  TCBName                                   const  0002f8 11
  TCBNext                                   const  0002d0 11
  TCBPrev                                   const  0002d8 11
  TCBPriority                               const  000289 11
  TCBResource                               const  000328 11
  TCBStackBot                               const  000290 11
  TCBStartTime                              const  0002b0 11
  TCBStatus                                 const  000288 11
  TCBTimeout                                const  0002e0 11
  TCBVidMem                                  code  800000000000024f 32
  TCBVideoMem                               const  000330 11
  TCBWaitMbx                                const  00028c 11
  TCBepc                                    const  000280 11
  TCBpVideo                                 const  000338 11
  TCBsegs                                   const  000200 11
  TCBxra                                    const  000340 11
  TICKX                                      code  fffc6d00 18
  TN1                                        code  fffc7448 18
  TN2                                        code  fffc7474 18
  TOOBIG                                     code  fffc6e58 18
  TOUPB1                                     code  fffc74e8 18
  TOUPBRT                                    code  fffc7530 18
  TOUPBUF                                    code  fffc74d4 18
  TOUPRET                                    code  fffc7554 18
  TSNMRET                                    code  fffc7494 18
  TSTC                                       code  fffc73e4 18
  TSTNUM                                     code  fffc7430 18
  TSTV                                       code  fffc6a18 18
  TSTVRT                                     code  fffc6a94 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc6a80 18
  TV2                                        code  fffc6a68 18
  TV3                                        code  fffc6a48 18
  TXTBGN                                    const  031800 19
  TXTUNF                                    const  030004 19
  Tick                                      const  024330 19
  TimeoutList                               const  024328 19
  TinyBasic                                  code  fffc5600 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  USRX                                       code  fffc6c34 18
  UpdateCursorPos                            code  fffc2214 18
  UserStart2                                 code  fffc0228 18
  UserStart2.0002                            code  fffc028c 18
  UserStart2.0003                            code  fffc02b0 18
  UserStart2.0004                            code  fffc028c 18
  UserStart2.0005                            code  fffc028c 18
  UserStart2.skip1                           code  fffc0238 18
  VARBGN                                    const  030008 19
  VAREND                                    const  03000c 19
  VIA                                       const  ffdc0600 33
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IER                                   const  000038 7
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  ViaFuncTbl                                 code  fffc1e60 18
  ViaIRQ                                     code  fffc1fc8 18
  ViaIRQ.0003                                code  fffc2028 18
  ViaIRQ.hart20                              code  fffc2024 18
  ViaInit                                    code  fffc1f60 18
  VideoClearScreen                           code  fffc21b0 18
  VideoClearScreen.0001                      code  fffc21dc 18
  VideoFuncTbl                               code  fffc2030 18
  VideoHomeCursor                            code  fffc21f4 18
  VideoIRQ                                   code  fffc2614 18
  VideoIRQ.0003                              code  fffc2614 18
  VideoInit                                  code  fffc2130 18
  VideoPutChar                               code  fffc2258 18
  VideoPutChar.0001                          code  fffc2388 18
  VideoPutChar.backspace                     code  fffc2514 18
  VideoPutChar.bll1                          code  fffc23b8 18
  VideoPutChar.bs0001                        code  fffc2598 18
  VideoPutChar.bs0002                        code  fffc2580 18
  VideoPutChar.cr1                           code  fffc2474 18
  VideoPutChar.cr2                           code  fffc246c 18
  VideoPutChar.cursorDown                    code  fffc24d0 18
  VideoPutChar.cursorLeft                    code  fffc2478 18
  VideoPutChar.cursorRight                   code  fffc243c 18
  VideoPutChar.cursorUp                      code  fffc24a4 18
  VideoPutChar.del0001                       code  fffc253c 18
  VideoPutChar.delete                        code  fffc25b8 18
  VideoPutChar.doCR                          code  fffc240c 18
  VideoPutChar.doCls                         code  fffc2500 18
  VideoPutChar.doLF                          code  fffc2428 18
  VideoPutChar.doLF1                         code  fffc234c 18
  VideoPutChar.saveX                         code  fffc23f0 18
  VideoPutChar.saveY                         code  fffc23e0 18
  VideoPutChar.xit                           code  fffc23cc 18
  VideoPutString                             code  fffc25d0 18
  VideoPutString.again                       code  fffc25d8 18
  VideoPutString.done                        code  fffc2604 18
  VirtToPhys                                 code  fffc183c 18
  VirtToPhys.notMapped                       code  fffc1874 18
  WAITIRQ                                    code  fffc5cf0 18
  WAITMSG                                    code  fffc76ac 18
  WAITMSG.0001                               code  fffc76e4 18
  WAITMSG.0002                               code  fffc76d8 18
  WAITMSG.err                                code  fffc776c 18
  WAITMSG.paren                              code  fffc7778 18
  WSTART                                     code  fffc5724 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc675c 18
  XP12                                       code  fffc6774 18
  XP13                                       code  fffc678c 18
  XP14                                       code  fffc67a4 18
  XP15                                       code  fffc67bc 18
  XP16                                       code  fffc67d4 18
  XP17                                       code  fffc6814 18
  XP18                                       code  fffc682c 18
  XP21                                       code  fffc687c 18
  XP22                                       code  fffc6888 18
  XP23                                       code  fffc688c 18
  XP24                                       code  fffc68a8 18
  XP25                                       code  fffc68bc 18
  XP26                                       code  fffc68c8 18
  XP31                                       code  fffc68f8 18
  XP34                                       code  fffc6928 18
  XP35                                       code  fffc694c 18
  XP40                                       code  fffc69a4 18
  XP41                                       code  fffc69c0 18
  XP42                                       code  fffc69fc 18
  XP43                                       code  fffc6a08 18
  XP45                                       code  fffc68d4 18
  XP46                                       code  fffc69cc 18
  XP47                                       code  fffc6970 18
  XPRT0                                      code  fffc67ec 18
  XPRT1                                      code  fffc6800 18
  XP_AND                                     code  fffc666c 18
  XP_AND1                                    code  fffc664c 18
  XP_ANDX                                    code  fffc6680 18
  XP_OR                                      code  fffc660c 18
  XP_OR1                                     code  fffc65ec 18
  XP_ORX                                     code  fffc6620 18
  YIELD0                                     code  fffc5b10 18
  _ACBPtrs                                 rodata  000000 32
  _Alloc                                   rodata  fffc1750 32
  _Alloc.ok                                  code  fffc1764 18
  _BIOS1_sema                              rodata  000000 32
  _BIOS_RespMbx                            rodata  000000 32
  _DBGAttr                                 rodata  000000 32
  _DBGBlankLine                              code  fffc4e30 32
  _DBGCRLF                                   code  fffc5320 32
  _DBGCheckForKey                            code  fffc47b0 32
  _DBGClearScreen                            code  fffc4d00 32
  _DBGCursorCol                            rodata  000000 32
  _DBGCursorRow                            rodata  000000 32
  _DBGDisplayAsciiString                     code  fffc53e4 32
  _DBGDisplayAsciiStringCRLF                 code  fffc5488 32
  _DBGDisplayChar                            code  fffc5020 32
  _DBGDisplayString                          code  fffc5380 32
  _DBGDisplayStringCRLF                      code  fffc5448 32
  _DBGGetKey                                 code  fffc47f0 32
  _DBGHideCursor                           rodata  fffc54c8 32
  _DBGHomeCursor                             code  fffc4df0 32
  _DBGIncrementCursorPos                     code  fffc4fc8 32
  _DBGIncrementCursorRow                     code  fffc4f68 32
  _DBGScrollUp                               code  fffc4ed0 32
  _DBGUpdateCursorPos                        code  fffc4d7c 32
  _DeviceTable                             rodata  000000 32
  _DumpTaskList                            rodata  000000 32
  _EnableSprite                              code  fffc79d0 32
  _EnableSprites                             code  fffc7a0c 32
  _FMTK_Inited                             rodata  000000 32
  _FMTK_Reschedule                         rodata  000000 32
  _FMTK_SendMsg                            rodata  000000 32
  _FMTK_StartApp                           rodata  000000 32
  _FMTK_StartThread                        rodata  000000 32
  _FMTK_WaitMsg                            rodata  000000 32
  _FocusSwitcher                           rodata  000000 32
  _GetACBPtr                               rodata  000000 32
  _GetAppHandle                            rodata  000000 32
  _GetRand                                 rodata  fffc4774 32
  _GetRunningACBPtr                        rodata  000000 32
  _GetVecno                                rodata  000000 32
  _IOFocusNdx                              rodata  000000 32
  _IOFocusTbl                              rodata  000000 32
  _InsertIntoReadyList                     rodata  000000 32
  _InsertIntoTimeoutList                   rodata  000000 32
  _KeyLED                                  rodata  024826 32
  _KeyState1                               rodata  024824 32
  _KeyState2                               rodata  024825 32
  _KeybdClearRcv                           rodata  000000 32
  _KeybdGetBufferStatus                      code  fffc468c 18
  _KeybdGetBufferStatus.empty                code  fffc46ac 18
  _KeybdGetBufferedScancode                  code  fffc46b8 18
  _KeybdGetBufferedScancode.empty            code  fffc46e8 18
  _KeybdGetID                                code  fffc43dc 18
  _KeybdGetID.0001                           code  fffc442c 18
  _KeybdGetID.notKbd                         code  fffc444c 18
  _KeybdGetScancode                        rodata  fffc455c 32
  _KeybdGetStatus                          rodata  fffc4534 32
  _KeybdID                                   code  80000000000002bc 32
  _KeybdInit                                 code  fffc4250 18
  _KeybdInit.0002                            code  fffc428c 18
  _KeybdInit.0004                            code  fffc4334 18
  _KeybdInit.config                          code  fffc42d8 18
  _KeybdInit.keybdErr                        code  fffc431c 18
  _KeybdInit.ledxit                          code  fffc4360 18
  _KeybdInit.tryAgain                        code  fffc4310 18
  _KeybdInit.xit                             code  fffc437c 18
  _KeybdPeekScancode                         code  fffc4548 18
  _KeybdRecvByte                             code  fffc4458 18
  _KeybdRecvByte.0003                        code  fffc4464 18
  _KeybdRecvByte.0004                        code  fffc44a8 18
  _KeybdSendByte                             code  fffc44bc 18
  _KeybdSetLED                             rodata  fffc438c 32
  _KeybdWaitTx                               code  fffc44d0 18
  _KeybdWaitTx.0001                          code  fffc44dc 18
  _KeybdWaitTx.0002                          code  fffc4520 18
  _LockIOFSemaphore                        rodata  000000 32
  _LockKbdSemaphore                        rodata  000000 32
  _LockSemaphore                           rodata  000000 32
  _LockSysSemaphore                        rodata  000000 32
  _MicroDelay                                code  fffc0988 18
  _MicroDelay.0001                           code  fffc098c 18
  _PRNGInit                                  code  fffc46f4 18
  _PeekRand                                  code  fffc474c 18
  _PutHexByte                                code  fffc08e0 18
  _PutHexDword                               code  fffc0874 18
  _PutHexHalf                                code  fffc08bc 18
  _PutHexNybble                              code  fffc0904 18
  _PutHexWord                              rodata  fffc0898 32
  _PutString                               rodata  fffc0950 32
  _RandomizeSpriteColors                     code  fffc7a6c 32
  _RandomizeSpritePositions                  code  fffc7b70 32
  _RemoveFromReadyList                     rodata  000000 32
  _RemoveFromTimeoutList                   rodata  000000 32
  _RequestIOFocus                          rodata  000000 32
  _SeedRand                                  code  fffc4730 18
  _SetBound48                              rodata  000000 32
  _SetBound49                              rodata  000000 32
  _SetBound50                              rodata  000000 32
  _SetBound51                              rodata  000000 32
  _SetSpritePos                              code  fffc7b08 32
  _SpriteDemo                                code  fffc7c80 32
  _TimeoutList                             rodata  000000 32
  _VirtToPhys                              rodata  fffc183c 32
  _XlatScancode                              code  fffc46f0 18
  _bios_stacks                             rodata  000000 32
  _chkTCB                                  rodata  000000 32
  _clr                                       code  fffc5c64 18
  _cls                                       code  8000000000000399 32
  _dumpaddr                                  code  fffc115c 32
  _end_init_data                           rodata  fffca000 32
  _fmtk_irq_stack                          rodata  000000 32
  _fmtk_sys_stack                          rodata  000000 32
  _freeMBX                                 rodata  000000 32
  _freeMSG                                 rodata  000000 32
  _freeTCB                                 rodata  000000 32
  _getCPU                                  rodata  000000 32
  _hFocusSwitchMbx                         rodata  000000 32
  _hasUltraHighPriorityTasks               rodata  000000 32
  _in16                                    rodata  000000 32
  _in16u                                   rodata  000000 32
  _in32                                    rodata  000000 32
  _in32u                                   rodata  000000 32
  _in64                                    rodata  000000 32
  _in8                                     rodata  000000 32
  _in8u                                    rodata  000000 32
  _iof_sema                                rodata  000000 32
  _iof_switch                              rodata  000000 32
  _irq_stack                               rodata  000000 32
  _kbd_sema                                rodata  000000 32
  _keybdControlCodes                       rodata  fffc4050 32
  _keybdExtendedCodes                      rodata  fffc40d0 32
  _mailbox                                 rodata  000000 32
  _memsetO                                 rodata  000000 32
  _memsetW                                 rodata  000000 32
  _message                                 rodata  000000 32
  _missed_ticks                            rodata  000000 32
  _mmu_Alloc512kPage                       rodata  000000 32
  _mmu_Alloc8kPage                         rodata  000000 32
  _mmu_AllocateMap                         rodata  000000 32
  _mmu_Free512kPage                        rodata  000000 32
  _mmu_Free8kPage                          rodata  000000 32
  _mmu_FreeMap                             rodata  000000 32
  _mmu_MapCardMemory                       rodata  000000 32
  _mmu_SetAccessKey                        rodata  000000 32
  _mmu_SetMapEntry                         rodata  000000 32
  _mmu_SetOperateKey                       rodata  000000 32
  _mmu_alloc                               rodata  000000 32
  _mmu_free                                rodata  000000 32
  _nMailbox                                rodata  000000 32
  _nMsgBlk                                 rodata  000000 32
  _out16                                   rodata  000000 32
  _out32                                   rodata  000000 32
  _out64                                   rodata  000000 32
  _out8                                    rodata  000000 32
  _outb                                    rodata  000000 32
  _outc                                    rodata  000000 32
  _outh                                    rodata  000000 32
  _outw                                    rodata  000000 32
  _prtnum                                  rodata  fffc72ac 32
  _putch                                   rodata  fffc0304 32
  _puthexnum                               rodata  000000 32
  _ramtest                                   code  fffc13d8 32
  _randStream                              rodata  024830 32
  _rdcf                                      code  800000000000039b 32
  _readyQ                                  rodata  000000 32
  _rmemsetW                                rodata  000000 32
  _set_vector                              rodata  000000 32
  _shiftedScanCodes                        rodata  fffc3f50 32
  _stacks                                  rodata  000000 32
  _sys_sema                                rodata  000000 32
  _sys_stacks                              rodata  000000 32
  _sysstack                                rodata  000000 32
  _tabstops                                rodata  000000 32
  _tcbs                                    rodata  000000 32
  _unshiftedScanCodes                      rodata  fffc3e50 32
  _video_bufs                              rodata  000000 32
  a2h1                                       code  fffc62b0 18
  asciiToHex                                 code  fffc62a4 18
  begin_init_data                          rodata  fffc9028 32
  clearVars                                  code  fffc5c6c 18
  clearVars.cv1                              code  fffc5c8c 18
  datAttr                                    code  fffc02c8 18
  doMem                                      code  fffc0688 18
  doMem.loop                                 code  fffc0704 18
  doMem.loop2                                code  fffc06d4 18
  ec1                                        code  fffc6e4c 18
  end_init_data                            rodata  fffca000 32
  findVar                                    code  fffc6b64 18
  fl1                                        code  fffc6ff8 18
  flt10                                      code  fffc0c78 18
  flt20                                      code  fffc0c68 18
  flt50                                      code  fffc0c58 18
  fltMillion                                 code  fffc1114 18
  fltOne                                     code  fffc110c 18
  fltTen                                     code  fffc1110 18
  fltToString                                code  fffc0d50 18
  fltToString.0001                           code  fffc0db0 18
  fltToString.0002                           code  fffc0e30 18
  fltToString.0003                           code  fffc0e1c 18
  fltToString.0004                           code  fffc0e7c 18
  fltToString.0005                           code  fffc0e74 18
  fltToString.0006                           code  fffc0e5c 18
  fltToString.0007                           code  fffc0e98 18
  fltToString.0008                           code  fffc0eac 18
  fltToString.0009                           code  fffc0ea8 18
  fltToString.0010                           code  fffc0ecc 18
  fltToString.0011                           code  fffc0f58 18
  fltToString.0012                           code  fffc0f10 18
  fltToString.0013                           code  fffc0efc 18
  fltToString.0014                           code  fffc0f2c 18
  fltToString.0015                           code  fffc0f48 18
  fltToString.0016                           code  fffc0ee4 18
  fltToString.0017                           code  fffc0f50 18
  fltToString.0018                           code  fffc0f58 18
  fltToString.0019                           code  fffc0f8c 18
  fltToString.0020                           code  fffc0f98 18
  fltToString.0021                           code  fffc0fbc 18
  fltToString.0022                           code  fffc0fc8 18
  fltToString.0023                           code  fffc0fd8 18
  fltToString.0024                           code  fffc0fe4 18
  fltToString.0025                           code  fffc0fd0 18
  fltToString.0026                           code  fffc0ff8 18
  fltToString.0027                           code  fffc1000 18
  fltToString.0028                           code  fffc1008 18
  fltToString.0029                           code  fffc1014 18
  fltToString.0030                           code  fffc1020 18
  fltToString.0031                           code  fffc102c 18
  fltToString.0032                           code  fffc1034 18
  fltToString.0034                           code  fffc103c 18
  fltToString.0035                           code  fffc1048 18
  fltToString.0036                           code  fffc1058 18
  fltToString.0037                           code  fffc1064 18
  fltToString.0038                           code  fffc106c 18
  fltToString.0039                           code  fffc1080 18
  fltToString.0040                           code  fffc1074 18
  fltToString.0041                           code  fffc10dc 18
  fltToString.0042                           code  fffc10a0 18
  fltToString.0043                           code  fffc10b0 18
  fltToString.0044                           code  fffc10c4 18
  fltToString.0045                           code  fffc10a8 18
  fltToString.0046                           code  fffc10d0 18
  fltToString.0047                           code  fffc10dc 18
  fltToString.0048                           code  fffc10c8 18
  fltToString.0050                           code  fffc10fc 18
  fltToString.0051                           code  fffc10f8 18
  fltToString.0052                           code  fffc10e8 18
  fltToString.inf                            code  fffc0d98 18
  fltToString.notZero                        code  fffc0dec 18
  fltToString.pos                            code  fffc0dd8 18
  fltToString.prt                            code  fffc1090 18
  fputc                                      code  fffc0378 18
  fv1                                        code  fffc6bc4 18
  fv2                                        code  fffc6bd8 18
  fv3                                        code  fffc6bbc 18
  fv4                                        code  fffc6b80 18
  gen_rand                                   code  800000000000046e 32
  getVarName                                 code  fffc6ab8 18
  gfn1                                       code  fffc633c 18
  gfn2                                       code  fffc62d4 18
  gfn3                                       code  fffc6310 18
  gosub1                                     code  fffc5e20 18
  gvn1                                       code  fffc6b50 18
  gvn2                                       code  fffc6b14 18
  gvn3                                       code  fffc6b30 18
  gvn4                                       code  fffc6ad8 18
  gvn6                                       code  fffc6b04 18
  hKeybdMbx                                 const  024822 19
  isAlnum                                    code  fffc66e8 18
  isAlpha                                    code  fffc66b8 18
  isAlphaFalse                               code  fffc66e0 18
  isAlphaTrue                                code  fffc66d8 18
  isDigit                                    code  fffc6698 18
  isDigitFalse                               code  fffc66b0 18
  isDigitx                                   code  fffc66fc 18
  mbxs                                      const  020000 19
  mbxs_end                                  const  022000 19
  milliseconds                              const  014208 18
  missed_ticks                              const  024320 19
  msgBadGotoGosub                            code  fffc7935 18
  msgBadKeybd                                code  80000000000002b6 32
  msgBytesFree                               code  fffc786d 18
  msgCRLF                                    code  fffc0c4e 18
  msgComma                                   code  fffc7882 18
  msgDivZero                                 code  fffc7844 18
  msgEnvFail                                 code  fffc799d 18
  msgExtraChars                              code  fffc797b 18
  msgIllegalInsn                             code  fffc0d03 18
  msgInf                                     code  fffc1104 18
  msgInit                                    code  fffc77cc 18
  msgInputVar                                code  fffc78e4 18
  msgInsnAccessFault                         code  fffc0ce8 18
  msgLineRange                               code  fffc7895 18
  msgLoadAccessFault                         code  fffc0d18 18
  msgMonHelp                                 code  fffc0b96 18
  msgNan                                     code  fffc1108 18
  msgNextFor                                 code  fffc7900 18
  msgNextVar                                 code  fffc7912 18
  msgNumTooBig                               code  fffc7831 18
  msgParen                                   code  fffc79b7 18
  msgRNDBad                                  code  fffc78c0 18
  msgReadError                               code  fffc7817 18
  msgReady                                   code  fffc787a 18
  msgReadyList                               code  fffc3aec 18
  msgReserved                                code  fffc0d41 18
  msgRetWoGosub                              code  fffc7951 18
  msgSYSBad                                  code  fffc78d3 18
  msgStart                                   code  fffc0b7c 18
  msgStoreAccessFault                        code  fffc0d2c 18
  msgTaskStart                               code  fffc0c40 18
  msgTimeoutList                             code  fffc3b18 18
  msgTooBig                                  code  fffc7967 18
  msgVar                                     code  fffc78aa 18
  msgVarSpace                                code  fffc7856 18
  msgWhat                                    code  fffc7808 18
  msgs                                      const  010000 18
  nmeSerial                                  code  fffc1e54 18
  noLock                                     code  fffc2e78 18
  prCRLF                                     code  fffc7288 18
  pword1                                     code  fffc64bc 18
  pword2                                     code  fffc64dc 18
  qToChk                                     code  fffc264e 18
  ramtest_10                                 code  fffc1148 18
  ramtest_100                                code  fffc13a0 18
  ramtest_102                                code  fffc13b4 18
  ramtest_105                              rodata  fffc9000 32
  ramtest_11                                 code  fffc1148 18
  ramtest_113                                code  fffc1494 18
  ramtest_114                                code  fffc1494 18
  ramtest_20                                 code  fffc11b0 18
  ramtest_21                                 code  fffc11b0 18
  ramtest_43                                 code  fffc1290 18
  ramtest_44                                 code  fffc1254 18
  ramtest_45                                 code  fffc120c 18
  ramtest_46                                 code  fffc1290 18
  ramtest_48                                 code  fffc1274 18
  ramtest_50                                 code  fffc1274 18
  ramtest_84                                 code  fffc13d4 18
  ramtest_85                                 code  fffc1338 18
  ramtest_86                                 code  fffc12f4 18
  ramtest_87                                 code  fffc13c0 18
  ramtest_89                                 code  fffc135c 18
  ramtest_91                                 code  fffc135c 18
  ramtest_98                                 code  fffc137c 18
  ramtest_CheckMem                           code  fffc12a0 18
  ramtest_SetMem                             code  fffc11c8 18
  ramtest_TwoSpaces                          code  fffc1120 18
  return1                                    code  fffc5e98 18
  rnd1                                       code  fffc6cb4 18
  rnd2                                       code  fffc6cc4 18
  switchflag                                const  014200 18
  sysx1                                      code  fffc65c0 18
  tah1                                       code  fffc6514 18
  tblCauseMsg                                code  fffc0c88 18
  toAsciiHex                                 code  fffc6504 18
  toUpper                                    code  fffc753c 18
  tstv_notfound                              code  fffc6aa4 18
  usrJmp                                    const  0300a0 19

Undefined Symbols
  A00000000000000                          rodata  80000000000004ef 32
  AUXIN                                      code  8000000000000349 32
  AUXIN_INIT                                 code  800000000000041c 32
  AUXOUT                                     code  8000000000000347 32
  AUXOUT_FLUSH                               code  8000000000000429 32
  AUXOUT_INIT                                code  8000000000000420 32
  ERETx                                      code  800000000000027e 32
  FFFC0100                                   code  80000000000002f6 32
  FMTK_Initialize                            code  80000000000001f8 32
  FMTK_PostMsg                               code  8000000000000200 32
  FMTK_SetTaskPriority                       code  80000000000001fc 32
  FMTK_StartApp                              code  8000000000000204 32
  KEYBD                                      code  80000000000002af 32
  KTAlreadyLocked                            code  800000000000024a 32
  KeybdIRQ.notAlt                            code  80000000000002c9 32
  KillTask                                   code  8000000000000247 32
  LOG_TCBSIZE                                code  8000000000000214 32
  SDReadSector                               code  800000000000041d 32
  SDWriteSector                              code  8000000000000422 32
  TCBKbdState2                               code  80000000000002c4 32
  TCBVidMem                                  code  800000000000024f 32
  _ACBPtrs                                 rodata  000000 32
  _Alloc                                   rodata  fffc1750 32
  _BIOS1_sema                              rodata  000000 32
  _BIOS_RespMbx                            rodata  000000 32
  _DBGAttr                                 rodata  000000 32
  _DBGCursorCol                            rodata  000000 32
  _DBGCursorRow                            rodata  000000 32
  _DBGHideCursor                           rodata  fffc54c8 32
  _DeviceTable                             rodata  000000 32
  _DumpTaskList                            rodata  000000 32
  _FMTK_Inited                             rodata  000000 32
  _FMTK_Reschedule                         rodata  000000 32
  _FMTK_SendMsg                            rodata  000000 32
  _FMTK_StartApp                           rodata  000000 32
  _FMTK_StartThread                        rodata  000000 32
  _FMTK_WaitMsg                            rodata  000000 32
  _FocusSwitcher                           rodata  000000 32
  _GetACBPtr                               rodata  000000 32
  _GetAppHandle                            rodata  000000 32
  _GetRand                                 rodata  fffc4774 32
  _GetRunningACBPtr                        rodata  000000 32
  _GetVecno                                rodata  000000 32
  _IOFocusNdx                              rodata  000000 32
  _IOFocusTbl                              rodata  000000 32
  _InsertIntoReadyList                     rodata  000000 32
  _InsertIntoTimeoutList                   rodata  000000 32
  _KeyLED                                  rodata  024826 32
  _KeyState1                               rodata  024824 32
  _KeyState2                               rodata  024825 32
  _KeybdClearRcv                           rodata  000000 32
  _KeybdGetScancode                        rodata  fffc455c 32
  _KeybdGetStatus                          rodata  fffc4534 32
  _KeybdID                                   code  80000000000002bc 32
  _KeybdSetLED                             rodata  fffc438c 32
  _LockIOFSemaphore                        rodata  000000 32
  _LockKbdSemaphore                        rodata  000000 32
  _LockSemaphore                           rodata  000000 32
  _LockSysSemaphore                        rodata  000000 32
  _PutHexWord                              rodata  fffc0898 32
  _PutString                               rodata  fffc0950 32
  _RemoveFromReadyList                     rodata  000000 32
  _RemoveFromTimeoutList                   rodata  000000 32
  _RequestIOFocus                          rodata  000000 32
  _SetBound48                              rodata  000000 32
  _SetBound49                              rodata  000000 32
  _SetBound50                              rodata  000000 32
  _SetBound51                              rodata  000000 32
  _TimeoutList                             rodata  000000 32
  _VirtToPhys                              rodata  fffc183c 32
  _bios_stacks                             rodata  000000 32
  _chkTCB                                  rodata  000000 32
  _cls                                       code  8000000000000399 32
  _fmtk_irq_stack                          rodata  000000 32
  _fmtk_sys_stack                          rodata  000000 32
  _freeMBX                                 rodata  000000 32
  _freeMSG                                 rodata  000000 32
  _freeTCB                                 rodata  000000 32
  _getCPU                                  rodata  000000 32
  _hFocusSwitchMbx                         rodata  000000 32
  _hasUltraHighPriorityTasks               rodata  000000 32
  _in16                                    rodata  000000 32
  _in16u                                   rodata  000000 32
  _in32                                    rodata  000000 32
  _in32u                                   rodata  000000 32
  _in64                                    rodata  000000 32
  _in8                                     rodata  000000 32
  _in8u                                    rodata  000000 32
  _iof_sema                                rodata  000000 32
  _iof_switch                              rodata  000000 32
  _irq_stack                               rodata  000000 32
  _kbd_sema                                rodata  000000 32
  _keybdControlCodes                       rodata  fffc4050 32
  _keybdExtendedCodes                      rodata  fffc40d0 32
  _mailbox                                 rodata  000000 32
  _memsetO                                 rodata  000000 32
  _memsetW                                 rodata  000000 32
  _message                                 rodata  000000 32
  _missed_ticks                            rodata  000000 32
  _mmu_Alloc512kPage                       rodata  000000 32
  _mmu_Alloc8kPage                         rodata  000000 32
  _mmu_AllocateMap                         rodata  000000 32
  _mmu_Free512kPage                        rodata  000000 32
  _mmu_Free8kPage                          rodata  000000 32
  _mmu_FreeMap                             rodata  000000 32
  _mmu_MapCardMemory                       rodata  000000 32
  _mmu_SetAccessKey                        rodata  000000 32
  _mmu_SetMapEntry                         rodata  000000 32
  _mmu_SetOperateKey                       rodata  000000 32
  _mmu_alloc                               rodata  000000 32
  _mmu_free                                rodata  000000 32
  _nMailbox                                rodata  000000 32
  _nMsgBlk                                 rodata  000000 32
  _out16                                   rodata  000000 32
  _out32                                   rodata  000000 32
  _out64                                   rodata  000000 32
  _out8                                    rodata  000000 32
  _outb                                    rodata  000000 32
  _outc                                    rodata  000000 32
  _outh                                    rodata  000000 32
  _outw                                    rodata  000000 32
  _prtnum                                  rodata  fffc72ac 32
  _putch                                   rodata  fffc0304 32
  _puthexnum                               rodata  000000 32
  _randStream                              rodata  024830 32
  _rdcf                                      code  800000000000039b 32
  _readyQ                                  rodata  000000 32
  _rmemsetW                                rodata  000000 32
  _set_vector                              rodata  000000 32
  _shiftedScanCodes                        rodata  fffc3f50 32
  _stacks                                  rodata  000000 32
  _sys_sema                                rodata  000000 32
  _sys_stacks                              rodata  000000 32
  _sysstack                                rodata  000000 32
  _tabstops                                rodata  000000 32
  _tcbs                                    rodata  000000 32
  _unshiftedScanCodes                      rodata  fffc3e50 32
  _video_bufs                              rodata  000000 32
  gen_rand                                   code  800000000000046e 32
  msgBadKeybd                                code  80000000000002b6 32

  Macro Name
 mDispIRQLive                              -842150451

	ldo      $v0,$FFD00000+440
	add     	$v0,$v0,#1
	sto      $v0,$FFD00000+440

 mGetCurrentTid                            -842150451

	csrrw	$v0,#$181,$x0
;	csrrw	$v1,#$F10,$x0
;	and		$v1,$v1,#$FFFFFF80
;	and		$v0,$v0,#31
;	or		$v0,$v0,$v1

 mGetVideoPtr                              -842150451

	
	csrrw	$v0,#$181,$x0
;	csrrw	$v1,#$F10,$x0
;	and		$v1,$v1,#$FFFFFF80
;	and		$v0,$v0,#31
;	or		$v0,$v0,$v1
sll		$v0,$v0,#LOG_TCBSZ
	ldo		$v0,TCBpVideo[$v0]
	ldi		$v0,#$FFD00000

 mHasFocus                                 -842150451

	ldi		$a0,#20
	ecall

 mLockSysMutex                             -842150451

	
	csrrw	$v0,#$181,$x0
;	csrrw	$v1,#$F10,$x0
;	and		$v1,$v1,#$FFFFFF80
;	and		$v0,$v0,#31
;	or		$v0,$v0,$v1
sll		$v0,$v0,#1
	or		$v0,$v0,#1
	ldi		$t0,#$FFDBFF00
.lock@:
	sto		$v0,[$t0]
	ldo		$v1,[$t0]
	bne		$v0,$v1,.lock@

 mPopTimeoutList                           -842150451

	sll		$t0,$v0,#LOG_TCBSZ		; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
	beqz	$t1,.noWait@
	mMbxRemoveTask							; remove task from mailbox list
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	stb		$v1,TCBStatus[$t0]
	ldw		$v1,TCBNext[$t0]			; get next task on timeout list
	stw		$v1,TimeoutList				; update list head
	ldi		$t1,#NR_TCB						; check valid handle
	bgeu	$v1,$t1,.done@
	ldi		$t1,#-1								;
	sll		$v1,$v1,#LOG_TCBSZ		; v1 = tid to pointer
	stw		$t1,TCBPrev[$v1]			; TimeoutList->prev = -1
.done@:
	ldi		$t1,#-1								; reset next and prev indexes
	stw		$t1,TCBNext[$t0]			; on popped task
	stw		$t1,TCBPrev[$t0]

 mSleep                                    1

	ldi		$a0,#5
	ldi		$a1,#0
	ecall

 mUnlockSemaphore                          1

	ldi		v0,#-1
	sw		v0,0

 mWaitForFocus                             -842150451

.WFF1@:
	
	ldi		$a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		$a0,#5
	ldi		$a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:

0 compressable instructions
The top 1024 are:
Comp  Opcode  Count
